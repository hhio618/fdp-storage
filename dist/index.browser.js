(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["fdp"] = factory();
	else
		root["fdp"] = factory();
})(this, function() {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/@ethersphere/bee-js/node_modules/semver/classes/semver.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/node_modules/semver/classes/semver.js ***!
  \********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(/*! ../internal/debug */ "./node_modules/@ethersphere/bee-js/node_modules/semver/internal/debug.js");

const {
  MAX_LENGTH,
  MAX_SAFE_INTEGER
} = __webpack_require__(/*! ../internal/constants */ "./node_modules/@ethersphere/bee-js/node_modules/semver/internal/constants.js");

const {
  re,
  t
} = __webpack_require__(/*! ../internal/re */ "./node_modules/@ethersphere/bee-js/node_modules/semver/internal/re.js");

const parseOptions = __webpack_require__(/*! ../internal/parse-options */ "./node_modules/@ethersphere/bee-js/node_modules/semver/internal/parse-options.js");

const {
  compareIdentifiers
} = __webpack_require__(/*! ../internal/identifiers */ "./node_modules/@ethersphere/bee-js/node_modules/semver/internal/identifiers.js");

class SemVer {
  constructor(version, options) {
    options = parseOptions(options);

    if (version instanceof SemVer) {
      if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
        return version;
      } else {
        version = version.version;
      }
    } else if (typeof version !== 'string') {
      throw new TypeError(`Invalid Version: ${version}`);
    }

    if (version.length > MAX_LENGTH) {
      throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
    }

    debug('SemVer', version, options);
    this.options = options;
    this.loose = !!options.loose; // this isn't actually relevant for versions, but keep it so that we
    // don't run into trouble passing this.options around.

    this.includePrerelease = !!options.includePrerelease;
    const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

    if (!m) {
      throw new TypeError(`Invalid Version: ${version}`);
    }

    this.raw = version; // these are actually numbers

    this.major = +m[1];
    this.minor = +m[2];
    this.patch = +m[3];

    if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
      throw new TypeError('Invalid major version');
    }

    if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
      throw new TypeError('Invalid minor version');
    }

    if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
      throw new TypeError('Invalid patch version');
    } // numberify any prerelease numeric ids


    if (!m[4]) {
      this.prerelease = [];
    } else {
      this.prerelease = m[4].split('.').map(id => {
        if (/^[0-9]+$/.test(id)) {
          const num = +id;

          if (num >= 0 && num < MAX_SAFE_INTEGER) {
            return num;
          }
        }

        return id;
      });
    }

    this.build = m[5] ? m[5].split('.') : [];
    this.format();
  }

  format() {
    this.version = `${this.major}.${this.minor}.${this.patch}`;

    if (this.prerelease.length) {
      this.version += `-${this.prerelease.join('.')}`;
    }

    return this.version;
  }

  toString() {
    return this.version;
  }

  compare(other) {
    debug('SemVer.compare', this.version, this.options, other);

    if (!(other instanceof SemVer)) {
      if (typeof other === 'string' && other === this.version) {
        return 0;
      }

      other = new SemVer(other, this.options);
    }

    if (other.version === this.version) {
      return 0;
    }

    return this.compareMain(other) || this.comparePre(other);
  }

  compareMain(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
  }

  comparePre(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    } // NOT having a prerelease is > having one


    if (this.prerelease.length && !other.prerelease.length) {
      return -1;
    } else if (!this.prerelease.length && other.prerelease.length) {
      return 1;
    } else if (!this.prerelease.length && !other.prerelease.length) {
      return 0;
    }

    let i = 0;

    do {
      const a = this.prerelease[i];
      const b = other.prerelease[i];
      debug('prerelease compare', i, a, b);

      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  }

  compareBuild(other) {
    if (!(other instanceof SemVer)) {
      other = new SemVer(other, this.options);
    }

    let i = 0;

    do {
      const a = this.build[i];
      const b = other.build[i];
      debug('prerelease compare', i, a, b);

      if (a === undefined && b === undefined) {
        return 0;
      } else if (b === undefined) {
        return 1;
      } else if (a === undefined) {
        return -1;
      } else if (a === b) {
        continue;
      } else {
        return compareIdentifiers(a, b);
      }
    } while (++i);
  } // preminor will bump the version up to the next minor release, and immediately
  // down to pre-release. premajor and prepatch work the same way.


  inc(release, identifier) {
    switch (release) {
      case 'premajor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor = 0;
        this.major++;
        this.inc('pre', identifier);
        break;

      case 'preminor':
        this.prerelease.length = 0;
        this.patch = 0;
        this.minor++;
        this.inc('pre', identifier);
        break;

      case 'prepatch':
        // If this is already a prerelease, it will bump to the next version
        // drop any prereleases that might already exist, since they are not
        // relevant at this point.
        this.prerelease.length = 0;
        this.inc('patch', identifier);
        this.inc('pre', identifier);
        break;
      // If the input is a non-prerelease version, this acts the same as
      // prepatch.

      case 'prerelease':
        if (this.prerelease.length === 0) {
          this.inc('patch', identifier);
        }

        this.inc('pre', identifier);
        break;

      case 'major':
        // If this is a pre-major version, bump up to the same major version.
        // Otherwise increment major.
        // 1.0.0-5 bumps to 1.0.0
        // 1.1.0 bumps to 2.0.0
        if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
          this.major++;
        }

        this.minor = 0;
        this.patch = 0;
        this.prerelease = [];
        break;

      case 'minor':
        // If this is a pre-minor version, bump up to the same minor version.
        // Otherwise increment minor.
        // 1.2.0-5 bumps to 1.2.0
        // 1.2.1 bumps to 1.3.0
        if (this.patch !== 0 || this.prerelease.length === 0) {
          this.minor++;
        }

        this.patch = 0;
        this.prerelease = [];
        break;

      case 'patch':
        // If this is not a pre-release version, it will increment the patch.
        // If it is a pre-release it will bump up to the same patch version.
        // 1.2.0-5 patches to 1.2.0
        // 1.2.0 patches to 1.2.1
        if (this.prerelease.length === 0) {
          this.patch++;
        }

        this.prerelease = [];
        break;
      // This probably shouldn't be used publicly.
      // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.

      case 'pre':
        if (this.prerelease.length === 0) {
          this.prerelease = [0];
        } else {
          let i = this.prerelease.length;

          while (--i >= 0) {
            if (typeof this.prerelease[i] === 'number') {
              this.prerelease[i]++;
              i = -2;
            }
          }

          if (i === -1) {
            // didn't increment anything
            this.prerelease.push(0);
          }
        }

        if (identifier) {
          // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
          // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
          if (this.prerelease[0] === identifier) {
            if (isNaN(this.prerelease[1])) {
              this.prerelease = [identifier, 0];
            }
          } else {
            this.prerelease = [identifier, 0];
          }
        }

        break;

      default:
        throw new Error(`invalid increment argument: ${release}`);
    }

    this.format();
    this.raw = this.version;
    return this;
  }

}

module.exports = SemVer;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/node_modules/semver/functions/major.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/node_modules/semver/functions/major.js ***!
  \*********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SemVer = __webpack_require__(/*! ../classes/semver */ "./node_modules/@ethersphere/bee-js/node_modules/semver/classes/semver.js");

const major = (a, loose) => new SemVer(a, loose).major;

module.exports = major;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/node_modules/semver/internal/constants.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/node_modules/semver/internal/constants.js ***!
  \************************************************************************************/
/***/ ((module) => {

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
const SEMVER_SPEC_VERSION = '2.0.0';
const MAX_LENGTH = 256;
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
/* istanbul ignore next */
9007199254740991; // Max safe segment length for coercion.

const MAX_SAFE_COMPONENT_LENGTH = 16;
module.exports = {
  SEMVER_SPEC_VERSION,
  MAX_LENGTH,
  MAX_SAFE_INTEGER,
  MAX_SAFE_COMPONENT_LENGTH
};

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/node_modules/semver/internal/debug.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/node_modules/semver/internal/debug.js ***!
  \********************************************************************************/
/***/ ((module) => {

const debug = typeof process === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error('SEMVER', ...args) : () => {};
module.exports = debug;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/node_modules/semver/internal/identifiers.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/node_modules/semver/internal/identifiers.js ***!
  \**************************************************************************************/
/***/ ((module) => {

const numeric = /^[0-9]+$/;

const compareIdentifiers = (a, b) => {
  const anum = numeric.test(a);
  const bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};

const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);

module.exports = {
  compareIdentifiers,
  rcompareIdentifiers
};

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/node_modules/semver/internal/parse-options.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/node_modules/semver/internal/parse-options.js ***!
  \****************************************************************************************/
/***/ ((module) => {

// parse out just the options we care about so we always get a consistent
// obj with keys in a consistent order.
const opts = ['includePrerelease', 'loose', 'rtl'];

const parseOptions = options => !options ? {} : typeof options !== 'object' ? {
  loose: true
} : opts.filter(k => options[k]).reduce((options, k) => {
  options[k] = true;
  return options;
}, {});

module.exports = parseOptions;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/node_modules/semver/internal/re.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/node_modules/semver/internal/re.js ***!
  \*****************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

const {
  MAX_SAFE_COMPONENT_LENGTH
} = __webpack_require__(/*! ./constants */ "./node_modules/@ethersphere/bee-js/node_modules/semver/internal/constants.js");

const debug = __webpack_require__(/*! ./debug */ "./node_modules/@ethersphere/bee-js/node_modules/semver/internal/debug.js");

exports = module.exports = {}; // The actual regexps go on exports.re

const re = exports.re = [];
const src = exports.src = [];
const t = exports.t = {};
let R = 0;

const createToken = (name, value, isGlobal) => {
  const index = R++;
  debug(index, value);
  t[name] = index;
  src[index] = value;
  re[index] = new RegExp(value, isGlobal ? 'g' : undefined);
}; // The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.
// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.


createToken('NUMERICIDENTIFIER', '0|[1-9]\\d*');
createToken('NUMERICIDENTIFIERLOOSE', '[0-9]+'); // ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

createToken('NONNUMERICIDENTIFIER', '\\d*[a-zA-Z-][a-zA-Z0-9-]*'); // ## Main Version
// Three dot-separated numeric identifiers.

createToken('MAINVERSION', `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
createToken('MAINVERSIONLOOSE', `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`); // ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

createToken('PRERELEASEIDENTIFIER', `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
createToken('PRERELEASEIDENTIFIERLOOSE', `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`); // ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

createToken('PRERELEASE', `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
createToken('PRERELEASELOOSE', `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`); // ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

createToken('BUILDIDENTIFIER', '[0-9A-Za-z-]+'); // ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

createToken('BUILD', `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`); // ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.
// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

createToken('FULLPLAIN', `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
createToken('FULL', `^${src[t.FULLPLAIN]}$`); // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.

createToken('LOOSEPLAIN', `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
createToken('LOOSE', `^${src[t.LOOSEPLAIN]}$`);
createToken('GTLT', '((?:<|>)?=?)'); // Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.

createToken('XRANGEIDENTIFIERLOOSE', `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
createToken('XRANGEIDENTIFIER', `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
createToken('XRANGEPLAIN', `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
createToken('XRANGEPLAINLOOSE', `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
createToken('XRANGE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
createToken('XRANGELOOSE', `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`); // Coercion.
// Extract anything that could conceivably be a part of a valid semver

createToken('COERCE', `${'(^|[^\\d])' + '(\\d{1,'}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:$|[^\\d])`);
createToken('COERCERTL', src[t.COERCE], true); // Tilde ranges.
// Meaning is "reasonably at or greater than"

createToken('LONETILDE', '(?:~>?)');
createToken('TILDETRIM', `(\\s*)${src[t.LONETILDE]}\\s+`, true);
exports.tildeTrimReplace = '$1~';
createToken('TILDE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
createToken('TILDELOOSE', `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`); // Caret ranges.
// Meaning is "at least and backwards compatible with"

createToken('LONECARET', '(?:\\^)');
createToken('CARETTRIM', `(\\s*)${src[t.LONECARET]}\\s+`, true);
exports.caretTrimReplace = '$1^';
createToken('CARET', `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
createToken('CARETLOOSE', `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`); // A simple gt/lt/eq thing, or just "" to indicate "any version"

createToken('COMPARATORLOOSE', `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
createToken('COMPARATOR', `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`); // An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`

createToken('COMPARATORTRIM', `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
exports.comparatorTrimReplace = '$1$2$3'; // Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.

createToken('HYPHENRANGE', `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*$`);
createToken('HYPHENRANGELOOSE', `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*$`); // Star ranges basically just allow anything at all.

createToken('STAR', '(<|>)?=?\\s*\\*'); // >=0.0.0 is like a star

createToken('GTE0', '^\\s*>=\\s*0\.0\.0\\s*$');
createToken('GTE0PRE', '^\\s*>=\\s*0\.0\.0-0\\s*$');

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/_version.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/_version.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "abi/5.6.1";

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/abi-coder.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/abi-coder.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbiCoder": () => (/* binding */ AbiCoder),
/* harmony export */   "defaultAbiCoder": () => (/* binding */ defaultAbiCoder)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/abi/lib.esm/_version.js");
/* harmony import */ var _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./coders/abstract-coder */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");
/* harmony import */ var _coders_address__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./coders/address */ "./node_modules/@ethersproject/abi/lib.esm/coders/address.js");
/* harmony import */ var _coders_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coders/array */ "./node_modules/@ethersproject/abi/lib.esm/coders/array.js");
/* harmony import */ var _coders_boolean__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./coders/boolean */ "./node_modules/@ethersproject/abi/lib.esm/coders/boolean.js");
/* harmony import */ var _coders_bytes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./coders/bytes */ "./node_modules/@ethersproject/abi/lib.esm/coders/bytes.js");
/* harmony import */ var _coders_fixed_bytes__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./coders/fixed-bytes */ "./node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js");
/* harmony import */ var _coders_null__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./coders/null */ "./node_modules/@ethersproject/abi/lib.esm/coders/null.js");
/* harmony import */ var _coders_number__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./coders/number */ "./node_modules/@ethersproject/abi/lib.esm/coders/number.js");
/* harmony import */ var _coders_string__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./coders/string */ "./node_modules/@ethersproject/abi/lib.esm/coders/string.js");
/* harmony import */ var _coders_tuple__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./coders/tuple */ "./node_modules/@ethersproject/abi/lib.esm/coders/tuple.js");
/* harmony import */ var _fragments__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./fragments */ "./node_modules/@ethersproject/abi/lib.esm/fragments.js");
 // See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI





const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);











const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
  constructor(coerceFunc) {
    logger.checkNew(new.target, AbiCoder);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, "coerceFunc", coerceFunc || null);
  }

  _getCoder(param) {
    switch (param.baseType) {
      case "address":
        return new _coders_address__WEBPACK_IMPORTED_MODULE_3__.AddressCoder(param.name);

      case "bool":
        return new _coders_boolean__WEBPACK_IMPORTED_MODULE_4__.BooleanCoder(param.name);

      case "string":
        return new _coders_string__WEBPACK_IMPORTED_MODULE_5__.StringCoder(param.name);

      case "bytes":
        return new _coders_bytes__WEBPACK_IMPORTED_MODULE_6__.BytesCoder(param.name);

      case "array":
        return new _coders_array__WEBPACK_IMPORTED_MODULE_7__.ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);

      case "tuple":
        return new _coders_tuple__WEBPACK_IMPORTED_MODULE_8__.TupleCoder((param.components || []).map(component => {
          return this._getCoder(component);
        }), param.name);

      case "":
        return new _coders_null__WEBPACK_IMPORTED_MODULE_9__.NullCoder(param.name);
    } // u?int[0-9]*


    let match = param.type.match(paramTypeNumber);

    if (match) {
      let size = parseInt(match[2] || "256");

      if (size === 0 || size > 256 || size % 8 !== 0) {
        logger.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
      }

      return new _coders_number__WEBPACK_IMPORTED_MODULE_10__.NumberCoder(size / 8, match[1] === "int", param.name);
    } // bytes[0-9]+


    match = param.type.match(paramTypeBytes);

    if (match) {
      let size = parseInt(match[1]);

      if (size === 0 || size > 32) {
        logger.throwArgumentError("invalid bytes length", "param", param);
      }

      return new _coders_fixed_bytes__WEBPACK_IMPORTED_MODULE_11__.FixedBytesCoder(size, param.name);
    }

    return logger.throwArgumentError("invalid type", "type", param.type);
  }

  _getWordSize() {
    return 32;
  }

  _getReader(data, allowLoose) {
    return new _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_12__.Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);
  }

  _getWriter() {
    return new _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_12__.Writer(this._getWordSize());
  }

  getDefaultValue(types) {
    const coders = types.map(type => this._getCoder(_fragments__WEBPACK_IMPORTED_MODULE_13__.ParamType.from(type)));
    const coder = new _coders_tuple__WEBPACK_IMPORTED_MODULE_8__.TupleCoder(coders, "_");
    return coder.defaultValue();
  }

  encode(types, values) {
    if (types.length !== values.length) {
      logger.throwError("types/values length mismatch", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {
        count: {
          types: types.length,
          values: values.length
        },
        value: {
          types: types,
          values: values
        }
      });
    }

    const coders = types.map(type => this._getCoder(_fragments__WEBPACK_IMPORTED_MODULE_13__.ParamType.from(type)));
    const coder = new _coders_tuple__WEBPACK_IMPORTED_MODULE_8__.TupleCoder(coders, "_");

    const writer = this._getWriter();

    coder.encode(writer, values);
    return writer.data;
  }

  decode(types, data, loose) {
    const coders = types.map(type => this._getCoder(_fragments__WEBPACK_IMPORTED_MODULE_13__.ParamType.from(type)));
    const coder = new _coders_tuple__WEBPACK_IMPORTED_MODULE_8__.TupleCoder(coders, "_");
    return coder.decode(this._getReader((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_14__.arrayify)(data), loose));
  }

}
const defaultAbiCoder = new AbiCoder();

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Coder": () => (/* binding */ Coder),
/* harmony export */   "Reader": () => (/* binding */ Reader),
/* harmony export */   "Writer": () => (/* binding */ Writer),
/* harmony export */   "checkResultErrors": () => (/* binding */ checkResultErrors)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version */ "./node_modules/@ethersproject/abi/lib.esm/_version.js");







const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
function checkResultErrors(result) {
  // Find the first error (if any)
  const errors = [];

  const checkErrors = function (path, object) {
    if (!Array.isArray(object)) {
      return;
    }

    for (let key in object) {
      const childPath = path.slice();
      childPath.push(key);

      try {
        checkErrors(childPath, object[key]);
      } catch (error) {
        errors.push({
          path: childPath,
          error: error
        });
      }
    }
  };

  checkErrors([], result);
  return errors;
}
class Coder {
  constructor(name, type, localName, dynamic) {
    // @TODO: defineReadOnly these
    this.name = name;
    this.type = type;
    this.localName = localName;
    this.dynamic = dynamic;
  }

  _throwError(message, value) {
    logger.throwArgumentError(message, this.localName, value);
  }

}
class Writer {
  constructor(wordSize) {
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, "wordSize", wordSize || 32);
    this._data = [];
    this._dataLength = 0;
    this._padding = new Uint8Array(wordSize);
  }

  get data() {
    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(this._data);
  }

  get length() {
    return this._dataLength;
  }

  _writeData(data) {
    this._data.push(data);

    this._dataLength += data.length;
    return data.length;
  }

  appendWriter(writer) {
    return this._writeData((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)(writer._data));
  } // Arrayish items; padded on the right to wordSize


  writeBytes(value) {
    let bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);
    const paddingOffset = bytes.length % this.wordSize;

    if (paddingOffset) {
      bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([bytes, this._padding.slice(paddingOffset)]);
    }

    return this._writeData(bytes);
  }

  _getValue(value) {
    let bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value));

    if (bytes.length > this.wordSize) {
      logger.throwError("value out-of-bounds", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {
        length: this.wordSize,
        offset: bytes.length
      });
    }

    if (bytes.length % this.wordSize) {
      bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([this._padding.slice(bytes.length % this.wordSize), bytes]);
    }

    return bytes;
  } // BigNumberish items; padded on the left to wordSize


  writeValue(value) {
    return this._writeData(this._getValue(value));
  }

  writeUpdatableValue() {
    const offset = this._data.length;

    this._data.push(this._padding);

    this._dataLength += this.wordSize;
    return value => {
      this._data[offset] = this._getValue(value);
    };
  }

}
class Reader {
  constructor(data, wordSize, coerceFunc, allowLoose) {
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, "_data", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data));
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, "wordSize", wordSize || 32);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, "_coerceFunc", coerceFunc);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, "allowLoose", allowLoose);
    this._offset = 0;
  }

  get data() {
    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(this._data);
  }

  get consumed() {
    return this._offset;
  } // The default Coerce function


  static coerce(name, value) {
    let match = name.match("^u?int([0-9]+)$");

    if (match && parseInt(match[1]) <= 48) {
      value = value.toNumber();
    }

    return value;
  }

  coerce(name, value) {
    if (this._coerceFunc) {
      return this._coerceFunc(name, value);
    }

    return Reader.coerce(name, value);
  }

  _peekBytes(offset, length, loose) {
    let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;

    if (this._offset + alignedLength > this._data.length) {
      if (this.allowLoose && loose && this._offset + length <= this._data.length) {
        alignedLength = length;
      } else {
        logger.throwError("data out-of-bounds", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {
          length: this._data.length,
          offset: this._offset + alignedLength
        });
      }
    }

    return this._data.slice(this._offset, this._offset + alignedLength);
  }

  subReader(offset) {
    return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
  }

  readBytes(length, loose) {
    let bytes = this._peekBytes(0, length, !!loose);

    this._offset += bytes.length; // @TODO: Make sure the length..end bytes are all 0?

    return bytes.slice(0, length);
  }

  readValue() {
    return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(this.readBytes(this.wordSize));
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/coders/address.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/coders/address.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddressCoder": () => (/* binding */ AddressCoder)
/* harmony export */ });
/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/address */ "./node_modules/@ethersproject/address/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");





class AddressCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }

  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }

  encode(writer, value) {
    try {
      value = (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_1__.getAddress)(value);
    } catch (error) {
      this._throwError(error.message, value);
    }

    return writer.writeValue(value);
  }

  decode(reader) {
    return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_1__.getAddress)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexZeroPad)(reader.readValue().toHexString(), 20));
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnonymousCoder": () => (/* binding */ AnonymousCoder)
/* harmony export */ });
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");


 // Clones the functionality of an existing Coder, but without a localName

class AnonymousCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {
  constructor(coder) {
    super(coder.name, coder.type, undefined, coder.dynamic);
    this.coder = coder;
  }

  defaultValue() {
    return this.coder.defaultValue();
  }

  encode(writer, value) {
    return this.coder.encode(writer, value);
  }

  decode(reader) {
    return this.coder.decode(reader);
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/coders/array.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/coders/array.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ArrayCoder": () => (/* binding */ ArrayCoder),
/* harmony export */   "pack": () => (/* binding */ pack),
/* harmony export */   "unpack": () => (/* binding */ unpack)
/* harmony export */ });
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version */ "./node_modules/@ethersproject/abi/lib.esm/_version.js");
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract-coder */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");
/* harmony import */ var _anonymous__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./anonymous */ "./node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js");




const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);


function pack(writer, coders, values) {
  let arrayValues = null;

  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map(coder => {
      const name = coder.localName;

      if (!name) {
        logger.throwError("cannot encode object for signature with missing names", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder: coder,
          value: values
        });
      }

      if (unique[name]) {
        logger.throwError("cannot encode object for signature with duplicate names", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {
          argument: "values",
          coder: coder,
          value: values
        });
      }

      unique[name] = true;
      return values[name];
    });
  } else {
    logger.throwArgumentError("invalid tuple value", "tuple", values);
  }

  if (coders.length !== arrayValues.length) {
    logger.throwArgumentError("types/value length mismatch", "tuple", values);
  }

  let staticWriter = new _abstract_coder__WEBPACK_IMPORTED_MODULE_2__.Writer(writer.wordSize);
  let dynamicWriter = new _abstract_coder__WEBPACK_IMPORTED_MODULE_2__.Writer(writer.wordSize);
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];

    if (coder.dynamic) {
      // Get current dynamic offset (for the future pointer)
      let dynamicOffset = dynamicWriter.length; // Encode the dynamic value into the dynamicWriter

      coder.encode(dynamicWriter, value); // Prepare to populate the correct offset once we are done

      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push(baseOffset => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  }); // Backfill all the dynamic offsets, now that we know the static length

  updateFuncs.forEach(func => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = []; // A reader anchored to this base

  let baseReader = reader.subReader(0);
  coders.forEach(coder => {
    let value = null;

    if (coder.dynamic) {
      let offset = reader.readValue();
      let offsetReader = baseReader.subReader(offset.toNumber());

      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        // Cannot recover from this
        if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }

        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        // Cannot recover from this
        if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN) {
          throw error;
        }

        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }

    if (value != undefined) {
      values.push(value);
    }
  }); // We only output named properties for uniquely named coders

  const uniqueNames = coders.reduce((accum, coder) => {
    const name = coder.localName;

    if (name) {
      if (!accum[name]) {
        accum[name] = 0;
      }

      accum[name]++;
    }

    return accum;
  }, {}); // Add any named parameters (i.e. tuples)

  coders.forEach((coder, index) => {
    let name = coder.localName;

    if (!name || uniqueNames[name] !== 1) {
      return;
    }

    if (name === "length") {
      name = "_length";
    }

    if (values[name] != null) {
      return;
    }

    const value = values[index];

    if (value instanceof Error) {
      Object.defineProperty(values, name, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    } else {
      values[name] = value;
    }
  });

  for (let i = 0; i < values.length; i++) {
    const value = values[i];

    if (value instanceof Error) {
      Object.defineProperty(values, i, {
        enumerable: true,
        get: () => {
          throw value;
        }
      });
    }
  }

  return Object.freeze(values);
}
class ArrayCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_2__.Coder {
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    this.coder = coder;
    this.length = length;
  }

  defaultValue() {
    // Verifies the child coder is valid (even if the array is dynamic or 0-length)
    const defaultChild = this.coder.defaultValue();
    const result = [];

    for (let i = 0; i < this.length; i++) {
      result.push(defaultChild);
    }

    return result;
  }

  encode(writer, value) {
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }

    let count = this.length;

    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }

    logger.checkArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];

    for (let i = 0; i < value.length; i++) {
      coders.push(this.coder);
    }

    return pack(writer, coders, value);
  }

  decode(reader) {
    let count = this.length;

    if (count === -1) {
      count = reader.readValue().toNumber(); // Check that there is *roughly* enough data to ensure
      // stray random data is not being read as a length. Each
      // slot requires at least 32 bytes for their value (or 32
      // bytes as a link to the data). This could use a much
      // tighter bound, but we are erroring on the side of safety.

      if (count * 32 > reader._data.length) {
        logger.throwError("insufficient data length", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {
          length: reader._data.length,
          count: count
        });
      }
    }

    let coders = [];

    for (let i = 0; i < count; i++) {
      coders.push(new _anonymous__WEBPACK_IMPORTED_MODULE_3__.AnonymousCoder(this.coder));
    }

    return reader.coerce(this.name, unpack(reader, coders));
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/coders/boolean.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/coders/boolean.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BooleanCoder": () => (/* binding */ BooleanCoder)
/* harmony export */ });
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");



class BooleanCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }

  defaultValue() {
    return false;
  }

  encode(writer, value) {
    return writer.writeValue(value ? 1 : 0);
  }

  decode(reader) {
    return reader.coerce(this.type, !reader.readValue().isZero());
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/coders/bytes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/coders/bytes.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BytesCoder": () => (/* binding */ BytesCoder),
/* harmony export */   "DynamicBytesCoder": () => (/* binding */ DynamicBytesCoder)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");




class DynamicBytesCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }

  defaultValue() {
    return "0x";
  }

  encode(writer, value) {
    value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }

  decode(reader) {
    return reader.readBytes(reader.readValue().toNumber(), true);
  }

}
class BytesCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }

  decode(reader) {
    return reader.coerce(this.name, (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.hexlify)(super.decode(reader)));
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FixedBytesCoder": () => (/* binding */ FixedBytesCoder)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");



 // @TODO: Merge this with bytes

class FixedBytesCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {
  constructor(size, localName) {
    let name = "bytes" + String(size);
    super(name, name, localName, false);
    this.size = size;
  }

  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }

  encode(writer, value) {
    let data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(value);

    if (data.length !== this.size) {
      this._throwError("incorrect data length", value);
    }

    return writer.writeBytes(data);
  }

  decode(reader) {
    return reader.coerce(this.name, (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.hexlify)(reader.readBytes(this.size)));
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/coders/null.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/coders/null.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NullCoder": () => (/* binding */ NullCoder)
/* harmony export */ });
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");



class NullCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }

  defaultValue() {
    return null;
  }

  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }

    return writer.writeBytes([]);
  }

  decode(reader) {
    reader.readBytes(0);
    return reader.coerce(this.name, null);
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/coders/number.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/coders/number.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NumberCoder": () => (/* binding */ NumberCoder)
/* harmony export */ });
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/constants */ "./node_modules/@ethersproject/constants/lib.esm/bignumbers.js");
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");





class NumberCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {
  constructor(size, signed, localName) {
    const name = (signed ? "int" : "uint") + size * 8;
    super(name, name, localName, false);
    this.size = size;
    this.signed = signed;
  }

  defaultValue() {
    return 0;
  }

  encode(writer, value) {
    let v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__.BigNumber.from(value); // Check bounds are safe for encoding

    let maxUintValue = _ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__.MaxUint256.mask(writer.wordSize * 8);

    if (this.signed) {
      let bounds = maxUintValue.mask(this.size * 8 - 1);

      if (v.gt(bounds) || v.lt(bounds.add(_ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__.One).mul(_ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__.NegativeOne))) {
        this._throwError("value out-of-bounds", value);
      }
    } else if (v.lt(_ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__.Zero) || v.gt(maxUintValue.mask(this.size * 8))) {
      this._throwError("value out-of-bounds", value);
    }

    v = v.toTwos(this.size * 8).mask(this.size * 8);

    if (this.signed) {
      v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
    }

    return writer.writeValue(v);
  }

  decode(reader) {
    let value = reader.readValue().mask(this.size * 8);

    if (this.signed) {
      value = value.fromTwos(this.size * 8);
    }

    return reader.coerce(this.name, value);
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/coders/string.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/coders/string.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StringCoder": () => (/* binding */ StringCoder)
/* harmony export */ });
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/utf8.js");
/* harmony import */ var _bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytes */ "./node_modules/@ethersproject/abi/lib.esm/coders/bytes.js");




class StringCoder extends _bytes__WEBPACK_IMPORTED_MODULE_0__.DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }

  defaultValue() {
    return "";
  }

  encode(writer, value) {
    return super.encode(writer, (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(value));
  }

  decode(reader) {
    return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__.toUtf8String)(super.decode(reader));
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/coders/tuple.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/coders/tuple.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TupleCoder": () => (/* binding */ TupleCoder)
/* harmony export */ });
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "./node_modules/@ethersproject/abi/lib.esm/coders/array.js");




class TupleCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__.Coder {
  constructor(coders, localName) {
    let dynamic = false;
    const types = [];
    coders.forEach(coder => {
      if (coder.dynamic) {
        dynamic = true;
      }

      types.push(coder.type);
    });
    const type = "tuple(" + types.join(",") + ")";
    super("tuple", type, localName, dynamic);
    this.coders = coders;
  }

  defaultValue() {
    const values = [];
    this.coders.forEach(coder => {
      values.push(coder.defaultValue());
    }); // We only output named properties for uniquely named coders

    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name = coder.localName;

      if (name) {
        if (!accum[name]) {
          accum[name] = 0;
        }

        accum[name]++;
      }

      return accum;
    }, {}); // Add named values

    this.coders.forEach((coder, index) => {
      let name = coder.localName;

      if (!name || uniqueNames[name] !== 1) {
        return;
      }

      if (name === "length") {
        name = "_length";
      }

      if (values[name] != null) {
        return;
      }

      values[name] = values[index];
    });
    return Object.freeze(values);
  }

  encode(writer, value) {
    return (0,_array__WEBPACK_IMPORTED_MODULE_1__.pack)(writer, this.coders, value);
  }

  decode(reader) {
    return reader.coerce(this.name, (0,_array__WEBPACK_IMPORTED_MODULE_1__.unpack)(reader, this.coders));
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/fragments.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/fragments.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConstructorFragment": () => (/* binding */ ConstructorFragment),
/* harmony export */   "ErrorFragment": () => (/* binding */ ErrorFragment),
/* harmony export */   "EventFragment": () => (/* binding */ EventFragment),
/* harmony export */   "FormatTypes": () => (/* binding */ FormatTypes),
/* harmony export */   "Fragment": () => (/* binding */ Fragment),
/* harmony export */   "FunctionFragment": () => (/* binding */ FunctionFragment),
/* harmony export */   "ParamType": () => (/* binding */ ParamType)
/* harmony export */ });
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/abi/lib.esm/_version.js");






const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
;
const _constructorGuard = {};
let ModifiersBytes = {
  calldata: true,
  memory: true,
  storage: true
};
let ModifiersNest = {
  calldata: true,
  memory: true
};

function checkModifier(type, name) {
  if (type === "bytes" || type === "string") {
    if (ModifiersBytes[name]) {
      return true;
    }
  } else if (type === "address") {
    if (name === "payable") {
      return true;
    }
  } else if (type.indexOf("[") >= 0 || type === "tuple") {
    if (ModifiersNest[name]) {
      return true;
    }
  }

  if (ModifiersBytes[name] || name === "payable") {
    logger.throwArgumentError("invalid modifier", "name", name);
  }

  return false;
} // @TODO: Make sure that children of an indexed tuple are marked with a null indexed


function parseParamType(param, allowIndexed) {
  let originalParam = param;

  function throwError(i) {
    logger.throwArgumentError(`unexpected character at position ${i}`, "param", param);
  }

  param = param.replace(/\s/g, " ");

  function newNode(parent) {
    let node = {
      type: "",
      name: "",
      parent: parent,
      state: {
        allowType: true
      }
    };

    if (allowIndexed) {
      node.indexed = false;
    }

    return node;
  }

  let parent = {
    type: "",
    name: "",
    state: {
      allowType: true
    }
  };
  let node = parent;

  for (let i = 0; i < param.length; i++) {
    let c = param[i];

    switch (c) {
      case "(":
        if (node.state.allowType && node.type === "") {
          node.type = "tuple";
        } else if (!node.state.allowParams) {
          throwError(i);
        }

        node.state.allowType = false;
        node.type = verifyType(node.type);
        node.components = [newNode(node)];
        node = node.components[0];
        break;

      case ")":
        delete node.state;

        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i);
          }

          node.indexed = true;
          node.name = "";
        }

        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }

        node.type = verifyType(node.type);
        let child = node;
        node = node.parent;

        if (!node) {
          throwError(i);
        }

        delete child.parent;
        node.state.allowParams = false;
        node.state.allowName = true;
        node.state.allowArray = true;
        break;

      case ",":
        delete node.state;

        if (node.name === "indexed") {
          if (!allowIndexed) {
            throwError(i);
          }

          node.indexed = true;
          node.name = "";
        }

        if (checkModifier(node.type, node.name)) {
          node.name = "";
        }

        node.type = verifyType(node.type);
        let sibling = newNode(node.parent); //{ type: "", name: "", parent: node.parent, state: { allowType: true } };

        node.parent.components.push(sibling);
        delete node.parent;
        node = sibling;
        break;
      // Hit a space...

      case " ":
        // If reading type, the type is done and may read a param or name
        if (node.state.allowType) {
          if (node.type !== "") {
            node.type = verifyType(node.type);
            delete node.state.allowType;
            node.state.allowName = true;
            node.state.allowParams = true;
          }
        } // If reading name, the name is done


        if (node.state.allowName) {
          if (node.name !== "") {
            if (node.name === "indexed") {
              if (!allowIndexed) {
                throwError(i);
              }

              if (node.indexed) {
                throwError(i);
              }

              node.indexed = true;
              node.name = "";
            } else if (checkModifier(node.type, node.name)) {
              node.name = "";
            } else {
              node.state.allowName = false;
            }
          }
        }

        break;

      case "[":
        if (!node.state.allowArray) {
          throwError(i);
        }

        node.type += c;
        node.state.allowArray = false;
        node.state.allowName = false;
        node.state.readArray = true;
        break;

      case "]":
        if (!node.state.readArray) {
          throwError(i);
        }

        node.type += c;
        node.state.readArray = false;
        node.state.allowArray = true;
        node.state.allowName = true;
        break;

      default:
        if (node.state.allowType) {
          node.type += c;
          node.state.allowParams = true;
          node.state.allowArray = true;
        } else if (node.state.allowName) {
          node.name += c;
          delete node.state.allowArray;
        } else if (node.state.readArray) {
          node.type += c;
        } else {
          throwError(i);
        }

    }
  }

  if (node.parent) {
    logger.throwArgumentError("unexpected eof", "param", param);
  }

  delete parent.state;

  if (node.name === "indexed") {
    if (!allowIndexed) {
      throwError(originalParam.length - 7);
    }

    if (node.indexed) {
      throwError(originalParam.length - 7);
    }

    node.indexed = true;
    node.name = "";
  } else if (checkModifier(node.type, node.name)) {
    node.name = "";
  }

  parent.type = verifyType(parent.type);
  return parent;
}

function populate(object, params) {
  for (let key in params) {
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(object, key, params[key]);
  }
}

const FormatTypes = Object.freeze({
  // Bare formatting, as is needed for computing a sighash of an event or function
  sighash: "sighash",
  // Human-Readable with Minimal spacing and without names (compact human-readable)
  minimal: "minimal",
  // Human-Readable with nice spacing, including all names
  full: "full",
  // JSON-format a la Solidity
  json: "json"
});
const paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard) {
      logger.throwError("use fromString", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new ParamType()"
      });
    }

    populate(this, params);
    let match = this.type.match(paramTypeArray);

    if (match) {
      populate(this, {
        arrayLength: parseInt(match[2] || "-1"),
        arrayChildren: ParamType.fromObject({
          type: match[1],
          components: this.components
        }),
        baseType: "array"
      });
    } else {
      populate(this, {
        arrayLength: null,
        arrayChildren: null,
        baseType: this.components != null ? "tuple" : this.type
      });
    }

    this._isParamType = true;
    Object.freeze(this);
  } // Format the parameter fragment
  //   - sighash: "(uint256,address)"
  //   - minimal: "tuple(uint256,address) indexed"
  //   - full:    "tuple(uint256 foo, address bar) indexed baz"


  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }

    if (!FormatTypes[format]) {
      logger.throwArgumentError("invalid format type", "format", format);
    }

    if (format === FormatTypes.json) {
      let result = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name: this.name || undefined
      };

      if (typeof this.indexed === "boolean") {
        result.indexed = this.indexed;
      }

      if (this.components) {
        result.components = this.components.map(comp => JSON.parse(comp.format(format)));
      }

      return JSON.stringify(result);
    }

    let result = ""; // Array

    if (this.baseType === "array") {
      result += this.arrayChildren.format(format);
      result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
    } else {
      if (this.baseType === "tuple") {
        if (format !== FormatTypes.sighash) {
          result += this.type;
        }

        result += "(" + this.components.map(comp => comp.format(format)).join(format === FormatTypes.full ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }

    if (format !== FormatTypes.sighash) {
      if (this.indexed === true) {
        result += " indexed";
      }

      if (format === FormatTypes.full && this.name) {
        result += " " + this.name;
      }
    }

    return result;
  }

  static from(value, allowIndexed) {
    if (typeof value === "string") {
      return ParamType.fromString(value, allowIndexed);
    }

    return ParamType.fromObject(value);
  }

  static fromObject(value) {
    if (ParamType.isParamType(value)) {
      return value;
    }

    return new ParamType(_constructorGuard, {
      name: value.name || null,
      type: verifyType(value.type),
      indexed: value.indexed == null ? null : !!value.indexed,
      components: value.components ? value.components.map(ParamType.fromObject) : null
    });
  }

  static fromString(value, allowIndexed) {
    function ParamTypify(node) {
      return ParamType.fromObject({
        name: node.name,
        type: node.type,
        indexed: node.indexed,
        components: node.components
      });
    }

    return ParamTypify(parseParamType(value, !!allowIndexed));
  }

  static isParamType(value) {
    return !!(value != null && value._isParamType);
  }

}
;

function parseParams(value, allowIndex) {
  return splitNesting(value).map(param => ParamType.fromString(param, allowIndex));
}

class Fragment {
  constructor(constructorGuard, params) {
    if (constructorGuard !== _constructorGuard) {
      logger.throwError("use a static from method", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new Fragment()"
      });
    }

    populate(this, params);
    this._isFragment = true;
    Object.freeze(this);
  }

  static from(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }

    if (typeof value === "string") {
      return Fragment.fromString(value);
    }

    return Fragment.fromObject(value);
  }

  static fromObject(value) {
    if (Fragment.isFragment(value)) {
      return value;
    }

    switch (value.type) {
      case "function":
        return FunctionFragment.fromObject(value);

      case "event":
        return EventFragment.fromObject(value);

      case "constructor":
        return ConstructorFragment.fromObject(value);

      case "error":
        return ErrorFragment.fromObject(value);

      case "fallback":
      case "receive":
        // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?
        return null;
    }

    return logger.throwArgumentError("invalid fragment object", "value", value);
  }

  static fromString(value) {
    // Make sure the "returns" is surrounded by a space and all whitespace is exactly one space
    value = value.replace(/\s/g, " ");
    value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
    value = value.trim();

    if (value.split(" ")[0] === "event") {
      return EventFragment.fromString(value.substring(5).trim());
    } else if (value.split(" ")[0] === "function") {
      return FunctionFragment.fromString(value.substring(8).trim());
    } else if (value.split("(")[0].trim() === "constructor") {
      return ConstructorFragment.fromString(value.trim());
    } else if (value.split(" ")[0] === "error") {
      return ErrorFragment.fromString(value.substring(5).trim());
    }

    return logger.throwArgumentError("unsupported fragment", "value", value);
  }

  static isFragment(value) {
    return !!(value && value._isFragment);
  }

}
class EventFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }

    if (!FormatTypes[format]) {
      logger.throwArgumentError("invalid format type", "format", format);
    }

    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map(input => JSON.parse(input.format(format)))
      });
    }

    let result = "";

    if (format !== FormatTypes.sighash) {
      result += "event ";
    }

    result += this.name + "(" + this.inputs.map(input => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";

    if (format !== FormatTypes.sighash) {
      if (this.anonymous) {
        result += "anonymous ";
      }
    }

    return result.trim();
  }

  static from(value) {
    if (typeof value === "string") {
      return EventFragment.fromString(value);
    }

    return EventFragment.fromObject(value);
  }

  static fromObject(value) {
    if (EventFragment.isEventFragment(value)) {
      return value;
    }

    if (value.type !== "event") {
      logger.throwArgumentError("invalid event object", "value", value);
    }

    const params = {
      name: verifyIdentifier(value.name),
      anonymous: value.anonymous,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      type: "event"
    };
    return new EventFragment(_constructorGuard, params);
  }

  static fromString(value) {
    let match = value.match(regexParen);

    if (!match) {
      logger.throwArgumentError("invalid event string", "value", value);
    }

    let anonymous = false;
    match[3].split(" ").forEach(modifier => {
      switch (modifier.trim()) {
        case "anonymous":
          anonymous = true;
          break;

        case "":
          break;

        default:
          logger.warn("unknown modifier: " + modifier);
      }
    });
    return EventFragment.fromObject({
      name: match[1].trim(),
      anonymous: anonymous,
      inputs: parseParams(match[2], true),
      type: "event"
    });
  }

  static isEventFragment(value) {
    return value && value._isFragment && value.type === "event";
  }

}

function parseGas(value, params) {
  params.gas = null;
  let comps = value.split("@");

  if (comps.length !== 1) {
    if (comps.length > 2) {
      logger.throwArgumentError("invalid human-readable ABI signature", "value", value);
    }

    if (!comps[1].match(/^[0-9]+$/)) {
      logger.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
    }

    params.gas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(comps[1]);
    return comps[0];
  }

  return value;
}

function parseModifiers(value, params) {
  params.constant = false;
  params.payable = false;
  params.stateMutability = "nonpayable";
  value.split(" ").forEach(modifier => {
    switch (modifier.trim()) {
      case "constant":
        params.constant = true;
        break;

      case "payable":
        params.payable = true;
        params.stateMutability = "payable";
        break;

      case "nonpayable":
        params.payable = false;
        params.stateMutability = "nonpayable";
        break;

      case "pure":
        params.constant = true;
        params.stateMutability = "pure";
        break;

      case "view":
        params.constant = true;
        params.stateMutability = "view";
        break;

      case "external":
      case "public":
      case "":
        break;

      default:
        console.log("unknown modifier: " + modifier);
    }
  });
}

function verifyState(value) {
  let result = {
    constant: false,
    payable: true,
    stateMutability: "payable"
  };

  if (value.stateMutability != null) {
    result.stateMutability = value.stateMutability; // Set (and check things are consistent) the constant property

    result.constant = result.stateMutability === "view" || result.stateMutability === "pure";

    if (value.constant != null) {
      if (!!value.constant !== result.constant) {
        logger.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
      }
    } // Set (and check things are consistent) the payable property


    result.payable = result.stateMutability === "payable";

    if (value.payable != null) {
      if (!!value.payable !== result.payable) {
        logger.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
      }
    }
  } else if (value.payable != null) {
    result.payable = !!value.payable; // If payable we can assume non-constant; otherwise we can't assume

    if (value.constant == null && !result.payable && value.type !== "constructor") {
      logger.throwArgumentError("unable to determine stateMutability", "value", value);
    }

    result.constant = !!value.constant;

    if (result.constant) {
      result.stateMutability = "view";
    } else {
      result.stateMutability = result.payable ? "payable" : "nonpayable";
    }

    if (result.payable && result.constant) {
      logger.throwArgumentError("cannot have constant payable function", "value", value);
    }
  } else if (value.constant != null) {
    result.constant = !!value.constant;
    result.payable = !result.constant;
    result.stateMutability = result.constant ? "view" : "payable";
  } else if (value.type !== "constructor") {
    logger.throwArgumentError("unable to determine stateMutability", "value", value);
  }

  return result;
}

class ConstructorFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }

    if (!FormatTypes[format]) {
      logger.throwArgumentError("invalid format type", "format", format);
    }

    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : undefined,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : undefined,
        inputs: this.inputs.map(input => JSON.parse(input.format(format)))
      });
    }

    if (format === FormatTypes.sighash) {
      logger.throwError("cannot format a constructor for sighash", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "format(sighash)"
      });
    }

    let result = "constructor(" + this.inputs.map(input => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";

    if (this.stateMutability && this.stateMutability !== "nonpayable") {
      result += this.stateMutability + " ";
    }

    return result.trim();
  }

  static from(value) {
    if (typeof value === "string") {
      return ConstructorFragment.fromString(value);
    }

    return ConstructorFragment.fromObject(value);
  }

  static fromObject(value) {
    if (ConstructorFragment.isConstructorFragment(value)) {
      return value;
    }

    if (value.type !== "constructor") {
      logger.throwArgumentError("invalid constructor object", "value", value);
    }

    let state = verifyState(value);

    if (state.constant) {
      logger.throwArgumentError("constructor cannot be constant", "value", value);
    }

    const params = {
      name: null,
      type: value.type,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      payable: state.payable,
      stateMutability: state.stateMutability,
      gas: value.gas ? _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(value.gas) : null
    };
    return new ConstructorFragment(_constructorGuard, params);
  }

  static fromString(value) {
    let params = {
      type: "constructor"
    };
    value = parseGas(value, params);
    let parens = value.match(regexParen);

    if (!parens || parens[1].trim() !== "constructor") {
      logger.throwArgumentError("invalid constructor string", "value", value);
    }

    params.inputs = parseParams(parens[2].trim(), false);
    parseModifiers(parens[3].trim(), params);
    return ConstructorFragment.fromObject(params);
  }

  static isConstructorFragment(value) {
    return value && value._isFragment && value.type === "constructor";
  }

}
class FunctionFragment extends ConstructorFragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }

    if (!FormatTypes[format]) {
      logger.throwArgumentError("invalid format type", "format", format);
    }

    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : undefined,
        payable: this.payable,
        gas: this.gas ? this.gas.toNumber() : undefined,
        inputs: this.inputs.map(input => JSON.parse(input.format(format))),
        outputs: this.outputs.map(output => JSON.parse(output.format(format)))
      });
    }

    let result = "";

    if (format !== FormatTypes.sighash) {
      result += "function ";
    }

    result += this.name + "(" + this.inputs.map(input => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";

    if (format !== FormatTypes.sighash) {
      if (this.stateMutability) {
        if (this.stateMutability !== "nonpayable") {
          result += this.stateMutability + " ";
        }
      } else if (this.constant) {
        result += "view ";
      }

      if (this.outputs && this.outputs.length) {
        result += "returns (" + this.outputs.map(output => output.format(format)).join(", ") + ") ";
      }

      if (this.gas != null) {
        result += "@" + this.gas.toString() + " ";
      }
    }

    return result.trim();
  }

  static from(value) {
    if (typeof value === "string") {
      return FunctionFragment.fromString(value);
    }

    return FunctionFragment.fromObject(value);
  }

  static fromObject(value) {
    if (FunctionFragment.isFunctionFragment(value)) {
      return value;
    }

    if (value.type !== "function") {
      logger.throwArgumentError("invalid function object", "value", value);
    }

    let state = verifyState(value);
    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      constant: state.constant,
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : [],
      outputs: value.outputs ? value.outputs.map(ParamType.fromObject) : [],
      payable: state.payable,
      stateMutability: state.stateMutability,
      gas: value.gas ? _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_3__.BigNumber.from(value.gas) : null
    };
    return new FunctionFragment(_constructorGuard, params);
  }

  static fromString(value) {
    let params = {
      type: "function"
    };
    value = parseGas(value, params);
    let comps = value.split(" returns ");

    if (comps.length > 2) {
      logger.throwArgumentError("invalid function string", "value", value);
    }

    let parens = comps[0].match(regexParen);

    if (!parens) {
      logger.throwArgumentError("invalid function signature", "value", value);
    }

    params.name = parens[1].trim();

    if (params.name) {
      verifyIdentifier(params.name);
    }

    params.inputs = parseParams(parens[2], false);
    parseModifiers(parens[3].trim(), params); // We have outputs

    if (comps.length > 1) {
      let returns = comps[1].match(regexParen);

      if (returns[1].trim() != "" || returns[3].trim() != "") {
        logger.throwArgumentError("unexpected tokens", "value", value);
      }

      params.outputs = parseParams(returns[2], false);
    } else {
      params.outputs = [];
    }

    return FunctionFragment.fromObject(params);
  }

  static isFunctionFragment(value) {
    return value && value._isFragment && value.type === "function";
  }

} //export class StructFragment extends Fragment {
//}

function checkForbidden(fragment) {
  const sig = fragment.format();

  if (sig === "Error(string)" || sig === "Panic(uint256)") {
    logger.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
  }

  return fragment;
}

class ErrorFragment extends Fragment {
  format(format) {
    if (!format) {
      format = FormatTypes.sighash;
    }

    if (!FormatTypes[format]) {
      logger.throwArgumentError("invalid format type", "format", format);
    }

    if (format === FormatTypes.json) {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map(input => JSON.parse(input.format(format)))
      });
    }

    let result = "";

    if (format !== FormatTypes.sighash) {
      result += "error ";
    }

    result += this.name + "(" + this.inputs.map(input => input.format(format)).join(format === FormatTypes.full ? ", " : ",") + ") ";
    return result.trim();
  }

  static from(value) {
    if (typeof value === "string") {
      return ErrorFragment.fromString(value);
    }

    return ErrorFragment.fromObject(value);
  }

  static fromObject(value) {
    if (ErrorFragment.isErrorFragment(value)) {
      return value;
    }

    if (value.type !== "error") {
      logger.throwArgumentError("invalid error object", "value", value);
    }

    const params = {
      type: value.type,
      name: verifyIdentifier(value.name),
      inputs: value.inputs ? value.inputs.map(ParamType.fromObject) : []
    };
    return checkForbidden(new ErrorFragment(_constructorGuard, params));
  }

  static fromString(value) {
    let params = {
      type: "error"
    };
    let parens = value.match(regexParen);

    if (!parens) {
      logger.throwArgumentError("invalid error signature", "value", value);
    }

    params.name = parens[1].trim();

    if (params.name) {
      verifyIdentifier(params.name);
    }

    params.inputs = parseParams(parens[2], false);
    return checkForbidden(ErrorFragment.fromObject(params));
  }

  static isErrorFragment(value) {
    return value && value._isFragment && value.type === "error";
  }

}

function verifyType(type) {
  // These need to be transformed to their full description
  if (type.match(/^uint($|[^1-9])/)) {
    type = "uint256" + type.substring(4);
  } else if (type.match(/^int($|[^1-9])/)) {
    type = "int256" + type.substring(3);
  } // @TODO: more verification


  return type;
} // See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234


const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");

function verifyIdentifier(value) {
  if (!value || !value.match(regexIdentifier)) {
    logger.throwArgumentError(`invalid identifier "${value}"`, "value", value);
  }

  return value;
}

const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");

function splitNesting(value) {
  value = value.trim();
  let result = [];
  let accum = "";
  let depth = 0;

  for (let offset = 0; offset < value.length; offset++) {
    let c = value[offset];

    if (c === "," && depth === 0) {
      result.push(accum);
      accum = "";
    } else {
      accum += c;

      if (c === "(") {
        depth++;
      } else if (c === ")") {
        depth--;

        if (depth === -1) {
          logger.throwArgumentError("unbalanced parenthesis", "value", value);
        }
      }
    }
  }

  if (accum) {
    result.push(accum);
  }

  return result;
}

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbiCoder": () => (/* reexport safe */ _abi_coder__WEBPACK_IMPORTED_MODULE_1__.AbiCoder),
/* harmony export */   "ConstructorFragment": () => (/* reexport safe */ _fragments__WEBPACK_IMPORTED_MODULE_0__.ConstructorFragment),
/* harmony export */   "ErrorFragment": () => (/* reexport safe */ _fragments__WEBPACK_IMPORTED_MODULE_0__.ErrorFragment),
/* harmony export */   "EventFragment": () => (/* reexport safe */ _fragments__WEBPACK_IMPORTED_MODULE_0__.EventFragment),
/* harmony export */   "FormatTypes": () => (/* reexport safe */ _fragments__WEBPACK_IMPORTED_MODULE_0__.FormatTypes),
/* harmony export */   "Fragment": () => (/* reexport safe */ _fragments__WEBPACK_IMPORTED_MODULE_0__.Fragment),
/* harmony export */   "FunctionFragment": () => (/* reexport safe */ _fragments__WEBPACK_IMPORTED_MODULE_0__.FunctionFragment),
/* harmony export */   "Indexed": () => (/* reexport safe */ _interface__WEBPACK_IMPORTED_MODULE_2__.Indexed),
/* harmony export */   "Interface": () => (/* reexport safe */ _interface__WEBPACK_IMPORTED_MODULE_2__.Interface),
/* harmony export */   "LogDescription": () => (/* reexport safe */ _interface__WEBPACK_IMPORTED_MODULE_2__.LogDescription),
/* harmony export */   "ParamType": () => (/* reexport safe */ _fragments__WEBPACK_IMPORTED_MODULE_0__.ParamType),
/* harmony export */   "TransactionDescription": () => (/* reexport safe */ _interface__WEBPACK_IMPORTED_MODULE_2__.TransactionDescription),
/* harmony export */   "checkResultErrors": () => (/* reexport safe */ _interface__WEBPACK_IMPORTED_MODULE_3__.checkResultErrors),
/* harmony export */   "defaultAbiCoder": () => (/* reexport safe */ _abi_coder__WEBPACK_IMPORTED_MODULE_1__.defaultAbiCoder)
/* harmony export */ });
/* harmony import */ var _fragments__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fragments */ "./node_modules/@ethersproject/abi/lib.esm/fragments.js");
/* harmony import */ var _abi_coder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abi-coder */ "./node_modules/@ethersproject/abi/lib.esm/abi-coder.js");
/* harmony import */ var _interface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interface */ "./node_modules/@ethersproject/abi/lib.esm/interface.js");
/* harmony import */ var _interface__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interface */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");







/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/interface.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/interface.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ErrorDescription": () => (/* binding */ ErrorDescription),
/* harmony export */   "Indexed": () => (/* binding */ Indexed),
/* harmony export */   "Interface": () => (/* binding */ Interface),
/* harmony export */   "LogDescription": () => (/* binding */ LogDescription),
/* harmony export */   "TransactionDescription": () => (/* binding */ TransactionDescription),
/* harmony export */   "checkResultErrors": () => (/* reexport safe */ _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_2__.checkResultErrors)
/* harmony export */ });
/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/address */ "./node_modules/@ethersproject/address/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/hash */ "./node_modules/@ethersproject/hash/lib.esm/id.js");
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _abi_coder__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abi-coder */ "./node_modules/@ethersproject/abi/lib.esm/abi-coder.js");
/* harmony import */ var _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./coders/abstract-coder */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");
/* harmony import */ var _fragments__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./fragments */ "./node_modules/@ethersproject/abi/lib.esm/fragments.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/abi/lib.esm/_version.js");













const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);

class LogDescription extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.Description {}
class TransactionDescription extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.Description {}
class ErrorDescription extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.Description {}
class Indexed extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.Description {
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }

}
const BuiltinErrors = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: true
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"]
  }
};

function wrapAccessError(property, error) {
  const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
  wrap.error = error;
  return wrap;
}
/*
function checkNames(fragment: Fragment, type: "input" | "output", params: Array<ParamType>): void {
    params.reduce((accum, param) => {
        if (param.name) {
            if (accum[param.name]) {
                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format("full") }`, "fragment", fragment);
            }
            accum[param.name] = true;
        }
        return accum;
    }, <{ [ name: string ]: boolean }>{ });
}
*/


class Interface {
  constructor(fragments) {
    logger.checkNew(new.target, Interface);
    let abi = [];

    if (typeof fragments === "string") {
      abi = JSON.parse(fragments);
    } else {
      abi = fragments;
    }

    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "fragments", abi.map(fragment => {
      return _fragments__WEBPACK_IMPORTED_MODULE_4__.Fragment.from(fragment);
    }).filter(fragment => fragment != null));
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "_abiCoder", (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, "getAbiCoder")());
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "functions", {});
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "errors", {});
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "events", {});
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "structs", {}); // Add all fragments by their signature

    this.fragments.forEach(fragment => {
      let bucket = null;

      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            logger.warn("duplicate definition - constructor");
            return;
          } //checkNames(fragment, "input", fragment.inputs);


          (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "deploy", fragment);
          return;

        case "function":
          //checkNames(fragment, "input", fragment.inputs);
          //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);
          bucket = this.functions;
          break;

        case "event":
          //checkNames(fragment, "input", fragment.inputs);
          bucket = this.events;
          break;

        case "error":
          bucket = this.errors;
          break;

        default:
          return;
      }

      let signature = fragment.format();

      if (bucket[signature]) {
        logger.warn("duplicate definition - " + signature);
        return;
      }

      bucket[signature] = fragment;
    }); // If we do not have a constructor add a default

    if (!this.deploy) {
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "deploy", _fragments__WEBPACK_IMPORTED_MODULE_4__.ConstructorFragment.from({
        payable: false,
        type: "constructor"
      }));
    }

    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "_isInterface", true);
  }

  format(format) {
    if (!format) {
      format = _fragments__WEBPACK_IMPORTED_MODULE_4__.FormatTypes.full;
    }

    if (format === _fragments__WEBPACK_IMPORTED_MODULE_4__.FormatTypes.sighash) {
      logger.throwArgumentError("interface does not support formatting sighash", "format", format);
    }

    const abi = this.fragments.map(fragment => fragment.format(format)); // We need to re-bundle the JSON fragments a bit

    if (format === _fragments__WEBPACK_IMPORTED_MODULE_4__.FormatTypes.json) {
      return JSON.stringify(abi.map(j => JSON.parse(j)));
    }

    return abi;
  } // Sub-classes can override these to handle other blockchains


  static getAbiCoder() {
    return _abi_coder__WEBPACK_IMPORTED_MODULE_5__.defaultAbiCoder;
  }

  static getAddress(address) {
    return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_6__.getAddress)(address);
  }

  static getSighash(fragment) {
    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexDataSlice)((0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__.id)(fragment.format()), 0, 4);
  }

  static getEventTopic(eventFragment) {
    return (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__.id)(eventFragment.format());
  } // Find a function definition by any means necessary (unless it is ambiguous)


  getFunction(nameOrSignatureOrSighash) {
    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.isHexString)(nameOrSignatureOrSighash)) {
      for (const name in this.functions) {
        if (nameOrSignatureOrSighash === this.getSighash(name)) {
          return this.functions[name];
        }
      }

      logger.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
    } // It is a bare name, look up the function (will return null if ambiguous)


    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.functions).filter(f => f.split("("
      /* fix:) */
      )[0] === name);

      if (matching.length === 0) {
        logger.throwArgumentError("no matching function", "name", name);
      } else if (matching.length > 1) {
        logger.throwArgumentError("multiple matching functions", "name", name);
      }

      return this.functions[matching[0]];
    } // Normalize the signature and lookup the function


    const result = this.functions[_fragments__WEBPACK_IMPORTED_MODULE_4__.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];

    if (!result) {
      logger.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
    }

    return result;
  } // Find an event definition by any means necessary (unless it is ambiguous)


  getEvent(nameOrSignatureOrTopic) {
    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.isHexString)(nameOrSignatureOrTopic)) {
      const topichash = nameOrSignatureOrTopic.toLowerCase();

      for (const name in this.events) {
        if (topichash === this.getEventTopic(name)) {
          return this.events[name];
        }
      }

      logger.throwArgumentError("no matching event", "topichash", topichash);
    } // It is a bare name, look up the function (will return null if ambiguous)


    if (nameOrSignatureOrTopic.indexOf("(") === -1) {
      const name = nameOrSignatureOrTopic.trim();
      const matching = Object.keys(this.events).filter(f => f.split("("
      /* fix:) */
      )[0] === name);

      if (matching.length === 0) {
        logger.throwArgumentError("no matching event", "name", name);
      } else if (matching.length > 1) {
        logger.throwArgumentError("multiple matching events", "name", name);
      }

      return this.events[matching[0]];
    } // Normalize the signature and lookup the function


    const result = this.events[_fragments__WEBPACK_IMPORTED_MODULE_4__.EventFragment.fromString(nameOrSignatureOrTopic).format()];

    if (!result) {
      logger.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
    }

    return result;
  } // Find a function definition by any means necessary (unless it is ambiguous)


  getError(nameOrSignatureOrSighash) {
    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.isHexString)(nameOrSignatureOrSighash)) {
      const getSighash = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, "getSighash");

      for (const name in this.errors) {
        const error = this.errors[name];

        if (nameOrSignatureOrSighash === getSighash(error)) {
          return this.errors[name];
        }
      }

      logger.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
    } // It is a bare name, look up the function (will return null if ambiguous)


    if (nameOrSignatureOrSighash.indexOf("(") === -1) {
      const name = nameOrSignatureOrSighash.trim();
      const matching = Object.keys(this.errors).filter(f => f.split("("
      /* fix:) */
      )[0] === name);

      if (matching.length === 0) {
        logger.throwArgumentError("no matching error", "name", name);
      } else if (matching.length > 1) {
        logger.throwArgumentError("multiple matching errors", "name", name);
      }

      return this.errors[matching[0]];
    } // Normalize the signature and lookup the function


    const result = this.errors[_fragments__WEBPACK_IMPORTED_MODULE_4__.FunctionFragment.fromString(nameOrSignatureOrSighash).format()];

    if (!result) {
      logger.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
    }

    return result;
  } // Get the sighash (the bytes4 selector) used by Solidity to identify a function


  getSighash(fragment) {
    if (typeof fragment === "string") {
      try {
        fragment = this.getFunction(fragment);
      } catch (error) {
        try {
          fragment = this.getError(fragment);
        } catch (_) {
          throw error;
        }
      }
    }

    return (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, "getSighash")(fragment);
  } // Get the topic (the bytes32 hash) used by Solidity to identify an event


  getEventTopic(eventFragment) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }

    return (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, "getEventTopic")(eventFragment);
  }

  _decodeParams(params, data) {
    return this._abiCoder.decode(params, data);
  }

  _encodeParams(params, values) {
    return this._abiCoder.encode(params, values);
  }

  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }

  decodeErrorResult(fragment, data) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }

    const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.arrayify)(data);

    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
      logger.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes));
    }

    return this._decodeParams(fragment.inputs, bytes.slice(4));
  }

  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      fragment = this.getError(fragment);
    }

    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.concat)([this.getSighash(fragment), this._encodeParams(fragment.inputs, values || [])]));
  } // Decode the data for a function call (e.g. tx.data)


  decodeFunctionData(functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }

    const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.arrayify)(data);

    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
      logger.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes));
    }

    return this._decodeParams(functionFragment.inputs, bytes.slice(4));
  } // Encode the data for a function call (e.g. tx.data)


  encodeFunctionData(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }

    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.concat)([this.getSighash(functionFragment), this._encodeParams(functionFragment.inputs, values || [])]));
  } // Decode the result from a function call (e.g. from eth_call)


  decodeFunctionResult(functionFragment, data) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }

    let bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.arrayify)(data);
    let reason = null;
    let message = "";
    let errorArgs = null;
    let errorName = null;
    let errorSignature = null;

    switch (bytes.length % this._abiCoder._getWordSize()) {
      case 0:
        try {
          return this._abiCoder.decode(functionFragment.outputs, bytes);
        } catch (error) {}

        break;

      case 4:
        {
          const selector = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(bytes.slice(0, 4));
          const builtin = BuiltinErrors[selector];

          if (builtin) {
            errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
            errorName = builtin.name;
            errorSignature = builtin.signature;

            if (builtin.reason) {
              reason = errorArgs[0];
            }

            if (errorName === "Error") {
              message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;
            } else if (errorName === "Panic") {
              message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;
            }
          } else {
            try {
              const error = this.getError(selector);
              errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
              errorName = error.name;
              errorSignature = error.format();
            } catch (error) {}
          }

          break;
        }
    }

    return logger.throwError("call revert exception" + message, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.CALL_EXCEPTION, {
      method: functionFragment.format(),
      data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(data),
      errorArgs,
      errorName,
      errorSignature,
      reason
    });
  } // Encode the result for a function call (e.g. for eth_call)


  encodeFunctionResult(functionFragment, values) {
    if (typeof functionFragment === "string") {
      functionFragment = this.getFunction(functionFragment);
    }

    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(this._abiCoder.encode(functionFragment.outputs, values || []));
  } // Create the filter for the event with search criteria (e.g. for eth_filterLog)


  encodeFilterTopics(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }

    if (values.length > eventFragment.inputs.length) {
      logger.throwError("too many arguments for " + eventFragment.format(), _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNEXPECTED_ARGUMENT, {
        argument: "values",
        value: values
      });
    }

    let topics = [];

    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }

    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__.id)(value);
      } else if (param.type === "bytes") {
        return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_9__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(value));
      } // Check addresses are valid


      if (param.type === "address") {
        this._abiCoder.encode(["address"], [value]);
      }

      return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexZeroPad)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(value), 32);
    };

    values.forEach((value, index) => {
      let param = eventFragment.inputs[index];

      if (!param.indexed) {
        if (value != null) {
          logger.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        }

        return;
      }

      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        logger.throwArgumentError("filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map(value => encodeTopic(param, value)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    }); // Trim off trailing nulls

    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }

    return topics;
  }

  encodeEventLog(eventFragment, values) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }

    const topics = [];
    const dataTypes = [];
    const dataValues = [];

    if (!eventFragment.anonymous) {
      topics.push(this.getEventTopic(eventFragment));
    }

    if (values.length !== eventFragment.inputs.length) {
      logger.throwArgumentError("event arguments/values mismatch", "values", values);
    }

    eventFragment.inputs.forEach((param, index) => {
      const value = values[index];

      if (param.indexed) {
        if (param.type === "string") {
          topics.push((0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_8__.id)(value));
        } else if (param.type === "bytes") {
          topics.push((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_9__.keccak256)(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          // @TODO
          throw new Error("not implemented");
        } else {
          topics.push(this._abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this._abiCoder.encode(dataTypes, dataValues),
      topics: topics
    };
  } // Decode a filter for the event and the search criteria


  decodeEventLog(eventFragment, data, topics) {
    if (typeof eventFragment === "string") {
      eventFragment = this.getEvent(eventFragment);
    }

    if (topics != null && !eventFragment.anonymous) {
      let topicHash = this.getEventTopic(eventFragment);

      if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.isHexString)(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
        logger.throwError("fragment/topic mismatch", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {
          argument: "topics[0]",
          expected: topicHash,
          value: topics[0]
        });
      }

      topics = topics.slice(1);
    }

    let indexed = [];
    let nonIndexed = [];
    let dynamic = [];
    eventFragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(_fragments__WEBPACK_IMPORTED_MODULE_4__.ParamType.fromObject({
            type: "bytes32",
            name: param.name
          }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    let resultIndexed = topics != null ? this._abiCoder.decode(indexed, (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.concat)(topics)) : null;

    let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);

    let result = [];
    let nonIndexedIndex = 0,
        indexedIndex = 0;
    eventFragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (resultIndexed == null) {
          result[index] = new Indexed({
            _isIndexed: true,
            hash: null
          });
        } else if (dynamic[index]) {
          result[index] = new Indexed({
            _isIndexed: true,
            hash: resultIndexed[indexedIndex++]
          });
        } else {
          try {
            result[index] = resultIndexed[indexedIndex++];
          } catch (error) {
            result[index] = error;
          }
        }
      } else {
        try {
          result[index] = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          result[index] = error;
        }
      } // Add the keyword argument if named and safe


      if (param.name && result[param.name] == null) {
        const value = result[index]; // Make error named values throw on access

        if (value instanceof Error) {
          Object.defineProperty(result, param.name, {
            enumerable: true,
            get: () => {
              throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value);
            }
          });
        } else {
          result[param.name] = value;
        }
      }
    }); // Make all error indexed values throw on access

    for (let i = 0; i < result.length; i++) {
      const value = result[i];

      if (value instanceof Error) {
        Object.defineProperty(result, i, {
          enumerable: true,
          get: () => {
            throw wrapAccessError(`index ${i}`, value);
          }
        });
      }
    }

    return Object.freeze(result);
  } // Given a transaction, find the matching function fragment (if any) and
  // determine all its properties and call parameters


  parseTransaction(tx) {
    let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());

    if (!fragment) {
      return null;
    }

    return new TransactionDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
      functionFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment),
      value: _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_10__.BigNumber.from(tx.value || "0")
    });
  } // @TODO
  //parseCallResult(data: BytesLike): ??
  // Given an event log, find the matching event fragment (if any) and
  // determine all its properties and values


  parseLog(log) {
    let fragment = this.getEvent(log.topics[0]);

    if (!fragment || fragment.anonymous) {
      return null;
    } // @TODO: If anonymous, and the only method, and the input count matches, should we parse?
    //        Probably not, because just because it is the only event in the ABI does
    //        not mean we have the full ABI; maybe just a fragment?


    return new LogDescription({
      eventFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      topic: this.getEventTopic(fragment),
      args: this.decodeEventLog(fragment, log.data, log.topics)
    });
  }

  parseError(data) {
    const hexData = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify)(data);
    let fragment = this.getError(hexData.substring(0, 10).toLowerCase());

    if (!fragment) {
      return null;
    }

    return new ErrorDescription({
      args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
      errorFragment: fragment,
      name: fragment.name,
      signature: fragment.format(),
      sighash: this.getSighash(fragment)
    });
  }
  /*
  static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
      if (Interface.isInterface(value)) {
          return value;
      }
      if (typeof(value) === "string") {
          return new Interface(JSON.parse(value));
      }
      return new Interface(value);
  }
  */


  static isInterface(value) {
    return !!(value && value._isInterface);
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/abstract-provider/lib.esm/_version.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@ethersproject/abstract-provider/lib.esm/_version.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "abstract-provider/5.6.0";

/***/ }),

/***/ "./node_modules/@ethersproject/abstract-provider/lib.esm/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@ethersproject/abstract-provider/lib.esm/index.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BlockForkEvent": () => (/* binding */ BlockForkEvent),
/* harmony export */   "ForkEvent": () => (/* binding */ ForkEvent),
/* harmony export */   "Provider": () => (/* binding */ Provider),
/* harmony export */   "TransactionForkEvent": () => (/* binding */ TransactionForkEvent),
/* harmony export */   "TransactionOrderForkEvent": () => (/* binding */ TransactionOrderForkEvent)
/* harmony export */ });
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/abstract-provider/lib.esm/_version.js");


var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};






const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
;
; //export type CallTransactionable = {
//    call(transaction: TransactionRequest): Promise<TransactionResponse>;
//};

class ForkEvent extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.Description {
  static isForkEvent(value) {
    return !!(value && value._isForkEvent);
  }

}
class BlockForkEvent extends ForkEvent {
  constructor(blockHash, expiry) {
    if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(blockHash, 32)) {
      logger.throwArgumentError("invalid blockHash", "blockHash", blockHash);
    }

    super({
      _isForkEvent: true,
      _isBlockForkEvent: true,
      expiry: expiry || 0,
      blockHash: blockHash
    });
  }

}
class TransactionForkEvent extends ForkEvent {
  constructor(hash, expiry) {
    if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(hash, 32)) {
      logger.throwArgumentError("invalid transaction hash", "hash", hash);
    }

    super({
      _isForkEvent: true,
      _isTransactionForkEvent: true,
      expiry: expiry || 0,
      hash: hash
    });
  }

}
class TransactionOrderForkEvent extends ForkEvent {
  constructor(beforeHash, afterHash, expiry) {
    if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(beforeHash, 32)) {
      logger.throwArgumentError("invalid transaction hash", "beforeHash", beforeHash);
    }

    if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(afterHash, 32)) {
      logger.throwArgumentError("invalid transaction hash", "afterHash", afterHash);
    }

    super({
      _isForkEvent: true,
      _isTransactionOrderForkEvent: true,
      expiry: expiry || 0,
      beforeHash: beforeHash,
      afterHash: afterHash
    });
  }

} ///////////////////////////////
// Exported Abstracts

class Provider {
  constructor() {
    logger.checkAbstract(new.target, Provider);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, "_isProvider", true);
  }

  getFeeData() {
    return __awaiter(this, void 0, void 0, function* () {
      const {
        block,
        gasPrice
      } = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)({
        block: this.getBlock("latest"),
        gasPrice: this.getGasPrice().catch(error => {
          // @TODO: Why is this now failing on Calaveras?
          //console.log(error);
          return null;
        })
      });
      let maxFeePerGas = null,
          maxPriorityFeePerGas = null;

      if (block && block.baseFeePerGas) {
        // We may want to compute this more accurately in the future,
        // using the formula "check if the base fee is correct".
        // See: https://eips.ethereum.org/EIPS/eip-1559
        maxPriorityFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from("1500000000");
        maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
      }

      return {
        maxFeePerGas,
        maxPriorityFeePerGas,
        gasPrice
      };
    });
  } // Alias for "on"


  addListener(eventName, listener) {
    return this.on(eventName, listener);
  } // Alias for "off"


  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }

  static isProvider(value) {
    return !!(value && value._isProvider);
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/abstract-signer/lib.esm/_version.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@ethersproject/abstract-signer/lib.esm/_version.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "abstract-signer/5.6.0";

/***/ }),

/***/ "./node_modules/@ethersproject/abstract-signer/lib.esm/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@ethersproject/abstract-signer/lib.esm/index.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Signer": () => (/* binding */ Signer),
/* harmony export */   "VoidSigner": () => (/* binding */ VoidSigner)
/* harmony export */ });
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/abstract-signer/lib.esm/_version.js");


var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};




const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
const allowedTransactionKeys = ["accessList", "ccipReadEnabled", "chainId", "customData", "data", "from", "gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "to", "type", "value"];
const forwardErrors = [_ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INSUFFICIENT_FUNDS, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NONCE_EXPIRED, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.REPLACEMENT_UNDERPRICED];
;
;
class Signer {
  ///////////////////
  // Sub-classes MUST call super
  constructor() {
    logger.checkAbstract(new.target, Signer);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, "_isSigner", true);
  } ///////////////////
  // Sub-classes MAY override these


  getBalance(blockTag) {
    return __awaiter(this, void 0, void 0, function* () {
      this._checkProvider("getBalance");

      return yield this.provider.getBalance(this.getAddress(), blockTag);
    });
  }

  getTransactionCount(blockTag) {
    return __awaiter(this, void 0, void 0, function* () {
      this._checkProvider("getTransactionCount");

      return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
    });
  } // Populates "from" if unspecified, and estimates the gas for the transaction


  estimateGas(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
      this._checkProvider("estimateGas");

      const tx = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)(this.checkTransaction(transaction));
      return yield this.provider.estimateGas(tx);
    });
  } // Populates "from" if unspecified, and calls with the transaction


  call(transaction, blockTag) {
    return __awaiter(this, void 0, void 0, function* () {
      this._checkProvider("call");

      const tx = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)(this.checkTransaction(transaction));
      return yield this.provider.call(tx, blockTag);
    });
  } // Populates all fields in a transaction, signs it and sends it to the network


  sendTransaction(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
      this._checkProvider("sendTransaction");

      const tx = yield this.populateTransaction(transaction);
      const signedTx = yield this.signTransaction(tx);
      return yield this.provider.sendTransaction(signedTx);
    });
  }

  getChainId() {
    return __awaiter(this, void 0, void 0, function* () {
      this._checkProvider("getChainId");

      const network = yield this.provider.getNetwork();
      return network.chainId;
    });
  }

  getGasPrice() {
    return __awaiter(this, void 0, void 0, function* () {
      this._checkProvider("getGasPrice");

      return yield this.provider.getGasPrice();
    });
  }

  getFeeData() {
    return __awaiter(this, void 0, void 0, function* () {
      this._checkProvider("getFeeData");

      return yield this.provider.getFeeData();
    });
  }

  resolveName(name) {
    return __awaiter(this, void 0, void 0, function* () {
      this._checkProvider("resolveName");

      return yield this.provider.resolveName(name);
    });
  } // Checks a transaction does not contain invalid keys and if
  // no "from" is provided, populates it.
  // - does NOT require a provider
  // - adds "from" is not present
  // - returns a COPY (safe to mutate the result)
  // By default called from: (overriding these prevents it)
  //   - call
  //   - estimateGas
  //   - populateTransaction (and therefor sendTransaction)


  checkTransaction(transaction) {
    for (const key in transaction) {
      if (allowedTransactionKeys.indexOf(key) === -1) {
        logger.throwArgumentError("invalid transaction key: " + key, "transaction", transaction);
      }
    }

    const tx = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.shallowCopy)(transaction);

    if (tx.from == null) {
      tx.from = this.getAddress();
    } else {
      // Make sure any provided address matches this signer
      tx.from = Promise.all([Promise.resolve(tx.from), this.getAddress()]).then(result => {
        if (result[0].toLowerCase() !== result[1].toLowerCase()) {
          logger.throwArgumentError("from address mismatch", "transaction", transaction);
        }

        return result[0];
      });
    }

    return tx;
  } // Populates ALL keys for a transaction and checks that "from" matches
  // this Signer. Should be used by sendTransaction but NOT by signTransaction.
  // By default called from: (overriding these prevents it)
  //   - sendTransaction
  //
  // Notes:
  //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas


  populateTransaction(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
      const tx = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)(this.checkTransaction(transaction));

      if (tx.to != null) {
        tx.to = Promise.resolve(tx.to).then(to => __awaiter(this, void 0, void 0, function* () {
          if (to == null) {
            return null;
          }

          const address = yield this.resolveName(to);

          if (address == null) {
            logger.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
          }

          return address;
        })); // Prevent this error from causing an UnhandledPromiseException

        tx.to.catch(error => {});
      } // Do not allow mixing pre-eip-1559 and eip-1559 properties


      const hasEip1559 = tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null;

      if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
        logger.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
      } else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
        logger.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
      }

      if ((tx.type === 2 || tx.type == null) && tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null) {
        // Fully-formed EIP-1559 transaction (skip getFeeData)
        tx.type = 2;
      } else if (tx.type === 0 || tx.type === 1) {
        // Explicit Legacy or EIP-2930 transaction
        // Populate missing gasPrice
        if (tx.gasPrice == null) {
          tx.gasPrice = this.getGasPrice();
        }
      } else {
        // We need to get fee data to determine things
        const feeData = yield this.getFeeData();

        if (tx.type == null) {
          // We need to auto-detect the intended type of this transaction...
          if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
            // The network supports EIP-1559!
            // Upgrade transaction from null to eip-1559
            tx.type = 2;

            if (tx.gasPrice != null) {
              // Using legacy gasPrice property on an eip-1559 network,
              // so use gasPrice as both fee properties
              const gasPrice = tx.gasPrice;
              delete tx.gasPrice;
              tx.maxFeePerGas = gasPrice;
              tx.maxPriorityFeePerGas = gasPrice;
            } else {
              // Populate missing fee data
              if (tx.maxFeePerGas == null) {
                tx.maxFeePerGas = feeData.maxFeePerGas;
              }

              if (tx.maxPriorityFeePerGas == null) {
                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
              }
            }
          } else if (feeData.gasPrice != null) {
            // Network doesn't support EIP-1559...
            // ...but they are trying to use EIP-1559 properties
            if (hasEip1559) {
              logger.throwError("network does not support EIP-1559", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "populateTransaction"
              });
            } // Populate missing fee data


            if (tx.gasPrice == null) {
              tx.gasPrice = feeData.gasPrice;
            } // Explicitly set untyped transaction to legacy


            tx.type = 0;
          } else {
            // getFeeData has failed us.
            logger.throwError("failed to get consistent fee data", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "signer.getFeeData"
            });
          }
        } else if (tx.type === 2) {
          // Explicitly using EIP-1559
          // Populate missing fee data
          if (tx.maxFeePerGas == null) {
            tx.maxFeePerGas = feeData.maxFeePerGas;
          }

          if (tx.maxPriorityFeePerGas == null) {
            tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
          }
        }
      }

      if (tx.nonce == null) {
        tx.nonce = this.getTransactionCount("pending");
      }

      if (tx.gasLimit == null) {
        tx.gasLimit = this.estimateGas(tx).catch(error => {
          if (forwardErrors.indexOf(error.code) >= 0) {
            throw error;
          }

          return logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
            error: error,
            tx: tx
          });
        });
      }

      if (tx.chainId == null) {
        tx.chainId = this.getChainId();
      } else {
        tx.chainId = Promise.all([Promise.resolve(tx.chainId), this.getChainId()]).then(results => {
          if (results[1] !== 0 && results[0] !== results[1]) {
            logger.throwArgumentError("chainId address mismatch", "transaction", transaction);
          }

          return results[0];
        });
      }

      return yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.resolveProperties)(tx);
    });
  } ///////////////////
  // Sub-classes SHOULD leave these alone


  _checkProvider(operation) {
    if (!this.provider) {
      logger.throwError("missing provider", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: operation || "_checkProvider"
      });
    }
  }

  static isSigner(value) {
    return !!(value && value._isSigner);
  }

}
class VoidSigner extends Signer {
  constructor(address, provider) {
    logger.checkNew(new.target, VoidSigner);
    super();
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, "address", address);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, "provider", provider || null);
  }

  getAddress() {
    return Promise.resolve(this.address);
  }

  _fail(message, operation) {
    return Promise.resolve().then(() => {
      logger.throwError(message, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: operation
      });
    });
  }

  signMessage(message) {
    return this._fail("VoidSigner cannot sign messages", "signMessage");
  }

  signTransaction(transaction) {
    return this._fail("VoidSigner cannot sign transactions", "signTransaction");
  }

  _signTypedData(domain, types, value) {
    return this._fail("VoidSigner cannot sign typed data", "signTypedData");
  }

  connect(provider) {
    return new VoidSigner(this.address, provider);
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/address/lib.esm/_version.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersproject/address/lib.esm/_version.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "address/5.6.0";

/***/ }),

/***/ "./node_modules/@ethersproject/address/lib.esm/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/address/lib.esm/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getAddress": () => (/* binding */ getAddress),
/* harmony export */   "getContractAddress": () => (/* binding */ getContractAddress),
/* harmony export */   "getCreate2Address": () => (/* binding */ getCreate2Address),
/* harmony export */   "getIcapAddress": () => (/* binding */ getIcapAddress),
/* harmony export */   "isAddress": () => (/* binding */ isAddress)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/rlp */ "./node_modules/@ethersproject/rlp/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/address/lib.esm/_version.js");








const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);

function getChecksumAddress(address) {
  if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isHexString)(address, 20)) {
    logger.throwArgumentError("invalid address", "address", address);
  }

  address = address.toLowerCase();
  const chars = address.substring(2).split("");
  const expanded = new Uint8Array(40);

  for (let i = 0; i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }

  const hashed = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__.keccak256)(expanded));

  for (let i = 0; i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }

    if ((hashed[i >> 1] & 0x0f) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }

  return "0x" + chars.join("");
} // Shims for environments that are missing some required constants and functions


const MAX_SAFE_INTEGER = 0x1fffffffffffff;

function log10(x) {
  if (Math.log10) {
    return Math.log10(x);
  }

  return Math.log(x) / Math.LN10;
} // See: https://en.wikipedia.org/wiki/International_Bank_Account_Number
// Create lookup table


const ibanLookup = {};

for (let i = 0; i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}

for (let i = 0; i < 26; i++) {
  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
} // How many decimal digits can we process? (for 64-bit float, this is 15)


const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));

function ibanChecksum(address) {
  address = address.toUpperCase();
  address = address.substring(4) + address.substring(0, 2) + "00";
  let expanded = address.split("").map(c => {
    return ibanLookup[c];
  }).join(""); // Javascript can handle integers safely up to 15 (decimal) digits

  while (expanded.length >= safeDigits) {
    let block = expanded.substring(0, safeDigits);
    expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
  }

  let checksum = String(98 - parseInt(expanded, 10) % 97);

  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }

  return checksum;
}

;
function getAddress(address) {
  let result = null;

  if (typeof address !== "string") {
    logger.throwArgumentError("invalid address", "address", address);
  }

  if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    // Missing the 0x prefix
    if (address.substring(0, 2) !== "0x") {
      address = "0x" + address;
    }

    result = getChecksumAddress(address); // It is a checksummed address with a bad checksum

    if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
      logger.throwArgumentError("bad address checksum", "address", address);
    } // Maybe ICAP? (we only support direct mode)

  } else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    // It is an ICAP address with a bad checksum
    if (address.substring(2, 4) !== ibanChecksum(address)) {
      logger.throwArgumentError("bad icap checksum", "address", address);
    }

    result = (0,_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__._base36To16)(address.substring(4));

    while (result.length < 40) {
      result = "0" + result;
    }

    result = getChecksumAddress("0x" + result);
  } else {
    logger.throwArgumentError("invalid address", "address", address);
  }

  return result;
}
function isAddress(address) {
  try {
    getAddress(address);
    return true;
  } catch (error) {}

  return false;
}
function getIcapAddress(address) {
  let base36 = (0,_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__._base16To36)(getAddress(address).substring(2)).toUpperCase();

  while (base36.length < 30) {
    base36 = "0" + base36;
  }

  return "XE" + ibanChecksum("XE00" + base36) + base36;
} // http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed

function getContractAddress(transaction) {
  let from = null;

  try {
    from = getAddress(transaction.from);
  } catch (error) {
    logger.throwArgumentError("missing from address", "transaction", transaction);
  }

  const nonce = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.stripZeros)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction.nonce).toHexString()));
  return getAddress((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataSlice)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_ethersproject_rlp__WEBPACK_IMPORTED_MODULE_5__.encode)([from, nonce])), 12));
}
function getCreate2Address(from, salt, initCodeHash) {
  if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataLength)(salt) !== 32) {
    logger.throwArgumentError("salt must be 32 bytes", "salt", salt);
  }

  if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataLength)(initCodeHash) !== 32) {
    logger.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
  }

  return getAddress((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataSlice)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.concat)(["0xff", getAddress(from), salt, initCodeHash])), 12));
}

/***/ }),

/***/ "./node_modules/@ethersproject/base64/lib.esm/base64.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/base64/lib.esm/base64.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decode": () => (/* binding */ decode),
/* harmony export */   "encode": () => (/* binding */ encode)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");



function decode(textData) {
  textData = atob(textData);
  const data = [];

  for (let i = 0; i < textData.length; i++) {
    data.push(textData.charCodeAt(i));
  }

  return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)(data);
}
function encode(data) {
  data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)(data);
  let textData = "";

  for (let i = 0; i < data.length; i++) {
    textData += String.fromCharCode(data[i]);
  }

  return btoa(textData);
}

/***/ }),

/***/ "./node_modules/@ethersproject/base64/lib.esm/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/base64/lib.esm/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decode": () => (/* reexport safe */ _base64__WEBPACK_IMPORTED_MODULE_0__.decode),
/* harmony export */   "encode": () => (/* reexport safe */ _base64__WEBPACK_IMPORTED_MODULE_0__.encode)
/* harmony export */ });
/* harmony import */ var _base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base64 */ "./node_modules/@ethersproject/base64/lib.esm/base64.js");




/***/ }),

/***/ "./node_modules/@ethersproject/basex/lib.esm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@ethersproject/basex/lib.esm/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Base32": () => (/* binding */ Base32),
/* harmony export */   "Base58": () => (/* binding */ Base58),
/* harmony export */   "BaseX": () => (/* binding */ BaseX)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/**
 * var basex = require("base-x");
 *
 * This implementation is heavily based on base-x. The main reason to
 * deviate was to prevent the dependency of Buffer.
 *
 * Contributors:
 *
 * base-x encoding
 * Forked from https://github.com/cryptocoinjs/bs58
 * Originally written by Mike Hearn for BitcoinJ
 * Copyright (c) 2011 Google Inc
 * Ported to JavaScript by Stefan Thomas
 * Merged Buffer refactorings from base58-native by Stephen Pair
 * Copyright (c) 2013 BitPay Inc
 *
 * The MIT License (MIT)
 *
 * Copyright base-x contributors (c) 2016
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 */


class BaseX {
  constructor(alphabet) {
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__.defineReadOnly)(this, "alphabet", alphabet);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__.defineReadOnly)(this, "base", alphabet.length);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__.defineReadOnly)(this, "_alphabetMap", {});
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__.defineReadOnly)(this, "_leader", alphabet.charAt(0)); // pre-compute lookup table

    for (let i = 0; i < alphabet.length; i++) {
      this._alphabetMap[alphabet.charAt(i)] = i;
    }
  }

  encode(value) {
    let source = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(value);

    if (source.length === 0) {
      return "";
    }

    let digits = [0];

    for (let i = 0; i < source.length; ++i) {
      let carry = source[i];

      for (let j = 0; j < digits.length; ++j) {
        carry += digits[j] << 8;
        digits[j] = carry % this.base;
        carry = carry / this.base | 0;
      }

      while (carry > 0) {
        digits.push(carry % this.base);
        carry = carry / this.base | 0;
      }
    }

    let string = ""; // deal with leading zeros

    for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {
      string += this._leader;
    } // convert digits to a string


    for (let q = digits.length - 1; q >= 0; --q) {
      string += this.alphabet[digits[q]];
    }

    return string;
  }

  decode(value) {
    if (typeof value !== "string") {
      throw new TypeError("Expected String");
    }

    let bytes = [];

    if (value.length === 0) {
      return new Uint8Array(bytes);
    }

    bytes.push(0);

    for (let i = 0; i < value.length; i++) {
      let byte = this._alphabetMap[value[i]];

      if (byte === undefined) {
        throw new Error("Non-base" + this.base + " character");
      }

      let carry = byte;

      for (let j = 0; j < bytes.length; ++j) {
        carry += bytes[j] * this.base;
        bytes[j] = carry & 0xff;
        carry >>= 8;
      }

      while (carry > 0) {
        bytes.push(carry & 0xff);
        carry >>= 8;
      }
    } // deal with leading zeros


    for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {
      bytes.push(0);
    }

    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(new Uint8Array(bytes.reverse()));
  }

}
const Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
const Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
 //console.log(Base58.decode("Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj"))
//console.log(Base58.encode(Base58.decode("Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj")))

/***/ }),

/***/ "./node_modules/@ethersproject/bignumber/lib.esm/_version.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersproject/bignumber/lib.esm/_version.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "bignumber/5.6.0";

/***/ }),

/***/ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BigNumber": () => (/* binding */ BigNumber),
/* harmony export */   "_base16To36": () => (/* binding */ _base16To36),
/* harmony export */   "_base36To16": () => (/* binding */ _base36To16),
/* harmony export */   "isBigNumberish": () => (/* binding */ isBigNumberish)
/* harmony export */ });
/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/bignumber/lib.esm/_version.js");

/**
 *  BigNumber
 *
 *  A wrapper around the BN.js object. We use the BN.js library
 *  because it is used by elliptic, so it is required regardless.
 *
 */


var BN = (bn_js__WEBPACK_IMPORTED_MODULE_0___default().BN);



const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(_version__WEBPACK_IMPORTED_MODULE_2__.version);
const _constructorGuard = {};
const MAX_SAFE = 0x1fffffffffffff;
function isBigNumberish(value) {
  return value != null && (BigNumber.isBigNumber(value) || typeof value === "number" && value % 1 === 0 || typeof value === "string" && !!value.match(/^-?[0-9]+$/) || (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(value) || typeof value === "bigint" || (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isBytes)(value));
} // Only warn about passing 10 into radix once

let _warnedToStringRadix = false;
class BigNumber {
  constructor(constructorGuard, hex) {
    logger.checkNew(new.target, BigNumber);

    if (constructorGuard !== _constructorGuard) {
      logger.throwError("cannot call constructor directly; use BigNumber.from", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new (BigNumber)"
      });
    }

    this._hex = hex;
    this._isBigNumber = true;
    Object.freeze(this);
  }

  fromTwos(value) {
    return toBigNumber(toBN(this).fromTwos(value));
  }

  toTwos(value) {
    return toBigNumber(toBN(this).toTwos(value));
  }

  abs() {
    if (this._hex[0] === "-") {
      return BigNumber.from(this._hex.substring(1));
    }

    return this;
  }

  add(other) {
    return toBigNumber(toBN(this).add(toBN(other)));
  }

  sub(other) {
    return toBigNumber(toBN(this).sub(toBN(other)));
  }

  div(other) {
    const o = BigNumber.from(other);

    if (o.isZero()) {
      throwFault("division-by-zero", "div");
    }

    return toBigNumber(toBN(this).div(toBN(other)));
  }

  mul(other) {
    return toBigNumber(toBN(this).mul(toBN(other)));
  }

  mod(other) {
    const value = toBN(other);

    if (value.isNeg()) {
      throwFault("division-by-zero", "mod");
    }

    return toBigNumber(toBN(this).umod(value));
  }

  pow(other) {
    const value = toBN(other);

    if (value.isNeg()) {
      throwFault("negative-power", "pow");
    }

    return toBigNumber(toBN(this).pow(value));
  }

  and(other) {
    const value = toBN(other);

    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "and");
    }

    return toBigNumber(toBN(this).and(value));
  }

  or(other) {
    const value = toBN(other);

    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "or");
    }

    return toBigNumber(toBN(this).or(value));
  }

  xor(other) {
    const value = toBN(other);

    if (this.isNegative() || value.isNeg()) {
      throwFault("unbound-bitwise-result", "xor");
    }

    return toBigNumber(toBN(this).xor(value));
  }

  mask(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "mask");
    }

    return toBigNumber(toBN(this).maskn(value));
  }

  shl(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "shl");
    }

    return toBigNumber(toBN(this).shln(value));
  }

  shr(value) {
    if (this.isNegative() || value < 0) {
      throwFault("negative-width", "shr");
    }

    return toBigNumber(toBN(this).shrn(value));
  }

  eq(other) {
    return toBN(this).eq(toBN(other));
  }

  lt(other) {
    return toBN(this).lt(toBN(other));
  }

  lte(other) {
    return toBN(this).lte(toBN(other));
  }

  gt(other) {
    return toBN(this).gt(toBN(other));
  }

  gte(other) {
    return toBN(this).gte(toBN(other));
  }

  isNegative() {
    return this._hex[0] === "-";
  }

  isZero() {
    return toBN(this).isZero();
  }

  toNumber() {
    try {
      return toBN(this).toNumber();
    } catch (error) {
      throwFault("overflow", "toNumber", this.toString());
    }

    return null;
  }

  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch (e) {}

    return logger.throwError("this platform does not support BigInt", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }

  toString() {
    // Lots of people expect this, which we do not support, so check (See: #889)
    if (arguments.length > 0) {
      if (arguments[0] === 10) {
        if (!_warnedToStringRadix) {
          _warnedToStringRadix = true;
          logger.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
        }
      } else if (arguments[0] === 16) {
        logger.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNEXPECTED_ARGUMENT, {});
      } else {
        logger.throwError("BigNumber.toString does not accept parameters", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNEXPECTED_ARGUMENT, {});
      }
    }

    return toBN(this).toString(10);
  }

  toHexString() {
    return this._hex;
  }

  toJSON(key) {
    return {
      type: "BigNumber",
      hex: this.toHexString()
    };
  }

  static from(value) {
    if (value instanceof BigNumber) {
      return value;
    }

    if (typeof value === "string") {
      if (value.match(/^-?0x[0-9a-f]+$/i)) {
        return new BigNumber(_constructorGuard, toHex(value));
      }

      if (value.match(/^-?[0-9]+$/)) {
        return new BigNumber(_constructorGuard, toHex(new BN(value)));
      }

      return logger.throwArgumentError("invalid BigNumber string", "value", value);
    }

    if (typeof value === "number") {
      if (value % 1) {
        throwFault("underflow", "BigNumber.from", value);
      }

      if (value >= MAX_SAFE || value <= -MAX_SAFE) {
        throwFault("overflow", "BigNumber.from", value);
      }

      return BigNumber.from(String(value));
    }

    const anyValue = value;

    if (typeof anyValue === "bigint") {
      return BigNumber.from(anyValue.toString());
    }

    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isBytes)(anyValue)) {
      return BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(anyValue));
    }

    if (anyValue) {
      // Hexable interface (takes priority)
      if (anyValue.toHexString) {
        const hex = anyValue.toHexString();

        if (typeof hex === "string") {
          return BigNumber.from(hex);
        }
      } else {
        // For now, handle legacy JSON-ified values (goes away in v6)
        let hex = anyValue._hex; // New-form JSON

        if (hex == null && anyValue.type === "BigNumber") {
          hex = anyValue.hex;
        }

        if (typeof hex === "string") {
          if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(hex) || hex[0] === "-" && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(hex.substring(1))) {
            return BigNumber.from(hex);
          }
        }
      }
    }

    return logger.throwArgumentError("invalid BigNumber value", "value", value);
  }

  static isBigNumber(value) {
    return !!(value && value._isBigNumber);
  }

} // Normalize the hex string

function toHex(value) {
  // For BN, call on the hex string
  if (typeof value !== "string") {
    return toHex(value.toString(16));
  } // If negative, prepend the negative sign to the normalized positive value


  if (value[0] === "-") {
    // Strip off the negative sign
    value = value.substring(1); // Cannot have multiple negative signs (e.g. "--0x04")

    if (value[0] === "-") {
      logger.throwArgumentError("invalid hex", "value", value);
    } // Call toHex on the positive component


    value = toHex(value); // Do not allow "-0x00"

    if (value === "0x00") {
      return value;
    } // Negate the value


    return "-" + value;
  } // Add a "0x" prefix if missing


  if (value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  } // Normalize zero


  if (value === "0x") {
    return "0x00";
  } // Make the string even length


  if (value.length % 2) {
    value = "0x0" + value.substring(2);
  } // Trim to smallest even-length string


  while (value.length > 4 && value.substring(0, 4) === "0x00") {
    value = "0x" + value.substring(4);
  }

  return value;
}

function toBigNumber(value) {
  return BigNumber.from(toHex(value));
}

function toBN(value) {
  const hex = BigNumber.from(value).toHexString();

  if (hex[0] === "-") {
    return new BN("-" + hex.substring(3), 16);
  }

  return new BN(hex.substring(2), 16);
}

function throwFault(fault, operation, value) {
  const params = {
    fault: fault,
    operation: operation
  };

  if (value != null) {
    params.value = value;
  }

  return logger.throwError(fault, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NUMERIC_FAULT, params);
} // value should have no prefix


function _base36To16(value) {
  return new BN(value, 36).toString(16);
} // value should have no prefix

function _base16To36(value) {
  return new BN(value, 16).toString(36);
}

/***/ }),

/***/ "./node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FixedFormat": () => (/* binding */ FixedFormat),
/* harmony export */   "FixedNumber": () => (/* binding */ FixedNumber),
/* harmony export */   "formatFixed": () => (/* binding */ formatFixed),
/* harmony export */   "parseFixed": () => (/* binding */ parseFixed)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/bignumber/lib.esm/_version.js");
/* harmony import */ var _bignumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");





const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);

const _constructorGuard = {};
const Zero = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(0);
const NegativeOne = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(-1);

function throwFault(message, fault, operation, value) {
  const params = {
    fault: fault,
    operation: operation
  };

  if (value !== undefined) {
    params.value = value;
  }

  return logger.throwError(message, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NUMERIC_FAULT, params);
} // Constant to pull zeros from for multipliers


let zeros = "0";

while (zeros.length < 256) {
  zeros += zeros;
} // Returns a string "1" followed by decimal "0"s


function getMultiplier(decimals) {
  if (typeof decimals !== "number") {
    try {
      decimals = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(decimals).toNumber();
    } catch (e) {}
  }

  if (typeof decimals === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
    return "1" + zeros.substring(0, decimals);
  }

  return logger.throwArgumentError("invalid decimal size", "decimals", decimals);
}

function formatFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }

  const multiplier = getMultiplier(decimals); // Make sure wei is a big number (convert as necessary)

  value = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value);
  const negative = value.lt(Zero);

  if (negative) {
    value = value.mul(NegativeOne);
  }

  let fraction = value.mod(multiplier).toString();

  while (fraction.length < multiplier.length - 1) {
    fraction = "0" + fraction;
  } // Strip training 0


  fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
  const whole = value.div(multiplier).toString();

  if (multiplier.length === 1) {
    value = whole;
  } else {
    value = whole + "." + fraction;
  }

  if (negative) {
    value = "-" + value;
  }

  return value;
}
function parseFixed(value, decimals) {
  if (decimals == null) {
    decimals = 0;
  }

  const multiplier = getMultiplier(decimals);

  if (typeof value !== "string" || !value.match(/^-?[0-9.]+$/)) {
    logger.throwArgumentError("invalid decimal value", "value", value);
  } // Is it negative?


  const negative = value.substring(0, 1) === "-";

  if (negative) {
    value = value.substring(1);
  }

  if (value === ".") {
    logger.throwArgumentError("missing value", "value", value);
  } // Split it into a whole and fractional part


  const comps = value.split(".");

  if (comps.length > 2) {
    logger.throwArgumentError("too many decimal points", "value", value);
  }

  let whole = comps[0],
      fraction = comps[1];

  if (!whole) {
    whole = "0";
  }

  if (!fraction) {
    fraction = "0";
  } // Trim trailing zeros


  while (fraction[fraction.length - 1] === "0") {
    fraction = fraction.substring(0, fraction.length - 1);
  } // Check the fraction doesn't exceed our decimals size


  if (fraction.length > multiplier.length - 1) {
    throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
  } // If decimals is 0, we have an empty string for fraction


  if (fraction === "") {
    fraction = "0";
  } // Fully pad the string with zeros to get to wei


  while (fraction.length < multiplier.length - 1) {
    fraction += "0";
  }

  const wholeValue = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(whole);
  const fractionValue = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(fraction);
  let wei = wholeValue.mul(multiplier).add(fractionValue);

  if (negative) {
    wei = wei.mul(NegativeOne);
  }

  return wei;
}
class FixedFormat {
  constructor(constructorGuard, signed, width, decimals) {
    if (constructorGuard !== _constructorGuard) {
      logger.throwError("cannot use FixedFormat constructor; use FixedFormat.from", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }

    this.signed = signed;
    this.width = width;
    this.decimals = decimals;
    this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
    this._multiplier = getMultiplier(decimals);
    Object.freeze(this);
  }

  static from(value) {
    if (value instanceof FixedFormat) {
      return value;
    }

    if (typeof value === "number") {
      value = `fixed128x${value}`;
    }

    let signed = true;
    let width = 128;
    let decimals = 18;

    if (typeof value === "string") {
      if (value === "fixed") {// defaults...
      } else if (value === "ufixed") {
        signed = false;
      } else {
        const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);

        if (!match) {
          logger.throwArgumentError("invalid fixed format", "format", value);
        }

        signed = match[1] !== "u";
        width = parseInt(match[2]);
        decimals = parseInt(match[3]);
      }
    } else if (value) {
      const check = (key, type, defaultValue) => {
        if (value[key] == null) {
          return defaultValue;
        }

        if (typeof value[key] !== type) {
          logger.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);
        }

        return value[key];
      };

      signed = check("signed", "boolean", signed);
      width = check("width", "number", width);
      decimals = check("decimals", "number", decimals);
    }

    if (width % 8) {
      logger.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
    }

    if (decimals > 80) {
      logger.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
    }

    return new FixedFormat(_constructorGuard, signed, width, decimals);
  }

}
class FixedNumber {
  constructor(constructorGuard, hex, value, format) {
    logger.checkNew(new.target, FixedNumber);

    if (constructorGuard !== _constructorGuard) {
      logger.throwError("cannot use FixedNumber constructor; use FixedNumber.from", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "new FixedFormat"
      });
    }

    this.format = format;
    this._hex = hex;
    this._value = value;
    this._isFixedNumber = true;
    Object.freeze(this);
  }

  _checkFormat(other) {
    if (this.format.name !== other.format.name) {
      logger.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
    }
  }

  addUnsafe(other) {
    this._checkFormat(other);

    const a = parseFixed(this._value, this.format.decimals);
    const b = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);
  }

  subUnsafe(other) {
    this._checkFormat(other);

    const a = parseFixed(this._value, this.format.decimals);
    const b = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);
  }

  mulUnsafe(other) {
    this._checkFormat(other);

    const a = parseFixed(this._value, this.format.decimals);
    const b = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
  }

  divUnsafe(other) {
    this._checkFormat(other);

    const a = parseFixed(this._value, this.format.decimals);
    const b = parseFixed(other._value, other.format.decimals);
    return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
  }

  floor() {
    const comps = this.toString().split(".");

    if (comps.length === 1) {
      comps.push("0");
    }

    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);

    if (this.isNegative() && hasFraction) {
      result = result.subUnsafe(ONE.toFormat(result.format));
    }

    return result;
  }

  ceiling() {
    const comps = this.toString().split(".");

    if (comps.length === 1) {
      comps.push("0");
    }

    let result = FixedNumber.from(comps[0], this.format);
    const hasFraction = !comps[1].match(/^(0*)$/);

    if (!this.isNegative() && hasFraction) {
      result = result.addUnsafe(ONE.toFormat(result.format));
    }

    return result;
  } // @TODO: Support other rounding algorithms


  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    } // If we are already in range, we're done


    const comps = this.toString().split(".");

    if (comps.length === 1) {
      comps.push("0");
    }

    if (decimals < 0 || decimals > 80 || decimals % 1) {
      logger.throwArgumentError("invalid decimal count", "decimals", decimals);
    }

    if (comps[1].length <= decimals) {
      return this;
    }

    const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
    const bump = BUMP.toFormat(this.format);
    return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
  }

  isZero() {
    return this._value === "0.0" || this._value === "0";
  }

  isNegative() {
    return this._value[0] === "-";
  }

  toString() {
    return this._value;
  }

  toHexString(width) {
    if (width == null) {
      return this._hex;
    }

    if (width % 8) {
      logger.throwArgumentError("invalid byte width", "width", width);
    }

    const hex = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(hex, width / 8);
  }

  toUnsafeFloat() {
    return parseFloat(this.toString());
  }

  toFormat(format) {
    return FixedNumber.fromString(this._value, format);
  }

  static fromValue(value, decimals, format) {
    // If decimals looks more like a format, and there is no format, shift the parameters
    if (format == null && decimals != null && !(0,_bignumber__WEBPACK_IMPORTED_MODULE_2__.isBigNumberish)(decimals)) {
      format = decimals;
      decimals = null;
    }

    if (decimals == null) {
      decimals = 0;
    }

    if (format == null) {
      format = "fixed";
    }

    return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
  }

  static fromString(value, format) {
    if (format == null) {
      format = "fixed";
    }

    const fixedFormat = FixedFormat.from(format);
    const numeric = parseFixed(value, fixedFormat.decimals);

    if (!fixedFormat.signed && numeric.lt(Zero)) {
      throwFault("unsigned value cannot be negative", "overflow", "value", value);
    }

    let hex = null;

    if (fixedFormat.signed) {
      hex = numeric.toTwos(fixedFormat.width).toHexString();
    } else {
      hex = numeric.toHexString();
      hex = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(hex, fixedFormat.width / 8);
    }

    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);
  }

  static fromBytes(value, format) {
    if (format == null) {
      format = "fixed";
    }

    const fixedFormat = FixedFormat.from(format);

    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value).length > fixedFormat.width / 8) {
      throw new Error("overflow");
    }

    let numeric = _bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value);

    if (fixedFormat.signed) {
      numeric = numeric.fromTwos(fixedFormat.width);
    }

    const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
    const decimal = formatFixed(numeric, fixedFormat.decimals);
    return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);
  }

  static from(value, format) {
    if (typeof value === "string") {
      return FixedNumber.fromString(value, format);
    }

    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isBytes)(value)) {
      return FixedNumber.fromBytes(value, format);
    }

    try {
      return FixedNumber.fromValue(value, 0, format);
    } catch (error) {
      // Allow NUMERIC_FAULT to bubble up
      if (error.code !== _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT) {
        throw error;
      }
    }

    return logger.throwArgumentError("invalid FixedNumber value", "value", value);
  }

  static isFixedNumber(value) {
    return !!(value && value._isFixedNumber);
  }

}
const ONE = FixedNumber.from(1);
const BUMP = FixedNumber.from("0.5");

/***/ }),

/***/ "./node_modules/@ethersproject/bytes/lib.esm/_version.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ethersproject/bytes/lib.esm/_version.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "bytes/5.6.1";

/***/ }),

/***/ "./node_modules/@ethersproject/bytes/lib.esm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@ethersproject/bytes/lib.esm/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "arrayify": () => (/* binding */ arrayify),
/* harmony export */   "concat": () => (/* binding */ concat),
/* harmony export */   "hexConcat": () => (/* binding */ hexConcat),
/* harmony export */   "hexDataLength": () => (/* binding */ hexDataLength),
/* harmony export */   "hexDataSlice": () => (/* binding */ hexDataSlice),
/* harmony export */   "hexStripZeros": () => (/* binding */ hexStripZeros),
/* harmony export */   "hexValue": () => (/* binding */ hexValue),
/* harmony export */   "hexZeroPad": () => (/* binding */ hexZeroPad),
/* harmony export */   "hexlify": () => (/* binding */ hexlify),
/* harmony export */   "isBytes": () => (/* binding */ isBytes),
/* harmony export */   "isBytesLike": () => (/* binding */ isBytesLike),
/* harmony export */   "isHexString": () => (/* binding */ isHexString),
/* harmony export */   "joinSignature": () => (/* binding */ joinSignature),
/* harmony export */   "splitSignature": () => (/* binding */ splitSignature),
/* harmony export */   "stripZeros": () => (/* binding */ stripZeros),
/* harmony export */   "zeroPad": () => (/* binding */ zeroPad)
/* harmony export */ });
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/bytes/lib.esm/_version.js");




const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version); ///////////////////////////////

function isHexable(value) {
  return !!value.toHexString;
}

function addSlice(array) {
  if (array.slice) {
    return array;
  }

  array.slice = function () {
    const args = Array.prototype.slice.call(arguments);
    return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
  };

  return array;
}

function isBytesLike(value) {
  return isHexString(value) && !(value.length % 2) || isBytes(value);
}

function isInteger(value) {
  return typeof value === "number" && value == value && value % 1 === 0;
}

function isBytes(value) {
  if (value == null) {
    return false;
  }

  if (value.constructor === Uint8Array) {
    return true;
  }

  if (typeof value === "string") {
    return false;
  }

  if (!isInteger(value.length) || value.length < 0) {
    return false;
  }

  for (let i = 0; i < value.length; i++) {
    const v = value[i];

    if (!isInteger(v) || v < 0 || v >= 256) {
      return false;
    }
  }

  return true;
}
function arrayify(value, options) {
  if (!options) {
    options = {};
  }

  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid arrayify value");
    const result = [];

    while (value) {
      result.unshift(value & 0xff);
      value = parseInt(String(value / 256));
    }

    if (result.length === 0) {
      result.push(0);
    }

    return addSlice(new Uint8Array(result));
  }

  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }

  if (isHexable(value)) {
    value = value.toHexString();
  }

  if (isHexString(value)) {
    let hex = value.substring(2);

    if (hex.length % 2) {
      if (options.hexPad === "left") {
        hex = "0" + hex;
      } else if (options.hexPad === "right") {
        hex += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }

    const result = [];

    for (let i = 0; i < hex.length; i += 2) {
      result.push(parseInt(hex.substring(i, i + 2), 16));
    }

    return addSlice(new Uint8Array(result));
  }

  if (isBytes(value)) {
    return addSlice(new Uint8Array(value));
  }

  return logger.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
  const objects = items.map(item => arrayify(item));
  const length = objects.reduce((accum, item) => accum + item.length, 0);
  const result = new Uint8Array(length);
  objects.reduce((offset, object) => {
    result.set(object, offset);
    return offset + object.length;
  }, 0);
  return addSlice(result);
}
function stripZeros(value) {
  let result = arrayify(value);

  if (result.length === 0) {
    return result;
  } // Find the first non-zero entry


  let start = 0;

  while (start < result.length && result[start] === 0) {
    start++;
  } // If we started with zeros, strip them


  if (start) {
    result = result.slice(start);
  }

  return result;
}
function zeroPad(value, length) {
  value = arrayify(value);

  if (value.length > length) {
    logger.throwArgumentError("value out of range", "value", arguments[0]);
  }

  const result = new Uint8Array(length);
  result.set(value, length - value.length);
  return addSlice(result);
}
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }

  if (length && value.length !== 2 + 2 * length) {
    return false;
  }

  return true;
}
const HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
  if (!options) {
    options = {};
  }

  if (typeof value === "number") {
    logger.checkSafeUint53(value, "invalid hexlify value");
    let hex = "";

    while (value) {
      hex = HexCharacters[value & 0xf] + hex;
      value = Math.floor(value / 16);
    }

    if (hex.length) {
      if (hex.length % 2) {
        hex = "0" + hex;
      }

      return "0x" + hex;
    }

    return "0x00";
  }

  if (typeof value === "bigint") {
    value = value.toString(16);

    if (value.length % 2) {
      return "0x0" + value;
    }

    return "0x" + value;
  }

  if (options.allowMissingPrefix && typeof value === "string" && value.substring(0, 2) !== "0x") {
    value = "0x" + value;
  }

  if (isHexable(value)) {
    return value.toHexString();
  }

  if (isHexString(value)) {
    if (value.length % 2) {
      if (options.hexPad === "left") {
        value = "0x0" + value.substring(2);
      } else if (options.hexPad === "right") {
        value += "0";
      } else {
        logger.throwArgumentError("hex data is odd-length", "value", value);
      }
    }

    return value.toLowerCase();
  }

  if (isBytes(value)) {
    let result = "0x";

    for (let i = 0; i < value.length; i++) {
      let v = value[i];
      result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
    }

    return result;
  }

  return logger.throwArgumentError("invalid hexlify value", "value", value);
}
/*
function unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {
    if (typeof(value) === "string" && value.length % 2 && value.substring(0, 2) === "0x") {
        return "0x0" + value.substring(2);
    }
    return value;
}
*/

function hexDataLength(data) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    return null;
  }

  return (data.length - 2) / 2;
}
function hexDataSlice(data, offset, endOffset) {
  if (typeof data !== "string") {
    data = hexlify(data);
  } else if (!isHexString(data) || data.length % 2) {
    logger.throwArgumentError("invalid hexData", "value", data);
  }

  offset = 2 + 2 * offset;

  if (endOffset != null) {
    return "0x" + data.substring(offset, 2 + 2 * endOffset);
  }

  return "0x" + data.substring(offset);
}
function hexConcat(items) {
  let result = "0x";
  items.forEach(item => {
    result += hexlify(item).substring(2);
  });
  return result;
}
function hexValue(value) {
  const trimmed = hexStripZeros(hexlify(value, {
    hexPad: "left"
  }));

  if (trimmed === "0x") {
    return "0x0";
  }

  return trimmed;
}
function hexStripZeros(value) {
  if (typeof value !== "string") {
    value = hexlify(value);
  }

  if (!isHexString(value)) {
    logger.throwArgumentError("invalid hex string", "value", value);
  }

  value = value.substring(2);
  let offset = 0;

  while (offset < value.length && value[offset] === "0") {
    offset++;
  }

  return "0x" + value.substring(offset);
}
function hexZeroPad(value, length) {
  if (typeof value !== "string") {
    value = hexlify(value);
  } else if (!isHexString(value)) {
    logger.throwArgumentError("invalid hex string", "value", value);
  }

  if (value.length > 2 * length + 2) {
    logger.throwArgumentError("value out of range", "value", arguments[1]);
  }

  while (value.length < 2 * length + 2) {
    value = "0x0" + value.substring(2);
  }

  return value;
}
function splitSignature(signature) {
  const result = {
    r: "0x",
    s: "0x",
    _vs: "0x",
    recoveryParam: 0,
    v: 0,
    yParityAndS: "0x",
    compact: "0x"
  };

  if (isBytesLike(signature)) {
    let bytes = arrayify(signature); // Get the r, s and v

    if (bytes.length === 64) {
      // EIP-2098; pull the v from the top bit of s and clear it
      result.v = 27 + (bytes[32] >> 7);
      bytes[32] &= 0x7f;
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
    } else if (bytes.length === 65) {
      result.r = hexlify(bytes.slice(0, 32));
      result.s = hexlify(bytes.slice(32, 64));
      result.v = bytes[64];
    } else {
      logger.throwArgumentError("invalid signature string", "signature", signature);
    } // Allow a recid to be used as the v


    if (result.v < 27) {
      if (result.v === 0 || result.v === 1) {
        result.v += 27;
      } else {
        logger.throwArgumentError("signature invalid v byte", "signature", signature);
      }
    } // Compute recoveryParam from v


    result.recoveryParam = 1 - result.v % 2; // Compute _vs from recoveryParam and s

    if (result.recoveryParam) {
      bytes[32] |= 0x80;
    }

    result._vs = hexlify(bytes.slice(32, 64));
  } else {
    result.r = signature.r;
    result.s = signature.s;
    result.v = signature.v;
    result.recoveryParam = signature.recoveryParam;
    result._vs = signature._vs; // If the _vs is available, use it to populate missing s, v and recoveryParam
    // and verify non-missing s, v and recoveryParam

    if (result._vs != null) {
      const vs = zeroPad(arrayify(result._vs), 32);
      result._vs = hexlify(vs); // Set or check the recid

      const recoveryParam = vs[0] >= 128 ? 1 : 0;

      if (result.recoveryParam == null) {
        result.recoveryParam = recoveryParam;
      } else if (result.recoveryParam !== recoveryParam) {
        logger.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature);
      } // Set or check the s


      vs[0] &= 0x7f;
      const s = hexlify(vs);

      if (result.s == null) {
        result.s = s;
      } else if (result.s !== s) {
        logger.throwArgumentError("signature v mismatch _vs", "signature", signature);
      }
    } // Use recid and v to populate each other


    if (result.recoveryParam == null) {
      if (result.v == null) {
        logger.throwArgumentError("signature missing v and recoveryParam", "signature", signature);
      } else if (result.v === 0 || result.v === 1) {
        result.recoveryParam = result.v;
      } else {
        result.recoveryParam = 1 - result.v % 2;
      }
    } else {
      if (result.v == null) {
        result.v = 27 + result.recoveryParam;
      } else {
        const recId = result.v === 0 || result.v === 1 ? result.v : 1 - result.v % 2;

        if (result.recoveryParam !== recId) {
          logger.throwArgumentError("signature recoveryParam mismatch v", "signature", signature);
        }
      }
    }

    if (result.r == null || !isHexString(result.r)) {
      logger.throwArgumentError("signature missing or invalid r", "signature", signature);
    } else {
      result.r = hexZeroPad(result.r, 32);
    }

    if (result.s == null || !isHexString(result.s)) {
      logger.throwArgumentError("signature missing or invalid s", "signature", signature);
    } else {
      result.s = hexZeroPad(result.s, 32);
    }

    const vs = arrayify(result.s);

    if (vs[0] >= 128) {
      logger.throwArgumentError("signature s out of range", "signature", signature);
    }

    if (result.recoveryParam) {
      vs[0] |= 0x80;
    }

    const _vs = hexlify(vs);

    if (result._vs) {
      if (!isHexString(result._vs)) {
        logger.throwArgumentError("signature invalid _vs", "signature", signature);
      }

      result._vs = hexZeroPad(result._vs, 32);
    } // Set or check the _vs


    if (result._vs == null) {
      result._vs = _vs;
    } else if (result._vs !== _vs) {
      logger.throwArgumentError("signature _vs mismatch v and s", "signature", signature);
    }
  }

  result.yParityAndS = result._vs;
  result.compact = result.r + result.yParityAndS.substring(2);
  return result;
}
function joinSignature(signature) {
  signature = splitSignature(signature);
  return hexlify(concat([signature.r, signature.s, signature.recoveryParam ? "0x1c" : "0x1b"]));
}

/***/ }),

/***/ "./node_modules/@ethersproject/constants/lib.esm/addresses.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ethersproject/constants/lib.esm/addresses.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddressZero": () => (/* binding */ AddressZero)
/* harmony export */ });
const AddressZero = "0x0000000000000000000000000000000000000000";

/***/ }),

/***/ "./node_modules/@ethersproject/constants/lib.esm/bignumbers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ethersproject/constants/lib.esm/bignumbers.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MaxInt256": () => (/* binding */ MaxInt256),
/* harmony export */   "MaxUint256": () => (/* binding */ MaxUint256),
/* harmony export */   "MinInt256": () => (/* binding */ MinInt256),
/* harmony export */   "NegativeOne": () => (/* binding */ NegativeOne),
/* harmony export */   "One": () => (/* binding */ One),
/* harmony export */   "Two": () => (/* binding */ Two),
/* harmony export */   "WeiPerEther": () => (/* binding */ WeiPerEther),
/* harmony export */   "Zero": () => (/* binding */ Zero)
/* harmony export */ });
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");

const NegativeOne = /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(-1);
const Zero = /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(0);
const One = /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(1);
const Two = /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from(2);
const WeiPerEther = /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from("1000000000000000000");
const MaxUint256 = /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
const MinInt256 = /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from("-0x8000000000000000000000000000000000000000000000000000000000000000");
const MaxInt256 = /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__.BigNumber.from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");


/***/ }),

/***/ "./node_modules/@ethersproject/constants/lib.esm/hashes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersproject/constants/lib.esm/hashes.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HashZero": () => (/* binding */ HashZero)
/* harmony export */ });
const HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";

/***/ }),

/***/ "./node_modules/@ethersproject/constants/lib.esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/constants/lib.esm/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddressZero": () => (/* reexport safe */ _addresses__WEBPACK_IMPORTED_MODULE_0__.AddressZero),
/* harmony export */   "EtherSymbol": () => (/* reexport safe */ _strings__WEBPACK_IMPORTED_MODULE_3__.EtherSymbol),
/* harmony export */   "HashZero": () => (/* reexport safe */ _hashes__WEBPACK_IMPORTED_MODULE_2__.HashZero),
/* harmony export */   "MaxInt256": () => (/* reexport safe */ _bignumbers__WEBPACK_IMPORTED_MODULE_1__.MaxInt256),
/* harmony export */   "MaxUint256": () => (/* reexport safe */ _bignumbers__WEBPACK_IMPORTED_MODULE_1__.MaxUint256),
/* harmony export */   "MinInt256": () => (/* reexport safe */ _bignumbers__WEBPACK_IMPORTED_MODULE_1__.MinInt256),
/* harmony export */   "NegativeOne": () => (/* reexport safe */ _bignumbers__WEBPACK_IMPORTED_MODULE_1__.NegativeOne),
/* harmony export */   "One": () => (/* reexport safe */ _bignumbers__WEBPACK_IMPORTED_MODULE_1__.One),
/* harmony export */   "Two": () => (/* reexport safe */ _bignumbers__WEBPACK_IMPORTED_MODULE_1__.Two),
/* harmony export */   "WeiPerEther": () => (/* reexport safe */ _bignumbers__WEBPACK_IMPORTED_MODULE_1__.WeiPerEther),
/* harmony export */   "Zero": () => (/* reexport safe */ _bignumbers__WEBPACK_IMPORTED_MODULE_1__.Zero)
/* harmony export */ });
/* harmony import */ var _addresses__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./addresses */ "./node_modules/@ethersproject/constants/lib.esm/addresses.js");
/* harmony import */ var _bignumbers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bignumbers */ "./node_modules/@ethersproject/constants/lib.esm/bignumbers.js");
/* harmony import */ var _hashes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hashes */ "./node_modules/@ethersproject/constants/lib.esm/hashes.js");
/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./strings */ "./node_modules/@ethersproject/constants/lib.esm/strings.js");







/***/ }),

/***/ "./node_modules/@ethersproject/constants/lib.esm/strings.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersproject/constants/lib.esm/strings.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EtherSymbol": () => (/* binding */ EtherSymbol)
/* harmony export */ });
// NFKC (composed)             // (decomposed)
const EtherSymbol = "\u039e"; // "\uD835\uDF63";

/***/ }),

/***/ "./node_modules/@ethersproject/contracts/lib.esm/_version.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersproject/contracts/lib.esm/_version.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "contracts/5.6.0";

/***/ }),

/***/ "./node_modules/@ethersproject/contracts/lib.esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/contracts/lib.esm/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseContract": () => (/* binding */ BaseContract),
/* harmony export */   "Contract": () => (/* binding */ Contract),
/* harmony export */   "ContractFactory": () => (/* binding */ ContractFactory)
/* harmony export */ });
/* harmony import */ var _ethersproject_abi__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/abi */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");
/* harmony import */ var _ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/abi */ "./node_modules/@ethersproject/abi/lib.esm/interface.js");
/* harmony import */ var _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/abstract-provider */ "./node_modules/@ethersproject/abstract-provider/lib.esm/index.js");
/* harmony import */ var _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/abstract-signer */ "./node_modules/@ethersproject/abstract-signer/lib.esm/index.js");
/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/address */ "./node_modules/@ethersproject/address/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/transactions */ "./node_modules/@ethersproject/transactions/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/contracts/lib.esm/_version.js");


var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};











const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
;
; ///////////////////////////////

const allowedTransactionKeys = {
  chainId: true,
  data: true,
  from: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true,
  customData: true,
  ccipReadEnabled: true
};

function resolveName(resolver, nameOrPromise) {
  return __awaiter(this, void 0, void 0, function* () {
    const name = yield nameOrPromise;

    if (typeof name !== "string") {
      logger.throwArgumentError("invalid address or ENS name", "name", name);
    } // If it is already an address, just use it (after adding checksum)


    try {
      return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(name);
    } catch (error) {}

    if (!resolver) {
      logger.throwError("a provider or signer is needed to resolve ENS names", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "resolveName"
      });
    }

    const address = yield resolver.resolveName(name);

    if (address == null) {
      logger.throwArgumentError("resolver or addr is not configured for ENS name", "name", name);
    }

    return address;
  });
} // Recursively replaces ENS names with promises to resolve the name and resolves all properties


function resolveAddresses(resolver, value, paramType) {
  return __awaiter(this, void 0, void 0, function* () {
    if (Array.isArray(paramType)) {
      return yield Promise.all(paramType.map((paramType, index) => {
        return resolveAddresses(resolver, Array.isArray(value) ? value[index] : value[paramType.name], paramType);
      }));
    }

    if (paramType.type === "address") {
      return yield resolveName(resolver, value);
    }

    if (paramType.type === "tuple") {
      return yield resolveAddresses(resolver, value, paramType.components);
    }

    if (paramType.baseType === "array") {
      if (!Array.isArray(value)) {
        return Promise.reject(logger.makeError("invalid value for array", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {
          argument: "value",
          value
        }));
      }

      return yield Promise.all(value.map(v => resolveAddresses(resolver, v, paramType.arrayChildren)));
    }

    return value;
  });
}

function populateTransaction(contract, fragment, args) {
  return __awaiter(this, void 0, void 0, function* () {
    // If an extra argument is given, it is overrides
    let overrides = {};

    if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      overrides = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(args.pop());
    } // Make sure the parameter count matches


    logger.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract"); // Populate "from" override (allow promises)

    if (contract.signer) {
      if (overrides.from) {
        // Contracts with a Signer are from the Signer's frame-of-reference;
        // but we allow overriding "from" if it matches the signer
        overrides.from = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)({
          override: resolveName(contract.signer, overrides.from),
          signer: contract.signer.getAddress()
        }).then(check => __awaiter(this, void 0, void 0, function* () {
          if ((0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(check.signer) !== check.override) {
            logger.throwError("Contract with a Signer cannot override from", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "overrides.from"
            });
          }

          return check.override;
        }));
      } else {
        overrides.from = contract.signer.getAddress();
      }
    } else if (overrides.from) {
      overrides.from = resolveName(contract.provider, overrides.from); //} else {
      // Contracts without a signer can override "from", and if
      // unspecified the zero address is used
      //overrides.from = AddressZero;
    } // Wait for all dependencies to be resolved (prefer the signer over the provider)


    const resolved = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)({
      args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
      address: contract.resolvedAddress,
      overrides: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.resolveProperties)(overrides) || {}
    }); // The ABI coded transaction

    const data = contract.interface.encodeFunctionData(fragment, resolved.args);
    const tx = {
      data: data,
      to: resolved.address
    }; // Resolved Overrides

    const ro = resolved.overrides; // Populate simple overrides

    if (ro.nonce != null) {
      tx.nonce = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.nonce).toNumber();
    }

    if (ro.gasLimit != null) {
      tx.gasLimit = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.gasLimit);
    }

    if (ro.gasPrice != null) {
      tx.gasPrice = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.gasPrice);
    }

    if (ro.maxFeePerGas != null) {
      tx.maxFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.maxFeePerGas);
    }

    if (ro.maxPriorityFeePerGas != null) {
      tx.maxPriorityFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.maxPriorityFeePerGas);
    }

    if (ro.from != null) {
      tx.from = ro.from;
    }

    if (ro.type != null) {
      tx.type = ro.type;
    }

    if (ro.accessList != null) {
      tx.accessList = (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_5__.accessListify)(ro.accessList);
    } // If there was no "gasLimit" override, but the ABI specifies a default, use it


    if (tx.gasLimit == null && fragment.gas != null) {
      // Compute the intrinsic gas cost for this transaction
      // @TODO: This is based on the yellow paper as of Petersburg; this is something
      // we may wish to parameterize in v6 as part of the Network object. Since this
      // is always a non-nil to address, we can ignore G_create, but may wish to add
      // similar logic to the ContractFactory.
      let intrinsic = 21000;
      const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(data);

      for (let i = 0; i < bytes.length; i++) {
        intrinsic += 4;

        if (bytes[i]) {
          intrinsic += 64;
        }
      }

      tx.gasLimit = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(fragment.gas).add(intrinsic);
    } // Populate "value" override


    if (ro.value) {
      const roValue = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(ro.value);

      if (!roValue.isZero() && !fragment.payable) {
        logger.throwError("non-payable method cannot override value", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: overrides.value
        });
      }

      tx.value = roValue;
    }

    if (ro.customData) {
      tx.customData = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(ro.customData);
    }

    if (ro.ccipReadEnabled) {
      tx.ccipReadEnabled = !!ro.ccipReadEnabled;
    } // Remove the overrides


    delete overrides.nonce;
    delete overrides.gasLimit;
    delete overrides.gasPrice;
    delete overrides.from;
    delete overrides.value;
    delete overrides.type;
    delete overrides.accessList;
    delete overrides.maxFeePerGas;
    delete overrides.maxPriorityFeePerGas;
    delete overrides.customData;
    delete overrides.ccipReadEnabled; // Make sure there are no stray overrides, which may indicate a
    // typo or using an unsupported key.

    const leftovers = Object.keys(overrides).filter(key => overrides[key] != null);

    if (leftovers.length) {
      logger.throwError(`cannot override ${leftovers.map(l => JSON.stringify(l)).join(",")}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "overrides",
        overrides: leftovers
      });
    }

    return tx;
  });
}

function buildPopulate(contract, fragment) {
  return function (...args) {
    return populateTransaction(contract, fragment, args);
  };
}

function buildEstimate(contract, fragment) {
  const signerOrProvider = contract.signer || contract.provider;
  return function (...args) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!signerOrProvider) {
        logger.throwError("estimate require a provider or signer", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "estimateGas"
        });
      }

      const tx = yield populateTransaction(contract, fragment, args);
      return yield signerOrProvider.estimateGas(tx);
    });
  };
}

function addContractWait(contract, tx) {
  const wait = tx.wait.bind(tx);

  tx.wait = confirmations => {
    return wait(confirmations).then(receipt => {
      receipt.events = receipt.logs.map(log => {
        let event = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.deepCopy)(log);
        let parsed = null;

        try {
          parsed = contract.interface.parseLog(log);
        } catch (e) {} // Successfully parsed the event log; include it


        if (parsed) {
          event.args = parsed.args;

          event.decode = (data, topics) => {
            return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
          };

          event.event = parsed.name;
          event.eventSignature = parsed.signature;
        } // Useful operations


        event.removeListener = () => {
          return contract.provider;
        };

        event.getBlock = () => {
          return contract.provider.getBlock(receipt.blockHash);
        };

        event.getTransaction = () => {
          return contract.provider.getTransaction(receipt.transactionHash);
        };

        event.getTransactionReceipt = () => {
          return Promise.resolve(receipt);
        };

        return event;
      });
      return receipt;
    });
  };
}

function buildCall(contract, fragment, collapseSimple) {
  const signerOrProvider = contract.signer || contract.provider;
  return function (...args) {
    return __awaiter(this, void 0, void 0, function* () {
      // Extract the "blockTag" override if present
      let blockTag = undefined;

      if (args.length === fragment.inputs.length + 1 && typeof args[args.length - 1] === "object") {
        const overrides = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(args.pop());

        if (overrides.blockTag != null) {
          blockTag = yield overrides.blockTag;
        }

        delete overrides.blockTag;
        args.push(overrides);
      } // If the contract was just deployed, wait until it is mined


      if (contract.deployTransaction != null) {
        yield contract._deployed(blockTag);
      } // Call a node and get the result


      const tx = yield populateTransaction(contract, fragment, args);
      const result = yield signerOrProvider.call(tx, blockTag);

      try {
        let value = contract.interface.decodeFunctionResult(fragment, result);

        if (collapseSimple && fragment.outputs.length === 1) {
          value = value[0];
        }

        return value;
      } catch (error) {
        if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.CALL_EXCEPTION) {
          error.address = contract.address;
          error.args = args;
          error.transaction = tx;
        }

        throw error;
      }
    });
  };
}

function buildSend(contract, fragment) {
  return function (...args) {
    return __awaiter(this, void 0, void 0, function* () {
      if (!contract.signer) {
        logger.throwError("sending a transaction requires a signer", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "sendTransaction"
        });
      } // If the contract was just deployed, wait until it is mined


      if (contract.deployTransaction != null) {
        yield contract._deployed();
      }

      const txRequest = yield populateTransaction(contract, fragment, args);
      const tx = yield contract.signer.sendTransaction(txRequest); // Tweak the tx.wait so the receipt has extra properties

      addContractWait(contract, tx);
      return tx;
    });
  };
}

function buildDefault(contract, fragment, collapseSimple) {
  if (fragment.constant) {
    return buildCall(contract, fragment, collapseSimple);
  }

  return buildSend(contract, fragment);
}

function getEventTag(filter) {
  if (filter.address && (filter.topics == null || filter.topics.length === 0)) {
    return "*";
  }

  return (filter.address || "*") + "@" + (filter.topics ? filter.topics.map(topic => {
    if (Array.isArray(topic)) {
      return topic.join("|");
    }

    return topic;
  }).join(":") : "");
}

class RunningEvent {
  constructor(tag, filter) {
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "tag", tag);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "filter", filter);
    this._listeners = [];
  }

  addListener(listener, once) {
    this._listeners.push({
      listener: listener,
      once: once
    });
  }

  removeListener(listener) {
    let done = false;
    this._listeners = this._listeners.filter(item => {
      if (done || item.listener !== listener) {
        return true;
      }

      done = true;
      return false;
    });
  }

  removeAllListeners() {
    this._listeners = [];
  }

  listeners() {
    return this._listeners.map(i => i.listener);
  }

  listenerCount() {
    return this._listeners.length;
  }

  run(args) {
    const listenerCount = this.listenerCount();
    this._listeners = this._listeners.filter(item => {
      const argsCopy = args.slice(); // Call the callback in the next event loop

      setTimeout(() => {
        item.listener.apply(this, argsCopy);
      }, 0); // Reschedule it if it not "once"

      return !item.once;
    });
    return listenerCount;
  }

  prepareEvent(event) {} // Returns the array that will be applied to an emit


  getEmit(event) {
    return [event];
  }

}

class ErrorRunningEvent extends RunningEvent {
  constructor() {
    super("error", null);
  }

} // @TODO Fragment should inherit Wildcard? and just override getEmit?
//       or have a common abstract super class, with enough constructor
//       options to configure both.
// A Fragment Event will populate all the properties that Wildcard
// will, and additionally dereference the arguments when emitting


class FragmentRunningEvent extends RunningEvent {
  constructor(address, contractInterface, fragment, topics) {
    const filter = {
      address: address
    };
    let topic = contractInterface.getEventTopic(fragment);

    if (topics) {
      if (topic !== topics[0]) {
        logger.throwArgumentError("topic mismatch", "topics", topics);
      }

      filter.topics = topics.slice();
    } else {
      filter.topics = [topic];
    }

    super(getEventTag(filter), filter);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "address", address);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "interface", contractInterface);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "fragment", fragment);
  }

  prepareEvent(event) {
    super.prepareEvent(event);
    event.event = this.fragment.name;
    event.eventSignature = this.fragment.format();

    event.decode = (data, topics) => {
      return this.interface.decodeEventLog(this.fragment, data, topics);
    };

    try {
      event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
    } catch (error) {
      event.args = null;
      event.decodeError = error;
    }
  }

  getEmit(event) {
    const errors = (0,_ethersproject_abi__WEBPACK_IMPORTED_MODULE_7__.checkResultErrors)(event.args);

    if (errors.length) {
      throw errors[0].error;
    }

    const args = (event.args || []).slice();
    args.push(event);
    return args;
  }

} // A Wildcard Event will attempt to populate:
//  - event            The name of the event name
//  - eventSignature   The full signature of the event
//  - decode           A function to decode data and topics
//  - args             The decoded data and topics


class WildcardRunningEvent extends RunningEvent {
  constructor(address, contractInterface) {
    super("*", {
      address: address
    });
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "address", address);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "interface", contractInterface);
  }

  prepareEvent(event) {
    super.prepareEvent(event);

    try {
      const parsed = this.interface.parseLog(event);
      event.event = parsed.name;
      event.eventSignature = parsed.signature;

      event.decode = (data, topics) => {
        return this.interface.decodeEventLog(parsed.eventFragment, data, topics);
      };

      event.args = parsed.args;
    } catch (error) {// No matching event
    }
  }

}

class BaseContract {
  constructor(addressOrName, contractInterface, signerOrProvider) {
    logger.checkNew(new.target, Contract); // @TODO: Maybe still check the addressOrName looks like a valid address or name?
    //address = getAddress(address);

    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "interface", (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, "getInterface")(contractInterface));

    if (signerOrProvider == null) {
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "provider", null);
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "signer", null);
    } else if (_ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_8__.Signer.isSigner(signerOrProvider)) {
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "provider", signerOrProvider.provider || null);
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "signer", signerOrProvider);
    } else if (_ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_9__.Provider.isProvider(signerOrProvider)) {
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "provider", signerOrProvider);
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "signer", null);
    } else {
      logger.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
    }

    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "callStatic", {});
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "estimateGas", {});
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "functions", {});
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "populateTransaction", {});
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "filters", {});
    {
      const uniqueFilters = {};
      Object.keys(this.interface.events).forEach(eventSignature => {
        const event = this.interface.events[eventSignature];
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.filters, eventSignature, (...args) => {
          return {
            address: this.address,
            topics: this.interface.encodeFilterTopics(event, args)
          };
        });

        if (!uniqueFilters[event.name]) {
          uniqueFilters[event.name] = [];
        }

        uniqueFilters[event.name].push(eventSignature);
      });
      Object.keys(uniqueFilters).forEach(name => {
        const filters = uniqueFilters[name];

        if (filters.length === 1) {
          (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.filters, name, this.filters[filters[0]]);
        } else {
          logger.warn(`Duplicate definition of ${name} (${filters.join(", ")})`);
        }
      });
    }
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "_runningEvents", {});
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "_wrappedEmits", {});

    if (addressOrName == null) {
      logger.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
    }

    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "address", addressOrName);

    if (this.provider) {
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "resolvedAddress", resolveName(this.provider, addressOrName));
    } else {
      try {
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "resolvedAddress", Promise.resolve((0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(addressOrName)));
      } catch (error) {
        // Without a provider, we cannot use ENS names
        logger.throwError("provider is required to use ENS name as contract address", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "new Contract"
        });
      }
    } // Swallow bad ENS names to prevent Unhandled Exceptions


    this.resolvedAddress.catch(e => {});
    const uniqueNames = {};
    const uniqueSignatures = {};
    Object.keys(this.interface.functions).forEach(signature => {
      const fragment = this.interface.functions[signature]; // Check that the signature is unique; if not the ABI generation has
      // not been cleaned or may be incorrectly generated

      if (uniqueSignatures[signature]) {
        logger.warn(`Duplicate ABI entry for ${JSON.stringify(signature)}`);
        return;
      }

      uniqueSignatures[signature] = true; // Track unique names; we only expose bare named functions if they
      // are ambiguous

      {
        const name = fragment.name;

        if (!uniqueNames[`%${name}`]) {
          uniqueNames[`%${name}`] = [];
        }

        uniqueNames[`%${name}`].push(signature);
      }

      if (this[signature] == null) {
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, signature, buildDefault(this, fragment, true));
      } // We do not collapse simple calls on this bucket, which allows
      // frameworks to safely use this without introspection as well as
      // allows decoding error recovery.


      if (this.functions[signature] == null) {
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.functions, signature, buildDefault(this, fragment, false));
      }

      if (this.callStatic[signature] == null) {
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.callStatic, signature, buildCall(this, fragment, true));
      }

      if (this.populateTransaction[signature] == null) {
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.populateTransaction, signature, buildPopulate(this, fragment));
      }

      if (this.estimateGas[signature] == null) {
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.estimateGas, signature, buildEstimate(this, fragment));
      }
    });
    Object.keys(uniqueNames).forEach(name => {
      // Ambiguous names to not get attached as bare names
      const signatures = uniqueNames[name];

      if (signatures.length > 1) {
        return;
      } // Strip off the leading "%" used for prototype protection


      name = name.substring(1);
      const signature = signatures[0]; // If overwriting a member property that is null, swallow the error

      try {
        if (this[name] == null) {
          (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, name, this[signature]);
        }
      } catch (e) {}

      if (this.functions[name] == null) {
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.functions, name, this.functions[signature]);
      }

      if (this.callStatic[name] == null) {
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.callStatic, name, this.callStatic[signature]);
      }

      if (this.populateTransaction[name] == null) {
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.populateTransaction, name, this.populateTransaction[signature]);
      }

      if (this.estimateGas[name] == null) {
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this.estimateGas, name, this.estimateGas[signature]);
      }
    });
  }

  static getContractAddress(transaction) {
    return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getContractAddress)(transaction);
  }

  static getInterface(contractInterface) {
    if (_ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__.Interface.isInterface(contractInterface)) {
      return contractInterface;
    }

    return new _ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__.Interface(contractInterface);
  } // @TODO: Allow timeout?


  deployed() {
    return this._deployed();
  }

  _deployed(blockTag) {
    if (!this._deployedPromise) {
      // If we were just deployed, we know the transaction we should occur in
      if (this.deployTransaction) {
        this._deployedPromise = this.deployTransaction.wait().then(() => {
          return this;
        });
      } else {
        // @TODO: Once we allow a timeout to be passed in, we will wait
        // up to that many blocks for getCode
        // Otherwise, poll for our code to be deployed
        this._deployedPromise = this.provider.getCode(this.address, blockTag).then(code => {
          if (code === "0x") {
            logger.throwError("contract not deployed", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
              contractAddress: this.address,
              operation: "getDeployed"
            });
          }

          return this;
        });
      }
    }

    return this._deployedPromise;
  } // @TODO:
  // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
  // @TODO:
  // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>


  fallback(overrides) {
    if (!this.signer) {
      logger.throwError("sending a transactions require a signer", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "sendTransaction(fallback)"
      });
    }

    const tx = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(overrides || {});
    ["from", "to"].forEach(function (key) {
      if (tx[key] == null) {
        return;
      }

      logger.throwError("cannot override " + key, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: key
      });
    });
    tx.to = this.resolvedAddress;
    return this.deployed().then(() => {
      return this.signer.sendTransaction(tx);
    });
  } // Reconnect to a different signer or provider


  connect(signerOrProvider) {
    if (typeof signerOrProvider === "string") {
      signerOrProvider = new _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_8__.VoidSigner(signerOrProvider, this.provider);
    }

    const contract = new this.constructor(this.address, this.interface, signerOrProvider);

    if (this.deployTransaction) {
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(contract, "deployTransaction", this.deployTransaction);
    }

    return contract;
  } // Re-attach to a different on-chain instance of this contract


  attach(addressOrName) {
    return new this.constructor(addressOrName, this.interface, this.signer || this.provider);
  }

  static isIndexed(value) {
    return _ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__.Indexed.isIndexed(value);
  }

  _normalizeRunningEvent(runningEvent) {
    // Already have an instance of this event running; we can re-use it
    if (this._runningEvents[runningEvent.tag]) {
      return this._runningEvents[runningEvent.tag];
    }

    return runningEvent;
  }

  _getRunningEvent(eventName) {
    if (typeof eventName === "string") {
      // Listen for "error" events (if your contract has an error event, include
      // the full signature to bypass this special event keyword)
      if (eventName === "error") {
        return this._normalizeRunningEvent(new ErrorRunningEvent());
      } // Listen for any event that is registered


      if (eventName === "event") {
        return this._normalizeRunningEvent(new RunningEvent("event", null));
      } // Listen for any event


      if (eventName === "*") {
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
      } // Get the event Fragment (throws if ambiguous/unknown event)


      const fragment = this.interface.getEvent(eventName);
      return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
    } // We have topics to filter by...


    if (eventName.topics && eventName.topics.length > 0) {
      // Is it a known topichash? (throws if no matching topichash)
      try {
        const topic = eventName.topics[0];

        if (typeof topic !== "string") {
          throw new Error("invalid topic"); // @TODO: May happen for anonymous events
        }

        const fragment = this.interface.getEvent(topic);
        return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
      } catch (error) {} // Filter by the unknown topichash


      const filter = {
        address: this.address,
        topics: eventName.topics
      };
      return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));
    }

    return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
  }

  _checkRunningEvents(runningEvent) {
    if (runningEvent.listenerCount() === 0) {
      delete this._runningEvents[runningEvent.tag]; // If we have a poller for this, remove it

      const emit = this._wrappedEmits[runningEvent.tag];

      if (emit && runningEvent.filter) {
        this.provider.off(runningEvent.filter, emit);
        delete this._wrappedEmits[runningEvent.tag];
      }
    }
  } // Subclasses can override this to gracefully recover
  // from parse errors if they wish


  _wrapEvent(runningEvent, log, listener) {
    const event = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.deepCopy)(log);

    event.removeListener = () => {
      if (!listener) {
        return;
      }

      runningEvent.removeListener(listener);

      this._checkRunningEvents(runningEvent);
    };

    event.getBlock = () => {
      return this.provider.getBlock(log.blockHash);
    };

    event.getTransaction = () => {
      return this.provider.getTransaction(log.transactionHash);
    };

    event.getTransactionReceipt = () => {
      return this.provider.getTransactionReceipt(log.transactionHash);
    }; // This may throw if the topics and data mismatch the signature


    runningEvent.prepareEvent(event);
    return event;
  }

  _addEventListener(runningEvent, listener, once) {
    if (!this.provider) {
      logger.throwError("events require a provider or a signer with a provider", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "once"
      });
    }

    runningEvent.addListener(listener, once); // Track this running event and its listeners (may already be there; but no hard in updating)

    this._runningEvents[runningEvent.tag] = runningEvent; // If we are not polling the provider, start polling

    if (!this._wrappedEmits[runningEvent.tag]) {
      const wrappedEmit = log => {
        let event = this._wrapEvent(runningEvent, log, listener); // Try to emit the result for the parameterized event...


        if (event.decodeError == null) {
          try {
            const args = runningEvent.getEmit(event);
            this.emit(runningEvent.filter, ...args);
          } catch (error) {
            event.decodeError = error.error;
          }
        } // Always emit "event" for fragment-base events


        if (runningEvent.filter != null) {
          this.emit("event", event);
        } // Emit "error" if there was an error


        if (event.decodeError != null) {
          this.emit("error", event.decodeError, event);
        }
      };

      this._wrappedEmits[runningEvent.tag] = wrappedEmit; // Special events, like "error" do not have a filter

      if (runningEvent.filter != null) {
        this.provider.on(runningEvent.filter, wrappedEmit);
      }
    }
  }

  queryFilter(event, fromBlockOrBlockhash, toBlock) {
    const runningEvent = this._getRunningEvent(event);

    const filter = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(runningEvent.filter);

    if (typeof fromBlockOrBlockhash === "string" && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.isHexString)(fromBlockOrBlockhash, 32)) {
      if (toBlock != null) {
        logger.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
      }

      filter.blockHash = fromBlockOrBlockhash;
    } else {
      filter.fromBlock = fromBlockOrBlockhash != null ? fromBlockOrBlockhash : 0;
      filter.toBlock = toBlock != null ? toBlock : "latest";
    }

    return this.provider.getLogs(filter).then(logs => {
      return logs.map(log => this._wrapEvent(runningEvent, log, null));
    });
  }

  on(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, false);

    return this;
  }

  once(event, listener) {
    this._addEventListener(this._getRunningEvent(event), listener, true);

    return this;
  }

  emit(eventName, ...args) {
    if (!this.provider) {
      return false;
    }

    const runningEvent = this._getRunningEvent(eventName);

    const result = runningEvent.run(args) > 0; // May have drained all the "once" events; check for living events

    this._checkRunningEvents(runningEvent);

    return result;
  }

  listenerCount(eventName) {
    if (!this.provider) {
      return 0;
    }

    if (eventName == null) {
      return Object.keys(this._runningEvents).reduce((accum, key) => {
        return accum + this._runningEvents[key].listenerCount();
      }, 0);
    }

    return this._getRunningEvent(eventName).listenerCount();
  }

  listeners(eventName) {
    if (!this.provider) {
      return [];
    }

    if (eventName == null) {
      const result = [];

      for (let tag in this._runningEvents) {
        this._runningEvents[tag].listeners().forEach(listener => {
          result.push(listener);
        });
      }

      return result;
    }

    return this._getRunningEvent(eventName).listeners();
  }

  removeAllListeners(eventName) {
    if (!this.provider) {
      return this;
    }

    if (eventName == null) {
      for (const tag in this._runningEvents) {
        const runningEvent = this._runningEvents[tag];
        runningEvent.removeAllListeners();

        this._checkRunningEvents(runningEvent);
      }

      return this;
    } // Delete any listeners


    const runningEvent = this._getRunningEvent(eventName);

    runningEvent.removeAllListeners();

    this._checkRunningEvents(runningEvent);

    return this;
  }

  off(eventName, listener) {
    if (!this.provider) {
      return this;
    }

    const runningEvent = this._getRunningEvent(eventName);

    runningEvent.removeListener(listener);

    this._checkRunningEvents(runningEvent);

    return this;
  }

  removeListener(eventName, listener) {
    return this.off(eventName, listener);
  }

}
class Contract extends BaseContract {}
class ContractFactory {
  constructor(contractInterface, bytecode, signer) {
    let bytecodeHex = null;

    if (typeof bytecode === "string") {
      bytecodeHex = bytecode;
    } else if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.isBytes)(bytecode)) {
      bytecodeHex = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(bytecode);
    } else if (bytecode && typeof bytecode.object === "string") {
      // Allow the bytecode object from the Solidity compiler
      bytecodeHex = bytecode.object;
    } else {
      // Crash in the next verification step
      bytecodeHex = "!";
    } // Make sure it is 0x prefixed


    if (bytecodeHex.substring(0, 2) !== "0x") {
      bytecodeHex = "0x" + bytecodeHex;
    } // Make sure the final result is valid bytecode


    if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.isHexString)(bytecodeHex) || bytecodeHex.length % 2) {
      logger.throwArgumentError("invalid bytecode", "bytecode", bytecode);
    } // If we have a signer, make sure it is valid


    if (signer && !_ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_8__.Signer.isSigner(signer)) {
      logger.throwArgumentError("invalid signer", "signer", signer);
    }

    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "bytecode", bytecodeHex);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "interface", (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, "getInterface")(contractInterface));
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "signer", signer || null);
  } // @TODO: Future; rename to populateTransaction?


  getDeployTransaction(...args) {
    let tx = {}; // If we have 1 additional argument, we allow transaction overrides

    if (args.length === this.interface.deploy.inputs.length + 1 && typeof args[args.length - 1] === "object") {
      tx = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(args.pop());

      for (const key in tx) {
        if (!allowedTransactionKeys[key]) {
          throw new Error("unknown transaction override " + key);
        }
      }
    } // Do not allow these to be overridden in a deployment transaction


    ["data", "from", "to"].forEach(key => {
      if (tx[key] == null) {
        return;
      }

      logger.throwError("cannot override " + key, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: key
      });
    });

    if (tx.value) {
      const value = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(tx.value);

      if (!value.isZero() && !this.interface.deploy.payable) {
        logger.throwError("non-payable constructor cannot override value", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "overrides.value",
          value: tx.value
        });
      }
    } // Make sure the call matches the constructor signature


    logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor"); // Set the data to the bytecode + the encoded constructor arguments

    tx.data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.concat)([this.bytecode, this.interface.encodeDeploy(args)]));
    return tx;
  }

  deploy(...args) {
    return __awaiter(this, void 0, void 0, function* () {
      let overrides = {}; // If 1 extra parameter was passed in, it contains overrides

      if (args.length === this.interface.deploy.inputs.length + 1) {
        overrides = args.pop();
      } // Make sure the call matches the constructor signature


      logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor"); // Resolve ENS names and promises in the arguments

      const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
      params.push(overrides); // Get the deployment transaction (with optional overrides)

      const unsignedTx = this.getDeployTransaction(...params); // Send the deployment transaction

      const tx = yield this.signer.sendTransaction(unsignedTx);
      const address = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, "getContractAddress")(tx);
      const contract = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(this.constructor, "getContract")(address, this.interface, this.signer); // Add the modified wait that wraps events

      addContractWait(contract, tx);
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(contract, "deployTransaction", tx);
      return contract;
    });
  }

  attach(address) {
    return this.constructor.getContract(address, this.interface, this.signer);
  }

  connect(signer) {
    return new this.constructor(this.interface, this.bytecode, signer);
  }

  static fromSolidity(compilerOutput, signer) {
    if (compilerOutput == null) {
      logger.throwError("missing compiler output", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.MISSING_ARGUMENT, {
        argument: "compilerOutput"
      });
    }

    if (typeof compilerOutput === "string") {
      compilerOutput = JSON.parse(compilerOutput);
    }

    const abi = compilerOutput.abi;
    let bytecode = null;

    if (compilerOutput.bytecode) {
      bytecode = compilerOutput.bytecode;
    } else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
      bytecode = compilerOutput.evm.bytecode;
    }

    return new this(abi, bytecode, signer);
  }

  static getInterface(contractInterface) {
    return Contract.getInterface(contractInterface);
  }

  static getContractAddress(tx) {
    return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getContractAddress)(tx);
  }

  static getContract(address, contractInterface, signer) {
    return new Contract(address, contractInterface, signer);
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/hash/lib.esm/_version.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/hash/lib.esm/_version.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "hash/5.6.0";

/***/ }),

/***/ "./node_modules/@ethersproject/hash/lib.esm/id.js":
/*!********************************************************!*\
  !*** ./node_modules/@ethersproject/hash/lib.esm/id.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "id": () => (/* binding */ id)
/* harmony export */ });
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/utf8.js");


function id(text) {
  return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_0__.keccak256)((0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(text));
}

/***/ }),

/***/ "./node_modules/@ethersproject/hash/lib.esm/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@ethersproject/hash/lib.esm/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_TypedDataEncoder": () => (/* reexport safe */ _typed_data__WEBPACK_IMPORTED_MODULE_3__.TypedDataEncoder),
/* harmony export */   "dnsEncode": () => (/* reexport safe */ _namehash__WEBPACK_IMPORTED_MODULE_1__.dnsEncode),
/* harmony export */   "hashMessage": () => (/* reexport safe */ _message__WEBPACK_IMPORTED_MODULE_2__.hashMessage),
/* harmony export */   "id": () => (/* reexport safe */ _id__WEBPACK_IMPORTED_MODULE_0__.id),
/* harmony export */   "isValidName": () => (/* reexport safe */ _namehash__WEBPACK_IMPORTED_MODULE_1__.isValidName),
/* harmony export */   "messagePrefix": () => (/* reexport safe */ _message__WEBPACK_IMPORTED_MODULE_2__.messagePrefix),
/* harmony export */   "namehash": () => (/* reexport safe */ _namehash__WEBPACK_IMPORTED_MODULE_1__.namehash)
/* harmony export */ });
/* harmony import */ var _id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./id */ "./node_modules/@ethersproject/hash/lib.esm/id.js");
/* harmony import */ var _namehash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namehash */ "./node_modules/@ethersproject/hash/lib.esm/namehash.js");
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./message */ "./node_modules/@ethersproject/hash/lib.esm/message.js");
/* harmony import */ var _typed_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./typed-data */ "./node_modules/@ethersproject/hash/lib.esm/typed-data.js");








/***/ }),

/***/ "./node_modules/@ethersproject/hash/lib.esm/message.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/hash/lib.esm/message.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "hashMessage": () => (/* binding */ hashMessage),
/* harmony export */   "messagePrefix": () => (/* binding */ messagePrefix)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/utf8.js");



const messagePrefix = "\x19Ethereum Signed Message:\n";
function hashMessage(message) {
  if (typeof message === "string") {
    message = (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes)(message);
  }

  return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_1__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.concat)([(0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes)(messagePrefix), (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes)(String(message.length)), message]));
}

/***/ }),

/***/ "./node_modules/@ethersproject/hash/lib.esm/namehash.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/hash/lib.esm/namehash.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "dnsEncode": () => (/* binding */ dnsEncode),
/* harmony export */   "isValidName": () => (/* binding */ isValidName),
/* harmony export */   "namehash": () => (/* binding */ namehash)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/idna.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/utf8.js");
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/hash/lib.esm/_version.js");





const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
const Zeros = new Uint8Array(32);
Zeros.fill(0);
const Partition = new RegExp("^((.*)\\.)?([^.]+)$");
function isValidName(name) {
  try {
    const comps = name.split(".");

    for (let i = 0; i < comps.length; i++) {
      if ((0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__.nameprep)(comps[i]).length === 0) {
        throw new Error("empty");
      }
    }

    return true;
  } catch (error) {}

  return false;
}
function namehash(name) {
  /* istanbul ignore if */
  if (typeof name !== "string") {
    logger.throwArgumentError("invalid ENS name; not a string", "name", name);
  }

  let current = name;
  let result = Zeros;

  while (current.length) {
    const partition = current.match(Partition);

    if (partition == null || partition[2] === "") {
      logger.throwArgumentError("invalid ENS address; missing component", "name", name);
    }

    const label = (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)((0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__.nameprep)(partition[3]));
    result = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.concat)([result, (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__.keccak256)(label)]));
    current = partition[2] || "";
  }

  return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexlify)(result);
}
function dnsEncode(name) {
  return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.concat)(name.split(".").map(comp => {
    // We jam in an _ prefix to fill in with the length later
    // Note: Nameprep throws if the component is over 63 bytes
    const bytes = (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)("_" + (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__.nameprep)(comp));
    bytes[0] = bytes.length - 1;
    return bytes;
  }))) + "00";
}

/***/ }),

/***/ "./node_modules/@ethersproject/hash/lib.esm/typed-data.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/hash/lib.esm/typed-data.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TypedDataEncoder": () => (/* binding */ TypedDataEncoder)
/* harmony export */ });
/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/address */ "./node_modules/@ethersproject/address/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/hash/lib.esm/_version.js");
/* harmony import */ var _id__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./id */ "./node_modules/@ethersproject/hash/lib.esm/id.js");
var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};








const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);

const padding = new Uint8Array(32);
padding.fill(0);
const NegativeOne = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(-1);
const Zero = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(0);
const One = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(1);
const MaxUint256 = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

function hexPadRight(value) {
  const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);
  const padOffset = bytes.length % 32;

  if (padOffset) {
    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([bytes, padding.slice(padOffset)]);
  }

  return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(bytes);
}

const hexTrue = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(One.toHexString(), 32);
const hexFalse = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(Zero.toHexString(), 32);
const domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
const domainFieldNames = ["name", "version", "chainId", "verifyingContract", "salt"];

function checkString(key) {
  return function (value) {
    if (typeof value !== "string") {
      logger.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
    }

    return value;
  };
}

const domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function (value) {
    try {
      return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value).toString();
    } catch (error) {}

    return logger.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
  },
  verifyingContract: function (value) {
    try {
      return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_4__.getAddress)(value).toLowerCase();
    } catch (error) {}

    return logger.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function (value) {
    try {
      const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);

      if (bytes.length !== 32) {
        throw new Error("bad length");
      }

      return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(bytes);
    } catch (error) {}

    return logger.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
  }
};

function getBaseEncoder(type) {
  // intXX and uintXX
  {
    const match = type.match(/^(u?)int(\d*)$/);

    if (match) {
      const signed = match[1] === "";
      const width = parseInt(match[2] || "256");

      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {
        logger.throwArgumentError("invalid numeric width", "type", type);
      }

      const boundsUpper = MaxUint256.mask(signed ? width - 1 : width);
      const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;
      return function (value) {
        const v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value);

        if (v.lt(boundsLower) || v.gt(boundsUpper)) {
          logger.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
        }

        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(v.toTwos(256).toHexString(), 32);
      };
    }
  } // bytesXX

  {
    const match = type.match(/^bytes(\d+)$/);

    if (match) {
      const width = parseInt(match[1]);

      if (width === 0 || width > 32 || match[1] !== String(width)) {
        logger.throwArgumentError("invalid bytes width", "type", type);
      }

      return function (value) {
        const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);

        if (bytes.length !== width) {
          logger.throwArgumentError(`invalid length for ${type}`, "value", value);
        }

        return hexPadRight(value);
      };
    }
  }

  switch (type) {
    case "address":
      return function (value) {
        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)((0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_4__.getAddress)(value), 32);
      };

    case "bool":
      return function (value) {
        return !value ? hexFalse : hexTrue;
      };

    case "bytes":
      return function (value) {
        return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)(value);
      };

    case "string":
      return function (value) {
        return (0,_id__WEBPACK_IMPORTED_MODULE_6__.id)(value);
      };
  }

  return null;
}

function encodeType(name, fields) {
  return `${name}(${fields.map(({
    name,
    type
  }) => type + " " + name).join(",")})`;
}

class TypedDataEncoder {
  constructor(types) {
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.defineReadOnly)(this, "types", Object.freeze((0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.deepCopy)(types)));
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.defineReadOnly)(this, "_encoderCache", {});
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.defineReadOnly)(this, "_types", {}); // Link struct types to their direct child structs

    const links = {}; // Link structs to structs which contain them as a child

    const parents = {}; // Link all subtypes within a given struct

    const subtypes = {};
    Object.keys(types).forEach(type => {
      links[type] = {};
      parents[type] = [];
      subtypes[type] = {};
    });

    for (const name in types) {
      const uniqueNames = {};
      types[name].forEach(field => {
        // Check each field has a unique name
        if (uniqueNames[field.name]) {
          logger.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", types);
        }

        uniqueNames[field.name] = true; // Get the base type (drop any array specifiers)

        const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];

        if (baseType === name) {
          logger.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
        } // Is this a base encoding type?


        const encoder = getBaseEncoder(baseType);

        if (encoder) {
          return;
        }

        if (!parents[baseType]) {
          logger.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
        } // Add linkage


        parents[baseType].push(name);
        links[name][baseType] = true;
      });
    } // Deduce the primary type


    const primaryTypes = Object.keys(parents).filter(n => parents[n].length === 0);

    if (primaryTypes.length === 0) {
      logger.throwArgumentError("missing primary type", "types", types);
    } else if (primaryTypes.length > 1) {
      logger.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map(t => JSON.stringify(t)).join(", ")}`, "types", types);
    }

    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.defineReadOnly)(this, "primaryType", primaryTypes[0]); // Check for circular type references

    function checkCircular(type, found) {
      if (found[type]) {
        logger.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types);
      }

      found[type] = true;
      Object.keys(links[type]).forEach(child => {
        if (!parents[child]) {
          return;
        } // Recursively check children


        checkCircular(child, found); // Mark all ancestors as having this decendant

        Object.keys(found).forEach(subtype => {
          subtypes[subtype][child] = true;
        });
      });
      delete found[type];
    }

    checkCircular(this.primaryType, {}); // Compute each fully describe type

    for (const name in subtypes) {
      const st = Object.keys(subtypes[name]);
      st.sort();
      this._types[name] = encodeType(name, types[name]) + st.map(t => encodeType(t, types[t])).join("");
    }
  }

  getEncoder(type) {
    let encoder = this._encoderCache[type];

    if (!encoder) {
      encoder = this._encoderCache[type] = this._getEncoder(type);
    }

    return encoder;
  }

  _getEncoder(type) {
    // Basic encoder type (address, bool, uint256, etc)
    {
      const encoder = getBaseEncoder(type);

      if (encoder) {
        return encoder;
      }
    } // Array

    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);

    if (match) {
      const subtype = match[1];
      const subEncoder = this.getEncoder(subtype);
      const length = parseInt(match[3]);
      return value => {
        if (length >= 0 && value.length !== length) {
          logger.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
        }

        let result = value.map(subEncoder);

        if (this._types[subtype]) {
          result = result.map(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256);
        }

        return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(result));
      };
    } // Struct


    const fields = this.types[type];

    if (fields) {
      const encodedType = (0,_id__WEBPACK_IMPORTED_MODULE_6__.id)(this._types[type]);
      return value => {
        const values = fields.map(({
          name,
          type
        }) => {
          const result = this.getEncoder(type)(value[name]);

          if (this._types[type]) {
            return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)(result);
          }

          return result;
        });
        values.unshift(encodedType);
        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(values);
      };
    }

    return logger.throwArgumentError(`unknown type: ${type}`, "type", type);
  }

  encodeType(name) {
    const result = this._types[name];

    if (!result) {
      logger.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, "name", name);
    }

    return result;
  }

  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }

  hashStruct(name, value) {
    return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)(this.encodeData(name, value));
  }

  encode(value) {
    return this.encodeData(this.primaryType, value);
  }

  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }

  _visit(type, value, callback) {
    // Basic encoder type (address, bool, uint256, etc)
    {
      const encoder = getBaseEncoder(type);

      if (encoder) {
        return callback(type, value);
      }
    } // Array

    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);

    if (match) {
      const subtype = match[1];
      const length = parseInt(match[3]);

      if (length >= 0 && value.length !== length) {
        logger.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
      }

      return value.map(v => this._visit(subtype, v, callback));
    } // Struct


    const fields = this.types[type];

    if (fields) {
      return fields.reduce((accum, {
        name,
        type
      }) => {
        accum[name] = this._visit(type, value[name], callback);
        return accum;
      }, {});
    }

    return logger.throwArgumentError(`unknown type: ${type}`, "type", type);
  }

  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }

  static from(types) {
    return new TypedDataEncoder(types);
  }

  static getPrimaryType(types) {
    return TypedDataEncoder.from(types).primaryType;
  }

  static hashStruct(name, types, value) {
    return TypedDataEncoder.from(types).hashStruct(name, value);
  }

  static hashDomain(domain) {
    const domainFields = [];

    for (const name in domain) {
      const type = domainFieldTypes[name];

      if (!type) {
        logger.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
      }

      domainFields.push({
        name,
        type
      });
    }

    domainFields.sort((a, b) => {
      return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
    });
    return TypedDataEncoder.hashStruct("EIP712Domain", {
      EIP712Domain: domainFields
    }, domain);
  }

  static encode(domain, types, value) {
    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(["0x1901", TypedDataEncoder.hashDomain(domain), TypedDataEncoder.from(types).hash(value)]);
  }

  static hash(domain, types, value) {
    return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)(TypedDataEncoder.encode(domain, types, value));
  } // Replaces all address types with ENS names with their looked up address


  static resolveNames(domain, types, value, resolveName) {
    return __awaiter(this, void 0, void 0, function* () {
      // Make a copy to isolate it from the object passed in
      domain = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.shallowCopy)(domain); // Look up all ENS names

      const ensCache = {}; // Do we need to look up the domain's verifyingContract?

      if (domain.verifyingContract && !(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(domain.verifyingContract, 20)) {
        ensCache[domain.verifyingContract] = "0x";
      } // We are going to use the encoder to visit all the base values


      const encoder = TypedDataEncoder.from(types); // Get a list of all the addresses

      encoder.visit(value, (type, value) => {
        if (type === "address" && !(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(value, 20)) {
          ensCache[value] = "0x";
        }

        return value;
      }); // Lookup each name

      for (const name in ensCache) {
        ensCache[name] = yield resolveName(name);
      } // Replace the domain verifyingContract if needed


      if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
        domain.verifyingContract = ensCache[domain.verifyingContract];
      } // Replace all ENS names with their address


      value = encoder.visit(value, (type, value) => {
        if (type === "address" && ensCache[value]) {
          return ensCache[value];
        }

        return value;
      });
      return {
        domain,
        value
      };
    });
  }

  static getPayload(domain, types, value) {
    // Validate the domain fields
    TypedDataEncoder.hashDomain(domain); // Derive the EIP712Domain Struct reference type

    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach(name => {
      const value = domain[name];

      if (value == null) {
        return;
      }

      domainValues[name] = domainChecks[name](value);
      domainTypes.push({
        name,
        type: domainFieldTypes[name]
      });
    });
    const encoder = TypedDataEncoder.from(types);
    const typesWithDomain = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__.shallowCopy)(types);

    if (typesWithDomain.EIP712Domain) {
      logger.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
    } else {
      typesWithDomain.EIP712Domain = domainTypes;
    } // Validate the data structures and types


    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value) => {
        // bytes
        if (type.match(/^bytes(\d*)/)) {
          return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value));
        } // uint or int


        if (type.match(/^u?int/)) {
          return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(value).toString();
        }

        switch (type) {
          case "address":
            return value.toLowerCase();

          case "bool":
            return !!value;

          case "string":
            if (typeof value !== "string") {
              logger.throwArgumentError(`invalid string`, "value", value);
            }

            return value;
        }

        return logger.throwArgumentError("unsupported type", "type", type);
      })
    };
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/hdnode/lib.esm/_version.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/hdnode/lib.esm/_version.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "hdnode/5.6.0";

/***/ }),

/***/ "./node_modules/@ethersproject/hdnode/lib.esm/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/hdnode/lib.esm/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HDNode": () => (/* binding */ HDNode),
/* harmony export */   "defaultPath": () => (/* binding */ defaultPath),
/* harmony export */   "entropyToMnemonic": () => (/* binding */ entropyToMnemonic),
/* harmony export */   "getAccountPath": () => (/* binding */ getAccountPath),
/* harmony export */   "isValidMnemonic": () => (/* binding */ isValidMnemonic),
/* harmony export */   "mnemonicToEntropy": () => (/* binding */ mnemonicToEntropy),
/* harmony export */   "mnemonicToSeed": () => (/* binding */ mnemonicToSeed)
/* harmony export */ });
/* harmony import */ var _ethersproject_basex__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/basex */ "./node_modules/@ethersproject/basex/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/utf8.js");
/* harmony import */ var _ethersproject_pbkdf2__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @ethersproject/pbkdf2 */ "./node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/signing-key */ "./node_modules/@ethersproject/signing-key/lib.esm/index.js");
/* harmony import */ var _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/sha2 */ "./node_modules/@ethersproject/sha2/lib.esm/sha2.js");
/* harmony import */ var _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @ethersproject/sha2 */ "./node_modules/@ethersproject/sha2/lib.esm/types.js");
/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/transactions */ "./node_modules/@ethersproject/transactions/lib.esm/index.js");
/* harmony import */ var _ethersproject_wordlists__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/wordlists */ "./node_modules/@ethersproject/wordlists/lib.esm/wordlists.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/hdnode/lib.esm/_version.js");














const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
const N = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"); // "Bitcoin seed"

const MasterSecret = (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)("Bitcoin seed");
const HardenedBit = 0x80000000; // Returns a byte with the MSB bits set

function getUpperMask(bits) {
  return (1 << bits) - 1 << 8 - bits;
} // Returns a byte with the LSB bits set


function getLowerMask(bits) {
  return (1 << bits) - 1;
}

function bytes32(value) {
  return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexZeroPad)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(value), 32);
}

function base58check(data) {
  return _ethersproject_basex__WEBPACK_IMPORTED_MODULE_5__.Base58.encode((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.concat)([data, (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexDataSlice)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_6__.sha256)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_6__.sha256)(data)), 0, 4)]));
}

function getWordlist(wordlist) {
  if (wordlist == null) {
    return _ethersproject_wordlists__WEBPACK_IMPORTED_MODULE_7__.wordlists.en;
  }

  if (typeof wordlist === "string") {
    const words = _ethersproject_wordlists__WEBPACK_IMPORTED_MODULE_7__.wordlists[wordlist];

    if (words == null) {
      logger.throwArgumentError("unknown locale", "wordlist", wordlist);
    }

    return words;
  }

  return wordlist;
}

const _constructorGuard = {};
const defaultPath = "m/44'/60'/0'/0/0";
;
class HDNode {
  /**
   *  This constructor should not be called directly.
   *
   *  Please use:
   *   - fromMnemonic
   *   - fromSeed
   */
  constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {
    logger.checkNew(new.target, HDNode);
    /* istanbul ignore if */

    if (constructorGuard !== _constructorGuard) {
      throw new Error("HDNode constructor cannot be called directly");
    }

    if (privateKey) {
      const signingKey = new _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_8__.SigningKey(privateKey);
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__.defineReadOnly)(this, "privateKey", signingKey.privateKey);
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__.defineReadOnly)(this, "publicKey", signingKey.compressedPublicKey);
    } else {
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__.defineReadOnly)(this, "privateKey", null);
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__.defineReadOnly)(this, "publicKey", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(publicKey));
    }

    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__.defineReadOnly)(this, "parentFingerprint", parentFingerprint);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__.defineReadOnly)(this, "fingerprint", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexDataSlice)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_6__.ripemd160)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_6__.sha256)(this.publicKey)), 0, 4));
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__.defineReadOnly)(this, "address", (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_10__.computeAddress)(this.publicKey));
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__.defineReadOnly)(this, "chainCode", chainCode);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__.defineReadOnly)(this, "index", index);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__.defineReadOnly)(this, "depth", depth);

    if (mnemonicOrPath == null) {
      // From a source that does not preserve the path (e.g. extended keys)
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__.defineReadOnly)(this, "mnemonic", null);
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__.defineReadOnly)(this, "path", null);
    } else if (typeof mnemonicOrPath === "string") {
      // From a source that does not preserve the mnemonic (e.g. neutered)
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__.defineReadOnly)(this, "mnemonic", null);
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__.defineReadOnly)(this, "path", mnemonicOrPath);
    } else {
      // From a fully qualified source
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__.defineReadOnly)(this, "mnemonic", mnemonicOrPath);
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__.defineReadOnly)(this, "path", mnemonicOrPath.path);
    }
  }

  get extendedKey() {
    // We only support the mainnet values for now, but if anyone needs
    // testnet values, let me know. I believe current sentiment is that
    // we should always use mainnet, and use BIP-44 to derive the network
    //   - Mainnet: public=0x0488B21E, private=0x0488ADE4
    //   - Testnet: public=0x043587CF, private=0x04358394
    if (this.depth >= 256) {
      throw new Error("Depth too large!");
    }

    return base58check((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.concat)([this.privateKey != null ? "0x0488ADE4" : "0x0488B21E", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(this.depth), this.parentFingerprint, (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexZeroPad)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(this.index), 4), this.chainCode, this.privateKey != null ? (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.concat)(["0x00", this.privateKey]) : this.publicKey]));
  }

  neuter() {
    return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
  }

  _derive(index) {
    if (index > 0xffffffff) {
      throw new Error("invalid index - " + String(index));
    } // Base path


    let path = this.path;

    if (path) {
      path += "/" + (index & ~HardenedBit);
    }

    const data = new Uint8Array(37);

    if (index & HardenedBit) {
      if (!this.privateKey) {
        throw new Error("cannot derive child of neutered node");
      } // Data = 0x00 || ser_256(k_par)


      data.set((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(this.privateKey), 1); // Hardened path

      if (path) {
        path += "'";
      }
    } else {
      // Data = ser_p(point(k_par))
      data.set((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(this.publicKey));
    } // Data += ser_32(i)


    for (let i = 24; i >= 0; i -= 8) {
      data[33 + (i >> 3)] = index >> 24 - i & 0xff;
    }

    const I = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_6__.computeHmac)(_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_11__.SupportedAlgorithm.sha512, this.chainCode, data));
    const IL = I.slice(0, 32);
    const IR = I.slice(32); // The private key

    let ki = null; // The public key

    let Ki = null;

    if (this.privateKey) {
      ki = bytes32(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.from(IL).add(this.privateKey).mod(N));
    } else {
      const ek = new _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_8__.SigningKey((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(IL));
      Ki = ek._addPoint(this.publicKey);
    }

    let mnemonicOrPath = path;
    const srcMnemonic = this.mnemonic;

    if (srcMnemonic) {
      mnemonicOrPath = Object.freeze({
        phrase: srcMnemonic.phrase,
        path: path,
        locale: srcMnemonic.locale || "en"
      });
    }

    return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);
  }

  derivePath(path) {
    const components = path.split("/");

    if (components.length === 0 || components[0] === "m" && this.depth !== 0) {
      throw new Error("invalid path - " + path);
    }

    if (components[0] === "m") {
      components.shift();
    }

    let result = this;

    for (let i = 0; i < components.length; i++) {
      const component = components[i];

      if (component.match(/^[0-9]+'$/)) {
        const index = parseInt(component.substring(0, component.length - 1));

        if (index >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }

        result = result._derive(HardenedBit + index);
      } else if (component.match(/^[0-9]+$/)) {
        const index = parseInt(component);

        if (index >= HardenedBit) {
          throw new Error("invalid path index - " + component);
        }

        result = result._derive(index);
      } else {
        throw new Error("invalid path component - " + component);
      }
    }

    return result;
  }

  static _fromSeed(seed, mnemonic) {
    const seedArray = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(seed);

    if (seedArray.length < 16 || seedArray.length > 64) {
      throw new Error("invalid seed");
    }

    const I = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_6__.computeHmac)(_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_11__.SupportedAlgorithm.sha512, MasterSecret, seedArray));
    return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, "0x00000000", bytes32(I.slice(32)), 0, 0, mnemonic);
  }

  static fromMnemonic(mnemonic, password, wordlist) {
    // If a locale name was passed in, find the associated wordlist
    wordlist = getWordlist(wordlist); // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)

    mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);
    return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {
      phrase: mnemonic,
      path: "m",
      locale: wordlist.locale
    });
  }

  static fromSeed(seed) {
    return HDNode._fromSeed(seed, null);
  }

  static fromExtendedKey(extendedKey) {
    const bytes = _ethersproject_basex__WEBPACK_IMPORTED_MODULE_5__.Base58.decode(extendedKey);

    if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {
      logger.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    }

    const depth = bytes[4];
    const parentFingerprint = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(bytes.slice(5, 9));
    const index = parseInt((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(bytes.slice(9, 13)).substring(2), 16);
    const chainCode = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(bytes.slice(13, 45));
    const key = bytes.slice(45, 78);

    switch ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(bytes.slice(0, 4))) {
      // Public Key
      case "0x0488b21e":
      case "0x043587cf":
        return new HDNode(_constructorGuard, null, (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(key), parentFingerprint, chainCode, index, depth, null);
      // Private Key

      case "0x0488ade4":
      case "0x04358394 ":
        if (key[0] !== 0) {
          break;
        }

        return new HDNode(_constructorGuard, (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);
    }

    return logger.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
  }

}
function mnemonicToSeed(mnemonic, password) {
  if (!password) {
    password = "";
  }

  const salt = (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)("mnemonic" + password, _ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.UnicodeNormalizationForm.NFKD);
  return (0,_ethersproject_pbkdf2__WEBPACK_IMPORTED_MODULE_12__.pbkdf2)((0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(mnemonic, _ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.UnicodeNormalizationForm.NFKD), salt, 2048, 64, "sha512");
}
function mnemonicToEntropy(mnemonic, wordlist) {
  wordlist = getWordlist(wordlist);
  logger.checkNormalize();
  const words = wordlist.split(mnemonic);

  if (words.length % 3 !== 0) {
    throw new Error("invalid mnemonic");
  }

  const entropy = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(new Uint8Array(Math.ceil(11 * words.length / 8)));
  let offset = 0;

  for (let i = 0; i < words.length; i++) {
    let index = wordlist.getWordIndex(words[i].normalize("NFKD"));

    if (index === -1) {
      throw new Error("invalid mnemonic");
    }

    for (let bit = 0; bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }

      offset++;
    }
  }

  const entropyBits = 32 * words.length / 3;
  const checksumBits = words.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_6__.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;

  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
    throw new Error("invalid checksum");
  }

  return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist) {
  wordlist = getWordlist(wordlist);
  entropy = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(entropy);

  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {
    throw new Error("invalid entropy");
  }

  const indices = [0];
  let remainingBits = 11;

  for (let i = 0; i < entropy.length; i++) {
    // Consume the whole byte (with still more to go)
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8; // This byte will complete an 11-bit index
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits; // Start the next word

      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  } // Compute the checksum bits


  const checksumBits = entropy.length / 4;
  const checksum = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_6__.sha256)(entropy))[0] & getUpperMask(checksumBits); // Shift the checksum into the word indices

  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum >> 8 - checksumBits;
  return wordlist.join(indices.map(index => wordlist.getWord(index)));
}
function isValidMnemonic(mnemonic, wordlist) {
  try {
    mnemonicToEntropy(mnemonic, wordlist);
    return true;
  } catch (error) {}

  return false;
}
function getAccountPath(index) {
  if (typeof index !== "number" || index < 0 || index >= HardenedBit || index % 1) {
    logger.throwArgumentError("invalid account index", "index", index);
  }

  return `m/44'/60'/${index}'/0/0`;
}

/***/ }),

/***/ "./node_modules/@ethersproject/json-wallets/lib.esm/_version.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@ethersproject/json-wallets/lib.esm/_version.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "json-wallets/5.6.0";

/***/ }),

/***/ "./node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CrowdsaleAccount": () => (/* binding */ CrowdsaleAccount),
/* harmony export */   "decrypt": () => (/* binding */ decrypt)
/* harmony export */ });
/* harmony import */ var aes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aes-js */ "./node_modules/aes-js/index.js");
/* harmony import */ var aes_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(aes_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/address */ "./node_modules/@ethersproject/address/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_pbkdf2__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/pbkdf2 */ "./node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/utf8.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/json-wallets/lib.esm/_version.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils */ "./node_modules/@ethersproject/json-wallets/lib.esm/utils.js");











const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(_version__WEBPACK_IMPORTED_MODULE_2__.version);

class CrowdsaleAccount extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.Description {
  isCrowdsaleAccount(value) {
    return !!(value && value._isCrowdsaleAccount);
  }

} // See: https://github.com/ethereum/pyethsaletool

function decrypt(json, password) {
  const data = JSON.parse(json);
  password = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.getPassword)(password); // Ethereum Address

  const ethaddr = (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_5__.getAddress)((0,_utils__WEBPACK_IMPORTED_MODULE_4__.searchPath)(data, "ethaddr")); // Encrypted Seed

  const encseed = (0,_utils__WEBPACK_IMPORTED_MODULE_4__.looseArrayify)((0,_utils__WEBPACK_IMPORTED_MODULE_4__.searchPath)(data, "encseed"));

  if (!encseed || encseed.length % 16 !== 0) {
    logger.throwArgumentError("invalid encseed", "json", json);
  }

  const key = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)((0,_ethersproject_pbkdf2__WEBPACK_IMPORTED_MODULE_7__.pbkdf2)(password, password, 2000, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16); // Decrypt the seed

  const aesCbc = new (aes_js__WEBPACK_IMPORTED_MODULE_0___default().ModeOfOperation.cbc)(key, iv);
  const seed = aes_js__WEBPACK_IMPORTED_MODULE_0___default().padding.pkcs7.strip((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(aesCbc.decrypt(encryptedSeed))); // This wallet format is weird... Convert the binary encoded hex to a string.

  let seedHex = "";

  for (let i = 0; i < seed.length; i++) {
    seedHex += String.fromCharCode(seed[i]);
  }

  const seedHexBytes = (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_8__.toUtf8Bytes)(seedHex);
  const privateKey = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_9__.keccak256)(seedHexBytes);
  return new CrowdsaleAccount({
    _isCrowdsaleAccount: true,
    address: ethaddr,
    privateKey: privateKey
  });
}

/***/ }),

/***/ "./node_modules/@ethersproject/json-wallets/lib.esm/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersproject/json-wallets/lib.esm/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decryptCrowdsale": () => (/* reexport safe */ _crowdsale__WEBPACK_IMPORTED_MODULE_1__.decrypt),
/* harmony export */   "decryptJsonWallet": () => (/* binding */ decryptJsonWallet),
/* harmony export */   "decryptJsonWalletSync": () => (/* binding */ decryptJsonWalletSync),
/* harmony export */   "decryptKeystore": () => (/* reexport safe */ _keystore__WEBPACK_IMPORTED_MODULE_2__.decrypt),
/* harmony export */   "decryptKeystoreSync": () => (/* reexport safe */ _keystore__WEBPACK_IMPORTED_MODULE_2__.decryptSync),
/* harmony export */   "encryptKeystore": () => (/* reexport safe */ _keystore__WEBPACK_IMPORTED_MODULE_2__.encrypt),
/* harmony export */   "getJsonWalletAddress": () => (/* reexport safe */ _inspect__WEBPACK_IMPORTED_MODULE_0__.getJsonWalletAddress),
/* harmony export */   "isCrowdsaleWallet": () => (/* reexport safe */ _inspect__WEBPACK_IMPORTED_MODULE_0__.isCrowdsaleWallet),
/* harmony export */   "isKeystoreWallet": () => (/* reexport safe */ _inspect__WEBPACK_IMPORTED_MODULE_0__.isKeystoreWallet)
/* harmony export */ });
/* harmony import */ var _crowdsale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./crowdsale */ "./node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js");
/* harmony import */ var _inspect__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inspect */ "./node_modules/@ethersproject/json-wallets/lib.esm/inspect.js");
/* harmony import */ var _keystore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keystore */ "./node_modules/@ethersproject/json-wallets/lib.esm/keystore.js");






function decryptJsonWallet(json, password, progressCallback) {
  if ((0,_inspect__WEBPACK_IMPORTED_MODULE_0__.isCrowdsaleWallet)(json)) {
    if (progressCallback) {
      progressCallback(0);
    }

    const account = (0,_crowdsale__WEBPACK_IMPORTED_MODULE_1__.decrypt)(json, password);

    if (progressCallback) {
      progressCallback(1);
    }

    return Promise.resolve(account);
  }

  if ((0,_inspect__WEBPACK_IMPORTED_MODULE_0__.isKeystoreWallet)(json)) {
    return (0,_keystore__WEBPACK_IMPORTED_MODULE_2__.decrypt)(json, password, progressCallback);
  }

  return Promise.reject(new Error("invalid JSON wallet"));
}

function decryptJsonWalletSync(json, password) {
  if ((0,_inspect__WEBPACK_IMPORTED_MODULE_0__.isCrowdsaleWallet)(json)) {
    return (0,_crowdsale__WEBPACK_IMPORTED_MODULE_1__.decrypt)(json, password);
  }

  if ((0,_inspect__WEBPACK_IMPORTED_MODULE_0__.isKeystoreWallet)(json)) {
    return (0,_keystore__WEBPACK_IMPORTED_MODULE_2__.decryptSync)(json, password);
  }

  throw new Error("invalid JSON wallet");
}



/***/ }),

/***/ "./node_modules/@ethersproject/json-wallets/lib.esm/inspect.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ethersproject/json-wallets/lib.esm/inspect.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getJsonWalletAddress": () => (/* binding */ getJsonWalletAddress),
/* harmony export */   "isCrowdsaleWallet": () => (/* binding */ isCrowdsaleWallet),
/* harmony export */   "isKeystoreWallet": () => (/* binding */ isKeystoreWallet)
/* harmony export */ });
/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/address */ "./node_modules/@ethersproject/address/lib.esm/index.js");



function isCrowdsaleWallet(json) {
  let data = null;

  try {
    data = JSON.parse(json);
  } catch (error) {
    return false;
  }

  return data.encseed && data.ethaddr;
}
function isKeystoreWallet(json) {
  let data = null;

  try {
    data = JSON.parse(json);
  } catch (error) {
    return false;
  }

  if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {
    return false;
  } // @TODO: Put more checks to make sure it has kdf, iv and all that good stuff


  return true;
} //export function isJsonWallet(json: string): boolean {
//    return (isSecretStorageWallet(json) || isCrowdsaleWallet(json));
//}

function getJsonWalletAddress(json) {
  if (isCrowdsaleWallet(json)) {
    try {
      return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_0__.getAddress)(JSON.parse(json).ethaddr);
    } catch (error) {
      return null;
    }
  }

  if (isKeystoreWallet(json)) {
    try {
      return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_0__.getAddress)(JSON.parse(json).address);
    } catch (error) {
      return null;
    }
  }

  return null;
}

/***/ }),

/***/ "./node_modules/@ethersproject/json-wallets/lib.esm/keystore.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@ethersproject/json-wallets/lib.esm/keystore.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KeystoreAccount": () => (/* binding */ KeystoreAccount),
/* harmony export */   "decrypt": () => (/* binding */ decrypt),
/* harmony export */   "decryptSync": () => (/* binding */ decryptSync),
/* harmony export */   "encrypt": () => (/* binding */ encrypt)
/* harmony export */ });
/* harmony import */ var aes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aes-js */ "./node_modules/aes-js/index.js");
/* harmony import */ var aes_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(aes_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var scrypt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! scrypt-js */ "./node_modules/scrypt-js/scrypt.js");
/* harmony import */ var scrypt_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(scrypt_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/address */ "./node_modules/@ethersproject/address/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/hdnode */ "./node_modules/@ethersproject/hdnode/lib.esm/index.js");
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_pbkdf2__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @ethersproject/pbkdf2 */ "./node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js");
/* harmony import */ var _ethersproject_random__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @ethersproject/random */ "./node_modules/@ethersproject/random/lib.esm/random.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/transactions */ "./node_modules/@ethersproject/transactions/lib.esm/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils */ "./node_modules/@ethersproject/json-wallets/lib.esm/utils.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/json-wallets/lib.esm/_version.js");


var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};














const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_2__.Logger(_version__WEBPACK_IMPORTED_MODULE_3__.version); // Exported Types

function hasMnemonic(value) {
  return value != null && value.mnemonic && value.mnemonic.phrase;
}

class KeystoreAccount extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.Description {
  isKeystoreAccount(value) {
    return !!(value && value._isKeystoreAccount);
  }

}

function _decrypt(data, key, ciphertext) {
  const cipher = (0,_utils__WEBPACK_IMPORTED_MODULE_5__.searchPath)(data, "crypto/cipher");

  if (cipher === "aes-128-ctr") {
    const iv = (0,_utils__WEBPACK_IMPORTED_MODULE_5__.looseArrayify)((0,_utils__WEBPACK_IMPORTED_MODULE_5__.searchPath)(data, "crypto/cipherparams/iv"));
    const counter = new (aes_js__WEBPACK_IMPORTED_MODULE_0___default().Counter)(iv);
    const aesCtr = new (aes_js__WEBPACK_IMPORTED_MODULE_0___default().ModeOfOperation.ctr)(key, counter);
    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(aesCtr.decrypt(ciphertext));
  }

  return null;
}

function _getAccount(data, key) {
  const ciphertext = (0,_utils__WEBPACK_IMPORTED_MODULE_5__.looseArrayify)((0,_utils__WEBPACK_IMPORTED_MODULE_5__.searchPath)(data, "crypto/ciphertext"));
  const computedMAC = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.concat)([key.slice(16, 32), ciphertext]))).substring(2);

  if (computedMAC !== (0,_utils__WEBPACK_IMPORTED_MODULE_5__.searchPath)(data, "crypto/mac").toLowerCase()) {
    throw new Error("invalid password");
  }

  const privateKey = _decrypt(data, key.slice(0, 16), ciphertext);

  if (!privateKey) {
    logger.throwError("unsupported cipher", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_2__.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "decrypt"
    });
  }

  const mnemonicKey = key.slice(32, 64);
  const address = (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_8__.computeAddress)(privateKey);

  if (data.address) {
    let check = data.address.toLowerCase();

    if (check.substring(0, 2) !== "0x") {
      check = "0x" + check;
    }

    if ((0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_9__.getAddress)(check) !== address) {
      throw new Error("address mismatch");
    }
  }

  const account = {
    _isKeystoreAccount: true,
    address: address,
    privateKey: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(privateKey)
  }; // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase

  if ((0,_utils__WEBPACK_IMPORTED_MODULE_5__.searchPath)(data, "x-ethers/version") === "0.1") {
    const mnemonicCiphertext = (0,_utils__WEBPACK_IMPORTED_MODULE_5__.looseArrayify)((0,_utils__WEBPACK_IMPORTED_MODULE_5__.searchPath)(data, "x-ethers/mnemonicCiphertext"));
    const mnemonicIv = (0,_utils__WEBPACK_IMPORTED_MODULE_5__.looseArrayify)((0,_utils__WEBPACK_IMPORTED_MODULE_5__.searchPath)(data, "x-ethers/mnemonicCounter"));
    const mnemonicCounter = new (aes_js__WEBPACK_IMPORTED_MODULE_0___default().Counter)(mnemonicIv);
    const mnemonicAesCtr = new (aes_js__WEBPACK_IMPORTED_MODULE_0___default().ModeOfOperation.ctr)(mnemonicKey, mnemonicCounter);
    const path = (0,_utils__WEBPACK_IMPORTED_MODULE_5__.searchPath)(data, "x-ethers/path") || _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_10__.defaultPath;
    const locale = (0,_utils__WEBPACK_IMPORTED_MODULE_5__.searchPath)(data, "x-ethers/locale") || "en";
    const entropy = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(mnemonicAesCtr.decrypt(mnemonicCiphertext));

    try {
      const mnemonic = (0,_ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_10__.entropyToMnemonic)(entropy, locale);
      const node = _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_10__.HDNode.fromMnemonic(mnemonic, null, locale).derivePath(path);

      if (node.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }

      account.mnemonic = node.mnemonic;
    } catch (error) {
      // If we don't have the locale wordlist installed to
      // read this mnemonic, just bail and don't set the
      // mnemonic
      if (error.code !== _ethersproject_logger__WEBPACK_IMPORTED_MODULE_2__.Logger.errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
        throw error;
      }
    }
  }

  return new KeystoreAccount(account);
}

function pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {
  return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)((0,_ethersproject_pbkdf2__WEBPACK_IMPORTED_MODULE_11__.pbkdf2)(passwordBytes, salt, count, dkLen, prfFunc));
}

function pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {
  return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));
}

function _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {
  const passwordBytes = (0,_utils__WEBPACK_IMPORTED_MODULE_5__.getPassword)(password);
  const kdf = (0,_utils__WEBPACK_IMPORTED_MODULE_5__.searchPath)(data, "crypto/kdf");

  if (kdf && typeof kdf === "string") {
    const throwError = function (name, value) {
      return logger.throwArgumentError("invalid key-derivation function parameters", name, value);
    };

    if (kdf.toLowerCase() === "scrypt") {
      const salt = (0,_utils__WEBPACK_IMPORTED_MODULE_5__.looseArrayify)((0,_utils__WEBPACK_IMPORTED_MODULE_5__.searchPath)(data, "crypto/kdfparams/salt"));
      const N = parseInt((0,_utils__WEBPACK_IMPORTED_MODULE_5__.searchPath)(data, "crypto/kdfparams/n"));
      const r = parseInt((0,_utils__WEBPACK_IMPORTED_MODULE_5__.searchPath)(data, "crypto/kdfparams/r"));
      const p = parseInt((0,_utils__WEBPACK_IMPORTED_MODULE_5__.searchPath)(data, "crypto/kdfparams/p")); // Check for all required parameters

      if (!N || !r || !p) {
        throwError("kdf", kdf);
      } // Make sure N is a power of 2


      if ((N & N - 1) !== 0) {
        throwError("N", N);
      }

      const dkLen = parseInt((0,_utils__WEBPACK_IMPORTED_MODULE_5__.searchPath)(data, "crypto/kdfparams/dklen"));

      if (dkLen !== 32) {
        throwError("dklen", dkLen);
      }

      return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = (0,_utils__WEBPACK_IMPORTED_MODULE_5__.looseArrayify)((0,_utils__WEBPACK_IMPORTED_MODULE_5__.searchPath)(data, "crypto/kdfparams/salt"));
      let prfFunc = null;
      const prf = (0,_utils__WEBPACK_IMPORTED_MODULE_5__.searchPath)(data, "crypto/kdfparams/prf");

      if (prf === "hmac-sha256") {
        prfFunc = "sha256";
      } else if (prf === "hmac-sha512") {
        prfFunc = "sha512";
      } else {
        throwError("prf", prf);
      }

      const count = parseInt((0,_utils__WEBPACK_IMPORTED_MODULE_5__.searchPath)(data, "crypto/kdfparams/c"));
      const dkLen = parseInt((0,_utils__WEBPACK_IMPORTED_MODULE_5__.searchPath)(data, "crypto/kdfparams/dklen"));

      if (dkLen !== 32) {
        throwError("dklen", dkLen);
      }

      return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);
    }
  }

  return logger.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
}

function decryptSync(json, password) {
  const data = JSON.parse(json);

  const key = _computeKdfKey(data, password, pbkdf2Sync, (scrypt_js__WEBPACK_IMPORTED_MODULE_1___default().syncScrypt));

  return _getAccount(data, key);
}
function decrypt(json, password, progressCallback) {
  return __awaiter(this, void 0, void 0, function* () {
    const data = JSON.parse(json);
    const key = yield _computeKdfKey(data, password, pbkdf2, (scrypt_js__WEBPACK_IMPORTED_MODULE_1___default().scrypt), progressCallback);
    return _getAccount(data, key);
  });
}
function encrypt(account, password, options, progressCallback) {
  try {
    // Check the address matches the private key
    if ((0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_9__.getAddress)(account.address) !== (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_8__.computeAddress)(account.privateKey)) {
      throw new Error("address/privateKey mismatch");
    } // Check the mnemonic (if any) matches the private key


    if (hasMnemonic(account)) {
      const mnemonic = account.mnemonic;
      const node = _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_10__.HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_10__.defaultPath);

      if (node.privateKey != account.privateKey) {
        throw new Error("mnemonic mismatch");
      }
    }
  } catch (e) {
    return Promise.reject(e);
  } // The options are optional, so adjust the call as needed


  if (typeof options === "function" && !progressCallback) {
    progressCallback = options;
    options = {};
  }

  if (!options) {
    options = {};
  }

  const privateKey = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(account.privateKey);
  const passwordBytes = (0,_utils__WEBPACK_IMPORTED_MODULE_5__.getPassword)(password);
  let entropy = null;
  let path = null;
  let locale = null;

  if (hasMnemonic(account)) {
    const srcMnemonic = account.mnemonic;
    entropy = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)((0,_ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_10__.mnemonicToEntropy)(srcMnemonic.phrase, srcMnemonic.locale || "en"));
    path = srcMnemonic.path || _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_10__.defaultPath;
    locale = srcMnemonic.locale || "en";
  }

  let client = options.client;

  if (!client) {
    client = "ethers.js";
  } // Check/generate the salt


  let salt = null;

  if (options.salt) {
    salt = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(options.salt);
  } else {
    salt = (0,_ethersproject_random__WEBPACK_IMPORTED_MODULE_12__.randomBytes)(32);
    ;
  } // Override initialization vector


  let iv = null;

  if (options.iv) {
    iv = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(options.iv);

    if (iv.length !== 16) {
      throw new Error("invalid iv");
    }
  } else {
    iv = (0,_ethersproject_random__WEBPACK_IMPORTED_MODULE_12__.randomBytes)(16);
  } // Override the uuid


  let uuidRandom = null;

  if (options.uuid) {
    uuidRandom = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(options.uuid);

    if (uuidRandom.length !== 16) {
      throw new Error("invalid uuid");
    }
  } else {
    uuidRandom = (0,_ethersproject_random__WEBPACK_IMPORTED_MODULE_12__.randomBytes)(16);
  } // Override the scrypt password-based key derivation function parameters


  let N = 1 << 17,
      r = 8,
      p = 1;

  if (options.scrypt) {
    if (options.scrypt.N) {
      N = options.scrypt.N;
    }

    if (options.scrypt.r) {
      r = options.scrypt.r;
    }

    if (options.scrypt.p) {
      p = options.scrypt.p;
    }
  } // We take 64 bytes:
  //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)
  //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)


  return scrypt_js__WEBPACK_IMPORTED_MODULE_1___default().scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then(key => {
    key = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(key); // This will be used to encrypt the wallet (as per Web3 secret storage)

    const derivedKey = key.slice(0, 16);
    const macPrefix = key.slice(16, 32); // This will be used to encrypt the mnemonic phrase (if any)

    const mnemonicKey = key.slice(32, 64); // Encrypt the private key

    const counter = new (aes_js__WEBPACK_IMPORTED_MODULE_0___default().Counter)(iv);
    const aesCtr = new (aes_js__WEBPACK_IMPORTED_MODULE_0___default().ModeOfOperation.ctr)(derivedKey, counter);
    const ciphertext = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(aesCtr.encrypt(privateKey)); // Compute the message authentication code, used to check the password

    const mac = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.concat)([macPrefix, ciphertext])); // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition

    const data = {
      address: account.address.substring(2).toLowerCase(),
      id: (0,_utils__WEBPACK_IMPORTED_MODULE_5__.uuidV4)(uuidRandom),
      version: 3,
      Crypto: {
        cipher: "aes-128-ctr",
        cipherparams: {
          iv: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(iv).substring(2)
        },
        ciphertext: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(ciphertext).substring(2),
        kdf: "scrypt",
        kdfparams: {
          salt: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(salt).substring(2),
          n: N,
          dklen: 32,
          p: p,
          r: r
        },
        mac: mac.substring(2)
      }
    }; // If we have a mnemonic, encrypt it into the JSON wallet

    if (entropy) {
      const mnemonicIv = (0,_ethersproject_random__WEBPACK_IMPORTED_MODULE_12__.randomBytes)(16);
      const mnemonicCounter = new (aes_js__WEBPACK_IMPORTED_MODULE_0___default().Counter)(mnemonicIv);
      const mnemonicAesCtr = new (aes_js__WEBPACK_IMPORTED_MODULE_0___default().ModeOfOperation.ctr)(mnemonicKey, mnemonicCounter);
      const mnemonicCiphertext = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(mnemonicAesCtr.encrypt(entropy));
      const now = new Date();
      const timestamp = now.getUTCFullYear() + "-" + (0,_utils__WEBPACK_IMPORTED_MODULE_5__.zpad)(now.getUTCMonth() + 1, 2) + "-" + (0,_utils__WEBPACK_IMPORTED_MODULE_5__.zpad)(now.getUTCDate(), 2) + "T" + (0,_utils__WEBPACK_IMPORTED_MODULE_5__.zpad)(now.getUTCHours(), 2) + "-" + (0,_utils__WEBPACK_IMPORTED_MODULE_5__.zpad)(now.getUTCMinutes(), 2) + "-" + (0,_utils__WEBPACK_IMPORTED_MODULE_5__.zpad)(now.getUTCSeconds(), 2) + ".0Z";
      data["x-ethers"] = {
        client: client,
        gethFilename: "UTC--" + timestamp + "--" + data.address,
        mnemonicCounter: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(mnemonicIv).substring(2),
        mnemonicCiphertext: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(mnemonicCiphertext).substring(2),
        path: path,
        locale: locale,
        version: "0.1"
      };
    }

    return JSON.stringify(data);
  });
}

/***/ }),

/***/ "./node_modules/@ethersproject/json-wallets/lib.esm/utils.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersproject/json-wallets/lib.esm/utils.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getPassword": () => (/* binding */ getPassword),
/* harmony export */   "looseArrayify": () => (/* binding */ looseArrayify),
/* harmony export */   "searchPath": () => (/* binding */ searchPath),
/* harmony export */   "uuidV4": () => (/* binding */ uuidV4),
/* harmony export */   "zpad": () => (/* binding */ zpad)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/utf8.js");




function looseArrayify(hexString) {
  if (typeof hexString === 'string' && hexString.substring(0, 2) !== '0x') {
    hexString = '0x' + hexString;
  }

  return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)(hexString);
}
function zpad(value, length) {
  value = String(value);

  while (value.length < length) {
    value = '0' + value;
  }

  return value;
}
function getPassword(password) {
  if (typeof password === 'string') {
    return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__.toUtf8Bytes)(password, _ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__.UnicodeNormalizationForm.NFKC);
  }

  return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)(password);
}
function searchPath(object, path) {
  let currentChild = object;
  const comps = path.toLowerCase().split('/');

  for (let i = 0; i < comps.length; i++) {
    // Search for a child object with a case-insensitive matching key
    let matchingChild = null;

    for (const key in currentChild) {
      if (key.toLowerCase() === comps[i]) {
        matchingChild = currentChild[key];
        break;
      }
    } // Didn't find one. :'(


    if (matchingChild === null) {
      return null;
    } // Now check this child...


    currentChild = matchingChild;
  }

  return currentChild;
} // See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)

function uuidV4(randomBytes) {
  const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)(randomBytes); // Section: 4.1.3:
  // - time_hi_and_version[12:16] = 0b0100

  bytes[6] = bytes[6] & 0x0f | 0x40; // Section 4.4
  // - clock_seq_hi_and_reserved[6] = 0b0
  // - clock_seq_hi_and_reserved[7] = 0b1

  bytes[8] = bytes[8] & 0x3f | 0x80;
  const value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.hexlify)(bytes);
  return [value.substring(2, 10), value.substring(10, 14), value.substring(14, 18), value.substring(18, 22), value.substring(22, 34)].join("-");
}

/***/ }),

/***/ "./node_modules/@ethersproject/keccak256/lib.esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/keccak256/lib.esm/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "keccak256": () => (/* binding */ keccak256)
/* harmony export */ });
/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-sha3 */ "./node_modules/js-sha3/src/sha3.js");
/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(js_sha3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");




function keccak256(data) {
  return '0x' + js_sha3__WEBPACK_IMPORTED_MODULE_0___default().keccak_256((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(data));
}

/***/ }),

/***/ "./node_modules/@ethersproject/logger/lib.esm/_version.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/logger/lib.esm/_version.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "logger/5.6.0";

/***/ }),

/***/ "./node_modules/@ethersproject/logger/lib.esm/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/logger/lib.esm/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ErrorCode": () => (/* binding */ ErrorCode),
/* harmony export */   "LogLevel": () => (/* binding */ LogLevel),
/* harmony export */   "Logger": () => (/* binding */ Logger)
/* harmony export */ });
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/logger/lib.esm/_version.js");


let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = {
  debug: 1,
  "default": 2,
  info: 2,
  warning: 3,
  error: 4,
  off: 5
};
let _logLevel = LogLevels["default"];

let _globalLogger = null;

function _checkNormalize() {
  try {
    const missing = []; // Make sure all forms of normalization are supported

    ["NFD", "NFC", "NFKD", "NFKC"].forEach(form => {
      try {
        if ("test".normalize(form) !== "test") {
          throw new Error("bad normalize");
        }

        ;
      } catch (error) {
        missing.push(form);
      }
    });

    if (missing.length) {
      throw new Error("missing " + missing.join(", "));
    }

    if (String.fromCharCode(0xe9).normalize("NFD") !== String.fromCharCode(0x65, 0x0301)) {
      throw new Error("broken implementation");
    }
  } catch (error) {
    return error.message;
  }

  return null;
}

const _normalizeError = _checkNormalize();

var LogLevel;

(function (LogLevel) {
  LogLevel["DEBUG"] = "DEBUG";
  LogLevel["INFO"] = "INFO";
  LogLevel["WARNING"] = "WARNING";
  LogLevel["ERROR"] = "ERROR";
  LogLevel["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));

var ErrorCode;

(function (ErrorCode) {
  ///////////////////
  // Generic Errors
  // Unknown Error
  ErrorCode["UNKNOWN_ERROR"] = "UNKNOWN_ERROR"; // Not Implemented

  ErrorCode["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED"; // Unsupported Operation
  //   - operation

  ErrorCode["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION"; // Network Error (i.e. Ethereum Network, such as an invalid chain ID)
  //   - event ("noNetwork" is not re-thrown in provider.ready; otherwise thrown)

  ErrorCode["NETWORK_ERROR"] = "NETWORK_ERROR"; // Some sort of bad response from the server

  ErrorCode["SERVER_ERROR"] = "SERVER_ERROR"; // Timeout

  ErrorCode["TIMEOUT"] = "TIMEOUT"; ///////////////////
  // Operational  Errors
  // Buffer Overrun

  ErrorCode["BUFFER_OVERRUN"] = "BUFFER_OVERRUN"; // Numeric Fault
  //   - operation: the operation being executed
  //   - fault: the reason this faulted

  ErrorCode["NUMERIC_FAULT"] = "NUMERIC_FAULT"; ///////////////////
  // Argument Errors
  // Missing new operator to an object
  //  - name: The name of the class

  ErrorCode["MISSING_NEW"] = "MISSING_NEW"; // Invalid argument (e.g. value is incompatible with type) to a function:
  //   - argument: The argument name that was invalid
  //   - value: The value of the argument

  ErrorCode["INVALID_ARGUMENT"] = "INVALID_ARGUMENT"; // Missing argument to a function:
  //   - count: The number of arguments received
  //   - expectedCount: The number of arguments expected

  ErrorCode["MISSING_ARGUMENT"] = "MISSING_ARGUMENT"; // Too many arguments
  //   - count: The number of arguments received
  //   - expectedCount: The number of arguments expected

  ErrorCode["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT"; ///////////////////
  // Blockchain Errors
  // Call exception
  //  - transaction: the transaction
  //  - address?: the contract address
  //  - args?: The arguments passed into the function
  //  - method?: The Solidity method signature
  //  - errorSignature?: The EIP848 error signature
  //  - errorArgs?: The EIP848 error parameters
  //  - reason: The reason (only for EIP848 "Error(string)")

  ErrorCode["CALL_EXCEPTION"] = "CALL_EXCEPTION"; // Insufficient funds (< value + gasLimit * gasPrice)
  //   - transaction: the transaction attempted

  ErrorCode["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS"; // Nonce has already been used
  //   - transaction: the transaction attempted

  ErrorCode["NONCE_EXPIRED"] = "NONCE_EXPIRED"; // The replacement fee for the transaction is too low
  //   - transaction: the transaction attempted

  ErrorCode["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED"; // The gas limit could not be estimated
  //   - transaction: the transaction passed to estimateGas

  ErrorCode["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT"; // The transaction was replaced by one with a higher gas price
  //   - reason: "cancelled", "replaced" or "repriced"
  //   - cancelled: true if reason == "cancelled" or reason == "replaced")
  //   - hash: original transaction hash
  //   - replacement: the full TransactionsResponse for the replacement
  //   - receipt: the receipt of the replacement

  ErrorCode["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode || (ErrorCode = {}));

;
const HEX = "0123456789abcdef";
class Logger {
  constructor(version) {
    Object.defineProperty(this, "version", {
      enumerable: true,
      value: version,
      writable: false
    });
  }

  _log(logLevel, args) {
    const level = logLevel.toLowerCase();

    if (LogLevels[level] == null) {
      this.throwArgumentError("invalid log level name", "logLevel", logLevel);
    }

    if (_logLevel > LogLevels[level]) {
      return;
    }

    console.log.apply(console, args);
  }

  debug(...args) {
    this._log(Logger.levels.DEBUG, args);
  }

  info(...args) {
    this._log(Logger.levels.INFO, args);
  }

  warn(...args) {
    this._log(Logger.levels.WARNING, args);
  }

  makeError(message, code, params) {
    // Errors are being censored
    if (_censorErrors) {
      return this.makeError("censored error", code, {});
    }

    if (!code) {
      code = Logger.errors.UNKNOWN_ERROR;
    }

    if (!params) {
      params = {};
    }

    const messageDetails = [];
    Object.keys(params).forEach(key => {
      const value = params[key];

      try {
        if (value instanceof Uint8Array) {
          let hex = "";

          for (let i = 0; i < value.length; i++) {
            hex += HEX[value[i] >> 4];
            hex += HEX[value[i] & 0x0f];
          }

          messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
        } else {
          messageDetails.push(key + "=" + JSON.stringify(value));
        }
      } catch (error) {
        messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
      }
    });
    messageDetails.push(`code=${code}`);
    messageDetails.push(`version=${this.version}`);
    const reason = message;
    let url = "";

    switch (code) {
      case ErrorCode.NUMERIC_FAULT:
        {
          url = "NUMERIC_FAULT";
          const fault = message;

          switch (fault) {
            case "overflow":
            case "underflow":
            case "division-by-zero":
              url += "-" + fault;
              break;

            case "negative-power":
            case "negative-width":
              url += "-unsupported";
              break;

            case "unbound-bitwise-result":
              url += "-unbound-result";
              break;
          }

          break;
        }

      case ErrorCode.CALL_EXCEPTION:
      case ErrorCode.INSUFFICIENT_FUNDS:
      case ErrorCode.MISSING_NEW:
      case ErrorCode.NONCE_EXPIRED:
      case ErrorCode.REPLACEMENT_UNDERPRICED:
      case ErrorCode.TRANSACTION_REPLACED:
      case ErrorCode.UNPREDICTABLE_GAS_LIMIT:
        url = code;
        break;
    }

    if (url) {
      message += " [ See: https:/\/links.ethers.org/v5-errors-" + url + " ]";
    }

    if (messageDetails.length) {
      message += " (" + messageDetails.join(", ") + ")";
    } // @TODO: Any??


    const error = new Error(message);
    error.reason = reason;
    error.code = code;
    Object.keys(params).forEach(function (key) {
      error[key] = params[key];
    });
    return error;
  }

  throwError(message, code, params) {
    throw this.makeError(message, code, params);
  }

  throwArgumentError(message, name, value) {
    return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
      argument: name,
      value: value
    });
  }

  assert(condition, message, code, params) {
    if (!!condition) {
      return;
    }

    this.throwError(message, code, params);
  }

  assertArgument(condition, message, name, value) {
    if (!!condition) {
      return;
    }

    this.throwArgumentError(message, name, value);
  }

  checkNormalize(message) {
    if (message == null) {
      message = "platform missing String.prototype.normalize";
    }

    if (_normalizeError) {
      this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "String.prototype.normalize",
        form: _normalizeError
      });
    }
  }

  checkSafeUint53(value, message) {
    if (typeof value !== "number") {
      return;
    }

    if (message == null) {
      message = "value not safe";
    }

    if (value < 0 || value >= 0x1fffffffffffff) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "out-of-safe-range",
        value: value
      });
    }

    if (value % 1) {
      this.throwError(message, Logger.errors.NUMERIC_FAULT, {
        operation: "checkSafeInteger",
        fault: "non-integer",
        value: value
      });
    }
  }

  checkArgumentCount(count, expectedCount, message) {
    if (message) {
      message = ": " + message;
    } else {
      message = "";
    }

    if (count < expectedCount) {
      this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
        count: count,
        expectedCount: expectedCount
      });
    }

    if (count > expectedCount) {
      this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
        count: count,
        expectedCount: expectedCount
      });
    }
  }

  checkNew(target, kind) {
    if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, {
        name: kind.name
      });
    }
  }

  checkAbstract(target, kind) {
    if (target === kind) {
      this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, {
        name: target.name,
        operation: "new"
      });
    } else if (target === Object || target == null) {
      this.throwError("missing new", Logger.errors.MISSING_NEW, {
        name: kind.name
      });
    }
  }

  static globalLogger() {
    if (!_globalLogger) {
      _globalLogger = new Logger(_version__WEBPACK_IMPORTED_MODULE_0__.version);
    }

    return _globalLogger;
  }

  static setCensorship(censorship, permanent) {
    if (!censorship && permanent) {
      this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }

    if (_permanentCensorErrors) {
      if (!censorship) {
        return;
      }

      this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }

    _censorErrors = !!censorship;
    _permanentCensorErrors = !!permanent;
  }

  static setLogLevel(logLevel) {
    const level = LogLevels[logLevel.toLowerCase()];

    if (level == null) {
      Logger.globalLogger().warn("invalid log level - " + logLevel);
      return;
    }

    _logLevel = level;
  }

  static from(version) {
    return new Logger(version);
  }

}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;

/***/ }),

/***/ "./node_modules/@ethersproject/networks/lib.esm/_version.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersproject/networks/lib.esm/_version.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "networks/5.6.2";

/***/ }),

/***/ "./node_modules/@ethersproject/networks/lib.esm/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ethersproject/networks/lib.esm/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getNetwork": () => (/* binding */ getNetwork)
/* harmony export */ });
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/networks/lib.esm/_version.js");




const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
;

function isRenetworkable(value) {
  return value && typeof value.renetwork === "function";
}

function ethDefaultProvider(network) {
  const func = function (providers, options) {
    if (options == null) {
      options = {};
    }

    const providerList = [];

    if (providers.InfuraProvider && options.infura !== "-") {
      try {
        providerList.push(new providers.InfuraProvider(network, options.infura));
      } catch (error) {}
    }

    if (providers.EtherscanProvider && options.etherscan !== "-") {
      try {
        providerList.push(new providers.EtherscanProvider(network, options.etherscan));
      } catch (error) {}
    }

    if (providers.AlchemyProvider && options.alchemy !== "-") {
      try {
        providerList.push(new providers.AlchemyProvider(network, options.alchemy));
      } catch (error) {}
    }

    if (providers.PocketProvider && options.pocket !== "-") {
      // These networks are currently faulty on Pocket as their
      // network does not handle the Berlin hardfork, which is
      // live on these ones.
      // @TODO: This goes away once Pocket has upgraded their nodes
      const skip = ["goerli", "ropsten", "rinkeby"];

      try {
        const provider = new providers.PocketProvider(network, options.pocket);

        if (provider.network && skip.indexOf(provider.network.name) === -1) {
          providerList.push(provider);
        }
      } catch (error) {}
    }

    if (providers.CloudflareProvider && options.cloudflare !== "-") {
      try {
        providerList.push(new providers.CloudflareProvider(network));
      } catch (error) {}
    }

    if (providers.AnkrProvider && options.ankr !== "-") {
      try {
        providerList.push(new providers.AnkrProvider(network, options.ankr));
      } catch (error) {}
    }

    if (providerList.length === 0) {
      return null;
    }

    if (providers.FallbackProvider) {
      let quorum = 1;

      if (options.quorum != null) {
        quorum = options.quorum;
      } else if (network === "homestead") {
        quorum = 2;
      }

      return new providers.FallbackProvider(providerList, quorum);
    }

    return providerList[0];
  };

  func.renetwork = function (network) {
    return ethDefaultProvider(network);
  };

  return func;
}

function etcDefaultProvider(url, network) {
  const func = function (providers, options) {
    if (providers.JsonRpcProvider) {
      return new providers.JsonRpcProvider(url, network);
    }

    return null;
  };

  func.renetwork = function (network) {
    return etcDefaultProvider(url, network);
  };

  return func;
}

const homestead = {
  chainId: 1,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "homestead",
  _defaultProvider: ethDefaultProvider("homestead")
};
const ropsten = {
  chainId: 3,
  ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  name: "ropsten",
  _defaultProvider: ethDefaultProvider("ropsten")
};
const classicMordor = {
  chainId: 63,
  name: "classicMordor",
  _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
}; // See: https://chainlist.org

const networks = {
  unspecified: {
    chainId: 0,
    name: "unspecified"
  },
  homestead: homestead,
  mainnet: homestead,
  morden: {
    chainId: 2,
    name: "morden"
  },
  ropsten: ropsten,
  testnet: ropsten,
  rinkeby: {
    chainId: 4,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "rinkeby",
    _defaultProvider: ethDefaultProvider("rinkeby")
  },
  kovan: {
    chainId: 42,
    name: "kovan",
    _defaultProvider: ethDefaultProvider("kovan")
  },
  goerli: {
    chainId: 5,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "goerli",
    _defaultProvider: ethDefaultProvider("goerli")
  },
  kintsugi: {
    chainId: 1337702,
    name: "kintsugi"
  },
  // ETC (See: #351)
  classic: {
    chainId: 61,
    name: "classic",
    _defaultProvider: etcDefaultProvider("https:/\/www.ethercluster.com/etc", "classic")
  },
  classicMorden: {
    chainId: 62,
    name: "classicMorden"
  },
  classicMordor: classicMordor,
  classicTestnet: classicMordor,
  classicKotti: {
    chainId: 6,
    name: "classicKotti",
    _defaultProvider: etcDefaultProvider("https:/\/www.ethercluster.com/kotti", "classicKotti")
  },
  xdai: {
    chainId: 100,
    name: "xdai"
  },
  matic: {
    chainId: 137,
    name: "matic"
  },
  maticmum: {
    chainId: 80001,
    name: "maticmum"
  },
  optimism: {
    chainId: 10,
    name: "optimism"
  },
  "optimism-kovan": {
    chainId: 69,
    name: "optimism-kovan"
  },
  "optimism-goerli": {
    chainId: 420,
    name: "optimism-goerli"
  },
  arbitrum: {
    chainId: 42161,
    name: "arbitrum"
  },
  "arbitrum-rinkeby": {
    chainId: 421611,
    name: "arbitrum-rinkeby"
  },
  bnb: {
    chainId: 56,
    name: "bnb"
  },
  bnbt: {
    chainId: 97,
    name: "bnbt"
  }
};
/**
 *  getNetwork
 *
 *  Converts a named common networks or chain ID (network ID) to a Network
 *  and verifies a network is a valid Network..
 */

function getNetwork(network) {
  // No network (null)
  if (network == null) {
    return null;
  }

  if (typeof network === "number") {
    for (const name in networks) {
      const standard = networks[name];

      if (standard.chainId === network) {
        return {
          name: standard.name,
          chainId: standard.chainId,
          ensAddress: standard.ensAddress || null,
          _defaultProvider: standard._defaultProvider || null
        };
      }
    }

    return {
      chainId: network,
      name: "unknown"
    };
  }

  if (typeof network === "string") {
    const standard = networks[network];

    if (standard == null) {
      return null;
    }

    return {
      name: standard.name,
      chainId: standard.chainId,
      ensAddress: standard.ensAddress,
      _defaultProvider: standard._defaultProvider || null
    };
  }

  const standard = networks[network.name]; // Not a standard network; check that it is a valid network in general

  if (!standard) {
    if (typeof network.chainId !== "number") {
      logger.throwArgumentError("invalid network chainId", "network", network);
    }

    return network;
  } // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)


  if (network.chainId !== 0 && network.chainId !== standard.chainId) {
    logger.throwArgumentError("network chainId mismatch", "network", network);
  } // @TODO: In the next major version add an attach function to a defaultProvider
  // class and move the _defaultProvider internal to this file (extend Network)


  let defaultProvider = network._defaultProvider || null;

  if (defaultProvider == null && standard._defaultProvider) {
    if (isRenetworkable(standard._defaultProvider)) {
      defaultProvider = standard._defaultProvider.renetwork(network);
    } else {
      defaultProvider = standard._defaultProvider;
    }
  } // Standard Network (allow overriding the ENS address)


  return {
    name: network.name,
    chainId: standard.chainId,
    ensAddress: network.ensAddress || standard.ensAddress || null,
    _defaultProvider: defaultProvider
  };
}

/***/ }),

/***/ "./node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "pbkdf2": () => (/* binding */ pbkdf2)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/sha2 */ "./node_modules/@ethersproject/sha2/lib.esm/sha2.js");




function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {
  password = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)(password);
  salt = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)(salt);
  let hLen;
  let l = 1;
  const DK = new Uint8Array(keylen);
  const block1 = new Uint8Array(salt.length + 4);
  block1.set(salt); //salt.copy(block1, 0, 0, salt.length)

  let r;
  let T;

  for (let i = 1; i <= l; i++) {
    //block1.writeUInt32BE(i, salt.length)
    block1[salt.length] = i >> 24 & 0xff;
    block1[salt.length + 1] = i >> 16 & 0xff;
    block1[salt.length + 2] = i >> 8 & 0xff;
    block1[salt.length + 3] = i & 0xff; //let U = createHmac(password).update(block1).digest();

    let U = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_1__.computeHmac)(hashAlgorithm, password, block1));

    if (!hLen) {
      hLen = U.length;
      T = new Uint8Array(hLen);
      l = Math.ceil(keylen / hLen);
      r = keylen - (l - 1) * hLen;
    } //U.copy(T, 0, 0, hLen)


    T.set(U);

    for (let j = 1; j < iterations; j++) {
      //U = createHmac(password).update(U).digest();
      U = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_1__.computeHmac)(hashAlgorithm, password, U));

      for (let k = 0; k < hLen; k++) T[k] ^= U[k];
    }

    const destPos = (i - 1) * hLen;
    const len = i === l ? r : hLen; //T.copy(DK, destPos, 0, len)

    DK.set((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)(T).slice(0, len), destPos);
  }

  return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.hexlify)(DK);
}

/***/ }),

/***/ "./node_modules/@ethersproject/properties/lib.esm/_version.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ethersproject/properties/lib.esm/_version.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "properties/5.6.0";

/***/ }),

/***/ "./node_modules/@ethersproject/properties/lib.esm/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersproject/properties/lib.esm/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Description": () => (/* binding */ Description),
/* harmony export */   "checkProperties": () => (/* binding */ checkProperties),
/* harmony export */   "deepCopy": () => (/* binding */ deepCopy),
/* harmony export */   "defineReadOnly": () => (/* binding */ defineReadOnly),
/* harmony export */   "getStatic": () => (/* binding */ getStatic),
/* harmony export */   "resolveProperties": () => (/* binding */ resolveProperties),
/* harmony export */   "shallowCopy": () => (/* binding */ shallowCopy)
/* harmony export */ });
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/properties/lib.esm/_version.js");


var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};



const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
function defineReadOnly(object, name, value) {
  Object.defineProperty(object, name, {
    enumerable: true,
    value: value,
    writable: false
  });
} // Crawl up the constructor chain to find a static method

function getStatic(ctor, key) {
  for (let i = 0; i < 32; i++) {
    if (ctor[key]) {
      return ctor[key];
    }

    if (!ctor.prototype || typeof ctor.prototype !== "object") {
      break;
    }

    ctor = Object.getPrototypeOf(ctor.prototype).constructor;
  }

  return null;
}
function resolveProperties(object) {
  return __awaiter(this, void 0, void 0, function* () {
    const promises = Object.keys(object).map(key => {
      const value = object[key];
      return Promise.resolve(value).then(v => ({
        key: key,
        value: v
      }));
    });
    const results = yield Promise.all(promises);
    return results.reduce((accum, result) => {
      accum[result.key] = result.value;
      return accum;
    }, {});
  });
}
function checkProperties(object, properties) {
  if (!object || typeof object !== "object") {
    logger.throwArgumentError("invalid object", "object", object);
  }

  Object.keys(object).forEach(key => {
    if (!properties[key]) {
      logger.throwArgumentError("invalid object key - " + key, "transaction:" + key, object);
    }
  });
}
function shallowCopy(object) {
  const result = {};

  for (const key in object) {
    result[key] = object[key];
  }

  return result;
}
const opaque = {
  bigint: true,
  boolean: true,
  "function": true,
  number: true,
  string: true
};

function _isFrozen(object) {
  // Opaque objects are not mutable, so safe to copy by assignment
  if (object === undefined || object === null || opaque[typeof object]) {
    return true;
  }

  if (Array.isArray(object) || typeof object === "object") {
    if (!Object.isFrozen(object)) {
      return false;
    }

    const keys = Object.keys(object);

    for (let i = 0; i < keys.length; i++) {
      let value = null;

      try {
        value = object[keys[i]];
      } catch (error) {
        // If accessing a value triggers an error, it is a getter
        // designed to do so (e.g. Result) and is therefore "frozen"
        continue;
      }

      if (!_isFrozen(value)) {
        return false;
      }
    }

    return true;
  }

  return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
} // Returns a new copy of object, such that no properties may be replaced.
// New properties may be added only to objects.


function _deepCopy(object) {
  if (_isFrozen(object)) {
    return object;
  } // Arrays are mutable, so we need to create a copy


  if (Array.isArray(object)) {
    return Object.freeze(object.map(item => deepCopy(item)));
  }

  if (typeof object === "object") {
    const result = {};

    for (const key in object) {
      const value = object[key];

      if (value === undefined) {
        continue;
      }

      defineReadOnly(result, key, deepCopy(value));
    }

    return result;
  }

  return logger.throwArgumentError(`Cannot deepCopy ${typeof object}`, "object", object);
}

function deepCopy(object) {
  return _deepCopy(object);
}
class Description {
  constructor(info) {
    for (const key in info) {
      this[key] = deepCopy(info[key]);
    }
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/_version.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/_version.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "providers/5.6.5";

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AlchemyProvider": () => (/* binding */ AlchemyProvider),
/* harmony export */   "AlchemyWebSocketProvider": () => (/* binding */ AlchemyWebSocketProvider)
/* harmony export */ });
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formatter */ "./node_modules/@ethersproject/providers/lib.esm/formatter.js");
/* harmony import */ var _websocket_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./websocket-provider */ "./node_modules/@ethersproject/providers/lib.esm/websocket-provider.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");
/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./url-json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js");







const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
 // This key was provided to ethers.js by Alchemy to be used by the
// default provider, but it is recommended that for your own
// production environments, that you acquire your own API key at:
//   https://dashboard.alchemyapi.io

const defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
class AlchemyWebSocketProvider extends _websocket_provider__WEBPACK_IMPORTED_MODULE_2__.WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new AlchemyProvider(network, apiKey);
    const url = provider.connection.url.replace(/^http/i, "ws").replace(".alchemyapi.", ".ws.alchemyapi.");
    super(url, provider.network);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "apiKey", provider.apiKey);
  }

  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }

}
class AlchemyProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_4__.UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new AlchemyWebSocketProvider(network, apiKey);
  }

  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey;
    }

    if (apiKey && typeof apiKey !== "string") {
      logger.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }

    return apiKey;
  }

  static getUrl(network, apiKey) {
    let host = null;

    switch (network.name) {
      case "homestead":
        host = "eth-mainnet.alchemyapi.io/v2/";
        break;

      case "ropsten":
        host = "eth-ropsten.alchemyapi.io/v2/";
        break;

      case "rinkeby":
        host = "eth-rinkeby.alchemyapi.io/v2/";
        break;

      case "goerli":
        host = "eth-goerli.alchemyapi.io/v2/";
        break;

      case "kovan":
        host = "eth-kovan.alchemyapi.io/v2/";
        break;

      case "matic":
        host = "polygon-mainnet.g.alchemy.com/v2/";
        break;

      case "maticmum":
        host = "polygon-mumbai.g.alchemy.com/v2/";
        break;

      case "arbitrum":
        host = "arb-mainnet.g.alchemy.com/v2/";
        break;

      case "arbitrum-rinkeby":
        host = "arb-rinkeby.g.alchemy.com/v2/";
        break;

      case "optimism":
        host = "opt-mainnet.g.alchemy.com/v2/";
        break;

      case "optimism-kovan":
        host = "opt-kovan.g.alchemy.com/v2/";
        break;

      default:
        logger.throwArgumentError("unsupported network", "network", arguments[0]);
    }

    return {
      allowGzip: true,
      url: "https:/" + "/" + host + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey === defaultApiKey) {
          (0,_formatter__WEBPACK_IMPORTED_MODULE_5__.showThrottleMessage)();
        }

        return Promise.resolve(true);
      }
    };
  }

  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/ankr-provider.js":
/*!************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/ankr-provider.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnkrProvider": () => (/* binding */ AnkrProvider)
/* harmony export */ });
/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./formatter */ "./node_modules/@ethersproject/providers/lib.esm/formatter.js");
/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./url-json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");




const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
const defaultApiKey = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";

function getHost(name) {
  switch (name) {
    case "homestead":
      return "rpc.ankr.com/eth/";

    case "ropsten":
      return "rpc.ankr.com/eth_ropsten/";

    case "rinkeby":
      return "rpc.ankr.com/eth_rinkeby/";

    case "goerli":
      return "rpc.ankr.com/eth_goerli/";

    case "matic":
      return "rpc.ankr.com/polygon/";

    case "arbitrum":
      return "rpc.ankr.com/arbitrum/";
  }

  return logger.throwArgumentError("unsupported network", "name", name);
}

class AnkrProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.UrlJsonRpcProvider {
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }

  static getApiKey(apiKey) {
    if (apiKey == null) {
      return defaultApiKey;
    }

    return apiKey;
  }

  static getUrl(network, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey;
    }

    const connection = {
      allowGzip: true,
      url: "https:/\/" + getHost(network.name) + apiKey,
      throttleCallback: (attempt, url) => {
        if (apiKey.apiKey === defaultApiKey) {
          (0,_formatter__WEBPACK_IMPORTED_MODULE_3__.showThrottleMessage)();
        }

        return Promise.resolve(true);
      }
    };

    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }

    return connection;
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/base-provider.js":
/*!************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/base-provider.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseProvider": () => (/* binding */ BaseProvider),
/* harmony export */   "Event": () => (/* binding */ Event),
/* harmony export */   "Resolver": () => (/* binding */ Resolver)
/* harmony export */ });
/* harmony import */ var _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/abstract-provider */ "./node_modules/@ethersproject/abstract-provider/lib.esm/index.js");
/* harmony import */ var _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/basex */ "./node_modules/@ethersproject/basex/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @ethersproject/constants */ "./node_modules/@ethersproject/constants/lib.esm/hashes.js");
/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/hash */ "./node_modules/@ethersproject/hash/lib.esm/namehash.js");
/* harmony import */ var _ethersproject_networks__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @ethersproject/networks */ "./node_modules/@ethersproject/networks/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/sha2 */ "./node_modules/@ethersproject/sha2/lib.esm/sha2.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/utf8.js");
/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @ethersproject/web */ "./node_modules/@ethersproject/web/lib.esm/index.js");
/* harmony import */ var bech32__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bech32 */ "./node_modules/bech32/index.js");
/* harmony import */ var bech32__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bech32__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");
/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./formatter */ "./node_modules/@ethersproject/providers/lib.esm/formatter.js");


var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};















const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(_version__WEBPACK_IMPORTED_MODULE_2__.version);

const MAX_CCIP_REDIRECTS = 10; //////////////////////////////
// Event Serializeing

function checkTopic(topic) {
  if (topic == null) {
    return "null";
  }

  if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(topic) !== 32) {
    logger.throwArgumentError("invalid topic", "topic", topic);
  }

  return topic.toLowerCase();
}

function serializeTopics(topics) {
  // Remove trailing null AND-topics; they are redundant
  topics = topics.slice();

  while (topics.length > 0 && topics[topics.length - 1] == null) {
    topics.pop();
  }

  return topics.map(topic => {
    if (Array.isArray(topic)) {
      // Only track unique OR-topics
      const unique = {};
      topic.forEach(topic => {
        unique[checkTopic(topic)] = true;
      }); // The order of OR-topics does not matter

      const sorted = Object.keys(unique);
      sorted.sort();
      return sorted.join("|");
    } else {
      return checkTopic(topic);
    }
  }).join("&");
}

function deserializeTopics(data) {
  if (data === "") {
    return [];
  }

  return data.split(/&/g).map(topic => {
    if (topic === "") {
      return [];
    }

    const comps = topic.split("|").map(topic => {
      return topic === "null" ? null : topic;
    });
    return comps.length === 1 ? comps[0] : comps;
  });
}

function getEventTag(eventName) {
  if (typeof eventName === "string") {
    eventName = eventName.toLowerCase();

    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(eventName) === 32) {
      return "tx:" + eventName;
    }

    if (eventName.indexOf(":") === -1) {
      return eventName;
    }
  } else if (Array.isArray(eventName)) {
    return "filter:*:" + serializeTopics(eventName);
  } else if (_ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_4__.ForkEvent.isForkEvent(eventName)) {
    logger.warn("not implemented");
    throw new Error("not implemented");
  } else if (eventName && typeof eventName === "object") {
    return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
  }

  throw new Error("invalid event - " + eventName);
} //////////////////////////////
// Helper Object


function getTime() {
  return new Date().getTime();
}

function stall(duration) {
  return new Promise(resolve => {
    setTimeout(resolve, duration);
  });
} //////////////////////////////
// Provider Object

/**
 *  EventType
 *   - "block"
 *   - "poll"
 *   - "didPoll"
 *   - "pending"
 *   - "error"
 *   - "network"
 *   - filter
 *   - topics array
 *   - transaction hash
 */


const PollableEvents = ["block", "network", "pending", "poll"];
class Event {
  constructor(tag, listener, once) {
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, "tag", tag);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, "listener", listener);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, "once", once);
    this._lastBlockNumber = -2;
    this._inflight = false;
  }

  get event() {
    switch (this.type) {
      case "tx":
        return this.hash;

      case "filter":
        return this.filter;
    }

    return this.tag;
  }

  get type() {
    return this.tag.split(":")[0];
  }

  get hash() {
    const comps = this.tag.split(":");

    if (comps[0] !== "tx") {
      return null;
    }

    return comps[1];
  }

  get filter() {
    const comps = this.tag.split(":");

    if (comps[0] !== "filter") {
      return null;
    }

    const address = comps[1];
    const topics = deserializeTopics(comps[2]);
    const filter = {};

    if (topics.length > 0) {
      filter.topics = topics;
    }

    if (address && address !== "*") {
      filter.address = address;
    }

    return filter;
  }

  pollable() {
    return this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0;
  }

}
; // https://github.com/satoshilabs/slips/blob/master/slip-0044.md

const coinInfos = {
  "0": {
    symbol: "btc",
    p2pkh: 0x00,
    p2sh: 0x05,
    prefix: "bc"
  },
  "2": {
    symbol: "ltc",
    p2pkh: 0x30,
    p2sh: 0x32,
    prefix: "ltc"
  },
  "3": {
    symbol: "doge",
    p2pkh: 0x1e,
    p2sh: 0x16
  },
  "60": {
    symbol: "eth",
    ilk: "eth"
  },
  "61": {
    symbol: "etc",
    ilk: "eth"
  },
  "700": {
    symbol: "xdai",
    ilk: "eth"
  }
};

function bytes32ify(value) {
  return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(value).toHexString(), 32);
} // Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)


function base58Encode(data) {
  return _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__.Base58.encode((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([data, (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_8__.sha256)((0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_8__.sha256)(data)), 0, 4)]));
}

const matcherIpfs = new RegExp("^(ipfs):/\/(.*)$", "i");
const matchers = [new RegExp("^(https):/\/(.*)$", "i"), new RegExp("^(data):(.*)$", "i"), matcherIpfs, new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")];

function _parseString(result, start) {
  try {
    return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__.toUtf8String)(_parseBytes(result, start));
  } catch (error) {}

  return null;
}

function _parseBytes(result, start) {
  if (result === "0x") {
    return null;
  }

  const offset = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, start, start + 32)).toNumber();
  const length = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, offset, offset + 32)).toNumber();
  return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, offset + 32, offset + 32 + length);
} // Trim off the ipfs:// prefix and return the default gateway URL


function getIpfsLink(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    logger.throwArgumentError("unsupported IPFS format", "link", link);
  }

  return `https:/\/gateway.ipfs.io/ipfs/${link}`;
}

function numPad(value) {
  const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(value);

  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }

  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
}

function bytesPad(value) {
  if (value.length % 32 === 0) {
    return value;
  }

  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
} // ABI Encodes a series of (bytes, bytes, ...)


function encodeBytes(datas) {
  const result = [];
  let byteCount = 0; // Add place-holders for pointers as we add items

  for (let i = 0; i < datas.length; i++) {
    result.push(null);
    byteCount += 32;
  }

  for (let i = 0; i < datas.length; i++) {
    const data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(datas[i]); // Update the bytes offset

    result[i] = numPad(byteCount); // The length and padded value of data

    result.push(numPad(data.length));
    result.push(bytesPad(data));
    byteCount += 32 + Math.ceil(data.length / 32) * 32;
  }

  return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(result);
}

class Resolver {
  // The resolvedAddress is only for creating a ReverseLookup resolver
  constructor(provider, address, name, resolvedAddress) {
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, "provider", provider);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, "name", name);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, "address", provider.formatter.address(address));
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, "_resolvedAddress", resolvedAddress);
  }

  supportsWildcard() {
    if (!this._supportsEip2544) {
      // supportsInterface(bytes4 = selector("resolve(bytes,bytes)"))
      this._supportsEip2544 = this.provider.call({
        to: this.address,
        data: "0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000"
      }).then(result => {
        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result).eq(1);
      }).catch(error => {
        if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {
          return false;
        } // Rethrow the error: link is down, etc. Let future attempts retry.


        this._supportsEip2544 = null;
        throw error;
      });
    }

    return this._supportsEip2544;
  }

  _fetch(selector, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      // e.g. keccak256("addr(bytes32,uint256)")
      const tx = {
        to: this.address,
        ccipReadEnabled: true,
        data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([selector, (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(this.name), parameters || "0x"])
      }; // Wildcard support; use EIP-2544 to resolve the request

      let parseBytes = false;

      if (yield this.supportsWildcard()) {
        parseBytes = true; // selector("resolve(bytes,bytes)")

        tx.data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(["0x9061b923", encodeBytes([(0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.dnsEncode)(this.name), tx.data])]);
      }

      try {
        let result = yield this.provider.call(tx);

        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(result).length % 32 === 4) {
          logger.throwError("resolver threw error", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {
            transaction: tx,
            data: result
          });
        }

        if (parseBytes) {
          result = _parseBytes(result, 0);
        }

        return result;
      } catch (error) {
        if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {
          return null;
        }

        throw error;
      }
    });
  }

  _fetchBytes(selector, parameters) {
    return __awaiter(this, void 0, void 0, function* () {
      const result = yield this._fetch(selector, parameters);

      if (result != null) {
        return _parseBytes(result, 0);
      }

      return null;
    });
  }

  _getAddress(coinType, hexBytes) {
    const coinInfo = coinInfos[String(coinType)];

    if (coinInfo == null) {
      logger.throwError(`unsupported coin type: ${coinType}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: `getAddress(${coinType})`
      });
    }

    if (coinInfo.ilk === "eth") {
      return this.provider.formatter.address(hexBytes);
    }

    const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(hexBytes); // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG

    if (coinInfo.p2pkh != null) {
      const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);

      if (p2pkh) {
        const length = parseInt(p2pkh[1], 16);

        if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([[coinInfo.p2pkh], "0x" + p2pkh[2]]));
        }
      }
    } // P2SH: OP_HASH160 <scriptHash> OP_EQUAL


    if (coinInfo.p2sh != null) {
      const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);

      if (p2sh) {
        const length = parseInt(p2sh[1], 16);

        if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {
          return base58Encode((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([[coinInfo.p2sh], "0x" + p2sh[2]]));
        }
      }
    } // Bech32


    if (coinInfo.prefix != null) {
      const length = bytes[1]; // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program

      let version = bytes[0];

      if (version === 0x00) {
        if (length !== 20 && length !== 32) {
          version = -1;
        }
      } else {
        version = -1;
      }

      if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {
        const words = bech32__WEBPACK_IMPORTED_MODULE_0___default().toWords(bytes.slice(2));
        words.unshift(version);
        return bech32__WEBPACK_IMPORTED_MODULE_0___default().encode(coinInfo.prefix, words);
      }
    }

    return null;
  }

  getAddress(coinType) {
    return __awaiter(this, void 0, void 0, function* () {
      if (coinType == null) {
        coinType = 60;
      } // If Ethereum, use the standard `addr(bytes32)`


      if (coinType === 60) {
        try {
          // keccak256("addr(bytes32)")
          const result = yield this._fetch("0x3b3b57de"); // No address

          if (result === "0x" || result === _ethersproject_constants__WEBPACK_IMPORTED_MODULE_11__.HashZero) {
            return null;
          }

          return this.provider.formatter.callAddress(result);
        } catch (error) {
          if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {
            return null;
          }

          throw error;
        }
      } // keccak256("addr(bytes32,uint256")


      const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType)); // No address

      if (hexBytes == null || hexBytes === "0x") {
        return null;
      } // Compute the address


      const address = this._getAddress(coinType, hexBytes);

      if (address == null) {
        logger.throwError(`invalid or unsupported coin data`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `getAddress(${coinType})`,
          coinType: coinType,
          data: hexBytes
        });
      }

      return address;
    });
  }

  getAvatar() {
    return __awaiter(this, void 0, void 0, function* () {
      const linkage = [{
        type: "name",
        content: this.name
      }];

      try {
        // test data for ricmoo.eth
        //const avatar = "eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233";
        const avatar = yield this.getText("avatar");

        if (avatar == null) {
          return null;
        }

        for (let i = 0; i < matchers.length; i++) {
          const match = avatar.match(matchers[i]);

          if (match == null) {
            continue;
          }

          const scheme = match[1].toLowerCase();

          switch (scheme) {
            case "https":
              linkage.push({
                type: "url",
                content: avatar
              });
              return {
                linkage,
                url: avatar
              };

            case "data":
              linkage.push({
                type: "data",
                content: avatar
              });
              return {
                linkage,
                url: avatar
              };

            case "ipfs":
              linkage.push({
                type: "ipfs",
                content: avatar
              });
              return {
                linkage,
                url: getIpfsLink(avatar)
              };

            case "erc721":
            case "erc1155":
              {
                // Depending on the ERC type, use tokenURI(uint256) or url(uint256)
                const selector = scheme === "erc721" ? "0xc87b56dd" : "0x0e89341c";
                linkage.push({
                  type: scheme,
                  content: avatar
                }); // The owner of this name

                const owner = this._resolvedAddress || (yield this.getAddress());
                const comps = (match[2] || "").split("/");

                if (comps.length !== 2) {
                  return null;
                }

                const addr = yield this.provider.formatter.address(comps[0]);
                const tokenId = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(comps[1]).toHexString(), 32); // Check that this account owns the token

                if (scheme === "erc721") {
                  // ownerOf(uint256 tokenId)
                  const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                    to: addr,
                    data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(["0x6352211e", tokenId])
                  }));

                  if (owner !== tokenOwner) {
                    return null;
                  }

                  linkage.push({
                    type: "owner",
                    content: tokenOwner
                  });
                } else if (scheme === "erc1155") {
                  // balanceOf(address owner, uint256 tokenId)
                  const balance = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(yield this.provider.call({
                    to: addr,
                    data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)(["0x00fdd58e", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)(owner, 32), tokenId])
                  }));

                  if (balance.isZero()) {
                    return null;
                  }

                  linkage.push({
                    type: "balance",
                    content: balance.toString()
                  });
                } // Call the token contract for the metadata URL


                const tx = {
                  to: this.provider.formatter.address(comps[0]),
                  data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([selector, tokenId])
                };

                let metadataUrl = _parseString(yield this.provider.call(tx), 0);

                if (metadataUrl == null) {
                  return null;
                }

                linkage.push({
                  type: "metadata-url-base",
                  content: metadataUrl
                }); // ERC-1155 allows a generic {id} in the URL

                if (scheme === "erc1155") {
                  metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                  linkage.push({
                    type: "metadata-url-expanded",
                    content: metadataUrl
                  });
                } // Transform IPFS metadata links


                if (metadataUrl.match(/^ipfs:/i)) {
                  metadataUrl = getIpfsLink(metadataUrl);
                }

                linkage.push({
                  type: "metadata-url",
                  content: metadataUrl
                }); // Get the token metadata

                const metadata = yield (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.fetchJson)(metadataUrl);

                if (!metadata) {
                  return null;
                }

                linkage.push({
                  type: "metadata",
                  content: JSON.stringify(metadata)
                }); // Pull the image URL out

                let imageUrl = metadata.image;

                if (typeof imageUrl !== "string") {
                  return null;
                }

                if (imageUrl.match(/^(https:\/\/|data:)/i)) {// Allow
                } else {
                  // Transform IPFS link to gateway
                  const ipfs = imageUrl.match(matcherIpfs);

                  if (ipfs == null) {
                    return null;
                  }

                  linkage.push({
                    type: "url-ipfs",
                    content: imageUrl
                  });
                  imageUrl = getIpfsLink(imageUrl);
                }

                linkage.push({
                  type: "url",
                  content: imageUrl
                });
                return {
                  linkage,
                  url: imageUrl
                };
              }
          }
        }
      } catch (error) {}

      return null;
    });
  }

  getContentHash() {
    return __awaiter(this, void 0, void 0, function* () {
      // keccak256("contenthash()")
      const hexBytes = yield this._fetchBytes("0xbc1c58d1"); // No contenthash

      if (hexBytes == null || hexBytes === "0x") {
        return null;
      } // IPFS (CID: 1, Type: DAG-PB)


      const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);

      if (ipfs) {
        const length = parseInt(ipfs[3], 16);

        if (ipfs[4].length === length * 2) {
          return "ipfs:/\/" + _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__.Base58.encode("0x" + ipfs[1]);
        }
      } // IPNS (CID: 1, Type: libp2p-key)


      const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);

      if (ipns) {
        const length = parseInt(ipns[3], 16);

        if (ipns[4].length === length * 2) {
          return "ipns:/\/" + _ethersproject_basex__WEBPACK_IMPORTED_MODULE_7__.Base58.encode("0x" + ipns[1]);
        }
      } // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)


      const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);

      if (swarm) {
        if (swarm[1].length === 32 * 2) {
          return "bzz:/\/" + swarm[1];
        }
      }

      return logger.throwError(`invalid or unsupported content hash data`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "getContentHash()",
        data: hexBytes
      });
    });
  }

  getText(key) {
    return __awaiter(this, void 0, void 0, function* () {
      // The key encoded as parameter to fetchBytes
      let keyBytes = (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__.toUtf8Bytes)(key); // The nodehash consumes the first slot, so the string pointer targets
      // offset 64, with the length at offset 64 and data starting at offset 96

      keyBytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]); // Pad to word-size (32 bytes)

      if (keyBytes.length % 32 !== 0) {
        keyBytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.concat)([keyBytes, (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexZeroPad)("0x", 32 - key.length % 32)]);
      }

      const hexBytes = yield this._fetchBytes("0x59d1d43c", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(keyBytes));

      if (hexBytes == null || hexBytes === "0x") {
        return null;
      }

      return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__.toUtf8String)(hexBytes);
    });
  }

}
let defaultFormatter = null;
let nextPollId = 1;
class BaseProvider extends _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_4__.Provider {
  /**
   *  ready
   *
   *  A Promise<Network> that resolves only once the provider is ready.
   *
   *  Sub-classes that call the super with a network without a chainId
   *  MUST set this. Standard named networks have a known chainId.
   *
   */
  constructor(network) {
    logger.checkNew(new.target, _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_4__.Provider);
    super(); // Events being listened to

    this._events = [];
    this._emitted = {
      block: -2
    };
    this.disableCcipRead = false;
    this.formatter = new.target.getFormatter(); // If network is any, this Provider allows the underlying
    // network to change dynamically, and we auto-detect the
    // current network

    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, "anyNetwork", network === "any");

    if (this.anyNetwork) {
      network = this.detectNetwork();
    }

    if (network instanceof Promise) {
      this._networkPromise = network; // Squash any "unhandled promise" errors; that do not need to be handled

      network.catch(error => {}); // Trigger initial network setting (async)

      this._ready().catch(error => {});
    } else {
      const knownNetwork = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.getStatic)(new.target, "getNetwork")(network);

      if (knownNetwork) {
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, "_network", knownNetwork);
        this.emit("network", knownNetwork, null);
      } else {
        logger.throwArgumentError("invalid network", "network", network);
      }
    }

    this._maxInternalBlockNumber = -1024;
    this._lastBlockNumber = -2;
    this._maxFilterBlockRange = 10;
    this._pollingInterval = 4000;
    this._fastQueryDate = 0;
  }

  _ready() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this._network == null) {
        let network = null;

        if (this._networkPromise) {
          try {
            network = yield this._networkPromise;
          } catch (error) {}
        } // Try the Provider's network detection (this MUST throw if it cannot)


        if (network == null) {
          network = yield this.detectNetwork();
        } // This should never happen; every Provider sub-class should have
        // suggested a network by here (or have thrown).


        if (!network) {
          logger.throwError("no network detected", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNKNOWN_ERROR, {});
        } // Possible this call stacked so do not call defineReadOnly again


        if (this._network == null) {
          if (this.anyNetwork) {
            this._network = network;
          } else {
            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, "_network", network);
          }

          this.emit("network", network, null);
        }
      }

      return this._network;
    });
  } // This will always return the most recently established network.
  // For "any", this can change (a "network" event is emitted before
  // any change is reflected); otherwise this cannot change


  get ready() {
    return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(() => {
      return this._ready().then(network => {
        return network;
      }, error => {
        // If the network isn't running yet, we will wait
        if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NETWORK_ERROR && error.event === "noNetwork") {
          return undefined;
        }

        throw error;
      });
    });
  } // @TODO: Remove this and just create a singleton formatter


  static getFormatter() {
    if (defaultFormatter == null) {
      defaultFormatter = new _formatter__WEBPACK_IMPORTED_MODULE_13__.Formatter();
    }

    return defaultFormatter;
  } // @TODO: Remove this and just use getNetwork


  static getNetwork(network) {
    return (0,_ethersproject_networks__WEBPACK_IMPORTED_MODULE_14__.getNetwork)(network == null ? "homestead" : network);
  }

  ccipReadFetch(tx, calldata, urls) {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.disableCcipRead || urls.length === 0) {
        return null;
      }

      const sender = tx.to.toLowerCase();
      const data = calldata.toLowerCase();
      const errorMessages = [];

      for (let i = 0; i < urls.length; i++) {
        const url = urls[i]; // URL expansion

        const href = url.replace("{sender}", sender).replace("{data}", data); // If no {data} is present, use POST; otherwise GET

        const json = url.indexOf("{data}") >= 0 ? null : JSON.stringify({
          data,
          sender
        });
        const result = yield (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.fetchJson)({
          url: href,
          errorPassThrough: true
        }, json, (value, response) => {
          value.status = response.statusCode;
          return value;
        });

        if (result.data) {
          return result.data;
        }

        const errorMessage = result.message || "unknown error"; // 4xx indicates the result is not present; stop

        if (result.status >= 400 && result.status < 500) {
          return logger.throwError(`response not found during CCIP fetch: ${errorMessage}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {
            url,
            errorMessage
          });
        } // 5xx indicates server issue; try the next url


        errorMessages.push(errorMessage);
      }

      return logger.throwError(`error encountered during CCIP fetch: ${errorMessages.map(m => JSON.stringify(m)).join(", ")}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {
        urls,
        errorMessages
      });
    });
  } // Fetches the blockNumber, but will reuse any result that is less
  // than maxAge old or has been requested since the last request


  _getInternalBlockNumber(maxAge) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this._ready(); // Allowing stale data up to maxAge old

      if (maxAge > 0) {
        // While there are pending internal block requests...
        while (this._internalBlockNumber) {
          // ..."remember" which fetch we started with
          const internalBlockNumber = this._internalBlockNumber;

          try {
            // Check the result is not too stale
            const result = yield internalBlockNumber;

            if (getTime() - result.respTime <= maxAge) {
              return result.blockNumber;
            } // Too old; fetch a new value


            break;
          } catch (error) {
            // The fetch rejected; if we are the first to get the
            // rejection, drop through so we replace it with a new
            // fetch; all others blocked will then get that fetch
            // which won't match the one they "remembered" and loop
            if (this._internalBlockNumber === internalBlockNumber) {
              break;
            }
          }
        }
      }

      const reqTime = getTime();
      const checkInternalBlockNumber = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({
        blockNumber: this.perform("getBlockNumber", {}),
        networkError: this.getNetwork().then(network => null, error => error)
      }).then(({
        blockNumber,
        networkError
      }) => {
        if (networkError) {
          // Unremember this bad internal block number
          if (this._internalBlockNumber === checkInternalBlockNumber) {
            this._internalBlockNumber = null;
          }

          throw networkError;
        }

        const respTime = getTime();
        blockNumber = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(blockNumber).toNumber();

        if (blockNumber < this._maxInternalBlockNumber) {
          blockNumber = this._maxInternalBlockNumber;
        }

        this._maxInternalBlockNumber = blockNumber;

        this._setFastBlockNumber(blockNumber); // @TODO: Still need this?


        return {
          blockNumber,
          reqTime,
          respTime
        };
      });
      this._internalBlockNumber = checkInternalBlockNumber; // Swallow unhandled exceptions; if needed they are handled else where

      checkInternalBlockNumber.catch(error => {
        // Don't null the dead (rejected) fetch, if it has already been updated
        if (this._internalBlockNumber === checkInternalBlockNumber) {
          this._internalBlockNumber = null;
        }
      });
      return (yield checkInternalBlockNumber).blockNumber;
    });
  }

  poll() {
    return __awaiter(this, void 0, void 0, function* () {
      const pollId = nextPollId++; // Track all running promises, so we can trigger a post-poll once they are complete

      const runners = [];
      let blockNumber = null;

      try {
        blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
      } catch (error) {
        this.emit("error", error);
        return;
      }

      this._setFastBlockNumber(blockNumber); // Emit a poll event after we have the latest (fast) block number


      this.emit("poll", pollId, blockNumber); // If the block has not changed, meh.

      if (blockNumber === this._lastBlockNumber) {
        this.emit("didPoll", pollId);
        return;
      } // First polling cycle, trigger a "block" events


      if (this._emitted.block === -2) {
        this._emitted.block = blockNumber - 1;
      }

      if (Math.abs(this._emitted.block - blockNumber) > 1000) {
        logger.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
        this.emit("error", logger.makeError("network block skew detected", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NETWORK_ERROR, {
          blockNumber: blockNumber,
          event: "blockSkew",
          previousBlockNumber: this._emitted.block
        }));
        this.emit("block", blockNumber);
      } else {
        // Notify all listener for each block that has passed
        for (let i = this._emitted.block + 1; i <= blockNumber; i++) {
          this.emit("block", i);
        }
      } // The emitted block was updated, check for obsolete events


      if (this._emitted.block !== blockNumber) {
        this._emitted.block = blockNumber;
        Object.keys(this._emitted).forEach(key => {
          // The block event does not expire
          if (key === "block") {
            return;
          } // The block we were at when we emitted this event


          const eventBlockNumber = this._emitted[key]; // We cannot garbage collect pending transactions or blocks here
          // They should be garbage collected by the Provider when setting
          // "pending" events

          if (eventBlockNumber === "pending") {
            return;
          } // Evict any transaction hashes or block hashes over 12 blocks
          // old, since they should not return null anyways


          if (blockNumber - eventBlockNumber > 12) {
            delete this._emitted[key];
          }
        });
      } // First polling cycle


      if (this._lastBlockNumber === -2) {
        this._lastBlockNumber = blockNumber - 1;
      } // Find all transaction hashes we are waiting on


      this._events.forEach(event => {
        switch (event.type) {
          case "tx":
            {
              const hash = event.hash;
              let runner = this.getTransactionReceipt(hash).then(receipt => {
                if (!receipt || receipt.blockNumber == null) {
                  return null;
                }

                this._emitted["t:" + hash] = receipt.blockNumber;
                this.emit(hash, receipt);
                return null;
              }).catch(error => {
                this.emit("error", error);
              });
              runners.push(runner);
              break;
            }

          case "filter":
            {
              // We only allow a single getLogs to be in-flight at a time
              if (!event._inflight) {
                event._inflight = true; // Filter from the last known event; due to load-balancing
                // and some nodes returning updated block numbers before
                // indexing events, a logs result with 0 entries cannot be
                // trusted and we must retry a range which includes it again

                const filter = event.filter;
                filter.fromBlock = event._lastBlockNumber + 1;
                filter.toBlock = blockNumber; // Prevent fitler ranges from growing too wild

                if (filter.toBlock - this._maxFilterBlockRange > filter.fromBlock) {
                  filter.fromBlock = filter.toBlock - this._maxFilterBlockRange;
                }

                const runner = this.getLogs(filter).then(logs => {
                  // Allow the next getLogs
                  event._inflight = false;

                  if (logs.length === 0) {
                    return;
                  }

                  logs.forEach(log => {
                    // Only when we get an event for a given block number
                    // can we trust the events are indexed
                    if (log.blockNumber > event._lastBlockNumber) {
                      event._lastBlockNumber = log.blockNumber;
                    } // Make sure we stall requests to fetch blocks and txs


                    this._emitted["b:" + log.blockHash] = log.blockNumber;
                    this._emitted["t:" + log.transactionHash] = log.blockNumber;
                    this.emit(filter, log);
                  });
                }).catch(error => {
                  this.emit("error", error); // Allow another getLogs (the range was not updated)

                  event._inflight = false;
                });
                runners.push(runner);
              }

              break;
            }
        }
      });

      this._lastBlockNumber = blockNumber; // Once all events for this loop have been processed, emit "didPoll"

      Promise.all(runners).then(() => {
        this.emit("didPoll", pollId);
      }).catch(error => {
        this.emit("error", error);
      });
      return;
    });
  } // Deprecated; do not use this


  resetEventsBlock(blockNumber) {
    this._lastBlockNumber = blockNumber - 1;

    if (this.polling) {
      this.poll();
    }
  }

  get network() {
    return this._network;
  } // This method should query the network if the underlying network
  // can change, such as when connected to a JSON-RPC backend


  detectNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      return logger.throwError("provider does not support network detection", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "provider.detectNetwork"
      });
    });
  }

  getNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      const network = yield this._ready(); // Make sure we are still connected to the same network; this is
      // only an external call for backends which can have the underlying
      // network change spontaneously

      const currentNetwork = yield this.detectNetwork();

      if (network.chainId !== currentNetwork.chainId) {
        // We are allowing network changes, things can get complex fast;
        // make sure you know what you are doing if you use "any"
        if (this.anyNetwork) {
          this._network = currentNetwork; // Reset all internal block number guards and caches

          this._lastBlockNumber = -2;
          this._fastBlockNumber = null;
          this._fastBlockNumberPromise = null;
          this._fastQueryDate = 0;
          this._emitted.block = -2;
          this._maxInternalBlockNumber = -1024;
          this._internalBlockNumber = null; // The "network" event MUST happen before this method resolves
          // so any events have a chance to unregister, so we stall an
          // additional event loop before returning from /this/ call

          this.emit("network", currentNetwork, network);
          yield stall(0);
          return this._network;
        }

        const error = logger.makeError("underlying network changed", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NETWORK_ERROR, {
          event: "changed",
          network: network,
          detectedNetwork: currentNetwork
        });
        this.emit("error", error);
        throw error;
      }

      return network;
    });
  }

  get blockNumber() {
    this._getInternalBlockNumber(100 + this.pollingInterval / 2).then(blockNumber => {
      this._setFastBlockNumber(blockNumber);
    }, error => {});

    return this._fastBlockNumber != null ? this._fastBlockNumber : -1;
  }

  get polling() {
    return this._poller != null;
  }

  set polling(value) {
    if (value && !this._poller) {
      this._poller = setInterval(() => {
        this.poll();
      }, this.pollingInterval);

      if (!this._bootstrapPoll) {
        this._bootstrapPoll = setTimeout(() => {
          this.poll(); // We block additional polls until the polling interval
          // is done, to prevent overwhelming the poll function

          this._bootstrapPoll = setTimeout(() => {
            // If polling was disabled, something may require a poke
            // since starting the bootstrap poll and it was disabled
            if (!this._poller) {
              this.poll();
            } // Clear out the bootstrap so we can do another


            this._bootstrapPoll = null;
          }, this.pollingInterval);
        }, 0);
      }
    } else if (!value && this._poller) {
      clearInterval(this._poller);
      this._poller = null;
    }
  }

  get pollingInterval() {
    return this._pollingInterval;
  }

  set pollingInterval(value) {
    if (typeof value !== "number" || value <= 0 || parseInt(String(value)) != value) {
      throw new Error("invalid polling interval");
    }

    this._pollingInterval = value;

    if (this._poller) {
      clearInterval(this._poller);
      this._poller = setInterval(() => {
        this.poll();
      }, this._pollingInterval);
    }
  }

  _getFastBlockNumber() {
    const now = getTime(); // Stale block number, request a newer value

    if (now - this._fastQueryDate > 2 * this._pollingInterval) {
      this._fastQueryDate = now;
      this._fastBlockNumberPromise = this.getBlockNumber().then(blockNumber => {
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
          this._fastBlockNumber = blockNumber;
        }

        return this._fastBlockNumber;
      });
    }

    return this._fastBlockNumberPromise;
  }

  _setFastBlockNumber(blockNumber) {
    // Older block, maybe a stale request
    if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
      return;
    } // Update the time we updated the blocknumber


    this._fastQueryDate = getTime(); // Newer block number, use  it

    if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
      this._fastBlockNumber = blockNumber;
      this._fastBlockNumberPromise = Promise.resolve(blockNumber);
    }
  }

  waitForTransaction(transactionHash, confirmations, timeout) {
    return __awaiter(this, void 0, void 0, function* () {
      return this._waitForTransaction(transactionHash, confirmations == null ? 1 : confirmations, timeout || 0, null);
    });
  }

  _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
    return __awaiter(this, void 0, void 0, function* () {
      const receipt = yield this.getTransactionReceipt(transactionHash); // Receipt is already good

      if ((receipt ? receipt.confirmations : 0) >= confirmations) {
        return receipt;
      } // Poll until the receipt is good...


      return new Promise((resolve, reject) => {
        const cancelFuncs = [];
        let done = false;

        const alreadyDone = function () {
          if (done) {
            return true;
          }

          done = true;
          cancelFuncs.forEach(func => {
            func();
          });
          return false;
        };

        const minedHandler = receipt => {
          if (receipt.confirmations < confirmations) {
            return;
          }

          if (alreadyDone()) {
            return;
          }

          resolve(receipt);
        };

        this.on(transactionHash, minedHandler);
        cancelFuncs.push(() => {
          this.removeListener(transactionHash, minedHandler);
        });

        if (replaceable) {
          let lastBlockNumber = replaceable.startBlock;
          let scannedBlock = null;

          const replaceHandler = blockNumber => __awaiter(this, void 0, void 0, function* () {
            if (done) {
              return;
            } // Wait 1 second; this is only used in the case of a fault, so
            // we will trade off a little bit of latency for more consistent
            // results and fewer JSON-RPC calls


            yield stall(1000);
            this.getTransactionCount(replaceable.from).then(nonce => __awaiter(this, void 0, void 0, function* () {
              if (done) {
                return;
              }

              if (nonce <= replaceable.nonce) {
                lastBlockNumber = blockNumber;
              } else {
                // First check if the transaction was mined
                {
                  const mined = yield this.getTransaction(transactionHash);

                  if (mined && mined.blockNumber != null) {
                    return;
                  }
                } // First time scanning. We start a little earlier for some
                // wiggle room here to handle the eventually consistent nature
                // of blockchain (e.g. the getTransactionCount was for a
                // different block)

                if (scannedBlock == null) {
                  scannedBlock = lastBlockNumber - 3;

                  if (scannedBlock < replaceable.startBlock) {
                    scannedBlock = replaceable.startBlock;
                  }
                }

                while (scannedBlock <= blockNumber) {
                  if (done) {
                    return;
                  }

                  const block = yield this.getBlockWithTransactions(scannedBlock);

                  for (let ti = 0; ti < block.transactions.length; ti++) {
                    const tx = block.transactions[ti]; // Successfully mined!

                    if (tx.hash === transactionHash) {
                      return;
                    } // Matches our transaction from and nonce; its a replacement


                    if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                      if (done) {
                        return;
                      } // Get the receipt of the replacement


                      const receipt = yield this.waitForTransaction(tx.hash, confirmations); // Already resolved or rejected (prolly a timeout)

                      if (alreadyDone()) {
                        return;
                      } // The reason we were replaced


                      let reason = "replaced";

                      if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                        reason = "repriced";
                      } else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                        reason = "cancelled";
                      } // Explain why we were replaced


                      reject(logger.makeError("transaction was replaced", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.TRANSACTION_REPLACED, {
                        cancelled: reason === "replaced" || reason === "cancelled",
                        reason,
                        replacement: this._wrapTransaction(tx),
                        hash: transactionHash,
                        receipt
                      }));
                      return;
                    }
                  }

                  scannedBlock++;
                }
              }

              if (done) {
                return;
              }

              this.once("block", replaceHandler);
            }), error => {
              if (done) {
                return;
              }

              this.once("block", replaceHandler);
            });
          });

          if (done) {
            return;
          }

          this.once("block", replaceHandler);
          cancelFuncs.push(() => {
            this.removeListener("block", replaceHandler);
          });
        }

        if (typeof timeout === "number" && timeout > 0) {
          const timer = setTimeout(() => {
            if (alreadyDone()) {
              return;
            }

            reject(logger.makeError("timeout exceeded", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.TIMEOUT, {
              timeout: timeout
            }));
          }, timeout);

          if (timer.unref) {
            timer.unref();
          }

          cancelFuncs.push(() => {
            clearTimeout(timer);
          });
        }
      });
    });
  }

  getBlockNumber() {
    return __awaiter(this, void 0, void 0, function* () {
      return this._getInternalBlockNumber(0);
    });
  }

  getGasPrice() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const result = yield this.perform("getGasPrice", {});

      try {
        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result);
      } catch (error) {
        return logger.throwError("bad result from backend", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {
          method: "getGasPrice",
          result,
          error
        });
      }
    });
  }

  getBalance(addressOrName, blockTag) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getBalance", params);

      try {
        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result);
      } catch (error) {
        return logger.throwError("bad result from backend", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {
          method: "getBalance",
          params,
          result,
          error
        });
      }
    });
  }

  getTransactionCount(addressOrName, blockTag) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getTransactionCount", params);

      try {
        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result).toNumber();
      } catch (error) {
        return logger.throwError("bad result from backend", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {
          method: "getTransactionCount",
          params,
          result,
          error
        });
      }
    });
  }

  getCode(addressOrName, blockTag) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag)
      });
      const result = yield this.perform("getCode", params);

      try {
        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(result);
      } catch (error) {
        return logger.throwError("bad result from backend", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {
          method: "getCode",
          params,
          result,
          error
        });
      }
    });
  }

  getStorageAt(addressOrName, position, blockTag) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({
        address: this._getAddress(addressOrName),
        blockTag: this._getBlockTag(blockTag),
        position: Promise.resolve(position).then(p => (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexValue)(p))
      });
      const result = yield this.perform("getStorageAt", params);

      try {
        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(result);
      } catch (error) {
        return logger.throwError("bad result from backend", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {
          method: "getStorageAt",
          params,
          result,
          error
        });
      }
    });
  } // This should be called by any subclass wrapping a TransactionResponse


  _wrapTransaction(tx, hash, startBlock) {
    if (hash != null && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(hash) !== 32) {
      throw new Error("invalid response - sendTransaction");
    }

    const result = tx; // Check the hash we expect is the same as the hash the server reported

    if (hash != null && tx.hash !== hash) {
      logger.throwError("Transaction hash mismatch from Provider.sendTransaction.", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNKNOWN_ERROR, {
        expectedHash: tx.hash,
        returnedHash: hash
      });
    }

    result.wait = (confirms, timeout) => __awaiter(this, void 0, void 0, function* () {
      if (confirms == null) {
        confirms = 1;
      }

      if (timeout == null) {
        timeout = 0;
      } // Get the details to detect replacement


      let replacement = undefined;

      if (confirms !== 0 && startBlock != null) {
        replacement = {
          data: tx.data,
          from: tx.from,
          nonce: tx.nonce,
          to: tx.to,
          value: tx.value,
          startBlock
        };
      }

      const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);

      if (receipt == null && confirms === 0) {
        return null;
      } // No longer pending, allow the polling loop to garbage collect this


      this._emitted["t:" + tx.hash] = receipt.blockNumber;

      if (receipt.status === 0) {
        logger.throwError("transaction failed", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {
          transactionHash: tx.hash,
          transaction: tx,
          receipt: receipt
        });
      }

      return receipt;
    });

    return result;
  }

  sendTransaction(signedTransaction) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const hexTx = yield Promise.resolve(signedTransaction).then(t => (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(t));
      const tx = this.formatter.transaction(signedTransaction);

      if (tx.confirmations == null) {
        tx.confirmations = 0;
      }

      const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);

      try {
        const hash = yield this.perform("sendTransaction", {
          signedTransaction: hexTx
        });
        return this._wrapTransaction(tx, hash, blockNumber);
      } catch (error) {
        error.transaction = tx;
        error.transactionHash = tx.hash;
        throw error;
      }
    });
  }

  _getTransactionRequest(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
      const values = yield transaction;
      const tx = {};
      ["from", "to"].forEach(key => {
        if (values[key] == null) {
          return;
        }

        tx[key] = Promise.resolve(values[key]).then(v => v ? this._getAddress(v) : null);
      });
      ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach(key => {
        if (values[key] == null) {
          return;
        }

        tx[key] = Promise.resolve(values[key]).then(v => v ? _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(v) : null);
      });
      ["type"].forEach(key => {
        if (values[key] == null) {
          return;
        }

        tx[key] = Promise.resolve(values[key]).then(v => v != null ? v : null);
      });

      if (values.accessList) {
        tx.accessList = this.formatter.accessList(values.accessList);
      }

      ["data"].forEach(key => {
        if (values[key] == null) {
          return;
        }

        tx[key] = Promise.resolve(values[key]).then(v => v ? (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(v) : null);
      });
      return this.formatter.transactionRequest(yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)(tx));
    });
  }

  _getFilter(filter) {
    return __awaiter(this, void 0, void 0, function* () {
      filter = yield filter;
      const result = {};

      if (filter.address != null) {
        result.address = this._getAddress(filter.address);
      }

      ["blockHash", "topics"].forEach(key => {
        if (filter[key] == null) {
          return;
        }

        result[key] = filter[key];
      });
      ["fromBlock", "toBlock"].forEach(key => {
        if (filter[key] == null) {
          return;
        }

        result[key] = this._getBlockTag(filter[key]);
      });
      return this.formatter.filter(yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)(result));
    });
  }

  _call(transaction, blockTag, attempt) {
    return __awaiter(this, void 0, void 0, function* () {
      if (attempt >= MAX_CCIP_REDIRECTS) {
        logger.throwError("CCIP read exceeded maximum redirections", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {
          redirects: attempt,
          transaction
        });
      }

      const txSender = transaction.to;
      const result = yield this.perform("call", {
        transaction,
        blockTag
      }); // CCIP Read request via OffchainLookup(address,string[],bytes,bytes4,bytes)

      if (attempt >= 0 && blockTag === "latest" && txSender != null && result.substring(0, 10) === "0x556f1830" && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataLength)(result) % 32 === 4) {
        try {
          const data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(result, 4); // Check the sender of the OffchainLookup matches the transaction

          const sender = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 0, 32);

          if (!_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(sender).eq(txSender)) {
            logger.throwError("CCIP Read sender did not match", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          } // Read the URLs from the response


          const urls = [];
          const urlsOffset = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 32, 64)).toNumber();
          const urlsLength = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, urlsOffset, urlsOffset + 32)).toNumber();
          const urlsData = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, urlsOffset + 32);

          for (let u = 0; u < urlsLength; u++) {
            const url = _parseString(urlsData, u * 32);

            if (url == null) {
              logger.throwError("CCIP Read contained corrupt URL string", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {
                name: "OffchainLookup",
                signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
                transaction,
                data: result
              });
            }

            urls.push(url);
          } // Get the CCIP calldata to forward


          const calldata = _parseBytes(data, 64); // Get the callbackSelector (bytes4)


          if (!_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 100, 128)).isZero()) {
            logger.throwError("CCIP Read callback selector included junk", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }

          const callbackSelector = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexDataSlice)(data, 96, 100); // Get the extra data to send back to the contract as context

          const extraData = _parseBytes(data, 128);

          const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);

          if (ccipResult == null) {
            logger.throwError("CCIP Read disabled or provided no URLs", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION, {
              name: "OffchainLookup",
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              transaction,
              data: result
            });
          }

          const tx = {
            to: txSender,
            data: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexConcat)([callbackSelector, encodeBytes([ccipResult, extraData])])
          };
          return this._call(tx, blockTag, attempt + 1);
        } catch (error) {
          if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR) {
            throw error;
          }
        }
      }

      try {
        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.hexlify)(result);
      } catch (error) {
        return logger.throwError("bad result from backend", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {
          method: "call",
          params: {
            transaction,
            blockTag
          },
          result,
          error
        });
      }
    });
  }

  call(transaction, blockTag) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const resolved = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({
        transaction: this._getTransactionRequest(transaction),
        blockTag: this._getBlockTag(blockTag),
        ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)
      });
      return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);
    });
  }

  estimateGas(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({
        transaction: this._getTransactionRequest(transaction)
      });
      const result = yield this.perform("estimateGas", params);

      try {
        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber.from(result);
      } catch (error) {
        return logger.throwError("bad result from backend", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.SERVER_ERROR, {
          method: "estimateGas",
          params,
          result,
          error
        });
      }
    });
  }

  _getAddress(addressOrName) {
    return __awaiter(this, void 0, void 0, function* () {
      addressOrName = yield addressOrName;

      if (typeof addressOrName !== "string") {
        logger.throwArgumentError("invalid address or ENS name", "name", addressOrName);
      }

      const address = yield this.resolveName(addressOrName);

      if (address == null) {
        logger.throwError("ENS name not configured", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: `resolveName(${JSON.stringify(addressOrName)})`
        });
      }

      return address;
    });
  }

  _getBlock(blockHashOrBlockTag, includeTransactions) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.getNetwork();
      blockHashOrBlockTag = yield blockHashOrBlockTag; // If blockTag is a number (not "latest", etc), this is the block number

      let blockNumber = -128;
      const params = {
        includeTransactions: !!includeTransactions
      };

      if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(blockHashOrBlockTag, 32)) {
        params.blockHash = blockHashOrBlockTag;
      } else {
        try {
          params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);

          if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(params.blockTag)) {
            blockNumber = parseInt(params.blockTag.substring(2), 16);
          }
        } catch (error) {
          logger.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
        }
      }

      return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(() => __awaiter(this, void 0, void 0, function* () {
        const block = yield this.perform("getBlock", params); // Block was not found

        if (block == null) {
          // For blockhashes, if we didn't say it existed, that blockhash may
          // not exist. If we did see it though, perhaps from a log, we know
          // it exists, and this node is just not caught up yet.
          if (params.blockHash != null) {
            if (this._emitted["b:" + params.blockHash] == null) {
              return null;
            }
          } // For block tags, if we are asking for a future block, we return null


          if (params.blockTag != null) {
            if (blockNumber > this._emitted.block) {
              return null;
            }
          } // Retry on the next block


          return undefined;
        } // Add transactions


        if (includeTransactions) {
          let blockNumber = null;

          for (let i = 0; i < block.transactions.length; i++) {
            const tx = block.transactions[i];

            if (tx.blockNumber == null) {
              tx.confirmations = 0;
            } else if (tx.confirmations == null) {
              if (blockNumber == null) {
                blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
              } // Add the confirmations using the fast block number (pessimistic)


              let confirmations = blockNumber - tx.blockNumber + 1;

              if (confirmations <= 0) {
                confirmations = 1;
              }

              tx.confirmations = confirmations;
            }
          }

          const blockWithTxs = this.formatter.blockWithTransactions(block);
          blockWithTxs.transactions = blockWithTxs.transactions.map(tx => this._wrapTransaction(tx));
          return blockWithTxs;
        }

        return this.formatter.block(block);
      }), {
        oncePoll: this
      });
    });
  }

  getBlock(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, false);
  }

  getBlockWithTransactions(blockHashOrBlockTag) {
    return this._getBlock(blockHashOrBlockTag, true);
  }

  getTransaction(transactionHash) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = {
        transactionHash: this.formatter.hash(transactionHash, true)
      };
      return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(() => __awaiter(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransaction", params);

        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }

          return undefined;
        }

        const tx = this.formatter.transactionResponse(result);

        if (tx.blockNumber == null) {
          tx.confirmations = 0;
        } else if (tx.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval); // Add the confirmations using the fast block number (pessimistic)

          let confirmations = blockNumber - tx.blockNumber + 1;

          if (confirmations <= 0) {
            confirmations = 1;
          }

          tx.confirmations = confirmations;
        }

        return this._wrapTransaction(tx);
      }), {
        oncePoll: this
      });
    });
  }

  getTransactionReceipt(transactionHash) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.getNetwork();
      transactionHash = yield transactionHash;
      const params = {
        transactionHash: this.formatter.hash(transactionHash, true)
      };
      return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_12__.poll)(() => __awaiter(this, void 0, void 0, function* () {
        const result = yield this.perform("getTransactionReceipt", params);

        if (result == null) {
          if (this._emitted["t:" + transactionHash] == null) {
            return null;
          }

          return undefined;
        } // "geth-etc" returns receipts before they are ready


        if (result.blockHash == null) {
          return undefined;
        }

        const receipt = this.formatter.receipt(result);

        if (receipt.blockNumber == null) {
          receipt.confirmations = 0;
        } else if (receipt.confirmations == null) {
          const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval); // Add the confirmations using the fast block number (pessimistic)

          let confirmations = blockNumber - receipt.blockNumber + 1;

          if (confirmations <= 0) {
            confirmations = 1;
          }

          receipt.confirmations = confirmations;
        }

        return receipt;
      }), {
        oncePoll: this
      });
    });
  }

  getLogs(filter) {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.getNetwork();
      const params = yield (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)({
        filter: this._getFilter(filter)
      });
      const logs = yield this.perform("getLogs", params);
      logs.forEach(log => {
        if (log.removed == null) {
          log.removed = false;
        }
      });
      return _formatter__WEBPACK_IMPORTED_MODULE_13__.Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
    });
  }

  getEtherPrice() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.getNetwork();
      return this.perform("getEtherPrice", {});
    });
  }

  _getBlockTag(blockTag) {
    return __awaiter(this, void 0, void 0, function* () {
      blockTag = yield blockTag;

      if (typeof blockTag === "number" && blockTag < 0) {
        if (blockTag % 1) {
          logger.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
        }

        let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
        blockNumber += blockTag;

        if (blockNumber < 0) {
          blockNumber = 0;
        }

        return this.formatter.blockTag(blockNumber);
      }

      return this.formatter.blockTag(blockTag);
    });
  }

  getResolver(name) {
    return __awaiter(this, void 0, void 0, function* () {
      let currentName = name;

      while (true) {
        if (currentName === "" || currentName === ".") {
          return null;
        } // Optimization since the eth node cannot change and does
        // not have a wildcard resolver


        if (name !== "eth" && currentName === "eth") {
          return null;
        } // Check the current node for a resolver


        const addr = yield this._getResolver(currentName, "getResolver"); // Found a resolver!

        if (addr != null) {
          const resolver = new Resolver(this, addr, name); // Legacy resolver found, using EIP-2544 so it isn't safe to use

          if (currentName !== name && !(yield resolver.supportsWildcard())) {
            return null;
          }

          return resolver;
        } // Get the parent node


        currentName = currentName.split(".").slice(1).join(".");
      }
    });
  }

  _getResolver(name, operation) {
    return __awaiter(this, void 0, void 0, function* () {
      if (operation == null) {
        operation = "ENS";
      }

      const network = yield this.getNetwork(); // No ENS...

      if (!network.ensAddress) {
        logger.throwError("network does not support ENS", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {
          operation,
          network: network.name
        });
      }

      try {
        // keccak256("resolver(bytes32)")
        const addrData = yield this.call({
          to: network.ensAddress,
          data: "0x0178b8bf" + (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(name).substring(2)
        });
        return this.formatter.callAddress(addrData);
      } catch (error) {// ENS registry cannot throw errors on resolver(bytes32)
      }

      return null;
    });
  }

  resolveName(name) {
    return __awaiter(this, void 0, void 0, function* () {
      name = yield name; // If it is already an address, nothing to resolve

      try {
        return Promise.resolve(this.formatter.address(name));
      } catch (error) {
        // If is is a hexstring, the address is bad (See #694)
        if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(name)) {
          throw error;
        }
      }

      if (typeof name !== "string") {
        logger.throwArgumentError("invalid ENS name", "name", name);
      } // Get the addr from the resolver


      const resolver = yield this.getResolver(name);

      if (!resolver) {
        return null;
      }

      return yield resolver.getAddress();
    });
  }

  lookupAddress(address) {
    return __awaiter(this, void 0, void 0, function* () {
      address = yield address;
      address = this.formatter.address(address);
      const node = address.substring(2).toLowerCase() + ".addr.reverse";
      const resolverAddr = yield this._getResolver(node, "lookupAddress");

      if (resolverAddr == null) {
        return null;
      } // keccak("name(bytes32)")


      const name = _parseString(yield this.call({
        to: resolverAddr,
        data: "0x691f3431" + (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(node).substring(2)
      }), 0);

      const addr = yield this.resolveName(name);

      if (addr != address) {
        return null;
      }

      return name;
    });
  }

  getAvatar(nameOrAddress) {
    return __awaiter(this, void 0, void 0, function* () {
      let resolver = null;

      if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.isHexString)(nameOrAddress)) {
        // Address; reverse lookup
        const address = this.formatter.address(nameOrAddress);
        const node = address.substring(2).toLowerCase() + ".addr.reverse";
        const resolverAddress = yield this._getResolver(node, "getAvatar");

        if (!resolverAddress) {
          return null;
        } // Try resolving the avatar against the addr.reverse resolver


        resolver = new Resolver(this, resolverAddress, node);

        try {
          const avatar = yield resolver.getAvatar();

          if (avatar) {
            return avatar.url;
          }
        } catch (error) {
          if (error.code !== _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {
            throw error;
          }
        } // Try getting the name and performing forward lookup; allowing wildcards


        try {
          // keccak("name(bytes32)")
          const name = _parseString(yield this.call({
            to: resolverAddress,
            data: "0x691f3431" + (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_10__.namehash)(node).substring(2)
          }), 0);

          resolver = yield this.getResolver(name);
        } catch (error) {
          if (error.code !== _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.CALL_EXCEPTION) {
            throw error;
          }

          return null;
        }
      } else {
        // ENS name; forward lookup with wildcard
        resolver = yield this.getResolver(nameOrAddress);

        if (!resolver) {
          return null;
        }
      }

      const avatar = yield resolver.getAvatar();

      if (avatar == null) {
        return null;
      }

      return avatar.url;
    });
  }

  perform(method, params) {
    return logger.throwError(method + " not implemented", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.NOT_IMPLEMENTED, {
      operation: method
    });
  }

  _startEvent(event) {
    this.polling = this._events.filter(e => e.pollable()).length > 0;
  }

  _stopEvent(event) {
    this.polling = this._events.filter(e => e.pollable()).length > 0;
  }

  _addEventListener(eventName, listener, once) {
    const event = new Event(getEventTag(eventName), listener, once);

    this._events.push(event);

    this._startEvent(event);

    return this;
  }

  on(eventName, listener) {
    return this._addEventListener(eventName, listener, false);
  }

  once(eventName, listener) {
    return this._addEventListener(eventName, listener, true);
  }

  emit(eventName, ...args) {
    let result = false;
    let stopped = [];
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter(event => {
      if (event.tag !== eventTag) {
        return true;
      }

      setTimeout(() => {
        event.listener.apply(this, args);
      }, 0);
      result = true;

      if (event.once) {
        stopped.push(event);
        return false;
      }

      return true;
    });
    stopped.forEach(event => {
      this._stopEvent(event);
    });
    return result;
  }

  listenerCount(eventName) {
    if (!eventName) {
      return this._events.length;
    }

    let eventTag = getEventTag(eventName);
    return this._events.filter(event => {
      return event.tag === eventTag;
    }).length;
  }

  listeners(eventName) {
    if (eventName == null) {
      return this._events.map(event => event.listener);
    }

    let eventTag = getEventTag(eventName);
    return this._events.filter(event => event.tag === eventTag).map(event => event.listener);
  }

  off(eventName, listener) {
    if (listener == null) {
      return this.removeAllListeners(eventName);
    }

    const stopped = [];
    let found = false;
    let eventTag = getEventTag(eventName);
    this._events = this._events.filter(event => {
      if (event.tag !== eventTag || event.listener != listener) {
        return true;
      }

      if (found) {
        return true;
      }

      found = true;
      stopped.push(event);
      return false;
    });
    stopped.forEach(event => {
      this._stopEvent(event);
    });
    return this;
  }

  removeAllListeners(eventName) {
    let stopped = [];

    if (eventName == null) {
      stopped = this._events;
      this._events = [];
    } else {
      const eventTag = getEventTag(eventName);
      this._events = this._events.filter(event => {
        if (event.tag !== eventTag) {
          return true;
        }

        stopped.push(event);
        return false;
      });
    }

    stopped.forEach(event => {
      this._stopEvent(event);
    });
    return this;
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CloudflareProvider": () => (/* binding */ CloudflareProvider)
/* harmony export */ });
/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./url-json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");


var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};




const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
class CloudflareProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey != null) {
      logger.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
    }

    return null;
  }

  static getUrl(network, apiKey) {
    let host = null;

    switch (network.name) {
      case "homestead":
        host = "https://cloudflare-eth.com/";
        break;

      default:
        logger.throwArgumentError("unsupported network", "network", arguments[0]);
    }

    return host;
  }

  perform(method, params) {
    const _super = Object.create(null, {
      perform: {
        get: () => super.perform
      }
    });

    return __awaiter(this, void 0, void 0, function* () {
      // The Cloudflare provider does not support eth_blockNumber,
      // so we get the latest block and pull it from that
      if (method === "getBlockNumber") {
        const block = yield _super.perform.call(this, "getBlock", {
          blockTag: "latest"
        });
        return block.number;
      }

      return _super.perform.call(this, method, params);
    });
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EtherscanProvider": () => (/* binding */ EtherscanProvider)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/transactions */ "./node_modules/@ethersproject/transactions/lib.esm/index.js");
/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/web */ "./node_modules/@ethersproject/web/lib.esm/index.js");
/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./formatter */ "./node_modules/@ethersproject/providers/lib.esm/formatter.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");
/* harmony import */ var _base_provider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./base-provider */ "./node_modules/@ethersproject/providers/lib.esm/base-provider.js");


var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};








const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
 // The transaction has already been sanitized by the calls in Provider

function getTransactionPostData(transaction) {
  const result = {};

  for (let key in transaction) {
    if (transaction[key] == null) {
      continue;
    }

    let value = transaction[key];

    if (key === "type" && value === 0) {
      continue;
    } // Quantity-types require no leading zero, unless 0


    if ({
      type: true,
      gasLimit: true,
      gasPrice: true,
      maxFeePerGs: true,
      maxPriorityFeePerGas: true,
      nonce: true,
      value: true
    }[key]) {
      value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexValue)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(value));
    } else if (key === "accessList") {
      value = "[" + (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__.accessListify)(value).map(set => {
        return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
      }).join(",") + "]";
    } else {
      value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(value);
    }

    result[key] = value;
  }

  return result;
}

function getResult(result) {
  // getLogs, getHistory have weird success responses
  if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
    return result.result;
  }

  if (result.status != 1 || result.message != "OK") {
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);

    if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
      error.throttleRetry = true;
    }

    throw error;
  }

  return result.result;
}

function getJsonResult(result) {
  // This response indicates we are being throttled
  if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
    const error = new Error("throttled response");
    error.result = JSON.stringify(result);
    error.throttleRetry = true;
    throw error;
  }

  if (result.jsonrpc != "2.0") {
    // @TODO: not any
    const error = new Error("invalid response");
    error.result = JSON.stringify(result);
    throw error;
  }

  if (result.error) {
    // @TODO: not any
    const error = new Error(result.error.message || "unknown error");

    if (result.error.code) {
      error.code = result.error.code;
    }

    if (result.error.data) {
      error.data = result.error.data;
    }

    throw error;
  }

  return result.result;
} // The blockTag was normalized as a string by the Provider pre-perform operations


function checkLogTag(blockTag) {
  if (blockTag === "pending") {
    throw new Error("pending not supported");
  }

  if (blockTag === "latest") {
    return blockTag;
  }

  return parseInt(blockTag.substring(2), 16);
}

const defaultApiKey = "9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB";

function checkError(method, error, transaction) {
  // Undo the "convenience" some nodes are attempting to prevent backwards
  // incompatibility; maybe for v6 consider forwarding reverts as errors
  if (method === "call" && error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR) {
    const e = error.error; // Etherscan keeps changing their string

    if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {
      // Etherscan prefixes the data like "Reverted 0x1234"
      let data = e.data;

      if (data) {
        data = "0x" + data.replace(/^.*0x/i, "");
      }

      if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isHexString)(data)) {
        return data;
      }

      logger.throwError("missing revert data in call exception", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.CALL_EXCEPTION, {
        error,
        data: "0x"
      });
    }
  } // Get the message from any nested error structure


  let message = error.message;

  if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR) {
    if (error.error && typeof error.error.message === "string") {
      message = error.error.message;
    } else if (typeof error.body === "string") {
      message = error.body;
    } else if (typeof error.responseText === "string") {
      message = error.responseText;
    }
  }

  message = (message || "").toLowerCase(); // "Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0"

  if (message.match(/insufficient funds/)) {
    logger.throwError("insufficient funds for intrinsic transaction cost", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  } // "Transaction with the same hash was already imported."


  if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
    logger.throwError("nonce has already been used", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  } // "Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce."


  if (message.match(/another transaction with same nonce/)) {
    logger.throwError("replacement fee too low", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  }

  if (message.match(/execution failed due to an exception|execution reverted/)) {
    logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }

  throw error;
}

class EtherscanProvider extends _base_provider__WEBPACK_IMPORTED_MODULE_4__.BaseProvider {
  constructor(network, apiKey) {
    logger.checkNew(new.target, EtherscanProvider);
    super(network);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, "baseUrl", this.getBaseUrl());
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, "apiKey", apiKey || defaultApiKey);
  }

  getBaseUrl() {
    switch (this.network ? this.network.name : "invalid") {
      case "homestead":
        return "https:/\/api.etherscan.io";

      case "ropsten":
        return "https:/\/api-ropsten.etherscan.io";

      case "rinkeby":
        return "https:/\/api-rinkeby.etherscan.io";

      case "kovan":
        return "https:/\/api-kovan.etherscan.io";

      case "goerli":
        return "https:/\/api-goerli.etherscan.io";

      default:
    }

    return logger.throwArgumentError("unsupported network", "network", name);
  }

  getUrl(module, params) {
    const query = Object.keys(params).reduce((accum, key) => {
      const value = params[key];

      if (value != null) {
        accum += `&${key}=${value}`;
      }

      return accum;
    }, "");
    const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
    return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;
  }

  getPostUrl() {
    return `${this.baseUrl}/api`;
  }

  getPostData(module, params) {
    params.module = module;
    params.apikey = this.apiKey;
    return params;
  }

  fetch(module, params, post) {
    return __awaiter(this, void 0, void 0, function* () {
      const url = post ? this.getPostUrl() : this.getUrl(module, params);
      const payload = post ? this.getPostData(module, params) : null;
      const procFunc = module === "proxy" ? getJsonResult : getResult;
      this.emit("debug", {
        action: "request",
        request: url,
        provider: this
      });
      const connection = {
        url: url,
        throttleSlotInterval: 1000,
        throttleCallback: (attempt, url) => {
          if (this.isCommunityResource()) {
            (0,_formatter__WEBPACK_IMPORTED_MODULE_6__.showThrottleMessage)();
          }

          return Promise.resolve(true);
        }
      };
      let payloadStr = null;

      if (payload) {
        connection.headers = {
          "content-type": "application/x-www-form-urlencoded; charset=UTF-8"
        };
        payloadStr = Object.keys(payload).map(key => {
          return `${key}=${payload[key]}`;
        }).join("&");
      }

      const result = yield (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_7__.fetchJson)(connection, payloadStr, procFunc || getJsonResult);
      this.emit("debug", {
        action: "response",
        request: url,
        response: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.deepCopy)(result),
        provider: this
      });
      return result;
    });
  }

  detectNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      return this.network;
    });
  }

  perform(method, params) {
    const _super = Object.create(null, {
      perform: {
        get: () => super.perform
      }
    });

    return __awaiter(this, void 0, void 0, function* () {
      switch (method) {
        case "getBlockNumber":
          return this.fetch("proxy", {
            action: "eth_blockNumber"
          });

        case "getGasPrice":
          return this.fetch("proxy", {
            action: "eth_gasPrice"
          });

        case "getBalance":
          // Returns base-10 result
          return this.fetch("account", {
            action: "balance",
            address: params.address,
            tag: params.blockTag
          });

        case "getTransactionCount":
          return this.fetch("proxy", {
            action: "eth_getTransactionCount",
            address: params.address,
            tag: params.blockTag
          });

        case "getCode":
          return this.fetch("proxy", {
            action: "eth_getCode",
            address: params.address,
            tag: params.blockTag
          });

        case "getStorageAt":
          return this.fetch("proxy", {
            action: "eth_getStorageAt",
            address: params.address,
            position: params.position,
            tag: params.blockTag
          });

        case "sendTransaction":
          return this.fetch("proxy", {
            action: "eth_sendRawTransaction",
            hex: params.signedTransaction
          }, true).catch(error => {
            return checkError("sendTransaction", error, params.signedTransaction);
          });

        case "getBlock":
          if (params.blockTag) {
            return this.fetch("proxy", {
              action: "eth_getBlockByNumber",
              tag: params.blockTag,
              boolean: params.includeTransactions ? "true" : "false"
            });
          }

          throw new Error("getBlock by blockHash not implemented");

        case "getTransaction":
          return this.fetch("proxy", {
            action: "eth_getTransactionByHash",
            txhash: params.transactionHash
          });

        case "getTransactionReceipt":
          return this.fetch("proxy", {
            action: "eth_getTransactionReceipt",
            txhash: params.transactionHash
          });

        case "call":
          {
            if (params.blockTag !== "latest") {
              throw new Error("EtherscanProvider does not support blockTag for call");
            }

            const postData = getTransactionPostData(params.transaction);
            postData.module = "proxy";
            postData.action = "eth_call";

            try {
              return yield this.fetch("proxy", postData, true);
            } catch (error) {
              return checkError("call", error, params.transaction);
            }
          }

        case "estimateGas":
          {
            const postData = getTransactionPostData(params.transaction);
            postData.module = "proxy";
            postData.action = "eth_estimateGas";

            try {
              return yield this.fetch("proxy", postData, true);
            } catch (error) {
              return checkError("estimateGas", error, params.transaction);
            }
          }

        case "getLogs":
          {
            const args = {
              action: "getLogs"
            };

            if (params.filter.fromBlock) {
              args.fromBlock = checkLogTag(params.filter.fromBlock);
            }

            if (params.filter.toBlock) {
              args.toBlock = checkLogTag(params.filter.toBlock);
            }

            if (params.filter.address) {
              args.address = params.filter.address;
            } // @TODO: We can handle slightly more complicated logs using the logs API


            if (params.filter.topics && params.filter.topics.length > 0) {
              if (params.filter.topics.length > 1) {
                logger.throwError("unsupported topic count", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
                  topics: params.filter.topics
                });
              }

              if (params.filter.topics.length === 1) {
                const topic0 = params.filter.topics[0];

                if (typeof topic0 !== "string" || topic0.length !== 66) {
                  logger.throwError("unsupported topic format", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
                    topic0: topic0
                  });
                }

                args.topic0 = topic0;
              }
            }

            const logs = yield this.fetch("logs", args); // Cache txHash => blockHash

            let blocks = {}; // Add any missing blockHash to the logs

            for (let i = 0; i < logs.length; i++) {
              const log = logs[i];

              if (log.blockHash != null) {
                continue;
              }

              if (blocks[log.blockNumber] == null) {
                const block = yield this.getBlock(log.blockNumber);

                if (block) {
                  blocks[log.blockNumber] = block.hash;
                }
              }

              log.blockHash = blocks[log.blockNumber];
            }

            return logs;
          }

        case "getEtherPrice":
          if (this.network.name !== "homestead") {
            return 0.0;
          }

          return parseFloat((yield this.fetch("stats", {
            action: "ethprice"
          })).ethusd);

        default:
          break;
      }

      return _super.perform.call(this, method, params);
    });
  } // Note: The `page` page parameter only allows pagination within the
  //       10,000 window available without a page and offset parameter
  //       Error: Result window is too large, PageNo x Offset size must
  //              be less than or equal to 10000


  getHistory(addressOrName, startBlock, endBlock) {
    return __awaiter(this, void 0, void 0, function* () {
      const params = {
        action: "txlist",
        address: yield this.resolveName(addressOrName),
        startblock: startBlock == null ? 0 : startBlock,
        endblock: endBlock == null ? 99999999 : endBlock,
        sort: "asc"
      };
      const result = yield this.fetch("account", params);
      return result.map(tx => {
        ["contractAddress", "to"].forEach(function (key) {
          if (tx[key] == "") {
            delete tx[key];
          }
        });

        if (tx.creates == null && tx.contractAddress != null) {
          tx.creates = tx.contractAddress;
        }

        const item = this.formatter.transactionResponse(tx);

        if (tx.timeStamp) {
          item.timestamp = parseInt(tx.timeStamp);
        }

        return item;
      });
    });
  }

  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/fallback-provider.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/fallback-provider.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FallbackProvider": () => (/* binding */ FallbackProvider)
/* harmony export */ });
/* harmony import */ var _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/abstract-provider */ "./node_modules/@ethersproject/abstract-provider/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_random__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/random */ "./node_modules/@ethersproject/random/lib.esm/shuffle.js");
/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/web */ "./node_modules/@ethersproject/web/lib.esm/index.js");
/* harmony import */ var _base_provider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./base-provider */ "./node_modules/@ethersproject/providers/lib.esm/base-provider.js");
/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./formatter */ "./node_modules/@ethersproject/providers/lib.esm/formatter.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");


var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};











const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);

function now() {
  return new Date().getTime();
} // Returns to network as long as all agree, or null if any is null.
// Throws an error if any two networks do not match.


function checkNetworks(networks) {
  let result = null;

  for (let i = 0; i < networks.length; i++) {
    const network = networks[i]; // Null! We do not know our network; bail.

    if (network == null) {
      return null;
    }

    if (result) {
      // Make sure the network matches the previous networks
      if (!(result.name === network.name && result.chainId === network.chainId && (result.ensAddress === network.ensAddress || result.ensAddress == null && network.ensAddress == null))) {
        logger.throwArgumentError("provider mismatch", "networks", networks);
      }
    } else {
      result = network;
    }
  }

  return result;
}

function median(values, maxDelta) {
  values = values.slice().sort();
  const middle = Math.floor(values.length / 2); // Odd length; take the middle

  if (values.length % 2) {
    return values[middle];
  } // Even length; take the average of the two middle


  const a = values[middle - 1],
        b = values[middle];

  if (maxDelta != null && Math.abs(a - b) > maxDelta) {
    return null;
  }

  return (a + b) / 2;
}

function serialize(value) {
  if (value === null) {
    return "null";
  } else if (typeof value === "number" || typeof value === "boolean") {
    return JSON.stringify(value);
  } else if (typeof value === "string") {
    return value;
  } else if (_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.BigNumber.isBigNumber(value)) {
    return value.toString();
  } else if (Array.isArray(value)) {
    return JSON.stringify(value.map(i => serialize(i)));
  } else if (typeof value === "object") {
    const keys = Object.keys(value);
    keys.sort();
    return "{" + keys.map(key => {
      let v = value[key];

      if (typeof v === "function") {
        v = "[function]";
      } else {
        v = serialize(v);
      }

      return JSON.stringify(key) + ":" + v;
    }).join(",") + "}";
  }

  throw new Error("unknown value type: " + typeof value);
} // Next request ID to use for emitting debug info


let nextRid = 1;
;

function stall(duration) {
  let cancel = null;
  let timer = null;
  let promise = new Promise(resolve => {
    cancel = function () {
      if (timer) {
        clearTimeout(timer);
        timer = null;
      }

      resolve();
    };

    timer = setTimeout(cancel, duration);
  });

  const wait = func => {
    promise = promise.then(func);
    return promise;
  };

  function getPromise() {
    return promise;
  }

  return {
    cancel,
    getPromise,
    wait
  };
}

const ForwardErrors = [_ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.CALL_EXCEPTION, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INSUFFICIENT_FUNDS, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NONCE_EXPIRED, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.REPLACEMENT_UNDERPRICED, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNPREDICTABLE_GAS_LIMIT];
const ForwardProperties = ["address", "args", "errorArgs", "errorSignature", "method", "transaction"];
;

function exposeDebugConfig(config, now) {
  const result = {
    weight: config.weight
  };
  Object.defineProperty(result, "provider", {
    get: () => config.provider
  });

  if (config.start) {
    result.start = config.start;
  }

  if (now) {
    result.duration = now - config.start;
  }

  if (config.done) {
    if (config.error) {
      result.error = config.error;
    } else {
      result.result = config.result || null;
    }
  }

  return result;
}

function normalizedTally(normalize, quorum) {
  return function (configs) {
    // Count the votes for each result
    const tally = {};
    configs.forEach(c => {
      const value = normalize(c.result);

      if (!tally[value]) {
        tally[value] = {
          count: 0,
          result: c.result
        };
      }

      tally[value].count++;
    }); // Check for a quorum on any given result

    const keys = Object.keys(tally);

    for (let i = 0; i < keys.length; i++) {
      const check = tally[keys[i]];

      if (check.count >= quorum) {
        return check.result;
      }
    } // No quroum


    return undefined;
  };
}

function getProcessFunc(provider, method, params) {
  let normalize = serialize;

  switch (method) {
    case "getBlockNumber":
      // Return the median value, unless there is (median + 1) is also
      // present, in which case that is probably true and the median
      // is going to be stale soon. In the event of a malicious node,
      // the lie will be true soon enough.
      return function (configs) {
        const values = configs.map(c => c.result); // Get the median block number

        let blockNumber = median(configs.map(c => c.result), 2);

        if (blockNumber == null) {
          return undefined;
        }

        blockNumber = Math.ceil(blockNumber); // If the next block height is present, its prolly safe to use

        if (values.indexOf(blockNumber + 1) >= 0) {
          blockNumber++;
        } // Don't ever roll back the blockNumber


        if (blockNumber >= provider._highestBlockNumber) {
          provider._highestBlockNumber = blockNumber;
        }

        return provider._highestBlockNumber;
      };

    case "getGasPrice":
      // Return the middle (round index up) value, similar to median
      // but do not average even entries and choose the higher.
      // Malicious actors must compromise 50% of the nodes to lie.
      return function (configs) {
        const values = configs.map(c => c.result);
        values.sort();
        return values[Math.floor(values.length / 2)];
      };

    case "getEtherPrice":
      // Returns the median price. Malicious actors must compromise at
      // least 50% of the nodes to lie (in a meaningful way).
      return function (configs) {
        return median(configs.map(c => c.result));
      };
    // No additional normalizing required; serialize is enough

    case "getBalance":
    case "getTransactionCount":
    case "getCode":
    case "getStorageAt":
    case "call":
    case "estimateGas":
    case "getLogs":
      break;
    // We drop the confirmations from transactions as it is approximate

    case "getTransaction":
    case "getTransactionReceipt":
      normalize = function (tx) {
        if (tx == null) {
          return null;
        }

        tx = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(tx);
        tx.confirmations = -1;
        return serialize(tx);
      };

      break;
    // We drop the confirmations from transactions as it is approximate

    case "getBlock":
      // We drop the confirmations from transactions as it is approximate
      if (params.includeTransactions) {
        normalize = function (block) {
          if (block == null) {
            return null;
          }

          block = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(block);
          block.transactions = block.transactions.map(tx => {
            tx = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(tx);
            tx.confirmations = -1;
            return tx;
          });
          return serialize(block);
        };
      } else {
        normalize = function (block) {
          if (block == null) {
            return null;
          }

          return serialize(block);
        };
      }

      break;

    default:
      throw new Error("unknown method: " + method);
  } // Return the result if and only if the expected quorum is
  // satisfied and agreed upon for the final result.


  return normalizedTally(normalize, provider.quorum);
} // If we are doing a blockTag query, we need to make sure the backend is
// caught up to the FallbackProvider, before sending a request to it.


function waitForSync(config, blockNumber) {
  return __awaiter(this, void 0, void 0, function* () {
    const provider = config.provider;

    if (provider.blockNumber != null && provider.blockNumber >= blockNumber || blockNumber === -1) {
      return provider;
    }

    return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_4__.poll)(() => {
      return new Promise((resolve, reject) => {
        setTimeout(function () {
          // We are synced
          if (provider.blockNumber >= blockNumber) {
            return resolve(provider);
          } // We're done; just quit


          if (config.cancelled) {
            return resolve(null);
          } // Try again, next block


          return resolve(undefined);
        }, 0);
      });
    }, {
      oncePoll: provider
    });
  });
}

function getRunner(config, currentBlockNumber, method, params) {
  return __awaiter(this, void 0, void 0, function* () {
    let provider = config.provider;

    switch (method) {
      case "getBlockNumber":
      case "getGasPrice":
        return provider[method]();

      case "getEtherPrice":
        if (provider.getEtherPrice) {
          return provider.getEtherPrice();
        }

        break;

      case "getBalance":
      case "getTransactionCount":
      case "getCode":
        if (params.blockTag && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }

        return provider[method](params.address, params.blockTag || "latest");

      case "getStorageAt":
        if (params.blockTag && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }

        return provider.getStorageAt(params.address, params.position, params.blockTag || "latest");

      case "getBlock":
        if (params.blockTag && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }

        return provider[params.includeTransactions ? "getBlockWithTransactions" : "getBlock"](params.blockTag || params.blockHash);

      case "call":
      case "estimateGas":
        if (params.blockTag && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(params.blockTag)) {
          provider = yield waitForSync(config, currentBlockNumber);
        }

        return provider[method](params.transaction);

      case "getTransaction":
      case "getTransactionReceipt":
        return provider[method](params.transactionHash);

      case "getLogs":
        {
          let filter = params.filter;

          if (filter.fromBlock && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(filter.fromBlock) || filter.toBlock && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(filter.toBlock)) {
            provider = yield waitForSync(config, currentBlockNumber);
          }

          return provider.getLogs(filter);
        }
    }

    return logger.throwError("unknown method error", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNKNOWN_ERROR, {
      method: method,
      params: params
    });
  });
}

class FallbackProvider extends _base_provider__WEBPACK_IMPORTED_MODULE_6__.BaseProvider {
  constructor(providers, quorum) {
    logger.checkNew(new.target, FallbackProvider);

    if (providers.length === 0) {
      logger.throwArgumentError("missing providers", "providers", providers);
    }

    const providerConfigs = providers.map((configOrProvider, index) => {
      if (_ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_7__.Provider.isProvider(configOrProvider)) {
        const stallTimeout = (0,_formatter__WEBPACK_IMPORTED_MODULE_8__.isCommunityResource)(configOrProvider) ? 2000 : 750;
        const priority = 1;
        return Object.freeze({
          provider: configOrProvider,
          weight: 1,
          stallTimeout,
          priority
        });
      }

      const config = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy)(configOrProvider);

      if (config.priority == null) {
        config.priority = 1;
      }

      if (config.stallTimeout == null) {
        config.stallTimeout = (0,_formatter__WEBPACK_IMPORTED_MODULE_8__.isCommunityResource)(configOrProvider) ? 2000 : 750;
      }

      if (config.weight == null) {
        config.weight = 1;
      }

      const weight = config.weight;

      if (weight % 1 || weight > 512 || weight < 1) {
        logger.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index}].weight`, weight);
      }

      return Object.freeze(config);
    });
    const total = providerConfigs.reduce((accum, c) => accum + c.weight, 0);

    if (quorum == null) {
      quorum = total / 2;
    } else if (quorum > total) {
      logger.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
    } // Are all providers' networks are known


    let networkOrReady = checkNetworks(providerConfigs.map(c => c.provider.network)); // Not all networks are known; we must stall

    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then(resolve, reject);
        }, 0);
      });
    }

    super(networkOrReady); // Preserve a copy, so we do not get mutated

    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "providerConfigs", Object.freeze(providerConfigs));
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "quorum", quorum);
    this._highestBlockNumber = -1;
  }

  detectNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      const networks = yield Promise.all(this.providerConfigs.map(c => c.provider.getNetwork()));
      return checkNetworks(networks);
    });
  }

  perform(method, params) {
    return __awaiter(this, void 0, void 0, function* () {
      // Sending transactions is special; always broadcast it to all backends
      if (method === "sendTransaction") {
        const results = yield Promise.all(this.providerConfigs.map(c => {
          return c.provider.sendTransaction(params.signedTransaction).then(result => {
            return result.hash;
          }, error => {
            return error;
          });
        })); // Any success is good enough (other errors are likely "already seen" errors

        for (let i = 0; i < results.length; i++) {
          const result = results[i];

          if (typeof result === "string") {
            return result;
          }
        } // They were all an error; pick the first error


        throw results[0];
      } // We need to make sure we are in sync with our backends, so we need
      // to know this before we can make a lot of calls


      if (this._highestBlockNumber === -1 && method !== "getBlockNumber") {
        yield this.getBlockNumber();
      }

      const processFunc = getProcessFunc(this, method, params); // Shuffle the providers and then sort them by their priority; we
      // shallowCopy them since we will store the result in them too

      const configs = (0,_ethersproject_random__WEBPACK_IMPORTED_MODULE_9__.shuffled)(this.providerConfigs.map(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.shallowCopy));
      configs.sort((a, b) => a.priority - b.priority);
      const currentBlockNumber = this._highestBlockNumber;
      let i = 0;
      let first = true;

      while (true) {
        const t0 = now(); // Compute the inflight weight (exclude anything past)

        let inflightWeight = configs.filter(c => c.runner && t0 - c.start < c.stallTimeout).reduce((accum, c) => accum + c.weight, 0); // Start running enough to meet quorum

        while (inflightWeight < this.quorum && i < configs.length) {
          const config = configs[i++];
          const rid = nextRid++;
          config.start = now();
          config.staller = stall(config.stallTimeout);
          config.staller.wait(() => {
            config.staller = null;
          });
          config.runner = getRunner(config, currentBlockNumber, method, params).then(result => {
            config.done = true;
            config.result = result;

            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid: rid,
                backend: exposeDebugConfig(config, now()),
                request: {
                  method: method,
                  params: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.deepCopy)(params)
                },
                provider: this
              });
            }
          }, error => {
            config.done = true;
            config.error = error;

            if (this.listenerCount("debug")) {
              this.emit("debug", {
                action: "request",
                rid: rid,
                backend: exposeDebugConfig(config, now()),
                request: {
                  method: method,
                  params: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.deepCopy)(params)
                },
                provider: this
              });
            }
          });

          if (this.listenerCount("debug")) {
            this.emit("debug", {
              action: "request",
              rid: rid,
              backend: exposeDebugConfig(config, null),
              request: {
                method: method,
                params: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.deepCopy)(params)
              },
              provider: this
            });
          }

          inflightWeight += config.weight;
        } // Wait for anything meaningful to finish or stall out


        const waiting = [];
        configs.forEach(c => {
          if (c.done || !c.runner) {
            return;
          }

          waiting.push(c.runner);

          if (c.staller) {
            waiting.push(c.staller.getPromise());
          }
        });

        if (waiting.length) {
          yield Promise.race(waiting);
        } // Check the quorum and process the results; the process function
        // may additionally decide the quorum is not met


        const results = configs.filter(c => c.done && c.error == null);

        if (results.length >= this.quorum) {
          const result = processFunc(results);

          if (result !== undefined) {
            // Shut down any stallers
            configs.forEach(c => {
              if (c.staller) {
                c.staller.cancel();
              }

              c.cancelled = true;
            });
            return result;
          }

          if (!first) {
            yield stall(100).getPromise();
          }

          first = false;
        } // No result, check for errors that should be forwarded


        const errors = configs.reduce((accum, c) => {
          if (!c.done || c.error == null) {
            return accum;
          }

          const code = c.error.code;

          if (ForwardErrors.indexOf(code) >= 0) {
            if (!accum[code]) {
              accum[code] = {
                error: c.error,
                weight: 0
              };
            }

            accum[code].weight += c.weight;
          }

          return accum;
        }, {});
        Object.keys(errors).forEach(errorCode => {
          const tally = errors[errorCode];

          if (tally.weight < this.quorum) {
            return;
          } // Shut down any stallers


          configs.forEach(c => {
            if (c.staller) {
              c.staller.cancel();
            }

            c.cancelled = true;
          });
          const e = tally.error;
          const props = {};
          ForwardProperties.forEach(name => {
            if (e[name] == null) {
              return;
            }

            props[name] = e[name];
          });
          logger.throwError(e.reason || e.message, errorCode, props);
        }); // All configs have run to completion; we will never get more data

        if (configs.filter(c => !c.done).length === 0) {
          break;
        }
      } // Shut down any stallers; shouldn't be any


      configs.forEach(c => {
        if (c.staller) {
          c.staller.cancel();
        }

        c.cancelled = true;
      });
      return logger.throwError("failed to meet quorum", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {
        method: method,
        params: params,
        //results: configs.map((c) => c.result),
        //errors: configs.map((c) => c.error),
        results: configs.map(c => exposeDebugConfig(c)),
        provider: this
      });
    });
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/formatter.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/formatter.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Formatter": () => (/* binding */ Formatter),
/* harmony export */   "isCommunityResourcable": () => (/* binding */ isCommunityResourcable),
/* harmony export */   "isCommunityResource": () => (/* binding */ isCommunityResource),
/* harmony export */   "showThrottleMessage": () => (/* binding */ showThrottleMessage)
/* harmony export */ });
/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/address */ "./node_modules/@ethersproject/address/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/constants */ "./node_modules/@ethersproject/constants/lib.esm/addresses.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/transactions */ "./node_modules/@ethersproject/transactions/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");










const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
class Formatter {
  constructor() {
    logger.checkNew(new.target, Formatter);
    this.formats = this.getDefaultFormats();
  }

  getDefaultFormats() {
    const formats = {};
    const address = this.address.bind(this);
    const bigNumber = this.bigNumber.bind(this);
    const blockTag = this.blockTag.bind(this);
    const data = this.data.bind(this);
    const hash = this.hash.bind(this);
    const hex = this.hex.bind(this);
    const number = this.number.bind(this);
    const type = this.type.bind(this);

    const strictData = v => {
      return this.data(v, true);
    };

    formats.transaction = {
      hash: hash,
      type: type,
      accessList: Formatter.allowNull(this.accessList.bind(this), null),
      blockHash: Formatter.allowNull(hash, null),
      blockNumber: Formatter.allowNull(number, null),
      transactionIndex: Formatter.allowNull(number, null),
      confirmations: Formatter.allowNull(number, null),
      from: address,
      // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
      // must be set
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      gasLimit: bigNumber,
      to: Formatter.allowNull(address, null),
      value: bigNumber,
      nonce: number,
      data: data,
      r: Formatter.allowNull(this.uint256),
      s: Formatter.allowNull(this.uint256),
      v: Formatter.allowNull(number),
      creates: Formatter.allowNull(address, null),
      raw: Formatter.allowNull(data)
    };
    formats.transactionRequest = {
      from: Formatter.allowNull(address),
      nonce: Formatter.allowNull(number),
      gasLimit: Formatter.allowNull(bigNumber),
      gasPrice: Formatter.allowNull(bigNumber),
      maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
      maxFeePerGas: Formatter.allowNull(bigNumber),
      to: Formatter.allowNull(address),
      value: Formatter.allowNull(bigNumber),
      data: Formatter.allowNull(strictData),
      type: Formatter.allowNull(number),
      accessList: Formatter.allowNull(this.accessList.bind(this), null)
    };
    formats.receiptLog = {
      transactionIndex: number,
      blockNumber: number,
      transactionHash: hash,
      address: address,
      topics: Formatter.arrayOf(hash),
      data: data,
      logIndex: number,
      blockHash: hash
    };
    formats.receipt = {
      to: Formatter.allowNull(this.address, null),
      from: Formatter.allowNull(this.address, null),
      contractAddress: Formatter.allowNull(address, null),
      transactionIndex: number,
      // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
      root: Formatter.allowNull(hex),
      gasUsed: bigNumber,
      logsBloom: Formatter.allowNull(data),
      blockHash: hash,
      transactionHash: hash,
      logs: Formatter.arrayOf(this.receiptLog.bind(this)),
      blockNumber: number,
      confirmations: Formatter.allowNull(number, null),
      cumulativeGasUsed: bigNumber,
      effectiveGasPrice: Formatter.allowNull(bigNumber),
      status: Formatter.allowNull(number),
      type: type
    };
    formats.block = {
      hash: Formatter.allowNull(hash),
      parentHash: hash,
      number: number,
      timestamp: number,
      nonce: Formatter.allowNull(hex),
      difficulty: this.difficulty.bind(this),
      gasLimit: bigNumber,
      gasUsed: bigNumber,
      miner: Formatter.allowNull(address),
      extraData: data,
      transactions: Formatter.allowNull(Formatter.arrayOf(hash)),
      baseFeePerGas: Formatter.allowNull(bigNumber)
    };
    formats.blockWithTransactions = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.shallowCopy)(formats.block);
    formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
    formats.filter = {
      fromBlock: Formatter.allowNull(blockTag, undefined),
      toBlock: Formatter.allowNull(blockTag, undefined),
      blockHash: Formatter.allowNull(hash, undefined),
      address: Formatter.allowNull(address, undefined),
      topics: Formatter.allowNull(this.topics.bind(this), undefined)
    };
    formats.filterLog = {
      blockNumber: Formatter.allowNull(number),
      blockHash: Formatter.allowNull(hash),
      transactionIndex: number,
      removed: Formatter.allowNull(this.boolean.bind(this)),
      address: address,
      data: Formatter.allowFalsish(data, "0x"),
      topics: Formatter.arrayOf(hash),
      transactionHash: hash,
      logIndex: number
    };
    return formats;
  }

  accessList(accessList) {
    return (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__.accessListify)(accessList || []);
  } // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
  // Strict! Used on input.


  number(number) {
    if (number === "0x") {
      return 0;
    }

    return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(number).toNumber();
  }

  type(number) {
    if (number === "0x" || number == null) {
      return 0;
    }

    return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(number).toNumber();
  } // Strict! Used on input.


  bigNumber(value) {
    return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value);
  } // Requires a boolean, "true" or  "false"; returns a boolean


  boolean(value) {
    if (typeof value === "boolean") {
      return value;
    }

    if (typeof value === "string") {
      value = value.toLowerCase();

      if (value === "true") {
        return true;
      }

      if (value === "false") {
        return false;
      }
    }

    throw new Error("invalid boolean - " + value);
  }

  hex(value, strict) {
    if (typeof value === "string") {
      if (!strict && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
      }

      if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(value)) {
        return value.toLowerCase();
      }
    }

    return logger.throwArgumentError("invalid hash", "value", value);
  }

  data(value, strict) {
    const result = this.hex(value, strict);

    if (result.length % 2 !== 0) {
      throw new Error("invalid data; odd-length - " + value);
    }

    return result;
  } // Requires an address
  // Strict! Used on input.


  address(value) {
    return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_6__.getAddress)(value);
  }

  callAddress(value) {
    if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(value, 32)) {
      return null;
    }

    const address = (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_6__.getAddress)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexDataSlice)(value, 12));
    return address === _ethersproject_constants__WEBPACK_IMPORTED_MODULE_7__.AddressZero ? null : address;
  }

  contractAddress(value) {
    return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_6__.getContractAddress)(value);
  } // Strict! Used on input.


  blockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }

    if (blockTag === "earliest") {
      return "0x0";
    }

    if (blockTag === "latest" || blockTag === "pending") {
      return blockTag;
    }

    if (typeof blockTag === "number" || (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(blockTag)) {
      return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexValue)(blockTag);
    }

    throw new Error("invalid blockTag");
  } // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.


  hash(value, strict) {
    const result = this.hex(value, strict);

    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexDataLength)(result) !== 32) {
      return logger.throwArgumentError("invalid hash", "value", value);
    }

    return result;
  } // Returns the difficulty as a number, or if too large (i.e. PoA network) null


  difficulty(value) {
    if (value == null) {
      return null;
    }

    const v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value);

    try {
      return v.toNumber();
    } catch (error) {}

    return null;
  }

  uint256(value) {
    if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(value)) {
      throw new Error("invalid uint256");
    }

    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.hexZeroPad)(value, 32);
  }

  _block(value, format) {
    if (value.author != null && value.miner == null) {
      value.miner = value.author;
    } // The difficulty may need to come from _difficulty in recursed blocks


    const difficulty = value._difficulty != null ? value._difficulty : value.difficulty;
    const result = Formatter.check(format, value);
    result._difficulty = difficulty == null ? null : _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(difficulty);
    return result;
  }

  block(value) {
    return this._block(value, this.formats.block);
  }

  blockWithTransactions(value) {
    return this._block(value, this.formats.blockWithTransactions);
  } // Strict! Used on input.


  transactionRequest(value) {
    return Formatter.check(this.formats.transactionRequest, value);
  }

  transactionResponse(transaction) {
    // Rename gas to gasLimit
    if (transaction.gas != null && transaction.gasLimit == null) {
      transaction.gasLimit = transaction.gas;
    } // Some clients (TestRPC) do strange things like return 0x0 for the
    // 0 address; correct this to be a real address


    if (transaction.to && _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction.to).isZero()) {
      transaction.to = "0x0000000000000000000000000000000000000000";
    } // Rename input to data


    if (transaction.input != null && transaction.data == null) {
      transaction.data = transaction.input;
    } // If to and creates are empty, populate the creates from the transaction


    if (transaction.to == null && transaction.creates == null) {
      transaction.creates = this.contractAddress(transaction);
    }

    if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
      transaction.accessList = [];
    }

    const result = Formatter.check(this.formats.transaction, transaction);

    if (transaction.chainId != null) {
      let chainId = transaction.chainId;

      if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(chainId)) {
        chainId = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(chainId).toNumber();
      }

      result.chainId = chainId;
    } else {
      let chainId = transaction.networkId; // geth-etc returns chainId

      if (chainId == null && result.v == null) {
        chainId = transaction.chainId;
      }

      if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__.isHexString)(chainId)) {
        chainId = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(chainId).toNumber();
      }

      if (typeof chainId !== "number" && result.v != null) {
        chainId = (result.v - 35) / 2;

        if (chainId < 0) {
          chainId = 0;
        }

        chainId = parseInt(chainId);
      }

      if (typeof chainId !== "number") {
        chainId = 0;
      }

      result.chainId = chainId;
    } // 0x0000... should actually be null


    if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
      result.blockHash = null;
    }

    return result;
  }

  transaction(value) {
    return (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_3__.parse)(value);
  }

  receiptLog(value) {
    return Formatter.check(this.formats.receiptLog, value);
  }

  receipt(value) {
    const result = Formatter.check(this.formats.receipt, value); // RSK incorrectly implemented EIP-658, so we munge things a bit here for it

    if (result.root != null) {
      if (result.root.length <= 4) {
        // Could be 0x00, 0x0, 0x01 or 0x1
        const value = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(result.root).toNumber();

        if (value === 0 || value === 1) {
          // Make sure if both are specified, they match
          if (result.status != null && result.status !== value) {
            logger.throwArgumentError("alt-root-status/status mismatch", "value", {
              root: result.root,
              status: result.status
            });
          }

          result.status = value;
          delete result.root;
        } else {
          logger.throwArgumentError("invalid alt-root-status", "value.root", result.root);
        }
      } else if (result.root.length !== 66) {
        // Must be a valid bytes32
        logger.throwArgumentError("invalid root hash", "value.root", result.root);
      }
    }

    if (result.status != null) {
      result.byzantium = true;
    }

    return result;
  }

  topics(value) {
    if (Array.isArray(value)) {
      return value.map(v => this.topics(v));
    } else if (value != null) {
      return this.hash(value, true);
    }

    return null;
  }

  filter(value) {
    return Formatter.check(this.formats.filter, value);
  }

  filterLog(value) {
    return Formatter.check(this.formats.filterLog, value);
  }

  static check(format, object) {
    const result = {};

    for (const key in format) {
      try {
        const value = format[key](object[key]);

        if (value !== undefined) {
          result[key] = value;
        }
      } catch (error) {
        error.checkKey = key;
        error.checkValue = object[key];
        throw error;
      }
    }

    return result;
  } // if value is null-ish, nullValue is returned


  static allowNull(format, nullValue) {
    return function (value) {
      if (value == null) {
        return nullValue;
      }

      return format(value);
    };
  } // If value is false-ish, replaceValue is returned


  static allowFalsish(format, replaceValue) {
    return function (value) {
      if (!value) {
        return replaceValue;
      }

      return format(value);
    };
  } // Requires an Array satisfying check


  static arrayOf(format) {
    return function (array) {
      if (!Array.isArray(array)) {
        throw new Error("not an array");
      }

      const result = [];
      array.forEach(function (value) {
        result.push(format(value));
      });
      return result;
    };
  }

}
function isCommunityResourcable(value) {
  return value && typeof value.isCommunityResource === "function";
}
function isCommunityResource(value) {
  return isCommunityResourcable(value) && value.isCommunityResource();
} // Show the throttle message only once

let throttleMessage = false;
function showThrottleMessage() {
  if (throttleMessage) {
    return;
  }

  throttleMessage = true;
  console.log("========= NOTICE =========");
  console.log("Request-Rate Exceeded  (this message will not be repeated)");
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https:/\/docs.ethers.io/api-keys/");
  console.log("==========================");
}

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AlchemyProvider": () => (/* reexport safe */ _alchemy_provider__WEBPACK_IMPORTED_MODULE_6__.AlchemyProvider),
/* harmony export */   "AlchemyWebSocketProvider": () => (/* reexport safe */ _alchemy_provider__WEBPACK_IMPORTED_MODULE_6__.AlchemyWebSocketProvider),
/* harmony export */   "AnkrProvider": () => (/* reexport safe */ _ankr_provider__WEBPACK_IMPORTED_MODULE_7__.AnkrProvider),
/* harmony export */   "BaseProvider": () => (/* reexport safe */ _base_provider__WEBPACK_IMPORTED_MODULE_16__.BaseProvider),
/* harmony export */   "CloudflareProvider": () => (/* reexport safe */ _cloudflare_provider__WEBPACK_IMPORTED_MODULE_8__.CloudflareProvider),
/* harmony export */   "EtherscanProvider": () => (/* reexport safe */ _etherscan_provider__WEBPACK_IMPORTED_MODULE_9__.EtherscanProvider),
/* harmony export */   "FallbackProvider": () => (/* reexport safe */ _fallback_provider__WEBPACK_IMPORTED_MODULE_5__.FallbackProvider),
/* harmony export */   "Formatter": () => (/* reexport safe */ _formatter__WEBPACK_IMPORTED_MODULE_19__.Formatter),
/* harmony export */   "InfuraProvider": () => (/* reexport safe */ _infura_provider__WEBPACK_IMPORTED_MODULE_10__.InfuraProvider),
/* harmony export */   "InfuraWebSocketProvider": () => (/* reexport safe */ _infura_provider__WEBPACK_IMPORTED_MODULE_10__.InfuraWebSocketProvider),
/* harmony export */   "IpcProvider": () => (/* reexport safe */ _ipc_provider__WEBPACK_IMPORTED_MODULE_14__.IpcProvider),
/* harmony export */   "JsonRpcBatchProvider": () => (/* reexport safe */ _json_rpc_batch_provider__WEBPACK_IMPORTED_MODULE_18__.JsonRpcBatchProvider),
/* harmony export */   "JsonRpcProvider": () => (/* reexport safe */ _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider),
/* harmony export */   "JsonRpcSigner": () => (/* reexport safe */ _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.JsonRpcSigner),
/* harmony export */   "NodesmithProvider": () => (/* reexport safe */ _nodesmith_provider__WEBPACK_IMPORTED_MODULE_11__.NodesmithProvider),
/* harmony export */   "PocketProvider": () => (/* reexport safe */ _pocket_provider__WEBPACK_IMPORTED_MODULE_12__.PocketProvider),
/* harmony export */   "Provider": () => (/* reexport safe */ _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_15__.Provider),
/* harmony export */   "Resolver": () => (/* reexport safe */ _base_provider__WEBPACK_IMPORTED_MODULE_16__.Resolver),
/* harmony export */   "StaticJsonRpcProvider": () => (/* reexport safe */ _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_17__.StaticJsonRpcProvider),
/* harmony export */   "UrlJsonRpcProvider": () => (/* reexport safe */ _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_17__.UrlJsonRpcProvider),
/* harmony export */   "Web3Provider": () => (/* reexport safe */ _web3_provider__WEBPACK_IMPORTED_MODULE_13__.Web3Provider),
/* harmony export */   "WebSocketProvider": () => (/* reexport safe */ _websocket_provider__WEBPACK_IMPORTED_MODULE_3__.WebSocketProvider),
/* harmony export */   "getDefaultProvider": () => (/* binding */ getDefaultProvider),
/* harmony export */   "getNetwork": () => (/* reexport safe */ _ethersproject_networks__WEBPACK_IMPORTED_MODULE_4__.getNetwork),
/* harmony export */   "isCommunityResourcable": () => (/* reexport safe */ _formatter__WEBPACK_IMPORTED_MODULE_19__.isCommunityResourcable),
/* harmony export */   "isCommunityResource": () => (/* reexport safe */ _formatter__WEBPACK_IMPORTED_MODULE_19__.isCommunityResource),
/* harmony export */   "showThrottleMessage": () => (/* reexport safe */ _formatter__WEBPACK_IMPORTED_MODULE_19__.showThrottleMessage)
/* harmony export */ });
/* harmony import */ var _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @ethersproject/abstract-provider */ "./node_modules/@ethersproject/abstract-provider/lib.esm/index.js");
/* harmony import */ var _ethersproject_networks__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/networks */ "./node_modules/@ethersproject/networks/lib.esm/index.js");
/* harmony import */ var _base_provider__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./base-provider */ "./node_modules/@ethersproject/providers/lib.esm/base-provider.js");
/* harmony import */ var _alchemy_provider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./alchemy-provider */ "./node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js");
/* harmony import */ var _ankr_provider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ankr-provider */ "./node_modules/@ethersproject/providers/lib.esm/ankr-provider.js");
/* harmony import */ var _cloudflare_provider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./cloudflare-provider */ "./node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js");
/* harmony import */ var _etherscan_provider__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./etherscan-provider */ "./node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js");
/* harmony import */ var _fallback_provider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./fallback-provider */ "./node_modules/@ethersproject/providers/lib.esm/fallback-provider.js");
/* harmony import */ var _ipc_provider__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./ipc-provider */ "./node_modules/@ethersproject/providers/lib.esm/ipc-provider.js");
/* harmony import */ var _infura_provider__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./infura-provider */ "./node_modules/@ethersproject/providers/lib.esm/infura-provider.js");
/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js");
/* harmony import */ var _json_rpc_batch_provider__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./json-rpc-batch-provider */ "./node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js");
/* harmony import */ var _nodesmith_provider__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./nodesmith-provider */ "./node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js");
/* harmony import */ var _pocket_provider__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./pocket-provider */ "./node_modules/@ethersproject/providers/lib.esm/pocket-provider.js");
/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./url-json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js");
/* harmony import */ var _web3_provider__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./web3-provider */ "./node_modules/@ethersproject/providers/lib.esm/web3-provider.js");
/* harmony import */ var _websocket_provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./websocket-provider */ "./node_modules/@ethersproject/providers/lib.esm/websocket-provider.js");
/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./formatter */ "./node_modules/@ethersproject/providers/lib.esm/formatter.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");






















const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version); ////////////////////////
// Helper Functions

function getDefaultProvider(network, options) {
  if (network == null) {
    network = "homestead";
  } // If passed a URL, figure out the right type of provider based on the scheme


  if (typeof network === "string") {
    // @TODO: Add support for IpcProvider; maybe if it ends in ".ipc"?
    // Handle http and ws (and their secure variants)
    const match = network.match(/^(ws|http)s?:/i);

    if (match) {
      switch (match[1]) {
        case "http":
          return new _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider(network);

        case "ws":
          return new _websocket_provider__WEBPACK_IMPORTED_MODULE_3__.WebSocketProvider(network);

        default:
          logger.throwArgumentError("unsupported URL scheme", "network", network);
      }
    }
  }

  const n = (0,_ethersproject_networks__WEBPACK_IMPORTED_MODULE_4__.getNetwork)(network);

  if (!n || !n._defaultProvider) {
    logger.throwError("unsupported getDefaultProvider network", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NETWORK_ERROR, {
      operation: "getDefaultProvider",
      network: network
    });
  }

  return n._defaultProvider({
    FallbackProvider: _fallback_provider__WEBPACK_IMPORTED_MODULE_5__.FallbackProvider,
    AlchemyProvider: _alchemy_provider__WEBPACK_IMPORTED_MODULE_6__.AlchemyProvider,
    AnkrProvider: _ankr_provider__WEBPACK_IMPORTED_MODULE_7__.AnkrProvider,
    CloudflareProvider: _cloudflare_provider__WEBPACK_IMPORTED_MODULE_8__.CloudflareProvider,
    EtherscanProvider: _etherscan_provider__WEBPACK_IMPORTED_MODULE_9__.EtherscanProvider,
    InfuraProvider: _infura_provider__WEBPACK_IMPORTED_MODULE_10__.InfuraProvider,
    JsonRpcProvider: _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider,
    NodesmithProvider: _nodesmith_provider__WEBPACK_IMPORTED_MODULE_11__.NodesmithProvider,
    PocketProvider: _pocket_provider__WEBPACK_IMPORTED_MODULE_12__.PocketProvider,
    Web3Provider: _web3_provider__WEBPACK_IMPORTED_MODULE_13__.Web3Provider,
    IpcProvider: _ipc_provider__WEBPACK_IMPORTED_MODULE_14__.IpcProvider
  }, options);
} ////////////////////////
// Exports




/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/infura-provider.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/infura-provider.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "InfuraProvider": () => (/* binding */ InfuraProvider),
/* harmony export */   "InfuraWebSocketProvider": () => (/* binding */ InfuraWebSocketProvider)
/* harmony export */ });
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _websocket_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./websocket-provider */ "./node_modules/@ethersproject/providers/lib.esm/websocket-provider.js");
/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./formatter */ "./node_modules/@ethersproject/providers/lib.esm/formatter.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");
/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./url-json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js");







const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);

const defaultProjectId = "84842078b09946638c03157f83405213";
class InfuraWebSocketProvider extends _websocket_provider__WEBPACK_IMPORTED_MODULE_2__.WebSocketProvider {
  constructor(network, apiKey) {
    const provider = new InfuraProvider(network, apiKey);
    const connection = provider.connection;

    if (connection.password) {
      logger.throwError("INFURA WebSocket project secrets unsupported", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "InfuraProvider.getWebSocketProvider()"
      });
    }

    const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url, network);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "apiKey", provider.projectId);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "projectId", provider.projectId);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "projectSecret", provider.projectSecret);
  }

  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }

}
class InfuraProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_4__.UrlJsonRpcProvider {
  static getWebSocketProvider(network, apiKey) {
    return new InfuraWebSocketProvider(network, apiKey);
  }

  static getApiKey(apiKey) {
    const apiKeyObj = {
      apiKey: defaultProjectId,
      projectId: defaultProjectId,
      projectSecret: null
    };

    if (apiKey == null) {
      return apiKeyObj;
    }

    if (typeof apiKey === "string") {
      apiKeyObj.projectId = apiKey;
    } else if (apiKey.projectSecret != null) {
      logger.assertArgument(typeof apiKey.projectId === "string", "projectSecret requires a projectId", "projectId", apiKey.projectId);
      logger.assertArgument(typeof apiKey.projectSecret === "string", "invalid projectSecret", "projectSecret", "[REDACTED]");
      apiKeyObj.projectId = apiKey.projectId;
      apiKeyObj.projectSecret = apiKey.projectSecret;
    } else if (apiKey.projectId) {
      apiKeyObj.projectId = apiKey.projectId;
    }

    apiKeyObj.apiKey = apiKeyObj.projectId;
    return apiKeyObj;
  }

  static getUrl(network, apiKey) {
    let host = null;

    switch (network ? network.name : "unknown") {
      case "homestead":
        host = "mainnet.infura.io";
        break;

      case "ropsten":
        host = "ropsten.infura.io";
        break;

      case "rinkeby":
        host = "rinkeby.infura.io";
        break;

      case "kovan":
        host = "kovan.infura.io";
        break;

      case "goerli":
        host = "goerli.infura.io";
        break;

      case "matic":
        host = "polygon-mainnet.infura.io";
        break;

      case "maticmum":
        host = "polygon-mumbai.infura.io";
        break;

      case "optimism":
        host = "optimism-mainnet.infura.io";
        break;

      case "optimism-kovan":
        host = "optimism-kovan.infura.io";
        break;

      case "arbitrum":
        host = "arbitrum-mainnet.infura.io";
        break;

      case "arbitrum-rinkeby":
        host = "arbitrum-rinkeby.infura.io";
        break;

      default:
        logger.throwError("unsupported network", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }

    const connection = {
      allowGzip: true,
      url: "https:/" + "/" + host + "/v3/" + apiKey.projectId,
      throttleCallback: (attempt, url) => {
        if (apiKey.projectId === defaultProjectId) {
          (0,_formatter__WEBPACK_IMPORTED_MODULE_5__.showThrottleMessage)();
        }

        return Promise.resolve(true);
      }
    };

    if (apiKey.projectSecret != null) {
      connection.user = "";
      connection.password = apiKey.projectSecret;
    }

    return connection;
  }

  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/ipc-provider.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/ipc-provider.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "IpcProvider": () => (/* binding */ IpcProvider)
/* harmony export */ });


const IpcProvider = null;


/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "JsonRpcBatchProvider": () => (/* binding */ JsonRpcBatchProvider)
/* harmony export */ });
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/web */ "./node_modules/@ethersproject/web/lib.esm/index.js");
/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js");


 // Experimental

class JsonRpcBatchProvider extends _json_rpc_provider__WEBPACK_IMPORTED_MODULE_0__.JsonRpcProvider {
  send(method, params) {
    const request = {
      method: method,
      params: params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };

    if (this._pendingBatch == null) {
      this._pendingBatch = [];
    }

    const inflightRequest = {
      request,
      resolve: null,
      reject: null
    };
    const promise = new Promise((resolve, reject) => {
      inflightRequest.resolve = resolve;
      inflightRequest.reject = reject;
    });

    this._pendingBatch.push(inflightRequest);

    if (!this._pendingBatchAggregator) {
      // Schedule batch for next event loop + short duration
      this._pendingBatchAggregator = setTimeout(() => {
        // Get teh current batch and clear it, so new requests
        // go into the next batch
        const batch = this._pendingBatch;
        this._pendingBatch = null;
        this._pendingBatchAggregator = null; // Get the request as an array of requests

        const request = batch.map(inflight => inflight.request);
        this.emit("debug", {
          action: "requestBatch",
          request: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__.deepCopy)(request),
          provider: this
        });
        return (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_2__.fetchJson)(this.connection, JSON.stringify(request)).then(result => {
          this.emit("debug", {
            action: "response",
            request: request,
            response: result,
            provider: this
          }); // For each result, feed it to the correct Promise, depending
          // on whether it was a success or error

          batch.forEach((inflightRequest, index) => {
            const payload = result[index];

            if (payload.error) {
              const error = new Error(payload.error.message);
              error.code = payload.error.code;
              error.data = payload.error.data;
              inflightRequest.reject(error);
            } else {
              inflightRequest.resolve(payload.result);
            }
          });
        }, error => {
          this.emit("debug", {
            action: "response",
            error: error,
            request: request,
            provider: this
          });
          batch.forEach(inflightRequest => {
            inflightRequest.reject(error);
          });
        });
      }, 10);
    }

    return promise;
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "JsonRpcProvider": () => (/* binding */ JsonRpcProvider),
/* harmony export */   "JsonRpcSigner": () => (/* binding */ JsonRpcSigner)
/* harmony export */ });
/* harmony import */ var _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/abstract-signer */ "./node_modules/@ethersproject/abstract-signer/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/hash */ "./node_modules/@ethersproject/hash/lib.esm/typed-data.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/utf8.js");
/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/transactions */ "./node_modules/@ethersproject/transactions/lib.esm/index.js");
/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/web */ "./node_modules/@ethersproject/web/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");
/* harmony import */ var _base_provider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./base-provider */ "./node_modules/@ethersproject/providers/lib.esm/base-provider.js");


var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};











const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);

const errorGas = ["call", "estimateGas"];

function spelunk(value) {
  if (value == null) {
    return null;
  } // These *are* the droids we're looking for.


  if (typeof value.message === "string" && value.message.match("reverted") && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isHexString)(value.data)) {
    return {
      message: value.message,
      data: value.data
    };
  } // Spelunk further...


  if (typeof value === "object") {
    for (const key in value) {
      const result = spelunk(value[key]);

      if (result) {
        return result;
      }
    }

    return null;
  } // Might be a JSON string we can further descend...


  if (typeof value === "string") {
    try {
      return spelunk(JSON.parse(value));
    } catch (error) {}
  }

  return null;
}

function checkError(method, error, params) {
  // Undo the "convenience" some nodes are attempting to prevent backwards
  // incompatibility; maybe for v6 consider forwarding reverts as errors
  if (method === "call") {
    const result = spelunk(error);

    if (result) {
      return result.data;
    }

    logger.throwError("missing revert data in call exception; Transaction reverted without a reason string", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.CALL_EXCEPTION, {
      error,
      data: "0x"
    });
  } // @TODO: Should we spelunk for message too?


  let message = error.message;

  if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR && error.error && typeof error.error.message === "string") {
    message = error.error.message;
  } else if (typeof error.body === "string") {
    message = error.body;
  } else if (typeof error.responseText === "string") {
    message = error.responseText;
  }

  message = (message || "").toLowerCase();
  const transaction = params.transaction || params.signedTransaction; // "insufficient funds for gas * price + value + cost(data)"

  if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
    logger.throwError("insufficient funds for intrinsic transaction cost", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INSUFFICIENT_FUNDS, {
      error,
      method,
      transaction
    });
  } // "nonce too low"


  if (message.match(/nonce (is )?too low/i)) {
    logger.throwError("nonce has already been used", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NONCE_EXPIRED, {
      error,
      method,
      transaction
    });
  } // "replacement transaction underpriced"


  if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {
    logger.throwError("replacement fee too low", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.REPLACEMENT_UNDERPRICED, {
      error,
      method,
      transaction
    });
  } // "replacement transaction underpriced"


  if (message.match(/only replay-protected/i)) {
    logger.throwError("legacy pre-eip-155 transactions not supported", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
      error,
      method,
      transaction
    });
  }

  if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {
    logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
      error,
      method,
      transaction
    });
  }

  throw error;
}

function timer(timeout) {
  return new Promise(function (resolve) {
    setTimeout(resolve, timeout);
  });
}

function getResult(payload) {
  if (payload.error) {
    // @TODO: not any
    const error = new Error(payload.error.message);
    error.code = payload.error.code;
    error.data = payload.error.data;
    throw error;
  }

  return payload.result;
}

function getLowerCase(value) {
  if (value) {
    return value.toLowerCase();
  }

  return value;
}

const _constructorGuard = {};
class JsonRpcSigner extends _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_3__.Signer {
  constructor(constructorGuard, provider, addressOrIndex) {
    logger.checkNew(new.target, JsonRpcSigner);
    super();

    if (constructorGuard !== _constructorGuard) {
      throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
    }

    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, "provider", provider);

    if (addressOrIndex == null) {
      addressOrIndex = 0;
    }

    if (typeof addressOrIndex === "string") {
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, "_address", this.provider.formatter.address(addressOrIndex));
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, "_index", null);
    } else if (typeof addressOrIndex === "number") {
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, "_index", addressOrIndex);
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, "_address", null);
    } else {
      logger.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
    }
  }

  connect(provider) {
    return logger.throwError("cannot alter JSON-RPC Signer connection", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "connect"
    });
  }

  connectUnchecked() {
    return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);
  }

  getAddress() {
    if (this._address) {
      return Promise.resolve(this._address);
    }

    return this.provider.send("eth_accounts", []).then(accounts => {
      if (accounts.length <= this._index) {
        logger.throwError("unknown account #" + this._index, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "getAddress"
        });
      }

      return this.provider.formatter.address(accounts[this._index]);
    });
  }

  sendUncheckedTransaction(transaction) {
    transaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(transaction);
    const fromAddress = this.getAddress().then(address => {
      if (address) {
        address = address.toLowerCase();
      }

      return address;
    }); // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user
    // wishes to use this, it is easy to specify explicitly, otherwise
    // we look it up for them.

    if (transaction.gasLimit == null) {
      const estimate = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(transaction);
      estimate.from = fromAddress;
      transaction.gasLimit = this.provider.estimateGas(estimate);
    }

    if (transaction.to != null) {
      transaction.to = Promise.resolve(transaction.to).then(to => __awaiter(this, void 0, void 0, function* () {
        if (to == null) {
          return null;
        }

        const address = yield this.provider.resolveName(to);

        if (address == null) {
          logger.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
        }

        return address;
      }));
    }

    return (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.resolveProperties)({
      tx: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.resolveProperties)(transaction),
      sender: fromAddress
    }).then(({
      tx,
      sender
    }) => {
      if (tx.from != null) {
        if (tx.from.toLowerCase() !== sender) {
          logger.throwArgumentError("from address mismatch", "transaction", transaction);
        }
      } else {
        tx.from = sender;
      }

      const hexTx = this.provider.constructor.hexlifyTransaction(tx, {
        from: true
      });
      return this.provider.send("eth_sendTransaction", [hexTx]).then(hash => {
        return hash;
      }, error => {
        return checkError("sendTransaction", error, hexTx);
      });
    });
  }

  signTransaction(transaction) {
    return logger.throwError("signing transactions is unsupported", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "signTransaction"
    });
  }

  sendTransaction(transaction) {
    return __awaiter(this, void 0, void 0, function* () {
      // This cannot be mined any earlier than any recent block
      const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval); // Send the transaction

      const hash = yield this.sendUncheckedTransaction(transaction);

      try {
        // Unfortunately, JSON-RPC only provides and opaque transaction hash
        // for a response, and we need the actual transaction, so we poll
        // for it; it should show up very quickly
        return yield (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_5__.poll)(() => __awaiter(this, void 0, void 0, function* () {
          const tx = yield this.provider.getTransaction(hash);

          if (tx === null) {
            return undefined;
          }

          return this.provider._wrapTransaction(tx, hash, blockNumber);
        }), {
          oncePoll: this.provider
        });
      } catch (error) {
        error.transactionHash = hash;
        throw error;
      }
    });
  }

  signMessage(message) {
    return __awaiter(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_6__.toUtf8Bytes)(message) : message;
      const address = yield this.getAddress();
      return yield this.provider.send("personal_sign", [(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data), address.toLowerCase()]);
    });
  }

  _legacySignMessage(message) {
    return __awaiter(this, void 0, void 0, function* () {
      const data = typeof message === "string" ? (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_6__.toUtf8Bytes)(message) : message;
      const address = yield this.getAddress(); // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign

      return yield this.provider.send("eth_sign", [address.toLowerCase(), (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data)]);
    });
  }

  _signTypedData(domain, types, value) {
    return __awaiter(this, void 0, void 0, function* () {
      // Populate any ENS names (in-place)
      const populated = yield _ethersproject_hash__WEBPACK_IMPORTED_MODULE_7__.TypedDataEncoder.resolveNames(domain, types, value, name => {
        return this.provider.resolveName(name);
      });
      const address = yield this.getAddress();
      return yield this.provider.send("eth_signTypedData_v4", [address.toLowerCase(), JSON.stringify(_ethersproject_hash__WEBPACK_IMPORTED_MODULE_7__.TypedDataEncoder.getPayload(populated.domain, types, populated.value))]);
    });
  }

  unlock(password) {
    return __awaiter(this, void 0, void 0, function* () {
      const provider = this.provider;
      const address = yield this.getAddress();
      return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
    });
  }

}

class UncheckedJsonRpcSigner extends JsonRpcSigner {
  sendTransaction(transaction) {
    return this.sendUncheckedTransaction(transaction).then(hash => {
      return {
        hash: hash,
        nonce: null,
        gasLimit: null,
        gasPrice: null,
        data: null,
        value: null,
        chainId: null,
        confirmations: 0,
        from: null,
        wait: confirmations => {
          return this.provider.waitForTransaction(hash, confirmations);
        }
      };
    });
  }

}

const allowedTransactionKeys = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  value: true,
  type: true,
  accessList: true,
  maxFeePerGas: true,
  maxPriorityFeePerGas: true
};
class JsonRpcProvider extends _base_provider__WEBPACK_IMPORTED_MODULE_8__.BaseProvider {
  constructor(url, network) {
    logger.checkNew(new.target, JsonRpcProvider);
    let networkOrReady = network; // The network is unknown, query the JSON-RPC for it

    if (networkOrReady == null) {
      networkOrReady = new Promise((resolve, reject) => {
        setTimeout(() => {
          this.detectNetwork().then(network => {
            resolve(network);
          }, error => {
            reject(error);
          });
        }, 0);
      });
    }

    super(networkOrReady); // Default URL

    if (!url) {
      url = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, "defaultUrl")();
    }

    if (typeof url === "string") {
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, "connection", Object.freeze({
        url: url
      }));
    } else {
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.defineReadOnly)(this, "connection", Object.freeze((0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(url)));
    }

    this._nextId = 42;
  }

  get _cache() {
    if (this._eventLoopCache == null) {
      this._eventLoopCache = {};
    }

    return this._eventLoopCache;
  }

  static defaultUrl() {
    return "http:/\/localhost:8545";
  }

  detectNetwork() {
    if (!this._cache["detectNetwork"]) {
      this._cache["detectNetwork"] = this._uncachedDetectNetwork(); // Clear this cache at the beginning of the next event loop

      setTimeout(() => {
        this._cache["detectNetwork"] = null;
      }, 0);
    }

    return this._cache["detectNetwork"];
  }

  _uncachedDetectNetwork() {
    return __awaiter(this, void 0, void 0, function* () {
      yield timer(0);
      let chainId = null;

      try {
        chainId = yield this.send("eth_chainId", []);
      } catch (error) {
        try {
          chainId = yield this.send("net_version", []);
        } catch (error) {}
      }

      if (chainId != null) {
        const getNetwork = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, "getNetwork");

        try {
          return getNetwork(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__.BigNumber.from(chainId).toNumber());
        } catch (error) {
          return logger.throwError("could not detect network", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NETWORK_ERROR, {
            chainId: chainId,
            event: "invalidNetwork",
            serverError: error
          });
        }
      }

      return logger.throwError("could not detect network", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NETWORK_ERROR, {
        event: "noNetwork"
      });
    });
  }

  getSigner(addressOrIndex) {
    return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);
  }

  getUncheckedSigner(addressOrIndex) {
    return this.getSigner(addressOrIndex).connectUnchecked();
  }

  listAccounts() {
    return this.send("eth_accounts", []).then(accounts => {
      return accounts.map(a => this.formatter.address(a));
    });
  }

  send(method, params) {
    const request = {
      method: method,
      params: params,
      id: this._nextId++,
      jsonrpc: "2.0"
    };
    this.emit("debug", {
      action: "request",
      request: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.deepCopy)(request),
      provider: this
    }); // We can expand this in the future to any call, but for now these
    // are the biggest wins and do not require any serializing parameters.

    const cache = ["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0;

    if (cache && this._cache[method]) {
      return this._cache[method];
    }

    const result = (0,_ethersproject_web__WEBPACK_IMPORTED_MODULE_5__.fetchJson)(this.connection, JSON.stringify(request), getResult).then(result => {
      this.emit("debug", {
        action: "response",
        request: request,
        response: result,
        provider: this
      });
      return result;
    }, error => {
      this.emit("debug", {
        action: "response",
        error: error,
        request: request,
        provider: this
      });
      throw error;
    }); // Cache the fetch, but clear it on the next event loop

    if (cache) {
      this._cache[method] = result;
      setTimeout(() => {
        this._cache[method] = null;
      }, 0);
    }

    return result;
  }

  prepareRequest(method, params) {
    switch (method) {
      case "getBlockNumber":
        return ["eth_blockNumber", []];

      case "getGasPrice":
        return ["eth_gasPrice", []];

      case "getBalance":
        return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];

      case "getTransactionCount":
        return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];

      case "getCode":
        return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];

      case "getStorageAt":
        return ["eth_getStorageAt", [getLowerCase(params.address), params.position, params.blockTag]];

      case "sendTransaction":
        return ["eth_sendRawTransaction", [params.signedTransaction]];

      case "getBlock":
        if (params.blockTag) {
          return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
        } else if (params.blockHash) {
          return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
        }

        return null;

      case "getTransaction":
        return ["eth_getTransactionByHash", [params.transactionHash]];

      case "getTransactionReceipt":
        return ["eth_getTransactionReceipt", [params.transactionHash]];

      case "call":
        {
          const hexlifyTransaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, "hexlifyTransaction");
          return ["eth_call", [hexlifyTransaction(params.transaction, {
            from: true
          }), params.blockTag]];
        }

      case "estimateGas":
        {
          const hexlifyTransaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.getStatic)(this.constructor, "hexlifyTransaction");
          return ["eth_estimateGas", [hexlifyTransaction(params.transaction, {
            from: true
          })]];
        }

      case "getLogs":
        if (params.filter && params.filter.address != null) {
          params.filter.address = getLowerCase(params.filter.address);
        }

        return ["eth_getLogs", [params.filter]];

      default:
        break;
    }

    return null;
  }

  perform(method, params) {
    return __awaiter(this, void 0, void 0, function* () {
      // Legacy networks do not like the type field being passed along (which
      // is fair), so we delete type if it is 0 and a non-EIP-1559 network
      if (method === "call" || method === "estimateGas") {
        const tx = params.transaction;

        if (tx && tx.type != null && _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__.BigNumber.from(tx.type).isZero()) {
          // If there are no EIP-1559 properties, it might be non-EIP-1559
          if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
            const feeData = yield this.getFeeData();

            if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
              // Network doesn't know about EIP-1559 (and hence type)
              params = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(params);
              params.transaction = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(tx);
              delete params.transaction.type;
            }
          }
        }
      }

      const args = this.prepareRequest(method, params);

      if (args == null) {
        logger.throwError(method + " not implemented", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NOT_IMPLEMENTED, {
          operation: method
        });
      }

      try {
        return yield this.send(args[0], args[1]);
      } catch (error) {
        return checkError(method, error, params);
      }
    });
  }

  _startEvent(event) {
    if (event.tag === "pending") {
      this._startPending();
    }

    super._startEvent(event);
  }

  _startPending() {
    if (this._pendingFilter != null) {
      return;
    }

    const self = this;
    const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
    this._pendingFilter = pendingFilter;
    pendingFilter.then(function (filterId) {
      function poll() {
        self.send("eth_getFilterChanges", [filterId]).then(function (hashes) {
          if (self._pendingFilter != pendingFilter) {
            return null;
          }

          let seq = Promise.resolve();
          hashes.forEach(function (hash) {
            // @TODO: This should be garbage collected at some point... How? When?
            self._emitted["t:" + hash.toLowerCase()] = "pending";
            seq = seq.then(function () {
              return self.getTransaction(hash).then(function (tx) {
                self.emit("pending", tx);
                return null;
              });
            });
          });
          return seq.then(function () {
            return timer(1000);
          });
        }).then(function () {
          if (self._pendingFilter != pendingFilter) {
            self.send("eth_uninstallFilter", [filterId]);
            return;
          }

          setTimeout(function () {
            poll();
          }, 0);
          return null;
        }).catch(error => {});
      }

      poll();
      return filterId;
    }).catch(error => {});
  }

  _stopEvent(event) {
    if (event.tag === "pending" && this.listenerCount("pending") === 0) {
      this._pendingFilter = null;
    }

    super._stopEvent(event);
  } // Convert an ethers.js transaction into a JSON-RPC transaction
  //  - gasLimit => gas
  //  - All values hexlified
  //  - All numeric values zero-striped
  //  - All addresses are lowercased
  // NOTE: This allows a TransactionRequest, but all values should be resolved
  //       before this is called
  // @TODO: This will likely be removed in future versions and prepareRequest
  //        will be the preferred method for this.


  static hexlifyTransaction(transaction, allowExtra) {
    // Check only allowed properties are given
    const allowed = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.shallowCopy)(allowedTransactionKeys);

    if (allowExtra) {
      for (const key in allowExtra) {
        if (allowExtra[key]) {
          allowed[key] = true;
        }
      }
    }

    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__.checkProperties)(transaction, allowed);
    const result = {}; // JSON-RPC now requires numeric values to be "quantity" values

    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function (key) {
      if (transaction[key] == null) {
        return;
      }

      const value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexValue)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_9__.BigNumber.from(transaction[key]));

      if (key === "gasLimit") {
        key = "gas";
      }

      result[key] = value;
    });
    ["from", "to", "data"].forEach(function (key) {
      if (transaction[key] == null) {
        return;
      }

      result[key] = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(transaction[key]);
    });

    if (transaction.accessList) {
      result["accessList"] = (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_10__.accessListify)(transaction.accessList);
    }

    return result;
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NodesmithProvider": () => (/* binding */ NodesmithProvider)
/* harmony export */ });
/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./url-json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");
/* istanbul ignore file */





const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version); // Special API key provided by Nodesmith for ethers.js

const defaultApiKey = "ETHERS_JS_SHARED";
class NodesmithProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.UrlJsonRpcProvider {
  static getApiKey(apiKey) {
    if (apiKey && typeof apiKey !== "string") {
      logger.throwArgumentError("invalid apiKey", "apiKey", apiKey);
    }

    return apiKey || defaultApiKey;
  }

  static getUrl(network, apiKey) {
    logger.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
    let host = null;

    switch (network.name) {
      case "homestead":
        host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
        break;

      case "ropsten":
        host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
        break;

      case "rinkeby":
        host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
        break;

      case "goerli":
        host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
        break;

      case "kovan":
        host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
        break;

      default:
        logger.throwArgumentError("unsupported network", "network", arguments[0]);
    }

    return host + "?apiKey=" + apiKey;
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/pocket-provider.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/pocket-provider.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PocketProvider": () => (/* binding */ PocketProvider)
/* harmony export */ });
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");
/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./url-json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js");





const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
 // These are load-balancer-based application IDs

const defaultApplicationIds = {
  homestead: "6004bcd10040261633ade990",
  ropsten: "6004bd4d0040261633ade991",
  rinkeby: "6004bda20040261633ade994",
  goerli: "6004bd860040261633ade992"
};
class PocketProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.UrlJsonRpcProvider {
  constructor(network, apiKey) {
    // We need a bit of creativity in the constructor because
    // Pocket uses different default API keys based on the network
    if (apiKey == null) {
      const n = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, "getNetwork")(network);

      if (n) {
        const applicationId = defaultApplicationIds[n.name];

        if (applicationId) {
          apiKey = {
            applicationId: applicationId,
            loadBalancer: true
          };
        }
      } // If there was any issue above, we don't know this network


      if (apiKey == null) {
        logger.throwError("unsupported network", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
      }
    }

    super(network, apiKey);
  }

  static getApiKey(apiKey) {
    // Most API Providers allow null to get the default configuration, but
    // Pocket requires the network to decide the default provider, so we
    // rely on hijacking the constructor to add a sensible default for us
    if (apiKey == null) {
      logger.throwArgumentError("PocketProvider.getApiKey does not support null apiKey", "apiKey", apiKey);
    }

    const apiKeyObj = {
      applicationId: null,
      loadBalancer: false,
      applicationSecretKey: null
    }; // Parse applicationId and applicationSecretKey

    if (typeof apiKey === "string") {
      apiKeyObj.applicationId = apiKey;
    } else if (apiKey.applicationSecretKey != null) {
      logger.assertArgument(typeof apiKey.applicationId === "string", "applicationSecretKey requires an applicationId", "applicationId", apiKey.applicationId);
      logger.assertArgument(typeof apiKey.applicationSecretKey === "string", "invalid applicationSecretKey", "applicationSecretKey", "[REDACTED]");
      apiKeyObj.applicationId = apiKey.applicationId;
      apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
      apiKeyObj.loadBalancer = !!apiKey.loadBalancer;
    } else if (apiKey.applicationId) {
      logger.assertArgument(typeof apiKey.applicationId === "string", "apiKey.applicationId must be a string", "apiKey.applicationId", apiKey.applicationId);
      apiKeyObj.applicationId = apiKey.applicationId;
      apiKeyObj.loadBalancer = !!apiKey.loadBalancer;
    } else {
      logger.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
    }

    return apiKeyObj;
  }

  static getUrl(network, apiKey) {
    let host = null;

    switch (network ? network.name : "unknown") {
      case "homestead":
        host = "eth-mainnet.gateway.pokt.network";
        break;

      case "ropsten":
        host = "eth-ropsten.gateway.pokt.network";
        break;

      case "rinkeby":
        host = "eth-rinkeby.gateway.pokt.network";
        break;

      case "goerli":
        host = "eth-goerli.gateway.pokt.network";
        break;

      default:
        logger.throwError("unsupported network", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {
          argument: "network",
          value: network
        });
    }

    let url = null;

    if (apiKey.loadBalancer) {
      url = `https:/\/${host}/v1/lb/${apiKey.applicationId}`;
    } else {
      url = `https:/\/${host}/v1/${apiKey.applicationId}`;
    }

    const connection = {
      url
    }; // Initialize empty headers

    connection.headers = {}; // Apply application secret key

    if (apiKey.applicationSecretKey != null) {
      connection.user = "";
      connection.password = apiKey.applicationSecretKey;
    }

    return connection;
  }

  isCommunityResource() {
    return this.applicationId === defaultApplicationIds[this.network.name];
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StaticJsonRpcProvider": () => (/* binding */ StaticJsonRpcProvider),
/* harmony export */   "UrlJsonRpcProvider": () => (/* binding */ UrlJsonRpcProvider)
/* harmony export */ });
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");
/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js");


var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};




const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
 // A StaticJsonRpcProvider is useful when you *know* for certain that
// the backend will never change, as it never calls eth_chainId to
// verify its backend. However, if the backend does change, the effects
// are undefined and may include:
// - inconsistent results
// - locking up the UI
// - block skew warnings
// - wrong results
// If the network is not explicit (i.e. auto-detection is expected), the
// node MUST be running and available to respond to requests BEFORE this
// is instantiated.

class StaticJsonRpcProvider extends _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider {
  detectNetwork() {
    const _super = Object.create(null, {
      detectNetwork: {
        get: () => super.detectNetwork
      }
    });

    return __awaiter(this, void 0, void 0, function* () {
      let network = this.network;

      if (network == null) {
        network = yield _super.detectNetwork.call(this);

        if (!network) {
          logger.throwError("no network detected", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNKNOWN_ERROR, {});
        } // If still not set, set it


        if (this._network == null) {
          // A static network does not support "any"
          (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "_network", network);
          this.emit("network", network, null);
        }
      }

      return network;
    });
  }

}
class UrlJsonRpcProvider extends StaticJsonRpcProvider {
  constructor(network, apiKey) {
    logger.checkAbstract(new.target, UrlJsonRpcProvider); // Normalize the Network and API Key

    network = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, "getNetwork")(network);
    apiKey = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, "getApiKey")(apiKey);
    const connection = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.getStatic)(new.target, "getUrl")(network, apiKey);
    super(connection, network);

    if (typeof apiKey === "string") {
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "apiKey", apiKey);
    } else if (apiKey != null) {
      Object.keys(apiKey).forEach(key => {
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, key, apiKey[key]);
      });
    }
  }

  _startPending() {
    logger.warn("WARNING: API provider does not support pending filters");
  }

  isCommunityResource() {
    return false;
  }

  getSigner(address) {
    return logger.throwError("API provider does not support signing", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "getSigner"
    });
  }

  listAccounts() {
    return Promise.resolve([]);
  } // Return a defaultApiKey if null, otherwise validate the API key


  static getApiKey(apiKey) {
    return apiKey;
  } // Returns the url or connection for the given network and API key. The
  // API key will have been sanitized by the getApiKey first, so any validation
  // or transformations can be done there.


  static getUrl(network, apiKey) {
    return logger.throwError("not implemented; sub-classes must override getUrl", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.NOT_IMPLEMENTED, {
      operation: "getUrl"
    });
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/web3-provider.js":
/*!************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/web3-provider.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Web3Provider": () => (/* binding */ Web3Provider)
/* harmony export */ });
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");
/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js");





const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);

let _nextId = 1;

function buildWeb3LegacyFetcher(provider, sendFunc) {
  const fetcher = "Web3LegacyFetcher";
  return function (method, params) {
    const request = {
      method: method,
      params: params,
      id: _nextId++,
      jsonrpc: "2.0"
    };
    return new Promise((resolve, reject) => {
      this.emit("debug", {
        action: "request",
        fetcher,
        request: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.deepCopy)(request),
        provider: this
      });
      sendFunc(request, (error, response) => {
        if (error) {
          this.emit("debug", {
            action: "response",
            fetcher,
            error,
            request,
            provider: this
          });
          return reject(error);
        }

        this.emit("debug", {
          action: "response",
          fetcher,
          request,
          response,
          provider: this
        });

        if (response.error) {
          const error = new Error(response.error.message);
          error.code = response.error.code;
          error.data = response.error.data;
          return reject(error);
        }

        resolve(response.result);
      });
    });
  };
}

function buildEip1193Fetcher(provider) {
  return function (method, params) {
    if (params == null) {
      params = [];
    }

    const request = {
      method,
      params
    };
    this.emit("debug", {
      action: "request",
      fetcher: "Eip1193Fetcher",
      request: (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.deepCopy)(request),
      provider: this
    });
    return provider.request(request).then(response => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        response,
        provider: this
      });
      return response;
    }, error => {
      this.emit("debug", {
        action: "response",
        fetcher: "Eip1193Fetcher",
        request,
        error,
        provider: this
      });
      throw error;
    });
  };
}

class Web3Provider extends _json_rpc_provider__WEBPACK_IMPORTED_MODULE_3__.JsonRpcProvider {
  constructor(provider, network) {
    logger.checkNew(new.target, Web3Provider);

    if (provider == null) {
      logger.throwArgumentError("missing provider", "provider", provider);
    }

    let path = null;
    let jsonRpcFetchFunc = null;
    let subprovider = null;

    if (typeof provider === "function") {
      path = "unknown:";
      jsonRpcFetchFunc = provider;
    } else {
      path = provider.host || provider.path || "";

      if (!path && provider.isMetaMask) {
        path = "metamask";
      }

      subprovider = provider;

      if (provider.request) {
        if (path === "") {
          path = "eip-1193:";
        }

        jsonRpcFetchFunc = buildEip1193Fetcher(provider);
      } else if (provider.sendAsync) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
      } else if (provider.send) {
        jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
      } else {
        logger.throwArgumentError("unsupported provider", "provider", provider);
      }

      if (!path) {
        path = "unknown:";
      }
    }

    super(path, network);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, "provider", subprovider);
  }

  send(method, params) {
    return this.jsonRpcFetchFunc(method, params);
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/websocket-provider.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/websocket-provider.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebSocketProvider": () => (/* binding */ WebSocketProvider)
/* harmony export */ });
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js");
/* harmony import */ var _ws__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ws */ "./node_modules/@ethersproject/providers/lib.esm/ws.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");


var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};







const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
/**
 *  Notes:
 *
 *  This provider differs a bit from the polling providers. One main
 *  difference is how it handles consistency. The polling providers
 *  will stall responses to ensure a consistent state, while this
 *  WebSocket provider assumes the connected backend will manage this.
 *
 *  For example, if a polling provider emits an event which indicates
 *  the event occurred in blockhash XXX, a call to fetch that block by
 *  its hash XXX, if not present will retry until it is present. This
 *  can occur when querying a pool of nodes that are mildly out of sync
 *  with each other.
 */

let NextId = 1; // For more info about the Real-time Event API see:
//   https://geth.ethereum.org/docs/rpc/pubsub

class WebSocketProvider extends _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__.JsonRpcProvider {
  constructor(url, network) {
    // This will be added in the future; please open an issue to expedite
    if (network === "any") {
      logger.throwError("WebSocketProvider does not support 'any' network yet", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "network:any"
      });
    }

    if (typeof url === "string") {
      super(url, network);
    } else {
      super("_websocket", network);
    }

    this._pollingInterval = -1;
    this._wsReady = false;

    if (typeof url === "string") {
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "_websocket", new _ws__WEBPACK_IMPORTED_MODULE_4__.WebSocket(this.connection.url));
    } else {
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "_websocket", url);
    }

    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "_requests", {});
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "_subs", {});
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "_subIds", {});
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "_detectNetwork", super.detectNetwork()); // Stall sending requests until the socket is open...

    this.websocket.onopen = () => {
      this._wsReady = true;
      Object.keys(this._requests).forEach(id => {
        this.websocket.send(this._requests[id].payload);
      });
    };

    this.websocket.onmessage = messageEvent => {
      const data = messageEvent.data;
      const result = JSON.parse(data);

      if (result.id != null) {
        const id = String(result.id);
        const request = this._requests[id];
        delete this._requests[id];

        if (result.result !== undefined) {
          request.callback(null, result.result);
          this.emit("debug", {
            action: "response",
            request: JSON.parse(request.payload),
            response: result.result,
            provider: this
          });
        } else {
          let error = null;

          if (result.error) {
            error = new Error(result.error.message || "unknown error");
            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(error, "code", result.error.code || null);
            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(error, "response", data);
          } else {
            error = new Error("unknown error");
          }

          request.callback(error, undefined);
          this.emit("debug", {
            action: "response",
            error: error,
            request: JSON.parse(request.payload),
            provider: this
          });
        }
      } else if (result.method === "eth_subscription") {
        // Subscription...
        const sub = this._subs[result.params.subscription];

        if (sub) {
          //this.emit.apply(this,                  );
          sub.processFunc(result.params.result);
        }
      } else {
        console.warn("this should not happen");
      }
    }; // This Provider does not actually poll, but we want to trigger
    // poll events for things that depend on them (like stalling for
    // block and transaction lookups)


    const fauxPoll = setInterval(() => {
      this.emit("poll");
    }, 1000);

    if (fauxPoll.unref) {
      fauxPoll.unref();
    }
  } // Cannot narrow the type of _websocket, as that is not backwards compatible
  // so we add a getter and let the WebSocket be a public API.


  get websocket() {
    return this._websocket;
  }

  detectNetwork() {
    return this._detectNetwork;
  }

  get pollingInterval() {
    return 0;
  }

  resetEventsBlock(blockNumber) {
    logger.throwError("cannot reset events block on WebSocketProvider", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "resetEventBlock"
    });
  }

  set pollingInterval(value) {
    logger.throwError("cannot set polling interval on WebSocketProvider", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPollingInterval"
    });
  }

  poll() {
    return __awaiter(this, void 0, void 0, function* () {
      return null;
    });
  }

  set polling(value) {
    if (!value) {
      return;
    }

    logger.throwError("cannot set polling on WebSocketProvider", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "setPolling"
    });
  }

  send(method, params) {
    const rid = NextId++;
    return new Promise((resolve, reject) => {
      function callback(error, result) {
        if (error) {
          return reject(error);
        }

        return resolve(result);
      }

      const payload = JSON.stringify({
        method: method,
        params: params,
        id: rid,
        jsonrpc: "2.0"
      });
      this.emit("debug", {
        action: "request",
        request: JSON.parse(payload),
        provider: this
      });
      this._requests[String(rid)] = {
        callback,
        payload
      };

      if (this._wsReady) {
        this.websocket.send(payload);
      }
    });
  }

  static defaultUrl() {
    return "ws:/\/localhost:8546";
  }

  _subscribe(tag, param, processFunc) {
    return __awaiter(this, void 0, void 0, function* () {
      let subIdPromise = this._subIds[tag];

      if (subIdPromise == null) {
        subIdPromise = Promise.all(param).then(param => {
          return this.send("eth_subscribe", param);
        });
        this._subIds[tag] = subIdPromise;
      }

      const subId = yield subIdPromise;
      this._subs[subId] = {
        tag,
        processFunc
      };
    });
  }

  _startEvent(event) {
    switch (event.type) {
      case "block":
        this._subscribe("block", ["newHeads"], result => {
          const blockNumber = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_5__.BigNumber.from(result.number).toNumber();
          this._emitted.block = blockNumber;
          this.emit("block", blockNumber);
        });

        break;

      case "pending":
        this._subscribe("pending", ["newPendingTransactions"], result => {
          this.emit("pending", result);
        });

        break;

      case "filter":
        this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], result => {
          if (result.removed == null) {
            result.removed = false;
          }

          this.emit(event.filter, this.formatter.filterLog(result));
        });

        break;

      case "tx":
        {
          const emitReceipt = event => {
            const hash = event.hash;
            this.getTransactionReceipt(hash).then(receipt => {
              if (!receipt) {
                return;
              }

              this.emit(hash, receipt);
            });
          }; // In case it is already mined


          emitReceipt(event); // To keep things simple, we start up a single newHeads subscription
          // to keep an eye out for transactions we are watching for.
          // Starting a subscription for an event (i.e. "tx") that is already
          // running is (basically) a nop.

          this._subscribe("tx", ["newHeads"], result => {
            this._events.filter(e => e.type === "tx").forEach(emitReceipt);
          });

          break;
        }
      // Nothing is needed

      case "debug":
      case "poll":
      case "willPoll":
      case "didPoll":
      case "error":
        break;

      default:
        console.log("unhandled:", event);
        break;
    }
  }

  _stopEvent(event) {
    let tag = event.tag;

    if (event.type === "tx") {
      // There are remaining transaction event listeners
      if (this._events.filter(e => e.type === "tx").length) {
        return;
      }

      tag = "tx";
    } else if (this.listenerCount(event.event)) {
      // There are remaining event listeners
      return;
    }

    const subId = this._subIds[tag];

    if (!subId) {
      return;
    }

    delete this._subIds[tag];
    subId.then(subId => {
      if (!this._subs[subId]) {
        return;
      }

      delete this._subs[subId];
      this.send("eth_unsubscribe", [subId]);
    });
  }

  destroy() {
    return __awaiter(this, void 0, void 0, function* () {
      // Wait until we have connected before trying to disconnect
      if (this.websocket.readyState === _ws__WEBPACK_IMPORTED_MODULE_4__.WebSocket.CONNECTING) {
        yield new Promise(resolve => {
          this.websocket.onopen = function () {
            resolve(true);
          };

          this.websocket.onerror = function () {
            resolve(false);
          };
        });
      } // Hangup
      // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes


      this.websocket.close(1000);
    });
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/ws.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/ws.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WebSocket": () => (/* binding */ WS)
/* harmony export */ });
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");




let WS = null;

try {
  WS = WebSocket;

  if (WS == null) {
    throw new Error("inject please");
  }
} catch (error) {
  const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);

  WS = function () {
    logger.throwError("WebSockets not supported in this environment", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "new WebSocket()"
    });
  };
} //export default WS;
//module.exports = WS;




/***/ }),

/***/ "./node_modules/@ethersproject/random/lib.esm/_version.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/random/lib.esm/_version.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "random/5.6.0";

/***/ }),

/***/ "./node_modules/@ethersproject/random/lib.esm/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/random/lib.esm/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "randomBytes": () => (/* reexport safe */ _random__WEBPACK_IMPORTED_MODULE_0__.randomBytes),
/* harmony export */   "shuffled": () => (/* reexport safe */ _shuffle__WEBPACK_IMPORTED_MODULE_1__.shuffled)
/* harmony export */ });
/* harmony import */ var _random__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./random */ "./node_modules/@ethersproject/random/lib.esm/random.js");
/* harmony import */ var _shuffle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shuffle */ "./node_modules/@ethersproject/random/lib.esm/shuffle.js");





/***/ }),

/***/ "./node_modules/@ethersproject/random/lib.esm/random.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/random/lib.esm/random.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "randomBytes": () => (/* binding */ randomBytes)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/random/lib.esm/_version.js");





const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version); // Debugging line for testing browser lib in node
//const window = { crypto: { getRandomValues: () => { } } };
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/globalThis

function getGlobal() {
  if (typeof self !== 'undefined') {
    return self;
  }

  if (typeof window !== 'undefined') {
    return window;
  }

  if (typeof __webpack_require__.g !== 'undefined') {
    return __webpack_require__.g;
  }

  throw new Error('unable to locate global object');
}

;
const anyGlobal = getGlobal();
let crypto = anyGlobal.crypto || anyGlobal.msCrypto;

if (!crypto || !crypto.getRandomValues) {
  logger.warn("WARNING: Missing strong random number source");
  crypto = {
    getRandomValues: function (buffer) {
      return logger.throwError("no secure random source avaialble", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
        operation: "crypto.getRandomValues"
      });
    }
  };
}

function randomBytes(length) {
  if (length <= 0 || length > 1024 || length % 1 || length != length) {
    logger.throwArgumentError("invalid length", "length", length);
  }

  const result = new Uint8Array(length);
  crypto.getRandomValues(result);
  return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(result);
}
;

/***/ }),

/***/ "./node_modules/@ethersproject/random/lib.esm/shuffle.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ethersproject/random/lib.esm/shuffle.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "shuffled": () => (/* binding */ shuffled)
/* harmony export */ });


function shuffled(array) {
  array = array.slice();

  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const tmp = array[i];
    array[i] = array[j];
    array[j] = tmp;
  }

  return array;
}

/***/ }),

/***/ "./node_modules/@ethersproject/rlp/lib.esm/_version.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/rlp/lib.esm/_version.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "rlp/5.6.0";

/***/ }),

/***/ "./node_modules/@ethersproject/rlp/lib.esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@ethersproject/rlp/lib.esm/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decode": () => (/* binding */ decode),
/* harmony export */   "encode": () => (/* binding */ encode)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/rlp/lib.esm/_version.js");
 //See: https://github.com/ethereum/wiki/wiki/RLP




const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);

function arrayifyInteger(value) {
  const result = [];

  while (value) {
    result.unshift(value & 0xff);
    value >>= 8;
  }

  return result;
}

function unarrayifyInteger(data, offset, length) {
  let result = 0;

  for (let i = 0; i < length; i++) {
    result = result * 256 + data[offset + i];
  }

  return result;
}

function _encode(object) {
  if (Array.isArray(object)) {
    let payload = [];
    object.forEach(function (child) {
      payload = payload.concat(_encode(child));
    });

    if (payload.length <= 55) {
      payload.unshift(0xc0 + payload.length);
      return payload;
    }

    const length = arrayifyInteger(payload.length);
    length.unshift(0xf7 + length.length);
    return length.concat(payload);
  }

  if (!(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isBytesLike)(object)) {
    logger.throwArgumentError("RLP object must be BytesLike", "object", object);
  }

  const data = Array.prototype.slice.call((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(object));

  if (data.length === 1 && data[0] <= 0x7f) {
    return data;
  } else if (data.length <= 55) {
    data.unshift(0x80 + data.length);
    return data;
  }

  const length = arrayifyInteger(data.length);
  length.unshift(0xb7 + length.length);
  return length.concat(data);
}

function encode(object) {
  return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(_encode(object));
}

function _decodeChildren(data, offset, childOffset, length) {
  const result = [];

  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data, childOffset);

    result.push(decoded.result);
    childOffset += decoded.consumed;

    if (childOffset > offset + 1 + length) {
      logger.throwError("child data too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});
    }
  }

  return {
    consumed: 1 + length,
    result: result
  };
} // returns { consumed: number, result: Object }


function _decode(data, offset) {
  if (data.length === 0) {
    logger.throwError("data too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});
  } // Array with extra length prefix


  if (data[offset] >= 0xf8) {
    const lengthLength = data[offset] - 0xf7;

    if (offset + 1 + lengthLength > data.length) {
      logger.throwError("data short segment too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});
    }

    const length = unarrayifyInteger(data, offset + 1, lengthLength);

    if (offset + 1 + lengthLength + length > data.length) {
      logger.throwError("data long segment too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});
    }

    return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data[offset] >= 0xc0) {
    const length = data[offset] - 0xc0;

    if (offset + 1 + length > data.length) {
      logger.throwError("data array too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});
    }

    return _decodeChildren(data, offset, offset + 1, length);
  } else if (data[offset] >= 0xb8) {
    const lengthLength = data[offset] - 0xb7;

    if (offset + 1 + lengthLength > data.length) {
      logger.throwError("data array too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});
    }

    const length = unarrayifyInteger(data, offset + 1, lengthLength);

    if (offset + 1 + lengthLength + length > data.length) {
      logger.throwError("data array too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});
    }

    const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return {
      consumed: 1 + lengthLength + length,
      result: result
    };
  } else if (data[offset] >= 0x80) {
    const length = data[offset] - 0x80;

    if (offset + 1 + length > data.length) {
      logger.throwError("data too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.BUFFER_OVERRUN, {});
    }

    const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data.slice(offset + 1, offset + 1 + length));
    return {
      consumed: 1 + length,
      result: result
    };
  }

  return {
    consumed: 1,
    result: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(data[offset])
  };
}

function decode(data) {
  const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(data);

  const decoded = _decode(bytes, 0);

  if (decoded.consumed !== bytes.length) {
    logger.throwArgumentError("invalid rlp data", "data", data);
  }

  return decoded.result;
}

/***/ }),

/***/ "./node_modules/@ethersproject/sha2/lib.esm/_version.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/sha2/lib.esm/_version.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "sha2/5.6.0";

/***/ }),

/***/ "./node_modules/@ethersproject/sha2/lib.esm/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@ethersproject/sha2/lib.esm/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SupportedAlgorithm": () => (/* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_1__.SupportedAlgorithm),
/* harmony export */   "computeHmac": () => (/* reexport safe */ _sha2__WEBPACK_IMPORTED_MODULE_0__.computeHmac),
/* harmony export */   "ripemd160": () => (/* reexport safe */ _sha2__WEBPACK_IMPORTED_MODULE_0__.ripemd160),
/* harmony export */   "sha256": () => (/* reexport safe */ _sha2__WEBPACK_IMPORTED_MODULE_0__.sha256),
/* harmony export */   "sha512": () => (/* reexport safe */ _sha2__WEBPACK_IMPORTED_MODULE_0__.sha512)
/* harmony export */ });
/* harmony import */ var _sha2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sha2 */ "./node_modules/@ethersproject/sha2/lib.esm/sha2.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/@ethersproject/sha2/lib.esm/types.js");




/***/ }),

/***/ "./node_modules/@ethersproject/sha2/lib.esm/sha2.js":
/*!**********************************************************!*\
  !*** ./node_modules/@ethersproject/sha2/lib.esm/sha2.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "computeHmac": () => (/* binding */ computeHmac),
/* harmony export */   "ripemd160": () => (/* binding */ ripemd160),
/* harmony export */   "sha256": () => (/* binding */ sha256),
/* harmony export */   "sha512": () => (/* binding */ sha512)
/* harmony export */ });
/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hash.js */ "./node_modules/hash.js/lib/hash.js");
/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hash_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types */ "./node_modules/@ethersproject/sha2/lib.esm/types.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/sha2/lib.esm/_version.js");


 //const _ripemd160 = _hash.ripemd160;





const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(_version__WEBPACK_IMPORTED_MODULE_2__.version);
function ripemd160(data) {
  return "0x" + hash_js__WEBPACK_IMPORTED_MODULE_0___default().ripemd160().update((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data)).digest("hex");
}
function sha256(data) {
  return "0x" + hash_js__WEBPACK_IMPORTED_MODULE_0___default().sha256().update((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data)).digest("hex");
}
function sha512(data) {
  return "0x" + hash_js__WEBPACK_IMPORTED_MODULE_0___default().sha512().update((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data)).digest("hex");
}
function computeHmac(algorithm, key, data) {
  if (!_types__WEBPACK_IMPORTED_MODULE_4__.SupportedAlgorithm[algorithm]) {
    logger.throwError("unsupported algorithm " + algorithm, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__.Logger.errors.UNSUPPORTED_OPERATION, {
      operation: "hmac",
      algorithm: algorithm
    });
  }

  return "0x" + hash_js__WEBPACK_IMPORTED_MODULE_0___default().hmac((hash_js__WEBPACK_IMPORTED_MODULE_0___default())[algorithm], (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(key)).update((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__.arrayify)(data)).digest("hex");
}

/***/ }),

/***/ "./node_modules/@ethersproject/sha2/lib.esm/types.js":
/*!***********************************************************!*\
  !*** ./node_modules/@ethersproject/sha2/lib.esm/types.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SupportedAlgorithm": () => (/* binding */ SupportedAlgorithm)
/* harmony export */ });
var SupportedAlgorithm;

(function (SupportedAlgorithm) {
  SupportedAlgorithm["sha256"] = "sha256";
  SupportedAlgorithm["sha512"] = "sha512";
})(SupportedAlgorithm || (SupportedAlgorithm = {}));

;

/***/ }),

/***/ "./node_modules/@ethersproject/signing-key/lib.esm/_version.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ethersproject/signing-key/lib.esm/_version.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "signing-key/5.6.1";

/***/ }),

/***/ "./node_modules/@ethersproject/signing-key/lib.esm/elliptic.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ethersproject/signing-key/lib.esm/elliptic.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EC": () => (/* binding */ EC$1)
/* harmony export */ });
/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hash.js */ "./node_modules/hash.js/lib/hash.js");
/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(hash_js__WEBPACK_IMPORTED_MODULE_1__);


var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function (path, base) {
      return commonjsRequire(path, base === undefined || base === null ? module.path : base);
    }
  }, fn(module, module.exports), module.exports;
}

function getDefaultExportFromNamespaceIfPresent(n) {
  return n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;
}

function getDefaultExportFromNamespaceIfNotNamed(n) {
  return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;
}

function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var a = Object.defineProperty({}, '__esModule', {
    value: true
  });
  Object.keys(n).forEach(function (k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function () {
        return n[k];
      }
    });
  });
  return a;
}

function commonjsRequire() {
  throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var minimalisticAssert = assert;

function assert(val, msg) {
  if (!val) throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r) throw new Error(msg || 'Assertion failed: ' + l + ' != ' + r);
};

var utils_1 = createCommonjsModule(function (module, exports) {
  'use strict';

  var utils = exports;

  function toArray(msg, enc) {
    if (Array.isArray(msg)) return msg.slice();
    if (!msg) return [];
    var res = [];

    if (typeof msg !== 'string') {
      for (var i = 0; i < msg.length; i++) res[i] = msg[i] | 0;

      return res;
    }

    if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0) msg = '0' + msg;

      for (var i = 0; i < msg.length; i += 2) res.push(parseInt(msg[i] + msg[i + 1], 16));
    } else {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 0xff;
        if (hi) res.push(hi, lo);else res.push(lo);
      }
    }

    return res;
  }

  utils.toArray = toArray;

  function zero2(word) {
    if (word.length === 1) return '0' + word;else return word;
  }

  utils.zero2 = zero2;

  function toHex(msg) {
    var res = '';

    for (var i = 0; i < msg.length; i++) res += zero2(msg[i].toString(16));

    return res;
  }

  utils.toHex = toHex;

  utils.encode = function encode(arr, enc) {
    if (enc === 'hex') return toHex(arr);else return arr;
  };
});
var utils_1$1 = createCommonjsModule(function (module, exports) {
  'use strict';

  var utils = exports;
  utils.assert = minimalisticAssert;
  utils.toArray = utils_1.toArray;
  utils.zero2 = utils_1.zero2;
  utils.toHex = utils_1.toHex;
  utils.encode = utils_1.encode; // Represent num in a w-NAF form

  function getNAF(num, w, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w + 1;
    var k = num.clone();

    for (var i = 0; i < naf.length; i++) {
      var z;
      var mod = k.andln(ws - 1);

      if (k.isOdd()) {
        if (mod > (ws >> 1) - 1) z = (ws >> 1) - mod;else z = mod;
        k.isubn(z);
      } else {
        z = 0;
      }

      naf[i] = z;
      k.iushrn(1);
    }

    return naf;
  }

  utils.getNAF = getNAF; // Represent k1, k2 in a Joint Sparse Form

  function getJSF(k1, k2) {
    var jsf = [[], []];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    var m8;

    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      // First phase
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3) m14 = -1;
      if (m24 === 3) m24 = -1;
      var u1;

      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14;else u1 = m14;
      }

      jsf[0].push(u1);
      var u2;

      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24;else u2 = m24;
      }

      jsf[1].push(u2); // Second phase

      if (2 * d1 === u1 + 1) d1 = 1 - d1;
      if (2 * d2 === u2 + 1) d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }

    return jsf;
  }

  utils.getJSF = getJSF;

  function cachedProperty(obj, name, computer) {
    var key = '_' + name;

    obj.prototype[name] = function cachedProperty() {
      return this[key] !== undefined ? this[key] : this[key] = computer.call(this);
    };
  }

  utils.cachedProperty = cachedProperty;

  function parseBytes(bytes) {
    return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') : bytes;
  }

  utils.parseBytes = parseBytes;

  function intFromLE(bytes) {
    return new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(bytes, 'hex', 'le');
  }

  utils.intFromLE = intFromLE;
});
'use strict';

var getNAF = utils_1$1.getNAF;
var getJSF = utils_1$1.getJSF;
var assert$1 = utils_1$1.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.p, 16); // Use Montgomery, when there is no fast reduction for the prime

  this.red = conf.prime ? bn_js__WEBPACK_IMPORTED_MODULE_0___default().red(conf.prime) : bn_js__WEBPACK_IMPORTED_MODULE_0___default().mont(this.p); // Useful for many curves

  this.zero = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(0).toRed(this.red);
  this.one = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(1).toRed(this.red);
  this.two = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(2).toRed(this.red); // Curve configuration, optional

  this.n = conf.n && new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed); // Temporary arrays

  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0; // Generalized Greg Maxwell's trick

  var adjustCount = this.n && this.p.div(this.n);

  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}

var base = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert$1(p.precomputed);

  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3; // Translate into more windowed form

  var repr = [];
  var j;
  var nafW;

  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;

    for (var l = j + doubles.step - 1; l >= j; l--) nafW = (nafW << 1) + naf[l];

    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);

  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i) b = b.mixedAdd(doubles.points[j]);else if (nafW === -i) b = b.mixedAdd(doubles.points[j].neg());
    }

    a = a.add(b);
  }

  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4; // Precompute window

  var nafPoints = p._getNAFPoints(w);

  w = nafPoints.wnd;
  var wnd = nafPoints.points; // Get NAF form

  var naf = getNAF(k, w, this._bitLength); // Add `this`*(N+1) for every w-NAF index

  var acc = this.jpoint(null, null, null);

  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--) l++;

    if (i >= 0) l++;
    acc = acc.dblp(l);
    if (i < 0) break;
    var z = naf[i];
    assert$1(z !== 0);

    if (p.type === 'affine') {
      // J +- P
      if (z > 0) acc = acc.mixedAdd(wnd[z - 1 >> 1]);else acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
    } else {
      // J +- J
      if (z > 0) acc = acc.add(wnd[z - 1 >> 1]);else acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
  }

  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3; // Fill all arrays

  var max = 0;
  var i;
  var j;
  var p;

  for (i = 0; i < len; i++) {
    p = points[i];

    var nafPoints = p._getNAFPoints(defW);

    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  } // Comb small window NAFs


  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;

    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [points[a],
    /* 1 */
    null,
    /* 3 */
    null,
    /* 5 */
    points[b]
    /* 7 */
    ]; // Try to avoid Projective points, if possible

    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [-3,
    /* -1 -1 */
    -1,
    /* -1 0 */
    -5,
    /* -1 1 */
    -7,
    /* 0 -1 */
    0,
    /* 0 0 */
    7,
    /* 0 1 */
    5,
    /* 1 -1 */
    1,
    /* 1 0 */
    3
    /* 1 1 */
    ];
    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);

    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;
      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;

  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;

      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0) zero = false;
      }

      if (!zero) break;
      k++;
      i--;
    }

    if (i >= 0) k++;
    acc = acc.dblp(k);
    if (i < 0) break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0) continue;else if (z > 0) p = wnd[j][z - 1 >> 1];else if (z < 0) p = wnd[j][-z - 1 >> 1].neg();
      if (p.type === 'affine') acc = acc.mixedAdd(p);else acc = acc.add(p);
    }
  } // Zeroify references


  for (i = 0; i < len; i++) wnd[i] = null;

  if (jacobianResult) return acc;else return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}

BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function
  /*other*/
eq() {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils_1$1.toArray(bytes, enc);
  var len = this.p.byteLength(); // uncompressed, hybrid-odd, hybrid-even

  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06) assert$1(bytes[bytes.length - 1] % 2 === 0);else if (bytes[0] === 0x07) assert$1(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }

  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);
  if (compact) return [this.getY().isEven() ? 0x02 : 0x03].concat(x);
  return [0x04].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils_1$1.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed) return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed) return false;
  var doubles = this.precomputed.doubles;
  if (!doubles) return false;
  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;

  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++) acc = acc.dbl();

    doubles.push(acc);
  }

  return {
    step: step,
    points: doubles
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
  var res = [this];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();

  for (var i = 1; i < max; i++) res[i] = res[i - 1].add(dbl);

  return {
    wnd: wnd,
    points: res
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;

  for (var i = 0; i < k; i++) r = r.dbl();

  return r;
};

var inherits_browser = createCommonjsModule(function (module) {
  if (typeof Object.create === 'function') {
    // implementation from standard node.js 'util' module
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    // old school shim for old browsers
    module.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;

        var TempCtor = function () {};

        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});
'use strict';

var assert$2 = utils_1$1.assert;

function ShortCurve(conf) {
  base.call(this, 'short', conf);
  this.a = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.a, 16).toRed(this.red);
  this.b = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0; // If the curve is endomorphic, precalculate beta and lambda

  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}

inherits_browser(ShortCurve, base);
var short_1 = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1) return; // Compute beta and lambda, that lambda * P = (beta * Px; Py)

  var beta;
  var lambda;

  if (conf.beta) {
    beta = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p); // Choose the smallest beta


    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }

  if (conf.lambda) {
    lambda = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);

    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  } // Get basis vectors, used for balanced length-two representation


  var basis;

  if (conf.basis) {
    basis = conf.basis.map(function (vec) {
      return {
        a: new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(vec.a, 16),
        b: new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : bn_js__WEBPACK_IMPORTED_MODULE_0___default().mont(num);
  var tinv = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [l1, l2];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2)); // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt

  var u = lambda;
  var v = this.n.clone();
  var x1 = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(1);
  var y1 = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(0);
  var x2 = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(0);
  var y2 = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(1); // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)

  var a0;
  var b0; // First vector

  var a1;
  var b1; // Second vector

  var a2;
  var b2;
  var prevR;
  var i = 0;
  var r;
  var x;

  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }

    prevR = r;
    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }

  a2 = r.neg();
  b2 = x;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());

  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  } // Normalize signs


  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }

  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [{
    a: a1,
    b: b1
  }, {
    a: a2,
    b: b2
  }];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b); // Calculate answer

  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return {
    k1: k1,
    k2: k2
  };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(x, 16);
  if (!x.red) x = x.toRed(this.red);
  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error('invalid point'); // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf) return true;
  var x = point.x;
  var y = point.y;
  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;

  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);

    var p = points[i];

    var beta = p._getBeta();

    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }

    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }

    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }

  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult); // Clean-up references to points and coefficients


  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }

  return res;
};

function Point(curve, x, y, isRed) {
  base.BasePoint.call(this, curve, 'affine');

  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(x, 16);
    this.y = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(y, 16); // Force redgomery representation when loading from JSON

    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }

    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
    if (!this.y.red) this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}

inherits_browser(Point, base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo) return;
  var pre = this.precomputed;
  if (pre && pre.beta) return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);

  if (pre) {
    var curve = this.curve;

    var endoMul = function (p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };

    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }

  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed) return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string') obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2]) return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity()) return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf) return p; // P + O = P

  if (p.inf) return this; // P + P = 2P

  if (this.eq(p)) return this.dbl(); // P + (-P) = O

  if (this.neg().eq(p)) return this.curve.point(null, null); // P + Q = O

  if (this.x.cmp(p.x) === 0) return this.curve.point(null, null);
  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0) c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf) return this; // 2P = O

  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0) return this.curve.point(null, null);
  var a = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(k, 16);
  if (this.isInfinity()) return this;else if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);else if (this.curve.endo) return this.curve._endoWnafMulAdd([this], [k]);else return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs);else return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs, true);else return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf) return this;
  var res = this.curve.point(this.x, this.y.redNeg());

  if (_precompute && this.precomputed) {
    var pre = this.precomputed;

    var negate = function (p) {
      return p.neg();
    };

    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }

  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf) return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  base.BasePoint.call(this, curve, 'jacobian');

  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(0);
  } else {
    this.x = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(x, 16);
    this.y = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(y, 16);
    this.z = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(z, 16);
  }

  if (!this.x.red) this.x = this.x.toRed(this.curve.red);
  if (!this.y.red) this.y = this.y.toRed(this.curve.red);
  if (!this.z.red) this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}

inherits_browser(JPoint, base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity()) return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity()) return p; // P + O = P

  if (p.isInfinity()) return this; // 12M + 4S + 7A

  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);

  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);else return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity()) return p.toJ(); // P + O = P

  if (p.isInfinity()) return this; // 8M + 3S + 7A

  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);

  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);else return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0) return this;
  if (this.isInfinity()) return this;
  if (!pow) return this.dbl();
  var i;

  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;

    for (i = 0; i < pow; i++) r = r.dbl();

    return r;
  } // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A


  var a = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr(); // Reuse results

  var jyd = jy.redAdd(jy);

  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow) jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity()) return this;
  if (this.curve.zeroA) return this._zeroDbl();else if (this.curve.threeA) return this._threeDbl();else return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz; // Z = 1

  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A
    // XX = X1^2
    var xx = this.x.redSqr(); // YY = Y1^2

    var yy = this.y.redSqr(); // YYYY = YY^2

    var yyyy = yy.redSqr(); // S = 2 * ((X1 + YY)^2 - XX - YYYY)

    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s); // M = 3 * XX + a; a = 0

    var m = xx.redAdd(xx).redIAdd(xx); // T = M ^ 2 - 2*S

    var t = m.redSqr().redISub(s).redISub(s); // 8 * YYYY

    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8); // X3 = T

    nx = t; // Y3 = M * (S - T) - 8 * YYYY

    ny = m.redMul(s.redISub(t)).redISub(yyyy8); // Z3 = 2*Y1

    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A
    // A = X1^2
    var a = this.x.redSqr(); // B = Y1^2

    var b = this.y.redSqr(); // C = B^2

    var c = b.redSqr(); // D = 2 * ((X1 + B)^2 - A - C)

    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d); // E = 3 * A

    var e = a.redAdd(a).redIAdd(a); // F = E^2

    var f = e.redSqr(); // 8 * C

    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8); // X3 = F - 2 * D

    nx = f.redISub(d).redISub(d); // Y3 = E * (D - X3) - 8 * C

    ny = e.redMul(d.redISub(nx)).redISub(c8); // Z3 = 2 * Y1 * Z1

    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz; // Z = 1

  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A
    // XX = X1^2
    var xx = this.x.redSqr(); // YY = Y1^2

    var yy = this.y.redSqr(); // YYYY = YY^2

    var yyyy = yy.redSqr(); // S = 2 * ((X1 + YY)^2 - XX - YYYY)

    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s); // M = 3 * XX + a

    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a); // T = M^2 - 2 * S

    var t = m.redSqr().redISub(s).redISub(s); // X3 = T

    nx = t; // Y3 = M * (S - T) - 8 * YYYY

    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8); // Z3 = 2 * Y1

    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S
    // delta = Z1^2
    var delta = this.z.redSqr(); // gamma = Y1^2

    var gamma = this.y.redSqr(); // beta = X1 * gamma

    var beta = this.x.redMul(gamma); // alpha = 3 * (X1 - delta) * (X1 + delta)

    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha); // X3 = alpha^2 - 8 * beta

    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8); // Z3 = (Y1 + Z1)^2 - gamma - delta

    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta); // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2

    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a; // 4M + 6S + 10A

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA) return this.dbl().add(this); // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...
  // XX = X1^2

  var xx = this.x.redSqr(); // YY = Y1^2

  var yy = this.y.redSqr(); // ZZ = Z1^2

  var zz = this.z.redSqr(); // YYYY = YY^2

  var yyyy = yy.redSqr(); // M = 3 * XX + a * ZZ2; a = 0

  var m = xx.redAdd(xx).redIAdd(xx); // MM = M^2

  var mm = m.redSqr(); // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM

  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm); // EE = E^2

  var ee = e.redSqr(); // T = 16*YYYY

  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t); // U = (M + E)^2 - MM - EE - T

  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t); // X3 = 4 * (X1 * EE - 4 * YY * U)

  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx); // Y3 = 8 * Y1 * (U * (T - U) - E * EE)

  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny); // Z3 = (Z1 + E)^2 - ZZ - EE

  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(k, kbase);
  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine') return this.eq(p.toJ());
  if (this === p) return true; // x1 * z2^2 == x2 * z1^2

  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0) return false; // y1 * z2^3 == y2 * z1^3

  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0) return true;
  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);

  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0) return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0) return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity()) return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) + ' y: ' + this.y.toString(16, 2) + ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

var curve_1 = createCommonjsModule(function (module, exports) {
  'use strict';

  var curve = exports;
  curve.base = base;
  curve.short = short_1;
  curve.mont =
  /*RicMoo:ethers:require(./mont)*/
  null;
  curve.edwards =
  /*RicMoo:ethers:require(./edwards)*/
  null;
});
var curves_1 = createCommonjsModule(function (module, exports) {
  'use strict';

  var curves = exports;
  var assert = utils_1$1.assert;

  function PresetCurve(options) {
    if (options.type === 'short') this.curve = new curve_1.short(options);else if (options.type === 'edwards') this.curve = new curve_1.edwards(options);else this.curve = new curve_1.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert(this.g.validate(), 'Invalid curve');
    assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
  }

  curves.PresetCurve = PresetCurve;

  function defineCurve(name, options) {
    Object.defineProperty(curves, name, {
      configurable: true,
      enumerable: true,
      get: function () {
        var curve = new PresetCurve(options);
        Object.defineProperty(curves, name, {
          configurable: true,
          enumerable: true,
          value: curve
        });
        return curve;
      }
    });
  }

  defineCurve('p192', {
    type: 'short',
    prime: 'p192',
    p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
    a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
    b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
    n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
    hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),
    gRed: false,
    g: ['188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012', '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811']
  });
  defineCurve('p224', {
    type: 'short',
    prime: 'p224',
    p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
    a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
    b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
    n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
    hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),
    gRed: false,
    g: ['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21', 'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34']
  });
  defineCurve('p256', {
    type: 'short',
    prime: null,
    p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
    a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
    b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
    n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
    hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),
    gRed: false,
    g: ['6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296', '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5']
  });
  defineCurve('p384', {
    type: 'short',
    prime: null,
    p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'fffffffe ffffffff 00000000 00000000 ffffffff',
    a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'fffffffe ffffffff 00000000 00000000 fffffffc',
    b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' + '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
    n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' + 'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
    hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha384),
    gRed: false,
    g: ['aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' + '5502f25d bf55296c 3a545e38 72760ab7', '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' + '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f']
  });
  defineCurve('p521', {
    type: 'short',
    prime: null,
    p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff',
    a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff fffffffc',
    b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' + '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' + '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
    n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' + 'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
    hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha512),
    gRed: false,
    g: ['000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' + '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' + 'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66', '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' + '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' + '3fad0761 353c7086 a272c240 88be9476 9fd16650']
  });
  defineCurve('curve25519', {
    type: 'mont',
    prime: 'p25519',
    p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
    a: '76d06',
    b: '1',
    n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
    hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),
    gRed: false,
    g: ['9']
  });
  defineCurve('ed25519', {
    type: 'edwards',
    prime: 'p25519',
    p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
    a: '-1',
    c: '1',
    // -121665 * (121666^(-1)) (mod P)
    d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
    n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
    hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),
    gRed: false,
    g: ['216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a', // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658']
  });
  var pre;

  try {
    pre =
    /*RicMoo:ethers:require(./precomputed/secp256k1)*/
    null.crash();
  } catch (e) {
    pre = undefined;
  }

  defineCurve('secp256k1', {
    type: 'short',
    prime: 'k256',
    p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
    a: '0',
    b: '7',
    n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
    h: '1',
    hash: (hash_js__WEBPACK_IMPORTED_MODULE_1___default().sha256),
    // Precomputed endomorphism
    beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
    lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
    basis: [{
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3'
    }, {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15'
    }],
    gRed: false,
    g: ['79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798', '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8', pre]
  });
});
'use strict';

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG)) return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils_1.toArray(options.pers, options.persEnc || 'hex');
  minimalisticAssert(entropy.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._init(entropy, nonce, pers);
}

var hmacDrbg = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);

  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);

  this._reseed = 1;
  this.reseedInterval = 0x1000000000000; // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new (hash_js__WEBPACK_IMPORTED_MODULE_1___default().hmac)(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac().update(this.V).update([0x00]);

  if (seed) kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed) return;
  this.K = this._hmac().update(this.V).update([0x01]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils_1.toArray(entropy, entropyEnc);
  add = utils_1.toArray(add, addEnc);
  minimalisticAssert(entropy.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));

  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval) throw new Error('Reseed is required'); // Optional encoding

  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  } // Optional additional data


  if (add) {
    add = utils_1.toArray(add, addEnc || 'hex');

    this._update(add);
  }

  var temp = [];

  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);

  this._update(add);

  this._reseed++;
  return utils_1.encode(res, enc);
};

'use strict';

var assert$3 = utils_1$1.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null; // KeyPair(ec, { priv: ..., pub: ... })

  if (options.priv) this._importPrivate(options.priv, options.privEnc);
  if (options.pub) this._importPublic(options.pub, options.pubEnc);
}

var key = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair) return pub;
  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair) return priv;
  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();
  if (pub.isInfinity()) return {
    result: false,
    reason: 'Invalid public key'
  };
  if (!pub.validate()) return {
    result: false,
    reason: 'Public key is not a point'
  };
  if (!pub.mul(this.ec.curve.n).isInfinity()) return {
    result: false,
    reason: 'Public key * N != O'
  };
  return {
    result: true,
    reason: null
  };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub) this.pub = this.ec.g.mul(this.priv);
  if (!enc) return this.pub;
  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex') return this.priv.toString(16, 2);else return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(key, enc || 16); // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method

  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert$3(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' || this.ec.curve.type === 'edwards') {
      assert$3(key.x && key.y, 'Need both x and y coordinate');
    }

    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }

  this.pub = this.ec.curve.decodePoint(key, enc);
}; // ECDH


KeyPair.prototype.derive = function derive(pub) {
  if (!pub.validate()) {
    assert$3(pub.validate(), 'public point not validated');
  }

  return pub.mul(this.priv).getX();
}; // ECDSA


KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) + ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

'use strict';

var assert$4 = utils_1$1.assert;

function Signature(options, enc) {
  if (options instanceof Signature) return options;
  if (this._importDER(options, enc)) return;
  assert$4(options.r && options.s, 'Signature without r or s');
  this.r = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(options.r, 16);
  this.s = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(options.s, 16);
  if (options.recoveryParam === undefined) this.recoveryParam = null;else this.recoveryParam = options.recoveryParam;
}

var signature = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];

  if (!(initial & 0x80)) {
    return initial;
  }

  var octetLen = initial & 0xf; // Indefinite length or overflow

  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  var val = 0;

  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  } // Leading zeroes


  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;

  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }

  if (i === 0) {
    return buf;
  }

  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils_1$1.toArray(data, enc);
  var p = new Position();

  if (data[p.place++] !== 0x30) {
    return false;
  }

  var len = getLength(data, p);

  if (len === false) {
    return false;
  }

  if (len + p.place !== data.length) {
    return false;
  }

  if (data[p.place++] !== 0x02) {
    return false;
  }

  var rlen = getLength(data, p);

  if (rlen === false) {
    return false;
  }

  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;

  if (data[p.place++] !== 0x02) {
    return false;
  }

  var slen = getLength(data, p);

  if (slen === false) {
    return false;
  }

  if (data.length !== slen + p.place) {
    return false;
  }

  var s = data.slice(p.place, slen + p.place);

  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(r);
  this.s = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(s);
  this.recoveryParam = null;
  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }

  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);

  while (--octets) {
    arr.push(len >>> (octets << 3) & 0xff);
  }

  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray(); // Pad values

  if (r[0] & 0x80) r = [0].concat(r); // Pad values

  if (s[0] & 0x80) s = [0].concat(s);
  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }

  var arr = [0x02];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [0x30];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$1.encode(res, enc);
};

'use strict';

var rand =
/*RicMoo:ethers:require(brorand)*/
function () {
  throw new Error('unsupported');
};

var assert$5 = utils_1$1.assert;

function EC(options) {
  if (!(this instanceof EC)) return new EC(options); // Shortcut `elliptic.ec(curve-name)`

  if (typeof options === 'string') {
    assert$5(Object.prototype.hasOwnProperty.call(curves_1, options), 'Unknown curve ' + options);
    options = curves_1[options];
  } // Shortcut for `elliptic.ec(elliptic.curves.curveName)`


  if (options instanceof curves_1.PresetCurve) options = {
    curve: options
  };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g; // Point on curve

  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1); // Hash for function for DRBG

  this.hash = options.hash || options.curve.hash;
}

var ec = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new key(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return key.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return key.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options) options = {}; // Instantiate Hmac_DRBG

  var drbg = new hmacDrbg({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(2));

  for (;;) {
    var priv = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0) continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0) msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0) return msg.sub(this.n);else return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }

  if (!options) options = {};
  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(msg, 16)); // Zero-extend key to provide enough entropy

  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes); // Zero-extend nonce to have the same byte size as N

  var nonce = msg.toArray('be', bytes); // Instantiate Hmac_DRBG

  var drbg = new hmacDrbg({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8'
  }); // Number of bytes to generate

  var ns1 = this.n.sub(new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(1));

  for (var iter = 0;; iter++) {
    var k = options.k ? options.k(iter) : new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0) continue;
    var kp = this.g.mul(k);
    if (kp.isInfinity()) continue;
    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0) continue;
    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0) continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0); // Use complement of `s`, if it is > `n / 2`

    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new signature({
      r: r,
      s: s,
      recoveryParam: recoveryParam
    });
  }
};

EC.prototype.verify = function verify(msg, signature$1, key, enc) {
  msg = this._truncateToN(new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature$1 = new signature(signature$1, 'hex'); // Perform primitive values validation

  var r = signature$1.r;
  var s = signature$1.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0) return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return false; // Validate signature

  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity()) return false;
    return p.getX().umod(this.n).cmp(r) === 0;
  } // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K


  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity()) return false; // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`

  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function (msg, signature$1, j, enc) {
  assert$5((3 & j) === j, 'The recovery param is more than two bits');
  signature$1 = new signature(signature$1, enc);
  var n = this.n;
  var e = new (bn_js__WEBPACK_IMPORTED_MODULE_0___default())(msg);
  var r = signature$1.r;
  var s = signature$1.s; // A set LSB signifies that the y-coordinate is odd

  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey) throw new Error('Unable to find sencond key candinate'); // 1.1. Let x = r + jn.

  if (isSecondKey) r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);else r = this.curve.pointFromX(r, isYOdd);
  var rInv = signature$1.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n); // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)

  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function (e, signature$1, Q, enc) {
  signature$1 = new signature(signature$1, enc);
  if (signature$1.recoveryParam !== null) return signature$1.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;

    try {
      Qprime = this.recoverPubKey(e, signature$1, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q)) return i;
  }

  throw new Error('Unable to find valid recovery factor');
};

var elliptic_1 = createCommonjsModule(function (module, exports) {
  'use strict';

  var elliptic = exports;
  elliptic.version =
  /*RicMoo:ethers*/
  {
    version: "6.5.4"
  }.version;
  elliptic.utils = utils_1$1;

  elliptic.rand =
  /*RicMoo:ethers:require(brorand)*/
  function () {
    throw new Error('unsupported');
  };

  elliptic.curve = curve_1;
  elliptic.curves = curves_1; // Protocols

  elliptic.ec = ec;
  elliptic.eddsa =
  /*RicMoo:ethers:require(./elliptic/eddsa)*/
  null;
});
var EC$1 = elliptic_1.ec;


/***/ }),

/***/ "./node_modules/@ethersproject/signing-key/lib.esm/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersproject/signing-key/lib.esm/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SigningKey": () => (/* binding */ SigningKey),
/* harmony export */   "computePublicKey": () => (/* binding */ computePublicKey),
/* harmony export */   "recoverPublicKey": () => (/* binding */ recoverPublicKey)
/* harmony export */ });
/* harmony import */ var _elliptic__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./elliptic */ "./node_modules/@ethersproject/signing-key/lib.esm/elliptic.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/signing-key/lib.esm/_version.js");







const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
let _curve = null;

function getCurve() {
  if (!_curve) {
    _curve = new _elliptic__WEBPACK_IMPORTED_MODULE_2__.EC("secp256k1");
  }

  return _curve;
}

class SigningKey {
  constructor(privateKey) {
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "curve", "secp256k1");
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "privateKey", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(privateKey));

    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexDataLength)(this.privateKey) !== 32) {
      logger.throwArgumentError("invalid private key", "privateKey", "[[ REDACTED ]]");
    }

    const keyPair = getCurve().keyFromPrivate((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(this.privateKey));
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "publicKey", "0x" + keyPair.getPublic(false, "hex"));
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "compressedPublicKey", "0x" + keyPair.getPublic(true, "hex"));
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__.defineReadOnly)(this, "_isSigningKey", true);
  }

  _addPoint(other) {
    const p0 = getCurve().keyFromPublic((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(this.publicKey));
    const p1 = getCurve().keyFromPublic((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(other));
    return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
  }

  signDigest(digest) {
    const keyPair = getCurve().keyFromPrivate((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(this.privateKey));
    const digestBytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(digest);

    if (digestBytes.length !== 32) {
      logger.throwArgumentError("bad digest length", "digest", digest);
    }

    const signature = keyPair.sign(digestBytes, {
      canonical: true
    });
    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.splitSignature)({
      recoveryParam: signature.recoveryParam,
      r: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexZeroPad)("0x" + signature.r.toString(16), 32),
      s: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexZeroPad)("0x" + signature.s.toString(16), 32)
    });
  }

  computeSharedSecret(otherKey) {
    const keyPair = getCurve().keyFromPrivate((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(this.privateKey));
    const otherKeyPair = getCurve().keyFromPublic((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(computePublicKey(otherKey)));
    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexZeroPad)("0x" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);
  }

  static isSigningKey(value) {
    return !!(value && value._isSigningKey);
  }

}
function recoverPublicKey(digest, signature) {
  const sig = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.splitSignature)(signature);
  const rs = {
    r: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(sig.r),
    s: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(sig.s)
  };
  return "0x" + getCurve().recoverPubKey((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(digest), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key, compressed) {
  const bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.arrayify)(key);

  if (bytes.length === 32) {
    const signingKey = new SigningKey(bytes);

    if (compressed) {
      return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
    }

    return signingKey.publicKey;
  } else if (bytes.length === 33) {
    if (compressed) {
      return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(bytes);
    }

    return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
  } else if (bytes.length === 65) {
    if (!compressed) {
      return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__.hexlify)(bytes);
    }

    return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
  }

  return logger.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}

/***/ }),

/***/ "./node_modules/@ethersproject/solidity/lib.esm/_version.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersproject/solidity/lib.esm/_version.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "solidity/5.6.0";

/***/ }),

/***/ "./node_modules/@ethersproject/solidity/lib.esm/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ethersproject/solidity/lib.esm/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "keccak256": () => (/* binding */ keccak256),
/* harmony export */   "pack": () => (/* binding */ pack),
/* harmony export */   "sha256": () => (/* binding */ sha256)
/* harmony export */ });
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/sha2 */ "./node_modules/@ethersproject/sha2/lib.esm/sha2.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/utf8.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/solidity/lib.esm/_version.js");







const regexBytes = new RegExp("^bytes([0-9]+)$");
const regexNumber = new RegExp("^(u?int)([0-9]*)$");
const regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
const Zeros = "0000000000000000000000000000000000000000000000000000000000000000";


const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);

function _pack(type, value, isArray) {
  switch (type) {
    case "address":
      if (isArray) {
        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.zeroPad)(value, 32);
      }

      return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(value);

    case "string":
      return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(value);

    case "bytes":
      return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(value);

    case "bool":
      value = value ? "0x01" : "0x00";

      if (isArray) {
        return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.zeroPad)(value, 32);
      }

      return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(value);
  }

  let match = type.match(regexNumber);

  if (match) {
    //let signed = (match[1] === "int")
    let size = parseInt(match[2] || "256");

    if (match[2] && String(size) !== match[2] || size % 8 !== 0 || size === 0 || size > 256) {
      logger.throwArgumentError("invalid number type", "type", type);
    }

    if (isArray) {
      size = 256;
    }

    value = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value).toTwos(size);
    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.zeroPad)(value, size / 8);
  }

  match = type.match(regexBytes);

  if (match) {
    const size = parseInt(match[1]);

    if (String(size) !== match[1] || size === 0 || size > 32) {
      logger.throwArgumentError("invalid bytes type", "type", type);
    }

    if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(value).byteLength !== size) {
      logger.throwArgumentError(`invalid value for ${type}`, "value", value);
    }

    if (isArray) {
      return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)((value + Zeros).substring(0, 66));
    }

    return value;
  }

  match = type.match(regexArray);

  if (match && Array.isArray(value)) {
    const baseType = match[1];
    const count = parseInt(match[2] || String(value.length));

    if (count != value.length) {
      logger.throwArgumentError(`invalid array length for ${type}`, "value", value);
    }

    const result = [];
    value.forEach(function (value) {
      result.push(_pack(baseType, value, true));
    });
    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.concat)(result);
  }

  return logger.throwArgumentError("invalid type", "type", type);
} // @TODO: Array Enum


function pack(types, values) {
  if (types.length != values.length) {
    logger.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
  }

  const tight = [];
  types.forEach(function (type, index) {
    tight.push(_pack(type, values[index]));
  });
  return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.concat)(tight));
}
function keccak256(types, values) {
  return (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__.keccak256)(pack(types, values));
}
function sha256(types, values) {
  return (0,_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_6__.sha256)(pack(types, values));
}

/***/ }),

/***/ "./node_modules/@ethersproject/strings/lib.esm/_version.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersproject/strings/lib.esm/_version.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "strings/5.6.0";

/***/ }),

/***/ "./node_modules/@ethersproject/strings/lib.esm/bytes32.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/strings/lib.esm/bytes32.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "formatBytes32String": () => (/* binding */ formatBytes32String),
/* harmony export */   "parseBytes32String": () => (/* binding */ parseBytes32String)
/* harmony export */ });
/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/constants */ "./node_modules/@ethersproject/constants/lib.esm/hashes.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utf8 */ "./node_modules/@ethersproject/strings/lib.esm/utf8.js");





function formatBytes32String(text) {
  // Get the bytes
  const bytes = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes)(text); // Check we have room for null-termination

  if (bytes.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  } // Zero-pad (implicitly null-terminates)


  return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.hexlify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.concat)([bytes, _ethersproject_constants__WEBPACK_IMPORTED_MODULE_2__.HashZero]).slice(0, 32));
}
function parseBytes32String(bytes) {
  const data = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__.arrayify)(bytes); // Must be 32 bytes with a null-termination

  if (data.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }

  if (data[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  } // Find the null termination


  let length = 31;

  while (data[length - 1] === 0) {
    length--;
  } // Determine the string value


  return (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.toUtf8String)(data.slice(0, length));
}

/***/ }),

/***/ "./node_modules/@ethersproject/strings/lib.esm/idna.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/strings/lib.esm/idna.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_nameprepTableA1": () => (/* binding */ _nameprepTableA1),
/* harmony export */   "_nameprepTableB2": () => (/* binding */ _nameprepTableB2),
/* harmony export */   "_nameprepTableC": () => (/* binding */ _nameprepTableC),
/* harmony export */   "nameprep": () => (/* binding */ nameprep)
/* harmony export */ });
/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utf8 */ "./node_modules/@ethersproject/strings/lib.esm/utf8.js");




function bytes2(data) {
  if (data.length % 4 !== 0) {
    throw new Error("bad data");
  }

  let result = [];

  for (let i = 0; i < data.length; i += 4) {
    result.push(parseInt(data.substring(i, i + 4), 16));
  }

  return result;
}

function createTable(data, func) {
  if (!func) {
    func = function (value) {
      return [parseInt(value, 16)];
    };
  }

  let lo = 0;
  let result = {};
  data.split(",").forEach(pair => {
    let comps = pair.split(":");
    lo += parseInt(comps[0], 16);
    result[lo] = func(comps[1]);
  });
  return result;
}

function createRangeTable(data) {
  let hi = 0;
  return data.split(",").map(v => {
    let comps = v.split("-");

    if (comps.length === 1) {
      comps[1] = "0";
    } else if (comps[1] === "") {
      comps[1] = "1";
    }

    let lo = hi + parseInt(comps[0], 16);
    hi = parseInt(comps[1], 16);
    return {
      l: lo,
      h: hi
    };
  });
}

function matchMap(value, ranges) {
  let lo = 0;

  for (let i = 0; i < ranges.length; i++) {
    let range = ranges[i];
    lo += range.l;

    if (value >= lo && value <= lo + range.h && (value - lo) % (range.d || 1) === 0) {
      if (range.e && range.e.indexOf(value - lo) !== -1) {
        continue;
      }

      return range;
    }
  }

  return null;
}

const Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d"); // @TODO: Make this relative...

const Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map(v => parseInt(v, 16));
const Table_B_2_ranges = [{
  h: 25,
  s: 32,
  l: 65
}, {
  h: 30,
  s: 32,
  e: [23],
  l: 127
}, {
  h: 54,
  s: 1,
  e: [48],
  l: 64,
  d: 2
}, {
  h: 14,
  s: 1,
  l: 57,
  d: 2
}, {
  h: 44,
  s: 1,
  l: 17,
  d: 2
}, {
  h: 10,
  s: 1,
  e: [2, 6, 8],
  l: 61,
  d: 2
}, {
  h: 16,
  s: 1,
  l: 68,
  d: 2
}, {
  h: 84,
  s: 1,
  e: [18, 24, 66],
  l: 19,
  d: 2
}, {
  h: 26,
  s: 32,
  e: [17],
  l: 435
}, {
  h: 22,
  s: 1,
  l: 71,
  d: 2
}, {
  h: 15,
  s: 80,
  l: 40
}, {
  h: 31,
  s: 32,
  l: 16
}, {
  h: 32,
  s: 1,
  l: 80,
  d: 2
}, {
  h: 52,
  s: 1,
  l: 42,
  d: 2
}, {
  h: 12,
  s: 1,
  l: 55,
  d: 2
}, {
  h: 40,
  s: 1,
  e: [38],
  l: 15,
  d: 2
}, {
  h: 14,
  s: 1,
  l: 48,
  d: 2
}, {
  h: 37,
  s: 48,
  l: 49
}, {
  h: 148,
  s: 1,
  l: 6351,
  d: 2
}, {
  h: 88,
  s: 1,
  l: 160,
  d: 2
}, {
  h: 15,
  s: 16,
  l: 704
}, {
  h: 25,
  s: 26,
  l: 854
}, {
  h: 25,
  s: 32,
  l: 55915
}, {
  h: 37,
  s: 40,
  l: 1247
}, {
  h: 25,
  s: -119711,
  l: 53248
}, {
  h: 25,
  s: -119763,
  l: 52
}, {
  h: 25,
  s: -119815,
  l: 52
}, {
  h: 25,
  s: -119867,
  e: [1, 4, 5, 7, 8, 11, 12, 17],
  l: 52
}, {
  h: 25,
  s: -119919,
  l: 52
}, {
  h: 24,
  s: -119971,
  e: [2, 7, 8, 17],
  l: 52
}, {
  h: 24,
  s: -120023,
  e: [2, 7, 13, 15, 16, 17],
  l: 52
}, {
  h: 25,
  s: -120075,
  l: 52
}, {
  h: 25,
  s: -120127,
  l: 52
}, {
  h: 25,
  s: -120179,
  l: 52
}, {
  h: 25,
  s: -120231,
  l: 52
}, {
  h: 25,
  s: -120283,
  l: 52
}, {
  h: 25,
  s: -120335,
  l: 52
}, {
  h: 24,
  s: -119543,
  e: [17],
  l: 56
}, {
  h: 24,
  s: -119601,
  e: [17],
  l: 58
}, {
  h: 24,
  s: -119659,
  e: [17],
  l: 58
}, {
  h: 24,
  s: -119717,
  e: [17],
  l: 58
}, {
  h: 24,
  s: -119775,
  e: [17],
  l: 58
}];
const Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
const Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
const Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
const Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");

function flatten(values) {
  return values.reduce((accum, value) => {
    value.forEach(value => {
      accum.push(value);
    });
    return accum;
  }, []);
}

function _nameprepTableA1(codepoint) {
  return !!matchMap(codepoint, Table_A_1_ranges);
}
function _nameprepTableB2(codepoint) {
  let range = matchMap(codepoint, Table_B_2_ranges);

  if (range) {
    return [codepoint + range.s];
  }

  let codes = Table_B_2_lut_abs[codepoint];

  if (codes) {
    return codes;
  }

  let shift = Table_B_2_lut_rel[codepoint];

  if (shift) {
    return [codepoint + shift[0]];
  }

  let complex = Table_B_2_complex[codepoint];

  if (complex) {
    return complex;
  }

  return null;
}
function _nameprepTableC(codepoint) {
  return !!matchMap(codepoint, Table_C_ranges);
}
function nameprep(value) {
  // This allows platforms with incomplete normalize to bypass
  // it for very basic names which the built-in toLowerCase
  // will certainly handle correctly
  if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
    return value.toLowerCase();
  } // Get the code points (keeping the current normalization)


  let codes = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.toUtf8CodePoints)(value);
  codes = flatten(codes.map(code => {
    // Substitute Table B.1 (Maps to Nothing)
    if (Table_B_1_flags.indexOf(code) >= 0) {
      return [];
    }

    if (code >= 0xfe00 && code <= 0xfe0f) {
      return [];
    } // Substitute Table B.2 (Case Folding)


    let codesTableB2 = _nameprepTableB2(code);

    if (codesTableB2) {
      return codesTableB2;
    } // No Substitution


    return [code];
  })); // Normalize using form KC

  codes = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__.toUtf8CodePoints)((0,_utf8__WEBPACK_IMPORTED_MODULE_0__._toUtf8String)(codes), _utf8__WEBPACK_IMPORTED_MODULE_0__.UnicodeNormalizationForm.NFKC); // Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9

  codes.forEach(code => {
    if (_nameprepTableC(code)) {
      throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
    }
  }); // Prohibit Unassigned Code Points (Table A.1)

  codes.forEach(code => {
    if (_nameprepTableA1(code)) {
      throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
    }
  }); // IDNA extras

  let name = (0,_utf8__WEBPACK_IMPORTED_MODULE_0__._toUtf8String)(codes); // IDNA: 4.2.3.1


  if (name.substring(0, 1) === "-" || name.substring(2, 4) === "--" || name.substring(name.length - 1) === "-") {
    throw new Error("invalid hyphen");
  } // IDNA: 4.2.4


  if (name.length > 63) {
    throw new Error("too long");
  }

  return name;
}

/***/ }),

/***/ "./node_modules/@ethersproject/strings/lib.esm/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/strings/lib.esm/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UnicodeNormalizationForm": () => (/* reexport safe */ _utf8__WEBPACK_IMPORTED_MODULE_0__.UnicodeNormalizationForm),
/* harmony export */   "Utf8ErrorFuncs": () => (/* reexport safe */ _utf8__WEBPACK_IMPORTED_MODULE_0__.Utf8ErrorFuncs),
/* harmony export */   "Utf8ErrorReason": () => (/* reexport safe */ _utf8__WEBPACK_IMPORTED_MODULE_0__.Utf8ErrorReason),
/* harmony export */   "_toEscapedUtf8String": () => (/* reexport safe */ _utf8__WEBPACK_IMPORTED_MODULE_0__._toEscapedUtf8String),
/* harmony export */   "formatBytes32String": () => (/* reexport safe */ _bytes32__WEBPACK_IMPORTED_MODULE_1__.formatBytes32String),
/* harmony export */   "nameprep": () => (/* reexport safe */ _idna__WEBPACK_IMPORTED_MODULE_2__.nameprep),
/* harmony export */   "parseBytes32String": () => (/* reexport safe */ _bytes32__WEBPACK_IMPORTED_MODULE_1__.parseBytes32String),
/* harmony export */   "toUtf8Bytes": () => (/* reexport safe */ _utf8__WEBPACK_IMPORTED_MODULE_0__.toUtf8Bytes),
/* harmony export */   "toUtf8CodePoints": () => (/* reexport safe */ _utf8__WEBPACK_IMPORTED_MODULE_0__.toUtf8CodePoints),
/* harmony export */   "toUtf8String": () => (/* reexport safe */ _utf8__WEBPACK_IMPORTED_MODULE_0__.toUtf8String)
/* harmony export */ });
/* harmony import */ var _bytes32__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bytes32 */ "./node_modules/@ethersproject/strings/lib.esm/bytes32.js");
/* harmony import */ var _idna__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./idna */ "./node_modules/@ethersproject/strings/lib.esm/idna.js");
/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utf8 */ "./node_modules/@ethersproject/strings/lib.esm/utf8.js");







/***/ }),

/***/ "./node_modules/@ethersproject/strings/lib.esm/utf8.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/strings/lib.esm/utf8.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "UnicodeNormalizationForm": () => (/* binding */ UnicodeNormalizationForm),
/* harmony export */   "Utf8ErrorFuncs": () => (/* binding */ Utf8ErrorFuncs),
/* harmony export */   "Utf8ErrorReason": () => (/* binding */ Utf8ErrorReason),
/* harmony export */   "_toEscapedUtf8String": () => (/* binding */ _toEscapedUtf8String),
/* harmony export */   "_toUtf8String": () => (/* binding */ _toUtf8String),
/* harmony export */   "toUtf8Bytes": () => (/* binding */ toUtf8Bytes),
/* harmony export */   "toUtf8CodePoints": () => (/* binding */ toUtf8CodePoints),
/* harmony export */   "toUtf8String": () => (/* binding */ toUtf8String)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/strings/lib.esm/_version.js");





const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version); ///////////////////////////////

var UnicodeNormalizationForm;

(function (UnicodeNormalizationForm) {
  UnicodeNormalizationForm["current"] = "";
  UnicodeNormalizationForm["NFC"] = "NFC";
  UnicodeNormalizationForm["NFD"] = "NFD";
  UnicodeNormalizationForm["NFKC"] = "NFKC";
  UnicodeNormalizationForm["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));

;
var Utf8ErrorReason;

(function (Utf8ErrorReason) {
  // A continuation byte was present where there was nothing to continue
  // - offset = the index the codepoint began in
  Utf8ErrorReason["UNEXPECTED_CONTINUE"] = "unexpected continuation byte"; // An invalid (non-continuation) byte to start a UTF-8 codepoint was found
  // - offset = the index the codepoint began in

  Utf8ErrorReason["BAD_PREFIX"] = "bad codepoint prefix"; // The string is too short to process the expected codepoint
  // - offset = the index the codepoint began in

  Utf8ErrorReason["OVERRUN"] = "string overrun"; // A missing continuation byte was expected but not found
  // - offset = the index the continuation byte was expected at

  Utf8ErrorReason["MISSING_CONTINUE"] = "missing continuation byte"; // The computed code point is outside the range for UTF-8
  // - offset       = start of this codepoint
  // - badCodepoint = the computed codepoint; outside the UTF-8 range

  Utf8ErrorReason["OUT_OF_RANGE"] = "out of UTF-8 range"; // UTF-8 strings may not contain UTF-16 surrogate pairs
  // - offset       = start of this codepoint
  // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range

  Utf8ErrorReason["UTF16_SURROGATE"] = "UTF-16 surrogate"; // The string is an overlong representation
  // - offset       = start of this codepoint
  // - badCodepoint = the computed codepoint; already bounds checked

  Utf8ErrorReason["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));

;

function errorFunc(reason, offset, bytes, output, badCodepoint) {
  return logger.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}

function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
  // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
  if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
    let i = 0;

    for (let o = offset + 1; o < bytes.length; o++) {
      if (bytes[o] >> 6 !== 0x02) {
        break;
      }

      i++;
    }

    return i;
  } // This byte runs us past the end of the string, so just jump to the end
  // (but the first byte was read already read and therefore skipped)


  if (reason === Utf8ErrorReason.OVERRUN) {
    return bytes.length - offset - 1;
  } // Nothing to skip


  return 0;
}

function replaceFunc(reason, offset, bytes, output, badCodepoint) {
  // Overlong representations are otherwise "valid" code points; just non-deistingtished
  if (reason === Utf8ErrorReason.OVERLONG) {
    output.push(badCodepoint);
    return 0;
  } // Put the replacement character into the output


  output.push(0xfffd); // Otherwise, process as if ignoring errors

  return ignoreFunc(reason, offset, bytes, output, badCodepoint);
} // Common error handing strategies


const Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
}); // http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499

function getUtf8CodePoints(bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }

  bytes = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(bytes);
  const result = [];
  let i = 0; // Invalid bytes are ignored

  while (i < bytes.length) {
    const c = bytes[i++]; // 0xxx xxxx

    if (c >> 7 === 0) {
      result.push(c);
      continue;
    } // Multibyte; how many bytes left for this character?


    let extraLength = null;
    let overlongMask = null; // 110x xxxx 10xx xxxx

    if ((c & 0xe0) === 0xc0) {
      extraLength = 1;
      overlongMask = 0x7f; // 1110 xxxx 10xx xxxx 10xx xxxx
    } else if ((c & 0xf0) === 0xe0) {
      extraLength = 2;
      overlongMask = 0x7ff; // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
    } else if ((c & 0xf8) === 0xf0) {
      extraLength = 3;
      overlongMask = 0xffff;
    } else {
      if ((c & 0xc0) === 0x80) {
        i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);
      } else {
        i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);
      }

      continue;
    } // Do we have enough bytes in our data?


    if (i - 1 + extraLength >= bytes.length) {
      i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);
      continue;
    } // Remove the length prefix from the char


    let res = c & (1 << 8 - extraLength - 1) - 1;

    for (let j = 0; j < extraLength; j++) {
      let nextChar = bytes[i]; // Invalid continuation byte

      if ((nextChar & 0xc0) != 0x80) {
        i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);
        res = null;
        break;
      }

      ;
      res = res << 6 | nextChar & 0x3f;
      i++;
    } // See above loop for invalid continuation byte


    if (res === null) {
      continue;
    } // Maximum code point


    if (res > 0x10ffff) {
      i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
      continue;
    } // Reserved for UTF-16 surrogate halves


    if (res >= 0xd800 && res <= 0xdfff) {
      i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
      continue;
    } // Check for overlong sequences (more bytes than needed)


    if (res <= overlongMask) {
      i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);
      continue;
    }

    result.push(res);
  }

  return result;
} // http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array


function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
  if (form != UnicodeNormalizationForm.current) {
    logger.checkNormalize();
    str = str.normalize(form);
  }

  let result = [];

  for (let i = 0; i < str.length; i++) {
    const c = str.charCodeAt(i);

    if (c < 0x80) {
      result.push(c);
    } else if (c < 0x800) {
      result.push(c >> 6 | 0xc0);
      result.push(c & 0x3f | 0x80);
    } else if ((c & 0xfc00) == 0xd800) {
      i++;
      const c2 = str.charCodeAt(i);

      if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {
        throw new Error("invalid utf-8 string");
      } // Surrogate Pair


      const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
      result.push(pair >> 18 | 0xf0);
      result.push(pair >> 12 & 0x3f | 0x80);
      result.push(pair >> 6 & 0x3f | 0x80);
      result.push(pair & 0x3f | 0x80);
    } else {
      result.push(c >> 12 | 0xe0);
      result.push(c >> 6 & 0x3f | 0x80);
      result.push(c & 0x3f | 0x80);
    }
  }

  return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)(result);
}
;

function escapeChar(value) {
  const hex = "0000" + value.toString(16);
  return "\\u" + hex.substring(hex.length - 4);
}

function _toEscapedUtf8String(bytes, onError) {
  return '"' + getUtf8CodePoints(bytes, onError).map(codePoint => {
    if (codePoint < 256) {
      switch (codePoint) {
        case 8:
          return "\\b";

        case 9:
          return "\\t";

        case 10:
          return "\\n";

        case 13:
          return "\\r";

        case 34:
          return "\\\"";

        case 92:
          return "\\\\";
      }

      if (codePoint >= 32 && codePoint < 127) {
        return String.fromCharCode(codePoint);
      }
    }

    if (codePoint <= 0xffff) {
      return escapeChar(codePoint);
    }

    codePoint -= 0x10000;
    return escapeChar((codePoint >> 10 & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);
  }).join("") + '"';
}
function _toUtf8String(codePoints) {
  return codePoints.map(codePoint => {
    if (codePoint <= 0xffff) {
      return String.fromCharCode(codePoint);
    }

    codePoint -= 0x10000;
    return String.fromCharCode((codePoint >> 10 & 0x3ff) + 0xd800, (codePoint & 0x3ff) + 0xdc00);
  }).join("");
}
function toUtf8String(bytes, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}

/***/ }),

/***/ "./node_modules/@ethersproject/transactions/lib.esm/_version.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@ethersproject/transactions/lib.esm/_version.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "transactions/5.6.0";

/***/ }),

/***/ "./node_modules/@ethersproject/transactions/lib.esm/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersproject/transactions/lib.esm/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TransactionTypes": () => (/* binding */ TransactionTypes),
/* harmony export */   "accessListify": () => (/* binding */ accessListify),
/* harmony export */   "computeAddress": () => (/* binding */ computeAddress),
/* harmony export */   "parse": () => (/* binding */ parse),
/* harmony export */   "recoverAddress": () => (/* binding */ recoverAddress),
/* harmony export */   "serialize": () => (/* binding */ serialize)
/* harmony export */ });
/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/address */ "./node_modules/@ethersproject/address/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/constants */ "./node_modules/@ethersproject/constants/lib.esm/bignumbers.js");
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/rlp */ "./node_modules/@ethersproject/rlp/lib.esm/index.js");
/* harmony import */ var _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/signing-key */ "./node_modules/@ethersproject/signing-key/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/transactions/lib.esm/_version.js");












const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
var TransactionTypes;

(function (TransactionTypes) {
  TransactionTypes[TransactionTypes["legacy"] = 0] = "legacy";
  TransactionTypes[TransactionTypes["eip2930"] = 1] = "eip2930";
  TransactionTypes[TransactionTypes["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));

; ///////////////////////////////

function handleAddress(value) {
  if (value === "0x") {
    return null;
  }

  return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(value);
}

function handleNumber(value) {
  if (value === "0x") {
    return _ethersproject_constants__WEBPACK_IMPORTED_MODULE_3__.Zero;
  }

  return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value);
} // Legacy Transaction Fields


const transactionFields = [{
  name: "nonce",
  maxLength: 32,
  numeric: true
}, {
  name: "gasPrice",
  maxLength: 32,
  numeric: true
}, {
  name: "gasLimit",
  maxLength: 32,
  numeric: true
}, {
  name: "to",
  length: 20
}, {
  name: "value",
  maxLength: 32,
  numeric: true
}, {
  name: "data"
}];
const allowedTransactionKeys = {
  chainId: true,
  data: true,
  gasLimit: true,
  gasPrice: true,
  nonce: true,
  to: true,
  type: true,
  value: true
};
function computeAddress(key) {
  const publicKey = (0,_ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_5__.computePublicKey)(key);
  return (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexDataSlice)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexDataSlice)(publicKey, 1)), 12));
}
function recoverAddress(digest, signature) {
  return computeAddress((0,_ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_5__.recoverPublicKey)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(digest), signature));
}

function formatNumber(value, name) {
  const result = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(value).toHexString());

  if (result.length > 32) {
    logger.throwArgumentError("invalid length for " + name, "transaction:" + name, value);
  }

  return result;
}

function accessSetify(addr, storageKeys) {
  return {
    address: (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(addr),
    storageKeys: (storageKeys || []).map((storageKey, index) => {
      if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexDataLength)(storageKey) !== 32) {
        logger.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index}]`, storageKey);
      }

      return storageKey.toLowerCase();
    })
  };
}

function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set, index) => {
      if (Array.isArray(set)) {
        if (set.length > 2) {
          logger.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index}]`, set);
        }

        return accessSetify(set[0], set[1]);
      }

      return accessSetify(set.address, set.storageKeys);
    });
  }

  const result = Object.keys(value).map(addr => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a, b) => a.address.localeCompare(b.address));
  return result;
}

function formatAccessList(value) {
  return accessListify(value).map(set => [set.address, set.storageKeys]);
}

function _serializeEip1559(transaction, signature) {
  // If there is an explicit gasPrice, make sure it matches the
  // EIP-1559 fees; otherwise they may not understand what they
  // think they are setting in terms of fee.
  if (transaction.gasPrice != null) {
    const gasPrice = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction.gasPrice);
    const maxFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction.maxFeePerGas || 0);

    if (!gasPrice.eq(maxFeePerGas)) {
      logger.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
        gasPrice,
        maxFeePerGas
      });
    }
  }

  const fields = [formatNumber(transaction.chainId || 0, "chainId"), formatNumber(transaction.nonce || 0, "nonce"), formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"), formatNumber(transaction.gasLimit || 0, "gasLimit"), transaction.to != null ? (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(transaction.to) : "0x", formatNumber(transaction.value || 0, "value"), transaction.data || "0x", formatAccessList(transaction.accessList || [])];

  if (signature) {
    const sig = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.splitSignature)(signature);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(sig.r));
    fields.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(sig.s));
  }

  return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexConcat)(["0x02", _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(fields)]);
}

function _serializeEip2930(transaction, signature) {
  const fields = [formatNumber(transaction.chainId || 0, "chainId"), formatNumber(transaction.nonce || 0, "nonce"), formatNumber(transaction.gasPrice || 0, "gasPrice"), formatNumber(transaction.gasLimit || 0, "gasLimit"), transaction.to != null ? (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__.getAddress)(transaction.to) : "0x", formatNumber(transaction.value || 0, "value"), transaction.data || "0x", formatAccessList(transaction.accessList || [])];

  if (signature) {
    const sig = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.splitSignature)(signature);
    fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
    fields.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(sig.r));
    fields.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(sig.s));
  }

  return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexConcat)(["0x01", _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(fields)]);
} // Legacy Transactions and EIP-155


function _serialize(transaction, signature) {
  (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_9__.checkProperties)(transaction, allowedTransactionKeys);
  const raw = [];
  transactionFields.forEach(function (fieldInfo) {
    let value = transaction[fieldInfo.name] || [];
    const options = {};

    if (fieldInfo.numeric) {
      options.hexPad = "left";
    }

    value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(value, options)); // Fixed-width field

    if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
      logger.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
    } // Variable-width (with a maximum)


    if (fieldInfo.maxLength) {
      value = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)(value);

      if (value.length > fieldInfo.maxLength) {
        logger.throwArgumentError("invalid length for " + fieldInfo.name, "transaction:" + fieldInfo.name, value);
      }
    }

    raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(value));
  });
  let chainId = 0;

  if (transaction.chainId != null) {
    // A chainId was provided; if non-zero we'll use EIP-155
    chainId = transaction.chainId;

    if (typeof chainId !== "number") {
      logger.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
    }
  } else if (signature && !(0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.isBytesLike)(signature) && signature.v > 28) {
    // No chainId provided, but the signature is signing with EIP-155; derive chainId
    chainId = Math.floor((signature.v - 35) / 2);
  } // We have an EIP-155 transaction (chainId was specified and non-zero)


  if (chainId !== 0) {
    raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(chainId)); // @TODO: hexValue?

    raw.push("0x");
    raw.push("0x");
  } // Requesting an unsigned transaction


  if (!signature) {
    return _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(raw);
  } // The splitSignature will ensure the transaction has a recoveryParam in the
  // case that the signTransaction function only adds a v.


  const sig = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.splitSignature)(signature); // We pushed a chainId and null r, s on for hashing only; remove those

  let v = 27 + sig.recoveryParam;

  if (chainId !== 0) {
    raw.pop();
    raw.pop();
    raw.pop();
    v += chainId * 2 + 8; // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!

    if (sig.v > 28 && sig.v !== v) {
      logger.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
    }
  } else if (sig.v !== v) {
    logger.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
  }

  raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(v));
  raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(sig.r)));
  raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.stripZeros)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(sig.s)));
  return _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(raw);
}

function serialize(transaction, signature) {
  // Legacy and EIP-155 Transactions
  if (transaction.type == null || transaction.type === 0) {
    if (transaction.accessList != null) {
      logger.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
    }

    return _serialize(transaction, signature);
  } // Typed Transactions (EIP-2718)


  switch (transaction.type) {
    case 1:
      return _serializeEip2930(transaction, signature);

    case 2:
      return _serializeEip1559(transaction, signature);

    default:
      break;
  }

  return logger.throwError(`unsupported transaction type: ${transaction.type}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "serializeTransaction",
    transactionType: transaction.type
  });
}

function _parseEipSignature(tx, fields, serialize) {
  try {
    const recid = handleNumber(fields[0]).toNumber();

    if (recid !== 0 && recid !== 1) {
      throw new Error("bad recid");
    }

    tx.v = recid;
  } catch (error) {
    logger.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
  }

  tx.r = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexZeroPad)(fields[1], 32);
  tx.s = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexZeroPad)(fields[2], 32);

  try {
    const digest = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(serialize(tx));
    tx.from = recoverAddress(digest, {
      r: tx.r,
      s: tx.s,
      recoveryParam: tx.v
    });
  } catch (error) {
    console.log(error);
  }
}

function _parseEip1559(payload) {
  const transaction = _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.decode(payload.slice(1));

  if (transaction.length !== 9 && transaction.length !== 12) {
    logger.throwArgumentError("invalid component count for transaction type: 2", "payload", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(payload));
  }

  const maxPriorityFeePerGas = handleNumber(transaction[2]);
  const maxFeePerGas = handleNumber(transaction[3]);
  const tx = {
    type: 2,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    maxPriorityFeePerGas: maxPriorityFeePerGas,
    maxFeePerGas: maxFeePerGas,
    gasPrice: null,
    gasLimit: handleNumber(transaction[4]),
    to: handleAddress(transaction[5]),
    value: handleNumber(transaction[6]),
    data: transaction[7],
    accessList: accessListify(transaction[8])
  }; // Unsigned EIP-1559 Transaction

  if (transaction.length === 9) {
    return tx;
  }

  tx.hash = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(payload);

  _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);

  return tx;
}

function _parseEip2930(payload) {
  const transaction = _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.decode(payload.slice(1));

  if (transaction.length !== 8 && transaction.length !== 11) {
    logger.throwArgumentError("invalid component count for transaction type: 1", "payload", (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(payload));
  }

  const tx = {
    type: 1,
    chainId: handleNumber(transaction[0]).toNumber(),
    nonce: handleNumber(transaction[1]).toNumber(),
    gasPrice: handleNumber(transaction[2]),
    gasLimit: handleNumber(transaction[3]),
    to: handleAddress(transaction[4]),
    value: handleNumber(transaction[5]),
    data: transaction[6],
    accessList: accessListify(transaction[7])
  }; // Unsigned EIP-2930 Transaction

  if (transaction.length === 8) {
    return tx;
  }

  tx.hash = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(payload);

  _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);

  return tx;
} // Legacy Transactions and EIP-155


function _parse(rawTransaction) {
  const transaction = _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.decode(rawTransaction);

  if (transaction.length !== 9 && transaction.length !== 6) {
    logger.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
  }

  const tx = {
    nonce: handleNumber(transaction[0]).toNumber(),
    gasPrice: handleNumber(transaction[1]),
    gasLimit: handleNumber(transaction[2]),
    to: handleAddress(transaction[3]),
    value: handleNumber(transaction[4]),
    data: transaction[5],
    chainId: 0
  }; // Legacy unsigned transaction

  if (transaction.length === 6) {
    return tx;
  }

  try {
    tx.v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(transaction[6]).toNumber();
  } catch (error) {
    console.log(error);
    return tx;
  }

  tx.r = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexZeroPad)(transaction[7], 32);
  tx.s = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexZeroPad)(transaction[8], 32);

  if (_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(tx.r).isZero() && _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__.BigNumber.from(tx.s).isZero()) {
    // EIP-155 unsigned transaction
    tx.chainId = tx.v;
    tx.v = 0;
  } else {
    // Signed Transaction
    tx.chainId = Math.floor((tx.v - 35) / 2);

    if (tx.chainId < 0) {
      tx.chainId = 0;
    }

    let recoveryParam = tx.v - 27;
    const raw = transaction.slice(0, 6);

    if (tx.chainId !== 0) {
      raw.push((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(tx.chainId));
      raw.push("0x");
      raw.push("0x");
      recoveryParam -= tx.chainId * 2 + 8;
    }

    const digest = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(_ethersproject_rlp__WEBPACK_IMPORTED_MODULE_8__.encode(raw));

    try {
      tx.from = recoverAddress(digest, {
        r: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(tx.r),
        s: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.hexlify)(tx.s),
        recoveryParam: recoveryParam
      });
    } catch (error) {
      console.log(error);
    }

    tx.hash = (0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_7__.keccak256)(rawTransaction);
  }

  tx.type = null;
  return tx;
}

function parse(rawTransaction) {
  const payload = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_6__.arrayify)(rawTransaction); // Legacy and EIP-155 Transactions

  if (payload[0] > 0x7f) {
    return _parse(payload);
  } // Typed Transaction (EIP-2718)


  switch (payload[0]) {
    case 1:
      return _parseEip2930(payload);

    case 2:
      return _parseEip1559(payload);

    default:
      break;
  }

  return logger.throwError(`unsupported transaction type: ${payload[0]}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
    operation: "parseTransaction",
    transactionType: payload[0]
  });
}

/***/ }),

/***/ "./node_modules/@ethersproject/units/lib.esm/_version.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ethersproject/units/lib.esm/_version.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "units/5.6.0";

/***/ }),

/***/ "./node_modules/@ethersproject/units/lib.esm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@ethersproject/units/lib.esm/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "commify": () => (/* binding */ commify),
/* harmony export */   "formatEther": () => (/* binding */ formatEther),
/* harmony export */   "formatUnits": () => (/* binding */ formatUnits),
/* harmony export */   "parseEther": () => (/* binding */ parseEther),
/* harmony export */   "parseUnits": () => (/* binding */ parseUnits)
/* harmony export */ });
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/units/lib.esm/_version.js");





const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
const names = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"]; // Some environments have issues with RegEx that contain back-tracking, so we cannot
// use them.

function commify(value) {
  const comps = String(value).split(".");

  if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || comps[1] && !comps[1].match(/^[0-9]*$/) || value === "." || value === "-.") {
    logger.throwArgumentError("invalid value", "value", value);
  } // Make sure we have at least one whole digit (0 if none)


  let whole = comps[0];
  let negative = "";

  if (whole.substring(0, 1) === "-") {
    negative = "-";
    whole = whole.substring(1);
  } // Make sure we have at least 1 whole digit with no leading zeros


  while (whole.substring(0, 1) === "0") {
    whole = whole.substring(1);
  }

  if (whole === "") {
    whole = "0";
  }

  let suffix = "";

  if (comps.length === 2) {
    suffix = "." + (comps[1] || "0");
  }

  while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
    suffix = suffix.substring(0, suffix.length - 1);
  }

  const formatted = [];

  while (whole.length) {
    if (whole.length <= 3) {
      formatted.unshift(whole);
      break;
    } else {
      const index = whole.length - 3;
      formatted.unshift(whole.substring(index));
      whole = whole.substring(0, index);
    }
  }

  return negative + formatted.join(",") + suffix;
}
function formatUnits(value, unitName) {
  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);

    if (index !== -1) {
      unitName = 3 * index;
    }
  }

  return (0,_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.formatFixed)(value, unitName != null ? unitName : 18);
}
function parseUnits(value, unitName) {
  if (typeof value !== "string") {
    logger.throwArgumentError("value must be a string", "value", value);
  }

  if (typeof unitName === "string") {
    const index = names.indexOf(unitName);

    if (index !== -1) {
      unitName = 3 * index;
    }
  }

  return (0,_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__.parseFixed)(value, unitName != null ? unitName : 18);
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits(ether, 18);
}

/***/ }),

/***/ "./node_modules/@ethersproject/wallet/lib.esm/_version.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/wallet/lib.esm/_version.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "wallet/5.6.0";

/***/ }),

/***/ "./node_modules/@ethersproject/wallet/lib.esm/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/wallet/lib.esm/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Wallet": () => (/* binding */ Wallet),
/* harmony export */   "verifyMessage": () => (/* binding */ verifyMessage),
/* harmony export */   "verifyTypedData": () => (/* binding */ verifyTypedData)
/* harmony export */ });
/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/address */ "./node_modules/@ethersproject/address/lib.esm/index.js");
/* harmony import */ var _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/abstract-provider */ "./node_modules/@ethersproject/abstract-provider/lib.esm/index.js");
/* harmony import */ var _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/abstract-signer */ "./node_modules/@ethersproject/abstract-signer/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @ethersproject/hash */ "./node_modules/@ethersproject/hash/lib.esm/message.js");
/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @ethersproject/hash */ "./node_modules/@ethersproject/hash/lib.esm/typed-data.js");
/* harmony import */ var _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/hdnode */ "./node_modules/@ethersproject/hdnode/lib.esm/index.js");
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_random__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @ethersproject/random */ "./node_modules/@ethersproject/random/lib.esm/random.js");
/* harmony import */ var _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/signing-key */ "./node_modules/@ethersproject/signing-key/lib.esm/index.js");
/* harmony import */ var _ethersproject_json_wallets__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @ethersproject/json-wallets */ "./node_modules/@ethersproject/json-wallets/lib.esm/keystore.js");
/* harmony import */ var _ethersproject_json_wallets__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @ethersproject/json-wallets */ "./node_modules/@ethersproject/json-wallets/lib.esm/index.js");
/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/transactions */ "./node_modules/@ethersproject/transactions/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/wallet/lib.esm/_version.js");


var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};















const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);

function isAccount(value) {
  return value != null && (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isHexString)(value.privateKey, 32) && value.address != null;
}

function hasMnemonic(value) {
  const mnemonic = value.mnemonic;
  return mnemonic && mnemonic.phrase;
}

class Wallet extends _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_3__.Signer {
  constructor(privateKey, provider) {
    logger.checkNew(new.target, Wallet);
    super();

    if (isAccount(privateKey)) {
      const signingKey = new _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_4__.SigningKey(privateKey.privateKey);
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, "_signingKey", () => signingKey);
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, "address", (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_6__.computeAddress)(this.publicKey));

      if (this.address !== (0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_7__.getAddress)(privateKey.address)) {
        logger.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
      }

      if (hasMnemonic(privateKey)) {
        const srcMnemonic = privateKey.mnemonic;
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, "_mnemonic", () => ({
          phrase: srcMnemonic.phrase,
          path: srcMnemonic.path || _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_8__.defaultPath,
          locale: srcMnemonic.locale || "en"
        }));
        const mnemonic = this.mnemonic;
        const node = _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_8__.HDNode.fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);

        if ((0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_6__.computeAddress)(node.privateKey) !== this.address) {
          logger.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
        }
      } else {
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, "_mnemonic", () => null);
      }
    } else {
      if (_ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_4__.SigningKey.isSigningKey(privateKey)) {
        /* istanbul ignore if */
        if (privateKey.curve !== "secp256k1") {
          logger.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
        }

        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, "_signingKey", () => privateKey);
      } else {
        // A lot of common tools do not prefix private keys with a 0x (see: #1166)
        if (typeof privateKey === "string") {
          if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
            privateKey = "0x" + privateKey;
          }
        }

        const signingKey = new _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_4__.SigningKey(privateKey);
        (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, "_signingKey", () => signingKey);
      }

      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, "_mnemonic", () => null);
      (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, "address", (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_6__.computeAddress)(this.publicKey));
    }
    /* istanbul ignore if */


    if (provider && !_ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_9__.Provider.isProvider(provider)) {
      logger.throwArgumentError("invalid provider", "provider", provider);
    }

    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.defineReadOnly)(this, "provider", provider || null);
  }

  get mnemonic() {
    return this._mnemonic();
  }

  get privateKey() {
    return this._signingKey().privateKey;
  }

  get publicKey() {
    return this._signingKey().publicKey;
  }

  getAddress() {
    return Promise.resolve(this.address);
  }

  connect(provider) {
    return new Wallet(this, provider);
  }

  signTransaction(transaction) {
    return (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__.resolveProperties)(transaction).then(tx => {
      if (tx.from != null) {
        if ((0,_ethersproject_address__WEBPACK_IMPORTED_MODULE_7__.getAddress)(tx.from) !== this.address) {
          logger.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
        }

        delete tx.from;
      }

      const signature = this._signingKey().signDigest((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_10__.keccak256)((0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_6__.serialize)(tx)));

      return (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_6__.serialize)(tx, signature);
    });
  }

  signMessage(message) {
    return __awaiter(this, void 0, void 0, function* () {
      return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.joinSignature)(this._signingKey().signDigest((0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_11__.hashMessage)(message)));
    });
  }

  _signTypedData(domain, types, value) {
    return __awaiter(this, void 0, void 0, function* () {
      // Populate any ENS names
      const populated = yield _ethersproject_hash__WEBPACK_IMPORTED_MODULE_12__.TypedDataEncoder.resolveNames(domain, types, value, name => {
        if (this.provider == null) {
          logger.throwError("cannot resolve ENS names without a provider", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "resolveName",
            value: name
          });
        }

        return this.provider.resolveName(name);
      });
      return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.joinSignature)(this._signingKey().signDigest(_ethersproject_hash__WEBPACK_IMPORTED_MODULE_12__.TypedDataEncoder.hash(populated.domain, types, populated.value)));
    });
  }

  encrypt(password, options, progressCallback) {
    if (typeof options === "function" && !progressCallback) {
      progressCallback = options;
      options = {};
    }

    if (progressCallback && typeof progressCallback !== "function") {
      throw new Error("invalid callback");
    }

    if (!options) {
      options = {};
    }

    return (0,_ethersproject_json_wallets__WEBPACK_IMPORTED_MODULE_13__.encrypt)(this, password, options, progressCallback);
  }
  /**
   *  Static methods to create Wallet instances.
   */


  static createRandom(options) {
    let entropy = (0,_ethersproject_random__WEBPACK_IMPORTED_MODULE_14__.randomBytes)(16);

    if (!options) {
      options = {};
    }

    if (options.extraEntropy) {
      entropy = (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.arrayify)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexDataSlice)((0,_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_10__.keccak256)((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.concat)([entropy, options.extraEntropy])), 0, 16));
    }

    const mnemonic = (0,_ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_8__.entropyToMnemonic)(entropy, options.locale);
    return Wallet.fromMnemonic(mnemonic, options.path, options.locale);
  }

  static fromEncryptedJson(json, password, progressCallback) {
    return (0,_ethersproject_json_wallets__WEBPACK_IMPORTED_MODULE_15__.decryptJsonWallet)(json, password, progressCallback).then(account => {
      return new Wallet(account);
    });
  }

  static fromEncryptedJsonSync(json, password) {
    return new Wallet((0,_ethersproject_json_wallets__WEBPACK_IMPORTED_MODULE_15__.decryptJsonWalletSync)(json, password));
  }

  static fromMnemonic(mnemonic, path, wordlist) {
    if (!path) {
      path = _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_8__.defaultPath;
    }

    return new Wallet(_ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_8__.HDNode.fromMnemonic(mnemonic, null, wordlist).derivePath(path));
  }

}
function verifyMessage(message, signature) {
  return (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_6__.recoverAddress)((0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_11__.hashMessage)(message), signature);
}
function verifyTypedData(domain, types, value, signature) {
  return (0,_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_6__.recoverAddress)(_ethersproject_hash__WEBPACK_IMPORTED_MODULE_12__.TypedDataEncoder.hash(domain, types, value), signature);
}

/***/ }),

/***/ "./node_modules/@ethersproject/web/lib.esm/_version.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/web/lib.esm/_version.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "web/5.6.0";

/***/ }),

/***/ "./node_modules/@ethersproject/web/lib.esm/geturl.js":
/*!***********************************************************!*\
  !*** ./node_modules/@ethersproject/web/lib.esm/geturl.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getUrl": () => (/* binding */ getUrl)
/* harmony export */ });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");


var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};


function getUrl(href, options) {
  return __awaiter(this, void 0, void 0, function* () {
    if (options == null) {
      options = {};
    }

    const request = {
      method: options.method || "GET",
      headers: options.headers || {},
      body: options.body || undefined
    };

    if (options.skipFetchSetup !== true) {
      request.mode = "cors"; // no-cors, cors, *same-origin

      request.cache = "no-cache"; // *default, no-cache, reload, force-cache, only-if-cached

      request.credentials = "same-origin"; // include, *same-origin, omit

      request.redirect = "follow"; // manual, *follow, error

      request.referrer = "client"; // no-referrer, *client
    }

    ;
    const response = yield fetch(href, request);
    const body = yield response.arrayBuffer();
    const headers = {};

    if (response.headers.forEach) {
      response.headers.forEach((value, key) => {
        headers[key.toLowerCase()] = value;
      });
    } else {
      response.headers.keys().forEach(key => {
        headers[key.toLowerCase()] = response.headers.get(key);
      });
    }

    return {
      headers: headers,
      statusCode: response.status,
      statusMessage: response.statusText,
      body: (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__.arrayify)(new Uint8Array(body))
    };
  });
}

/***/ }),

/***/ "./node_modules/@ethersproject/web/lib.esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@ethersproject/web/lib.esm/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "_fetchData": () => (/* binding */ _fetchData),
/* harmony export */   "fetchJson": () => (/* binding */ fetchJson),
/* harmony export */   "poll": () => (/* binding */ poll)
/* harmony export */ });
/* harmony import */ var _ethersproject_base64__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/base64 */ "./node_modules/@ethersproject/base64/lib.esm/base64.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/utf8.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/web/lib.esm/_version.js");
/* harmony import */ var _geturl__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./geturl */ "./node_modules/@ethersproject/web/lib.esm/geturl.js");


var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};







const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);


function staller(duration) {
  return new Promise(resolve => {
    setTimeout(resolve, duration);
  });
}

function bodyify(value, type) {
  if (value == null) {
    return null;
  }

  if (typeof value === "string") {
    return value;
  }

  if ((0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.isBytesLike)(value)) {
    if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
      try {
        return (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8String)(value);
      } catch (error) {}

      ;
    }

    return (0,_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__.hexlify)(value);
  }

  return value;
} // This API is still a work in progress; the future changes will likely be:
// - ConnectionInfo => FetchDataRequest<T = any>
// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }
//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)
// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T
// For this reason, it should be considered internal until the API is finalized


function _fetchData(connection, body, processFunc) {
  // How many times to retry in the event of a throttle
  const attemptLimit = typeof connection === "object" && connection.throttleLimit != null ? connection.throttleLimit : 12;
  logger.assertArgument(attemptLimit > 0 && attemptLimit % 1 === 0, "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
  const throttleCallback = typeof connection === "object" ? connection.throttleCallback : null;
  const throttleSlotInterval = typeof connection === "object" && typeof connection.throttleSlotInterval === "number" ? connection.throttleSlotInterval : 100;
  logger.assertArgument(throttleSlotInterval > 0 && throttleSlotInterval % 1 === 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
  const errorPassThrough = typeof connection === "object" ? !!connection.errorPassThrough : false;
  const headers = {};
  let url = null; // @TODO: Allow ConnectionInfo to override some of these values

  const options = {
    method: "GET"
  };
  let allow304 = false;
  let timeout = 2 * 60 * 1000;

  if (typeof connection === "string") {
    url = connection;
  } else if (typeof connection === "object") {
    if (connection == null || connection.url == null) {
      logger.throwArgumentError("missing URL", "connection.url", connection);
    }

    url = connection.url;

    if (typeof connection.timeout === "number" && connection.timeout > 0) {
      timeout = connection.timeout;
    }

    if (connection.headers) {
      for (const key in connection.headers) {
        headers[key.toLowerCase()] = {
          key: key,
          value: String(connection.headers[key])
        };

        if (["if-none-match", "if-modified-since"].indexOf(key.toLowerCase()) >= 0) {
          allow304 = true;
        }
      }
    }

    options.allowGzip = !!connection.allowGzip;

    if (connection.user != null && connection.password != null) {
      if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
        logger.throwError("basic authentication requires a secure https url", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.INVALID_ARGUMENT, {
          argument: "url",
          url: url,
          user: connection.user,
          password: "[REDACTED]"
        });
      }

      const authorization = connection.user + ":" + connection.password;
      headers["authorization"] = {
        key: "Authorization",
        value: "Basic " + (0,_ethersproject_base64__WEBPACK_IMPORTED_MODULE_4__.encode)((0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(authorization))
      };
    }

    if (connection.skipFetchSetup != null) {
      options.skipFetchSetup = !!connection.skipFetchSetup;
    }
  }

  const reData = new RegExp("^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$", "i");
  const dataMatch = url ? url.match(reData) : null;

  if (dataMatch) {
    try {
      const response = {
        statusCode: 200,
        statusMessage: "OK",
        headers: {
          "content-type": dataMatch[1]
        },
        body: (0,_ethersproject_base64__WEBPACK_IMPORTED_MODULE_4__.decode)(dataMatch[2])
      };
      let result = response.body;

      if (processFunc) {
        result = processFunc(response.body, response);
      }

      return Promise.resolve(result);
    } catch (error) {
      logger.throwError("processing response error", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {
        body: bodyify(dataMatch[1], dataMatch[2]),
        error: error,
        requestBody: null,
        requestMethod: "GET",
        url: url
      });
    }
  }

  if (body) {
    options.method = "POST";
    options.body = body;

    if (headers["content-type"] == null) {
      headers["content-type"] = {
        key: "Content-Type",
        value: "application/octet-stream"
      };
    }

    if (headers["content-length"] == null) {
      headers["content-length"] = {
        key: "Content-Length",
        value: String(body.length)
      };
    }
  }

  const flatHeaders = {};
  Object.keys(headers).forEach(key => {
    const header = headers[key];
    flatHeaders[header.key] = header.value;
  });
  options.headers = flatHeaders;

  const runningTimeout = function () {
    let timer = null;
    const promise = new Promise(function (resolve, reject) {
      if (timeout) {
        timer = setTimeout(() => {
          if (timer == null) {
            return;
          }

          timer = null;
          reject(logger.makeError("timeout", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.TIMEOUT, {
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            timeout: timeout,
            url: url
          }));
        }, timeout);
      }
    });

    const cancel = function () {
      if (timer == null) {
        return;
      }

      clearTimeout(timer);
      timer = null;
    };

    return {
      promise,
      cancel
    };
  }();

  const runningFetch = function () {
    return __awaiter(this, void 0, void 0, function* () {
      for (let attempt = 0; attempt < attemptLimit; attempt++) {
        let response = null;

        try {
          response = yield (0,_geturl__WEBPACK_IMPORTED_MODULE_5__.getUrl)(url, options);

          if (attempt < attemptLimit) {
            if (response.statusCode === 301 || response.statusCode === 302) {
              // Redirection; for now we only support absolute locataions
              const location = response.headers.location || "";

              if (options.method === "GET" && location.match(/^https:/)) {
                url = response.headers.location;
                continue;
              }
            } else if (response.statusCode === 429) {
              // Exponential back-off throttling
              let tryAgain = true;

              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }

              if (tryAgain) {
                let stall = 0;
                const retryAfter = response.headers["retry-after"];

                if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                  stall = parseInt(retryAfter) * 1000;
                } else {
                  stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                } //console.log("Stalling 429");


                yield staller(stall);
                continue;
              }
            }
          }
        } catch (error) {
          response = error.response;

          if (response == null) {
            runningTimeout.cancel();
            logger.throwError("missing response", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              serverError: error,
              url: url
            });
          }
        }

        let body = response.body;

        if (allow304 && response.statusCode === 304) {
          body = null;
        } else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {
          runningTimeout.cancel();
          logger.throwError("bad response", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {
            status: response.statusCode,
            headers: response.headers,
            body: bodyify(body, response.headers ? response.headers["content-type"] : null),
            requestBody: bodyify(options.body, flatHeaders["content-type"]),
            requestMethod: options.method,
            url: url
          });
        }

        if (processFunc) {
          try {
            const result = yield processFunc(body, response);
            runningTimeout.cancel();
            return result;
          } catch (error) {
            // Allow the processFunc to trigger a throttle
            if (error.throttleRetry && attempt < attemptLimit) {
              let tryAgain = true;

              if (throttleCallback) {
                tryAgain = yield throttleCallback(attempt, url);
              }

              if (tryAgain) {
                const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt))); //console.log("Stalling callback");

                yield staller(timeout);
                continue;
              }
            }

            runningTimeout.cancel();
            logger.throwError("processing response error", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {
              body: bodyify(body, response.headers ? response.headers["content-type"] : null),
              error: error,
              requestBody: bodyify(options.body, flatHeaders["content-type"]),
              requestMethod: options.method,
              url: url
            });
          }
        }

        runningTimeout.cancel(); // If we had a processFunc, it either returned a T or threw above.
        // The "body" is now a Uint8Array.

        return body;
      }

      return logger.throwError("failed response", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {
        requestBody: bodyify(options.body, flatHeaders["content-type"]),
        requestMethod: options.method,
        url: url
      });
    });
  }();

  return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson(connection, json, processFunc) {
  let processJsonFunc = (value, response) => {
    let result = null;

    if (value != null) {
      try {
        result = JSON.parse((0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8String)(value));
      } catch (error) {
        logger.throwError("invalid JSON", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger.errors.SERVER_ERROR, {
          body: value,
          error: error
        });
      }
    }

    if (processFunc) {
      result = processFunc(result, response);
    }

    return result;
  }; // If we have json to send, we must
  // - add content-type of application/json (unless already overridden)
  // - convert the json to bytes


  let body = null;

  if (json != null) {
    body = (0,_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__.toUtf8Bytes)(json); // Create a connection with the content-type set for JSON

    const updated = typeof connection === "string" ? {
      url: connection
    } : (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__.shallowCopy)(connection);

    if (updated.headers) {
      const hasContentType = Object.keys(updated.headers).filter(k => k.toLowerCase() === "content-type").length !== 0;

      if (!hasContentType) {
        updated.headers = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__.shallowCopy)(updated.headers);
        updated.headers["content-type"] = "application/json";
      }
    } else {
      updated.headers = {
        "content-type": "application/json"
      };
    }

    connection = updated;
  }

  return _fetchData(connection, body, processJsonFunc);
}
function poll(func, options) {
  if (!options) {
    options = {};
  }

  options = (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__.shallowCopy)(options);

  if (options.floor == null) {
    options.floor = 0;
  }

  if (options.ceiling == null) {
    options.ceiling = 10000;
  }

  if (options.interval == null) {
    options.interval = 250;
  }

  return new Promise(function (resolve, reject) {
    let timer = null;
    let done = false; // Returns true if cancel was successful. Unsuccessful cancel means we're already done.

    const cancel = () => {
      if (done) {
        return false;
      }

      done = true;

      if (timer) {
        clearTimeout(timer);
      }

      return true;
    };

    if (options.timeout) {
      timer = setTimeout(() => {
        if (cancel()) {
          reject(new Error("timeout"));
        }
      }, options.timeout);
    }

    const retryLimit = options.retryLimit;
    let attempt = 0;

    function check() {
      return func().then(function (result) {
        // If we have a result, or are allowed null then we're done
        if (result !== undefined) {
          if (cancel()) {
            resolve(result);
          }
        } else if (options.oncePoll) {
          options.oncePoll.once("poll", check);
        } else if (options.onceBlock) {
          options.onceBlock.once("block", check); // Otherwise, exponential back-off (up to 10s) our next request
        } else if (!done) {
          attempt++;

          if (attempt > retryLimit) {
            if (cancel()) {
              reject(new Error("retry limit reached"));
            }

            return;
          }

          let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));

          if (timeout < options.floor) {
            timeout = options.floor;
          }

          if (timeout > options.ceiling) {
            timeout = options.ceiling;
          }

          setTimeout(check, timeout);
        }

        return null;
      }, function (error) {
        if (cancel()) {
          reject(error);
        }
      });
    }

    check();
  });
}

/***/ }),

/***/ "./node_modules/@ethersproject/wordlists/lib.esm/_version.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersproject/wordlists/lib.esm/_version.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "wordlists/5.6.0";

/***/ }),

/***/ "./node_modules/@ethersproject/wordlists/lib.esm/lang-en.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersproject/wordlists/lib.esm/lang-en.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "langEn": () => (/* binding */ langEn)
/* harmony export */ });
/* harmony import */ var _wordlist__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wordlist */ "./node_modules/@ethersproject/wordlists/lib.esm/wordlist.js");



const words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
let wordlist = null;

function loadWords(lang) {
  if (wordlist != null) {
    return;
  }

  wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" "); // Verify the computed list matches the official list

  /* istanbul ignore if */

  if (_wordlist__WEBPACK_IMPORTED_MODULE_0__.Wordlist.check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
    wordlist = null;
    throw new Error("BIP39 Wordlist for en (English) FAILED");
  }
}

class LangEn extends _wordlist__WEBPACK_IMPORTED_MODULE_0__.Wordlist {
  constructor() {
    super("en");
  }

  getWord(index) {
    loadWords(this);
    return wordlist[index];
  }

  getWordIndex(word) {
    loadWords(this);
    return wordlist.indexOf(word);
  }

}

const langEn = new LangEn();
_wordlist__WEBPACK_IMPORTED_MODULE_0__.Wordlist.register(langEn);


/***/ }),

/***/ "./node_modules/@ethersproject/wordlists/lib.esm/wordlist.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersproject/wordlists/lib.esm/wordlist.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Wordlist": () => (/* binding */ Wordlist),
/* harmony export */   "logger": () => (/* binding */ logger)
/* harmony export */ });
/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/hash */ "./node_modules/@ethersproject/hash/lib.esm/id.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/wordlists/lib.esm/_version.js");
 // This gets overridden by rollup

const exportWordlist = false;




const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version);
class Wordlist {
  constructor(locale) {
    logger.checkAbstract(new.target, Wordlist);
    (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(this, "locale", locale);
  } // Subclasses may override this


  split(mnemonic) {
    return mnemonic.toLowerCase().split(/ +/g);
  } // Subclasses may override this


  join(words) {
    return words.join(" ");
  }

  static check(wordlist) {
    const words = [];

    for (let i = 0; i < 2048; i++) {
      const word = wordlist.getWord(i);
      /* istanbul ignore if */

      if (i !== wordlist.getWordIndex(word)) {
        return "0x";
      }

      words.push(word);
    }

    return (0,_ethersproject_hash__WEBPACK_IMPORTED_MODULE_3__.id)(words.join("\n") + "\n");
  }

  static register(lang, name) {
    if (!name) {
      name = lang.locale;
    }
    /* istanbul ignore if */


    if (exportWordlist) {
      try {
        const anyGlobal = window;

        if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {
          if (!anyGlobal._ethers.wordlists[name]) {
            (0,_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__.defineReadOnly)(anyGlobal._ethers.wordlists, name, lang);
          }
        }
      } catch (error) {}
    }
  }

}

/***/ }),

/***/ "./node_modules/@ethersproject/wordlists/lib.esm/wordlists.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ethersproject/wordlists/lib.esm/wordlists.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "wordlists": () => (/* binding */ wordlists)
/* harmony export */ });
/* harmony import */ var _lang_en__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lang-en */ "./node_modules/@ethersproject/wordlists/lib.esm/lang-en.js");



const wordlists = {
  en: _lang_en__WEBPACK_IMPORTED_MODULE_0__.langEn
};

/***/ }),

/***/ "./node_modules/@fairdatasociety/fdp-contracts/build/index.js":
/*!********************************************************************!*\
  !*** ./node_modules/@fairdatasociety/fdp-contracts/build/index.js ***!
  \********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

!function (f, e) {
   true ? module.exports = e(__webpack_require__(/*! ethers */ "./node_modules/ethers/lib.esm/index.js")) : 0;
}(this, f => (() => {
  var e = {
    3900: (f, e, t) => {
      "use strict";

      t.r(e), t.d(e, {
        AbiCoder: () => tf,
        ConstructorFragment: () => S,
        ErrorFragment: () => _,
        EventFragment: () => g,
        FormatTypes: () => l,
        Fragment: () => y,
        FunctionFragment: () => A,
        Indexed: () => df,
        Interface: () => hf,
        LogDescription: () => sf,
        ParamType: () => p,
        TransactionDescription: () => uf,
        checkResultErrors: () => N,
        defaultAbiCoder: () => rf
      });
      var r = t(2593),
          n = t(3587),
          i = t(711);
      const a = "abi/5.6.1",
            o = new i.Logger(a),
            s = {};
      let u = {
        calldata: !0,
        memory: !0,
        storage: !0
      },
          c = {
        calldata: !0,
        memory: !0
      };

      function d(f, e) {
        if ("bytes" === f || "string" === f) {
          if (u[e]) return !0;
        } else if ("address" === f) {
          if ("payable" === e) return !0;
        } else if ((f.indexOf("[") >= 0 || "tuple" === f) && c[e]) return !0;

        return (u[e] || "payable" === e) && o.throwArgumentError("invalid modifier", "name", e), !1;
      }

      function b(f, e) {
        for (let t in e) (0, n.defineReadOnly)(f, t, e[t]);
      }

      const l = Object.freeze({
        sighash: "sighash",
        minimal: "minimal",
        full: "full",
        json: "json"
      }),
            h = new RegExp(/^(.*)\[([0-9]*)\]$/);

      class p {
        constructor(f, e) {
          f !== s && o.throwError("use fromString", i.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new ParamType()"
          }), b(this, e);
          let t = this.type.match(h);
          b(this, t ? {
            arrayLength: parseInt(t[2] || "-1"),
            arrayChildren: p.fromObject({
              type: t[1],
              components: this.components
            }),
            baseType: "array"
          } : {
            arrayLength: null,
            arrayChildren: null,
            baseType: null != this.components ? "tuple" : this.type
          }), this._isParamType = !0, Object.freeze(this);
        }

        format(f) {
          if (f || (f = l.sighash), l[f] || o.throwArgumentError("invalid format type", "format", f), f === l.json) {
            let e = {
              type: "tuple" === this.baseType ? "tuple" : this.type,
              name: this.name || void 0
            };
            return "boolean" == typeof this.indexed && (e.indexed = this.indexed), this.components && (e.components = this.components.map(e => JSON.parse(e.format(f)))), JSON.stringify(e);
          }

          let e = "";
          return "array" === this.baseType ? (e += this.arrayChildren.format(f), e += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]") : "tuple" === this.baseType ? (f !== l.sighash && (e += this.type), e += "(" + this.components.map(e => e.format(f)).join(f === l.full ? ", " : ",") + ")") : e += this.type, f !== l.sighash && (!0 === this.indexed && (e += " indexed"), f === l.full && this.name && (e += " " + this.name)), e;
        }

        static from(f, e) {
          return "string" == typeof f ? p.fromString(f, e) : p.fromObject(f);
        }

        static fromObject(f) {
          return p.isParamType(f) ? f : new p(s, {
            name: f.name || null,
            type: M(f.type),
            indexed: null == f.indexed ? null : !!f.indexed,
            components: f.components ? f.components.map(p.fromObject) : null
          });
        }

        static fromString(f, e) {
          return t = function (f, e) {
            let t = f;

            function r(e) {
              o.throwArgumentError(`unexpected character at position ${e}`, "param", f);
            }

            function n(f) {
              let t = {
                type: "",
                name: "",
                parent: f,
                state: {
                  allowType: !0
                }
              };
              return e && (t.indexed = !1), t;
            }

            f = f.replace(/\s/g, " ");
            let i = {
              type: "",
              name: "",
              state: {
                allowType: !0
              }
            },
                a = i;

            for (let t = 0; t < f.length; t++) {
              let i = f[t];

              switch (i) {
                case "(":
                  a.state.allowType && "" === a.type ? a.type = "tuple" : a.state.allowParams || r(t), a.state.allowType = !1, a.type = M(a.type), a.components = [n(a)], a = a.components[0];
                  break;

                case ")":
                  delete a.state, "indexed" === a.name && (e || r(t), a.indexed = !0, a.name = ""), d(a.type, a.name) && (a.name = ""), a.type = M(a.type);
                  let f = a;
                  a = a.parent, a || r(t), delete f.parent, a.state.allowParams = !1, a.state.allowName = !0, a.state.allowArray = !0;
                  break;

                case ",":
                  delete a.state, "indexed" === a.name && (e || r(t), a.indexed = !0, a.name = ""), d(a.type, a.name) && (a.name = ""), a.type = M(a.type);
                  let o = n(a.parent);
                  a.parent.components.push(o), delete a.parent, a = o;
                  break;

                case " ":
                  a.state.allowType && "" !== a.type && (a.type = M(a.type), delete a.state.allowType, a.state.allowName = !0, a.state.allowParams = !0), a.state.allowName && "" !== a.name && ("indexed" === a.name ? (e || r(t), a.indexed && r(t), a.indexed = !0, a.name = "") : d(a.type, a.name) ? a.name = "" : a.state.allowName = !1);
                  break;

                case "[":
                  a.state.allowArray || r(t), a.type += i, a.state.allowArray = !1, a.state.allowName = !1, a.state.readArray = !0;
                  break;

                case "]":
                  a.state.readArray || r(t), a.type += i, a.state.readArray = !1, a.state.allowArray = !0, a.state.allowName = !0;
                  break;

                default:
                  a.state.allowType ? (a.type += i, a.state.allowParams = !0, a.state.allowArray = !0) : a.state.allowName ? (a.name += i, delete a.state.allowArray) : a.state.readArray ? a.type += i : r(t);
              }
            }

            return a.parent && o.throwArgumentError("unexpected eof", "param", f), delete i.state, "indexed" === a.name ? (e || r(t.length - 7), a.indexed && r(t.length - 7), a.indexed = !0, a.name = "") : d(a.type, a.name) && (a.name = ""), i.type = M(i.type), i;
          }(f, !!e), p.fromObject({
            name: t.name,
            type: t.type,
            indexed: t.indexed,
            components: t.components
          });
          var t;
        }

        static isParamType(f) {
          return !(null == f || !f._isParamType);
        }

      }

      function m(f, e) {
        return function (f) {
          f = f.trim();
          let e = [],
              t = "",
              r = 0;

          for (let n = 0; n < f.length; n++) {
            let i = f[n];
            "," === i && 0 === r ? (e.push(t), t = "") : (t += i, "(" === i ? r++ : ")" === i && (r--, -1 === r && o.throwArgumentError("unbalanced parenthesis", "value", f)));
          }

          t && e.push(t);
          return e;
        }(f).map(f => p.fromString(f, e));
      }

      class y {
        constructor(f, e) {
          f !== s && o.throwError("use a static from method", i.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new Fragment()"
          }), b(this, e), this._isFragment = !0, Object.freeze(this);
        }

        static from(f) {
          return y.isFragment(f) ? f : "string" == typeof f ? y.fromString(f) : y.fromObject(f);
        }

        static fromObject(f) {
          if (y.isFragment(f)) return f;

          switch (f.type) {
            case "function":
              return A.fromObject(f);

            case "event":
              return g.fromObject(f);

            case "constructor":
              return S.fromObject(f);

            case "error":
              return _.fromObject(f);

            case "fallback":
            case "receive":
              return null;
          }

          return o.throwArgumentError("invalid fragment object", "value", f);
        }

        static fromString(f) {
          return "event" === (f = (f = (f = f.replace(/\s/g, " ")).replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ")).trim()).split(" ")[0] ? g.fromString(f.substring(5).trim()) : "function" === f.split(" ")[0] ? A.fromString(f.substring(8).trim()) : "constructor" === f.split("(")[0].trim() ? S.fromString(f.trim()) : "error" === f.split(" ")[0] ? _.fromString(f.substring(5).trim()) : o.throwArgumentError("unsupported fragment", "value", f);
        }

        static isFragment(f) {
          return !(!f || !f._isFragment);
        }

      }

      class g extends y {
        format(f) {
          if (f || (f = l.sighash), l[f] || o.throwArgumentError("invalid format type", "format", f), f === l.json) return JSON.stringify({
            type: "event",
            anonymous: this.anonymous,
            name: this.name,
            inputs: this.inputs.map(e => JSON.parse(e.format(f)))
          });
          let e = "";
          return f !== l.sighash && (e += "event "), e += this.name + "(" + this.inputs.map(e => e.format(f)).join(f === l.full ? ", " : ",") + ") ", f !== l.sighash && this.anonymous && (e += "anonymous "), e.trim();
        }

        static from(f) {
          return "string" == typeof f ? g.fromString(f) : g.fromObject(f);
        }

        static fromObject(f) {
          if (g.isEventFragment(f)) return f;
          "event" !== f.type && o.throwArgumentError("invalid event object", "value", f);
          const e = {
            name: T(f.name),
            anonymous: f.anonymous,
            inputs: f.inputs ? f.inputs.map(p.fromObject) : [],
            type: "event"
          };
          return new g(s, e);
        }

        static fromString(f) {
          let e = f.match(O);
          e || o.throwArgumentError("invalid event string", "value", f);
          let t = !1;
          return e[3].split(" ").forEach(f => {
            switch (f.trim()) {
              case "anonymous":
                t = !0;
                break;

              case "":
                break;

              default:
                o.warn("unknown modifier: " + f);
            }
          }), g.fromObject({
            name: e[1].trim(),
            anonymous: t,
            inputs: m(e[2], !0),
            type: "event"
          });
        }

        static isEventFragment(f) {
          return f && f._isFragment && "event" === f.type;
        }

      }

      function v(f, e) {
        e.gas = null;
        let t = f.split("@");
        return 1 !== t.length ? (t.length > 2 && o.throwArgumentError("invalid human-readable ABI signature", "value", f), t[1].match(/^[0-9]+$/) || o.throwArgumentError("invalid human-readable ABI signature gas", "value", f), e.gas = r.O$.from(t[1]), t[0]) : f;
      }

      function w(f, e) {
        e.constant = !1, e.payable = !1, e.stateMutability = "nonpayable", f.split(" ").forEach(f => {
          switch (f.trim()) {
            case "constant":
              e.constant = !0;
              break;

            case "payable":
              e.payable = !0, e.stateMutability = "payable";
              break;

            case "nonpayable":
              e.payable = !1, e.stateMutability = "nonpayable";
              break;

            case "pure":
              e.constant = !0, e.stateMutability = "pure";
              break;

            case "view":
              e.constant = !0, e.stateMutability = "view";
              break;

            case "external":
            case "public":
            case "":
              break;

            default:
              console.log("unknown modifier: " + f);
          }
        });
      }

      function E(f) {
        let e = {
          constant: !1,
          payable: !0,
          stateMutability: "payable"
        };
        return null != f.stateMutability ? (e.stateMutability = f.stateMutability, e.constant = "view" === e.stateMutability || "pure" === e.stateMutability, null != f.constant && !!f.constant !== e.constant && o.throwArgumentError("cannot have constant function with mutability " + e.stateMutability, "value", f), e.payable = "payable" === e.stateMutability, null != f.payable && !!f.payable !== e.payable && o.throwArgumentError("cannot have payable function with mutability " + e.stateMutability, "value", f)) : null != f.payable ? (e.payable = !!f.payable, null != f.constant || e.payable || "constructor" === f.type || o.throwArgumentError("unable to determine stateMutability", "value", f), e.constant = !!f.constant, e.constant ? e.stateMutability = "view" : e.stateMutability = e.payable ? "payable" : "nonpayable", e.payable && e.constant && o.throwArgumentError("cannot have constant payable function", "value", f)) : null != f.constant ? (e.constant = !!f.constant, e.payable = !e.constant, e.stateMutability = e.constant ? "view" : "payable") : "constructor" !== f.type && o.throwArgumentError("unable to determine stateMutability", "value", f), e;
      }

      class S extends y {
        format(f) {
          if (f || (f = l.sighash), l[f] || o.throwArgumentError("invalid format type", "format", f), f === l.json) return JSON.stringify({
            type: "constructor",
            stateMutability: "nonpayable" !== this.stateMutability ? this.stateMutability : void 0,
            payable: this.payable,
            gas: this.gas ? this.gas.toNumber() : void 0,
            inputs: this.inputs.map(e => JSON.parse(e.format(f)))
          });
          f === l.sighash && o.throwError("cannot format a constructor for sighash", i.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "format(sighash)"
          });
          let e = "constructor(" + this.inputs.map(e => e.format(f)).join(f === l.full ? ", " : ",") + ") ";
          return this.stateMutability && "nonpayable" !== this.stateMutability && (e += this.stateMutability + " "), e.trim();
        }

        static from(f) {
          return "string" == typeof f ? S.fromString(f) : S.fromObject(f);
        }

        static fromObject(f) {
          if (S.isConstructorFragment(f)) return f;
          "constructor" !== f.type && o.throwArgumentError("invalid constructor object", "value", f);
          let e = E(f);
          e.constant && o.throwArgumentError("constructor cannot be constant", "value", f);
          const t = {
            name: null,
            type: f.type,
            inputs: f.inputs ? f.inputs.map(p.fromObject) : [],
            payable: e.payable,
            stateMutability: e.stateMutability,
            gas: f.gas ? r.O$.from(f.gas) : null
          };
          return new S(s, t);
        }

        static fromString(f) {
          let e = {
            type: "constructor"
          },
              t = (f = v(f, e)).match(O);
          return t && "constructor" === t[1].trim() || o.throwArgumentError("invalid constructor string", "value", f), e.inputs = m(t[2].trim(), !1), w(t[3].trim(), e), S.fromObject(e);
        }

        static isConstructorFragment(f) {
          return f && f._isFragment && "constructor" === f.type;
        }

      }

      class A extends S {
        format(f) {
          if (f || (f = l.sighash), l[f] || o.throwArgumentError("invalid format type", "format", f), f === l.json) return JSON.stringify({
            type: "function",
            name: this.name,
            constant: this.constant,
            stateMutability: "nonpayable" !== this.stateMutability ? this.stateMutability : void 0,
            payable: this.payable,
            gas: this.gas ? this.gas.toNumber() : void 0,
            inputs: this.inputs.map(e => JSON.parse(e.format(f))),
            outputs: this.outputs.map(e => JSON.parse(e.format(f)))
          });
          let e = "";
          return f !== l.sighash && (e += "function "), e += this.name + "(" + this.inputs.map(e => e.format(f)).join(f === l.full ? ", " : ",") + ") ", f !== l.sighash && (this.stateMutability ? "nonpayable" !== this.stateMutability && (e += this.stateMutability + " ") : this.constant && (e += "view "), this.outputs && this.outputs.length && (e += "returns (" + this.outputs.map(e => e.format(f)).join(", ") + ") "), null != this.gas && (e += "@" + this.gas.toString() + " ")), e.trim();
        }

        static from(f) {
          return "string" == typeof f ? A.fromString(f) : A.fromObject(f);
        }

        static fromObject(f) {
          if (A.isFunctionFragment(f)) return f;
          "function" !== f.type && o.throwArgumentError("invalid function object", "value", f);
          let e = E(f);
          const t = {
            type: f.type,
            name: T(f.name),
            constant: e.constant,
            inputs: f.inputs ? f.inputs.map(p.fromObject) : [],
            outputs: f.outputs ? f.outputs.map(p.fromObject) : [],
            payable: e.payable,
            stateMutability: e.stateMutability,
            gas: f.gas ? r.O$.from(f.gas) : null
          };
          return new A(s, t);
        }

        static fromString(f) {
          let e = {
            type: "function"
          },
              t = (f = v(f, e)).split(" returns ");
          t.length > 2 && o.throwArgumentError("invalid function string", "value", f);
          let r = t[0].match(O);

          if (r || o.throwArgumentError("invalid function signature", "value", f), e.name = r[1].trim(), e.name && T(e.name), e.inputs = m(r[2], !1), w(r[3].trim(), e), t.length > 1) {
            let r = t[1].match(O);
            "" == r[1].trim() && "" == r[3].trim() || o.throwArgumentError("unexpected tokens", "value", f), e.outputs = m(r[2], !1);
          } else e.outputs = [];

          return A.fromObject(e);
        }

        static isFunctionFragment(f) {
          return f && f._isFragment && "function" === f.type;
        }

      }

      function x(f) {
        const e = f.format();
        return "Error(string)" !== e && "Panic(uint256)" !== e || o.throwArgumentError(`cannot specify user defined ${e} error`, "fragment", f), f;
      }

      class _ extends y {
        format(f) {
          if (f || (f = l.sighash), l[f] || o.throwArgumentError("invalid format type", "format", f), f === l.json) return JSON.stringify({
            type: "error",
            name: this.name,
            inputs: this.inputs.map(e => JSON.parse(e.format(f)))
          });
          let e = "";
          return f !== l.sighash && (e += "error "), e += this.name + "(" + this.inputs.map(e => e.format(f)).join(f === l.full ? ", " : ",") + ") ", e.trim();
        }

        static from(f) {
          return "string" == typeof f ? _.fromString(f) : _.fromObject(f);
        }

        static fromObject(f) {
          if (_.isErrorFragment(f)) return f;
          "error" !== f.type && o.throwArgumentError("invalid error object", "value", f);
          const e = {
            type: f.type,
            name: T(f.name),
            inputs: f.inputs ? f.inputs.map(p.fromObject) : []
          };
          return x(new _(s, e));
        }

        static fromString(f) {
          let e = {
            type: "error"
          },
              t = f.match(O);
          return t || o.throwArgumentError("invalid error signature", "value", f), e.name = t[1].trim(), e.name && T(e.name), e.inputs = m(t[2], !1), x(_.fromObject(e));
        }

        static isErrorFragment(f) {
          return f && f._isFragment && "error" === f.type;
        }

      }

      function M(f) {
        return f.match(/^uint($|[^1-9])/) ? f = "uint256" + f.substring(4) : f.match(/^int($|[^1-9])/) && (f = "int256" + f.substring(3)), f;
      }

      const P = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");

      function T(f) {
        return f && f.match(P) || o.throwArgumentError(`invalid identifier "${f}"`, "value", f), f;
      }

      const O = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
      var C = t(3286);
      const R = new i.Logger(a);

      function N(f) {
        const e = [],
              t = function (f, r) {
          if (Array.isArray(r)) for (let n in r) {
            const i = f.slice();
            i.push(n);

            try {
              t(i, r[n]);
            } catch (f) {
              e.push({
                path: i,
                error: f
              });
            }
          }
        };

        return t([], f), e;
      }

      class k {
        constructor(f, e, t, r) {
          this.name = f, this.type = e, this.localName = t, this.dynamic = r;
        }

        _throwError(f, e) {
          R.throwArgumentError(f, this.localName, e);
        }

      }

      class I {
        constructor(f) {
          (0, n.defineReadOnly)(this, "wordSize", f || 32), this._data = [], this._dataLength = 0, this._padding = new Uint8Array(f);
        }

        get data() {
          return (0, C.hexConcat)(this._data);
        }

        get length() {
          return this._dataLength;
        }

        _writeData(f) {
          return this._data.push(f), this._dataLength += f.length, f.length;
        }

        appendWriter(f) {
          return this._writeData((0, C.concat)(f._data));
        }

        writeBytes(f) {
          let e = (0, C.arrayify)(f);
          const t = e.length % this.wordSize;
          return t && (e = (0, C.concat)([e, this._padding.slice(t)])), this._writeData(e);
        }

        _getValue(f) {
          let e = (0, C.arrayify)(r.O$.from(f));
          return e.length > this.wordSize && R.throwError("value out-of-bounds", i.Logger.errors.BUFFER_OVERRUN, {
            length: this.wordSize,
            offset: e.length
          }), e.length % this.wordSize && (e = (0, C.concat)([this._padding.slice(e.length % this.wordSize), e])), e;
        }

        writeValue(f) {
          return this._writeData(this._getValue(f));
        }

        writeUpdatableValue() {
          const f = this._data.length;
          return this._data.push(this._padding), this._dataLength += this.wordSize, e => {
            this._data[f] = this._getValue(e);
          };
        }

      }

      class F {
        constructor(f, e, t, r) {
          (0, n.defineReadOnly)(this, "_data", (0, C.arrayify)(f)), (0, n.defineReadOnly)(this, "wordSize", e || 32), (0, n.defineReadOnly)(this, "_coerceFunc", t), (0, n.defineReadOnly)(this, "allowLoose", r), this._offset = 0;
        }

        get data() {
          return (0, C.hexlify)(this._data);
        }

        get consumed() {
          return this._offset;
        }

        static coerce(f, e) {
          let t = f.match("^u?int([0-9]+)$");
          return t && parseInt(t[1]) <= 48 && (e = e.toNumber()), e;
        }

        coerce(f, e) {
          return this._coerceFunc ? this._coerceFunc(f, e) : F.coerce(f, e);
        }

        _peekBytes(f, e, t) {
          let r = Math.ceil(e / this.wordSize) * this.wordSize;
          return this._offset + r > this._data.length && (this.allowLoose && t && this._offset + e <= this._data.length ? r = e : R.throwError("data out-of-bounds", i.Logger.errors.BUFFER_OVERRUN, {
            length: this._data.length,
            offset: this._offset + r
          })), this._data.slice(this._offset, this._offset + r);
        }

        subReader(f) {
          return new F(this._data.slice(this._offset + f), this.wordSize, this._coerceFunc, this.allowLoose);
        }

        readBytes(f, e) {
          let t = this._peekBytes(0, f, !!e);

          return this._offset += t.length, t.slice(0, f);
        }

        readValue() {
          return r.O$.from(this.readBytes(this.wordSize));
        }

      }

      var B = t(4594);

      class L extends k {
        constructor(f) {
          super("address", "address", f, !1);
        }

        defaultValue() {
          return "0x0000000000000000000000000000000000000000";
        }

        encode(f, e) {
          try {
            e = (0, B.getAddress)(e);
          } catch (f) {
            this._throwError(f.message, e);
          }

          return f.writeValue(e);
        }

        decode(f) {
          return (0, B.getAddress)((0, C.hexZeroPad)(f.readValue().toHexString(), 20));
        }

      }

      class D extends k {
        constructor(f) {
          super(f.name, f.type, void 0, f.dynamic), this.coder = f;
        }

        defaultValue() {
          return this.coder.defaultValue();
        }

        encode(f, e) {
          return this.coder.encode(f, e);
        }

        decode(f) {
          return this.coder.decode(f);
        }

      }

      const U = new i.Logger(a);

      function j(f, e, t) {
        let r = null;
        if (Array.isArray(t)) r = t;else if (t && "object" == typeof t) {
          let f = {};
          r = e.map(e => {
            const r = e.localName;
            return r || U.throwError("cannot encode object for signature with missing names", i.Logger.errors.INVALID_ARGUMENT, {
              argument: "values",
              coder: e,
              value: t
            }), f[r] && U.throwError("cannot encode object for signature with duplicate names", i.Logger.errors.INVALID_ARGUMENT, {
              argument: "values",
              coder: e,
              value: t
            }), f[r] = !0, t[r];
          });
        } else U.throwArgumentError("invalid tuple value", "tuple", t);
        e.length !== r.length && U.throwArgumentError("types/value length mismatch", "tuple", t);
        let n = new I(f.wordSize),
            a = new I(f.wordSize),
            o = [];
        e.forEach((f, e) => {
          let t = r[e];

          if (f.dynamic) {
            let e = a.length;
            f.encode(a, t);
            let r = n.writeUpdatableValue();
            o.push(f => {
              r(f + e);
            });
          } else f.encode(n, t);
        }), o.forEach(f => {
          f(n.length);
        });
        let s = f.appendWriter(n);
        return s += f.appendWriter(a), s;
      }

      function z(f, e) {
        let t = [],
            r = f.subReader(0);
        e.forEach(e => {
          let n = null;

          if (e.dynamic) {
            let t = f.readValue(),
                a = r.subReader(t.toNumber());

            try {
              n = e.decode(a);
            } catch (f) {
              if (f.code === i.Logger.errors.BUFFER_OVERRUN) throw f;
              n = f, n.baseType = e.name, n.name = e.localName, n.type = e.type;
            }
          } else try {
            n = e.decode(f);
          } catch (f) {
            if (f.code === i.Logger.errors.BUFFER_OVERRUN) throw f;
            n = f, n.baseType = e.name, n.name = e.localName, n.type = e.type;
          }

          null != n && t.push(n);
        });
        const n = e.reduce((f, e) => {
          const t = e.localName;
          return t && (f[t] || (f[t] = 0), f[t]++), f;
        }, {});
        e.forEach((f, e) => {
          let r = f.localName;
          if (!r || 1 !== n[r]) return;
          if ("length" === r && (r = "_length"), null != t[r]) return;
          const i = t[e];
          i instanceof Error ? Object.defineProperty(t, r, {
            enumerable: !0,
            get: () => {
              throw i;
            }
          }) : t[r] = i;
        });

        for (let f = 0; f < t.length; f++) {
          const e = t[f];
          e instanceof Error && Object.defineProperty(t, f, {
            enumerable: !0,
            get: () => {
              throw e;
            }
          });
        }

        return Object.freeze(t);
      }

      class G extends k {
        constructor(f, e, t) {
          super("array", f.type + "[" + (e >= 0 ? e : "") + "]", t, -1 === e || f.dynamic), this.coder = f, this.length = e;
        }

        defaultValue() {
          const f = this.coder.defaultValue(),
                e = [];

          for (let t = 0; t < this.length; t++) e.push(f);

          return e;
        }

        encode(f, e) {
          Array.isArray(e) || this._throwError("expected array value", e);
          let t = this.length;
          -1 === t && (t = e.length, f.writeValue(e.length)), U.checkArgumentCount(e.length, t, "coder array" + (this.localName ? " " + this.localName : ""));
          let r = [];

          for (let f = 0; f < e.length; f++) r.push(this.coder);

          return j(f, r, e);
        }

        decode(f) {
          let e = this.length;
          -1 === e && (e = f.readValue().toNumber(), 32 * e > f._data.length && U.throwError("insufficient data length", i.Logger.errors.BUFFER_OVERRUN, {
            length: f._data.length,
            count: e
          }));
          let t = [];

          for (let f = 0; f < e; f++) t.push(new D(this.coder));

          return f.coerce(this.name, z(f, t));
        }

      }

      class K extends k {
        constructor(f) {
          super("bool", "bool", f, !1);
        }

        defaultValue() {
          return !1;
        }

        encode(f, e) {
          return f.writeValue(e ? 1 : 0);
        }

        decode(f) {
          return f.coerce(this.type, !f.readValue().isZero());
        }

      }

      class V extends k {
        constructor(f, e) {
          super(f, f, e, !0);
        }

        defaultValue() {
          return "0x";
        }

        encode(f, e) {
          e = (0, C.arrayify)(e);
          let t = f.writeValue(e.length);
          return t += f.writeBytes(e), t;
        }

        decode(f) {
          return f.readBytes(f.readValue().toNumber(), !0);
        }

      }

      class H extends V {
        constructor(f) {
          super("bytes", f);
        }

        decode(f) {
          return f.coerce(this.name, (0, C.hexlify)(super.decode(f)));
        }

      }

      class q extends k {
        constructor(f, e) {
          let t = "bytes" + String(f);
          super(t, t, e, !1), this.size = f;
        }

        defaultValue() {
          return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + 2 * this.size);
        }

        encode(f, e) {
          let t = (0, C.arrayify)(e);
          return t.length !== this.size && this._throwError("incorrect data length", e), f.writeBytes(t);
        }

        decode(f) {
          return f.coerce(this.name, (0, C.hexlify)(f.readBytes(this.size)));
        }

      }

      class W extends k {
        constructor(f) {
          super("null", "", f, !1);
        }

        defaultValue() {
          return null;
        }

        encode(f, e) {
          return null != e && this._throwError("not null", e), f.writeBytes([]);
        }

        decode(f) {
          return f.readBytes(0), f.coerce(this.name, null);
        }

      }

      var $ = t(1046);

      class J extends k {
        constructor(f, e, t) {
          const r = (e ? "int" : "uint") + 8 * f;
          super(r, r, t, !1), this.size = f, this.signed = e;
        }

        defaultValue() {
          return 0;
        }

        encode(f, e) {
          let t = r.O$.from(e),
              n = $.Bz.mask(8 * f.wordSize);

          if (this.signed) {
            let f = n.mask(8 * this.size - 1);
            (t.gt(f) || t.lt(f.add($.fh).mul($.tL))) && this._throwError("value out-of-bounds", e);
          } else (t.lt($._Y) || t.gt(n.mask(8 * this.size))) && this._throwError("value out-of-bounds", e);

          return t = t.toTwos(8 * this.size).mask(8 * this.size), this.signed && (t = t.fromTwos(8 * this.size).toTwos(8 * f.wordSize)), f.writeValue(t);
        }

        decode(f) {
          let e = f.readValue().mask(8 * this.size);
          return this.signed && (e = e.fromTwos(8 * this.size)), f.coerce(this.name, e);
        }

      }

      var Z = t(4242);

      class Y extends V {
        constructor(f) {
          super("string", f);
        }

        defaultValue() {
          return "";
        }

        encode(f, e) {
          return super.encode(f, (0, Z.Y0)(e));
        }

        decode(f) {
          return (0, Z.ZN)(super.decode(f));
        }

      }

      class X extends k {
        constructor(f, e) {
          let t = !1;
          const r = [];
          f.forEach(f => {
            f.dynamic && (t = !0), r.push(f.type);
          });
          super("tuple", "tuple(" + r.join(",") + ")", e, t), this.coders = f;
        }

        defaultValue() {
          const f = [];
          this.coders.forEach(e => {
            f.push(e.defaultValue());
          });
          const e = this.coders.reduce((f, e) => {
            const t = e.localName;
            return t && (f[t] || (f[t] = 0), f[t]++), f;
          }, {});
          return this.coders.forEach((t, r) => {
            let n = t.localName;
            n && 1 === e[n] && ("length" === n && (n = "_length"), null == f[n] && (f[n] = f[r]));
          }), Object.freeze(f);
        }

        encode(f, e) {
          return j(f, this.coders, e);
        }

        decode(f) {
          return f.coerce(this.name, z(f, this.coders));
        }

      }

      const Q = new i.Logger(a),
            ff = new RegExp(/^bytes([0-9]*)$/),
            ef = new RegExp(/^(u?int)([0-9]*)$/);

      class tf {
        constructor(f) {
          Q.checkNew(new.target, tf), (0, n.defineReadOnly)(this, "coerceFunc", f || null);
        }

        _getCoder(f) {
          switch (f.baseType) {
            case "address":
              return new L(f.name);

            case "bool":
              return new K(f.name);

            case "string":
              return new Y(f.name);

            case "bytes":
              return new H(f.name);

            case "array":
              return new G(this._getCoder(f.arrayChildren), f.arrayLength, f.name);

            case "tuple":
              return new X((f.components || []).map(f => this._getCoder(f)), f.name);

            case "":
              return new W(f.name);
          }

          let e = f.type.match(ef);

          if (e) {
            let t = parseInt(e[2] || "256");
            return (0 === t || t > 256 || t % 8 != 0) && Q.throwArgumentError("invalid " + e[1] + " bit length", "param", f), new J(t / 8, "int" === e[1], f.name);
          }

          if (e = f.type.match(ff), e) {
            let t = parseInt(e[1]);
            return (0 === t || t > 32) && Q.throwArgumentError("invalid bytes length", "param", f), new q(t, f.name);
          }

          return Q.throwArgumentError("invalid type", "type", f.type);
        }

        _getWordSize() {
          return 32;
        }

        _getReader(f, e) {
          return new F(f, this._getWordSize(), this.coerceFunc, e);
        }

        _getWriter() {
          return new I(this._getWordSize());
        }

        getDefaultValue(f) {
          const e = f.map(f => this._getCoder(p.from(f)));
          return new X(e, "_").defaultValue();
        }

        encode(f, e) {
          f.length !== e.length && Q.throwError("types/values length mismatch", i.Logger.errors.INVALID_ARGUMENT, {
            count: {
              types: f.length,
              values: e.length
            },
            value: {
              types: f,
              values: e
            }
          });

          const t = f.map(f => this._getCoder(p.from(f))),
                r = new X(t, "_"),
                n = this._getWriter();

          return r.encode(n, e), n.data;
        }

        decode(f, e, t) {
          const r = f.map(f => this._getCoder(p.from(f)));
          return new X(r, "_").decode(this._getReader((0, C.arrayify)(e), t));
        }

      }

      const rf = new tf();
      var nf = t(2046),
          af = t(8197);
      const of = new i.Logger(a);

      class sf extends n.Description {}

      class uf extends n.Description {}

      class cf extends n.Description {}

      class df extends n.Description {
        static isIndexed(f) {
          return !(!f || !f._isIndexed);
        }

      }

      const bf = {
        "0x08c379a0": {
          signature: "Error(string)",
          name: "Error",
          inputs: ["string"],
          reason: !0
        },
        "0x4e487b71": {
          signature: "Panic(uint256)",
          name: "Panic",
          inputs: ["uint256"]
        }
      };

      function lf(f, e) {
        const t = new Error(`deferred error during ABI decoding triggered accessing ${f}`);
        return t.error = e, t;
      }

      class hf {
        constructor(f) {
          of.checkNew(new.target, hf);
          let e = [];
          e = "string" == typeof f ? JSON.parse(f) : f, (0, n.defineReadOnly)(this, "fragments", e.map(f => y.from(f)).filter(f => null != f)), (0, n.defineReadOnly)(this, "_abiCoder", (0, n.getStatic)(new.target, "getAbiCoder")()), (0, n.defineReadOnly)(this, "functions", {}), (0, n.defineReadOnly)(this, "errors", {}), (0, n.defineReadOnly)(this, "events", {}), (0, n.defineReadOnly)(this, "structs", {}), this.fragments.forEach(f => {
            let e = null;

            switch (f.type) {
              case "constructor":
                return this.deploy ? void of.warn("duplicate definition - constructor") : void (0, n.defineReadOnly)(this, "deploy", f);

              case "function":
                e = this.functions;
                break;

              case "event":
                e = this.events;
                break;

              case "error":
                e = this.errors;
                break;

              default:
                return;
            }

            let t = f.format();
            e[t] ? of.warn("duplicate definition - " + t) : e[t] = f;
          }), this.deploy || (0, n.defineReadOnly)(this, "deploy", S.from({
            payable: !1,
            type: "constructor"
          })), (0, n.defineReadOnly)(this, "_isInterface", !0);
        }

        format(f) {
          f || (f = l.full), f === l.sighash && of.throwArgumentError("interface does not support formatting sighash", "format", f);
          const e = this.fragments.map(e => e.format(f));
          return f === l.json ? JSON.stringify(e.map(f => JSON.parse(f))) : e;
        }

        static getAbiCoder() {
          return rf;
        }

        static getAddress(f) {
          return (0, B.getAddress)(f);
        }

        static getSighash(f) {
          return (0, C.hexDataSlice)((0, nf.id)(f.format()), 0, 4);
        }

        static getEventTopic(f) {
          return (0, nf.id)(f.format());
        }

        getFunction(f) {
          if ((0, C.isHexString)(f)) {
            for (const e in this.functions) if (f === this.getSighash(e)) return this.functions[e];

            of.throwArgumentError("no matching function", "sighash", f);
          }

          if (-1 === f.indexOf("(")) {
            const e = f.trim(),
                  t = Object.keys(this.functions).filter(f => f.split("(")[0] === e);
            return 0 === t.length ? of.throwArgumentError("no matching function", "name", e) : t.length > 1 && of.throwArgumentError("multiple matching functions", "name", e), this.functions[t[0]];
          }

          const e = this.functions[A.fromString(f).format()];
          return e || of.throwArgumentError("no matching function", "signature", f), e;
        }

        getEvent(f) {
          if ((0, C.isHexString)(f)) {
            const e = f.toLowerCase();

            for (const f in this.events) if (e === this.getEventTopic(f)) return this.events[f];

            of.throwArgumentError("no matching event", "topichash", e);
          }

          if (-1 === f.indexOf("(")) {
            const e = f.trim(),
                  t = Object.keys(this.events).filter(f => f.split("(")[0] === e);
            return 0 === t.length ? of.throwArgumentError("no matching event", "name", e) : t.length > 1 && of.throwArgumentError("multiple matching events", "name", e), this.events[t[0]];
          }

          const e = this.events[g.fromString(f).format()];
          return e || of.throwArgumentError("no matching event", "signature", f), e;
        }

        getError(f) {
          if ((0, C.isHexString)(f)) {
            const e = (0, n.getStatic)(this.constructor, "getSighash");

            for (const t in this.errors) {
              if (f === e(this.errors[t])) return this.errors[t];
            }

            of.throwArgumentError("no matching error", "sighash", f);
          }

          if (-1 === f.indexOf("(")) {
            const e = f.trim(),
                  t = Object.keys(this.errors).filter(f => f.split("(")[0] === e);
            return 0 === t.length ? of.throwArgumentError("no matching error", "name", e) : t.length > 1 && of.throwArgumentError("multiple matching errors", "name", e), this.errors[t[0]];
          }

          const e = this.errors[A.fromString(f).format()];
          return e || of.throwArgumentError("no matching error", "signature", f), e;
        }

        getSighash(f) {
          if ("string" == typeof f) try {
            f = this.getFunction(f);
          } catch (e) {
            try {
              f = this.getError(f);
            } catch (f) {
              throw e;
            }
          }
          return (0, n.getStatic)(this.constructor, "getSighash")(f);
        }

        getEventTopic(f) {
          return "string" == typeof f && (f = this.getEvent(f)), (0, n.getStatic)(this.constructor, "getEventTopic")(f);
        }

        _decodeParams(f, e) {
          return this._abiCoder.decode(f, e);
        }

        _encodeParams(f, e) {
          return this._abiCoder.encode(f, e);
        }

        encodeDeploy(f) {
          return this._encodeParams(this.deploy.inputs, f || []);
        }

        decodeErrorResult(f, e) {
          "string" == typeof f && (f = this.getError(f));
          const t = (0, C.arrayify)(e);
          return (0, C.hexlify)(t.slice(0, 4)) !== this.getSighash(f) && of.throwArgumentError(`data signature does not match error ${f.name}.`, "data", (0, C.hexlify)(t)), this._decodeParams(f.inputs, t.slice(4));
        }

        encodeErrorResult(f, e) {
          return "string" == typeof f && (f = this.getError(f)), (0, C.hexlify)((0, C.concat)([this.getSighash(f), this._encodeParams(f.inputs, e || [])]));
        }

        decodeFunctionData(f, e) {
          "string" == typeof f && (f = this.getFunction(f));
          const t = (0, C.arrayify)(e);
          return (0, C.hexlify)(t.slice(0, 4)) !== this.getSighash(f) && of.throwArgumentError(`data signature does not match function ${f.name}.`, "data", (0, C.hexlify)(t)), this._decodeParams(f.inputs, t.slice(4));
        }

        encodeFunctionData(f, e) {
          return "string" == typeof f && (f = this.getFunction(f)), (0, C.hexlify)((0, C.concat)([this.getSighash(f), this._encodeParams(f.inputs, e || [])]));
        }

        decodeFunctionResult(f, e) {
          "string" == typeof f && (f = this.getFunction(f));
          let t = (0, C.arrayify)(e),
              r = null,
              n = "",
              a = null,
              o = null,
              s = null;

          switch (t.length % this._abiCoder._getWordSize()) {
            case 0:
              try {
                return this._abiCoder.decode(f.outputs, t);
              } catch (f) {}

              break;

            case 4:
              {
                const f = (0, C.hexlify)(t.slice(0, 4)),
                      e = bf[f];
                if (e) a = this._abiCoder.decode(e.inputs, t.slice(4)), o = e.name, s = e.signature, e.reason && (r = a[0]), "Error" === o ? n = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(a[0])}` : "Panic" === o && (n = `; VM Exception while processing transaction: reverted with panic code ${a[0]}`);else try {
                  const e = this.getError(f);
                  a = this._abiCoder.decode(e.inputs, t.slice(4)), o = e.name, s = e.format();
                } catch (f) {}
                break;
              }
          }

          return of.throwError("call revert exception" + n, i.Logger.errors.CALL_EXCEPTION, {
            method: f.format(),
            data: (0, C.hexlify)(e),
            errorArgs: a,
            errorName: o,
            errorSignature: s,
            reason: r
          });
        }

        encodeFunctionResult(f, e) {
          return "string" == typeof f && (f = this.getFunction(f)), (0, C.hexlify)(this._abiCoder.encode(f.outputs, e || []));
        }

        encodeFilterTopics(f, e) {
          "string" == typeof f && (f = this.getEvent(f)), e.length > f.inputs.length && of.throwError("too many arguments for " + f.format(), i.Logger.errors.UNEXPECTED_ARGUMENT, {
            argument: "values",
            value: e
          });
          let t = [];
          f.anonymous || t.push(this.getEventTopic(f));

          const r = (f, e) => "string" === f.type ? (0, nf.id)(e) : "bytes" === f.type ? (0, af.keccak256)((0, C.hexlify)(e)) : ("address" === f.type && this._abiCoder.encode(["address"], [e]), (0, C.hexZeroPad)((0, C.hexlify)(e), 32));

          for (e.forEach((e, n) => {
            let i = f.inputs[n];
            i.indexed ? null == e ? t.push(null) : "array" === i.baseType || "tuple" === i.baseType ? of.throwArgumentError("filtering with tuples or arrays not supported", "contract." + i.name, e) : Array.isArray(e) ? t.push(e.map(f => r(i, f))) : t.push(r(i, e)) : null != e && of.throwArgumentError("cannot filter non-indexed parameters; must be null", "contract." + i.name, e);
          }); t.length && null === t[t.length - 1];) t.pop();

          return t;
        }

        encodeEventLog(f, e) {
          "string" == typeof f && (f = this.getEvent(f));
          const t = [],
                r = [],
                n = [];
          return f.anonymous || t.push(this.getEventTopic(f)), e.length !== f.inputs.length && of.throwArgumentError("event arguments/values mismatch", "values", e), f.inputs.forEach((f, i) => {
            const a = e[i];
            if (f.indexed) {
              if ("string" === f.type) t.push((0, nf.id)(a));else if ("bytes" === f.type) t.push((0, af.keccak256)(a));else {
                if ("tuple" === f.baseType || "array" === f.baseType) throw new Error("not implemented");
                t.push(this._abiCoder.encode([f.type], [a]));
              }
            } else r.push(f), n.push(a);
          }), {
            data: this._abiCoder.encode(r, n),
            topics: t
          };
        }

        decodeEventLog(f, e, t) {
          if ("string" == typeof f && (f = this.getEvent(f)), null != t && !f.anonymous) {
            let e = this.getEventTopic(f);
            (0, C.isHexString)(t[0], 32) && t[0].toLowerCase() === e || of.throwError("fragment/topic mismatch", i.Logger.errors.INVALID_ARGUMENT, {
              argument: "topics[0]",
              expected: e,
              value: t[0]
            }), t = t.slice(1);
          }

          let r = [],
              n = [],
              a = [];
          f.inputs.forEach((f, e) => {
            f.indexed ? "string" === f.type || "bytes" === f.type || "tuple" === f.baseType || "array" === f.baseType ? (r.push(p.fromObject({
              type: "bytes32",
              name: f.name
            })), a.push(!0)) : (r.push(f), a.push(!1)) : (n.push(f), a.push(!1));
          });

          let o = null != t ? this._abiCoder.decode(r, (0, C.concat)(t)) : null,
              s = this._abiCoder.decode(n, e, !0),
              u = [],
              c = 0,
              d = 0;

          f.inputs.forEach((f, e) => {
            if (f.indexed) {
              if (null == o) u[e] = new df({
                _isIndexed: !0,
                hash: null
              });else if (a[e]) u[e] = new df({
                _isIndexed: !0,
                hash: o[d++]
              });else try {
                u[e] = o[d++];
              } catch (f) {
                u[e] = f;
              }
            } else try {
              u[e] = s[c++];
            } catch (f) {
              u[e] = f;
            }

            if (f.name && null == u[f.name]) {
              const t = u[e];
              t instanceof Error ? Object.defineProperty(u, f.name, {
                enumerable: !0,
                get: () => {
                  throw lf(`property ${JSON.stringify(f.name)}`, t);
                }
              }) : u[f.name] = t;
            }
          });

          for (let f = 0; f < u.length; f++) {
            const e = u[f];
            e instanceof Error && Object.defineProperty(u, f, {
              enumerable: !0,
              get: () => {
                throw lf(`index ${f}`, e);
              }
            });
          }

          return Object.freeze(u);
        }

        parseTransaction(f) {
          let e = this.getFunction(f.data.substring(0, 10).toLowerCase());
          return e ? new uf({
            args: this._abiCoder.decode(e.inputs, "0x" + f.data.substring(10)),
            functionFragment: e,
            name: e.name,
            signature: e.format(),
            sighash: this.getSighash(e),
            value: r.O$.from(f.value || "0")
          }) : null;
        }

        parseLog(f) {
          let e = this.getEvent(f.topics[0]);
          return !e || e.anonymous ? null : new sf({
            eventFragment: e,
            name: e.name,
            signature: e.format(),
            topic: this.getEventTopic(e),
            args: this.decodeEventLog(e, f.data, f.topics)
          });
        }

        parseError(f) {
          const e = (0, C.hexlify)(f);
          let t = this.getError(e.substring(0, 10).toLowerCase());
          return t ? new cf({
            args: this._abiCoder.decode(t.inputs, "0x" + e.substring(10)),
            errorFragment: t,
            name: t.name,
            signature: t.format(),
            sighash: this.getSighash(t)
          }) : null;
        }

        static isInterface(f) {
          return !(!f || !f._isInterface);
        }

      }
    },
    4594: (f, e, t) => {
      "use strict";

      t.r(e), t.d(e, {
        getAddress: () => l,
        getContractAddress: () => m,
        getCreate2Address: () => y,
        getIcapAddress: () => p,
        isAddress: () => h
      });
      var r = t(3286),
          n = t(2593),
          i = t(8197),
          a = t(1843);
      const o = new (t(711).Logger)("address/5.6.0");

      function s(f) {
        (0, r.isHexString)(f, 20) || o.throwArgumentError("invalid address", "address", f);
        const e = (f = f.toLowerCase()).substring(2).split(""),
              t = new Uint8Array(40);

        for (let f = 0; f < 40; f++) t[f] = e[f].charCodeAt(0);

        const n = (0, r.arrayify)((0, i.keccak256)(t));

        for (let f = 0; f < 40; f += 2) n[f >> 1] >> 4 >= 8 && (e[f] = e[f].toUpperCase()), (15 & n[f >> 1]) >= 8 && (e[f + 1] = e[f + 1].toUpperCase());

        return "0x" + e.join("");
      }

      const u = {};

      for (let f = 0; f < 10; f++) u[String(f)] = String(f);

      for (let f = 0; f < 26; f++) u[String.fromCharCode(65 + f)] = String(10 + f);

      const c = Math.floor((d = 9007199254740991, Math.log10 ? Math.log10(d) : Math.log(d) / Math.LN10));
      var d;

      function b(f) {
        let e = (f = (f = f.toUpperCase()).substring(4) + f.substring(0, 2) + "00").split("").map(f => u[f]).join("");

        for (; e.length >= c;) {
          let f = e.substring(0, c);
          e = parseInt(f, 10) % 97 + e.substring(f.length);
        }

        let t = String(98 - parseInt(e, 10) % 97);

        for (; t.length < 2;) t = "0" + t;

        return t;
      }

      function l(f) {
        let e = null;
        if ("string" != typeof f && o.throwArgumentError("invalid address", "address", f), f.match(/^(0x)?[0-9a-fA-F]{40}$/)) "0x" !== f.substring(0, 2) && (f = "0x" + f), e = s(f), f.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && e !== f && o.throwArgumentError("bad address checksum", "address", f);else if (f.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
          for (f.substring(2, 4) !== b(f) && o.throwArgumentError("bad icap checksum", "address", f), e = (0, n.g$)(f.substring(4)); e.length < 40;) e = "0" + e;

          e = s("0x" + e);
        } else o.throwArgumentError("invalid address", "address", f);
        return e;
      }

      function h(f) {
        try {
          return l(f), !0;
        } catch (f) {}

        return !1;
      }

      function p(f) {
        let e = (0, n.t2)(l(f).substring(2)).toUpperCase();

        for (; e.length < 30;) e = "0" + e;

        return "XE" + b("XE00" + e) + e;
      }

      function m(f) {
        let e = null;

        try {
          e = l(f.from);
        } catch (e) {
          o.throwArgumentError("missing from address", "transaction", f);
        }

        const t = (0, r.stripZeros)((0, r.arrayify)(n.O$.from(f.nonce).toHexString()));
        return l((0, r.hexDataSlice)((0, i.keccak256)((0, a.encode)([e, t])), 12));
      }

      function y(f, e, t) {
        return 32 !== (0, r.hexDataLength)(e) && o.throwArgumentError("salt must be 32 bytes", "salt", e), 32 !== (0, r.hexDataLength)(t) && o.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", t), l((0, r.hexDataSlice)((0, i.keccak256)((0, r.concat)(["0xff", l(f), e, t])), 12));
      }
    },
    9567: (f, e, t) => {
      "use strict";

      t.d(e, {
        J: () => n,
        c: () => i
      });
      var r = t(3286);

      function n(f) {
        f = atob(f);
        const e = [];

        for (let t = 0; t < f.length; t++) e.push(f.charCodeAt(t));

        return (0, r.arrayify)(e);
      }

      function i(f) {
        f = (0, r.arrayify)(f);
        let e = "";

        for (let t = 0; t < f.length; t++) e += String.fromCharCode(f[t]);

        return btoa(e);
      }
    },
    4089: (f, e, t) => {
      "use strict";

      t.r(e), t.d(e, {
        decode: () => r.J,
        encode: () => r.c
      });
      var r = t(9567);
    },
    7727: (f, e, t) => {
      "use strict";

      t.r(e), t.d(e, {
        Base32: () => a,
        Base58: () => o,
        BaseX: () => i
      });
      var r = t(3286),
          n = t(3587);

      class i {
        constructor(f) {
          (0, n.defineReadOnly)(this, "alphabet", f), (0, n.defineReadOnly)(this, "base", f.length), (0, n.defineReadOnly)(this, "_alphabetMap", {}), (0, n.defineReadOnly)(this, "_leader", f.charAt(0));

          for (let e = 0; e < f.length; e++) this._alphabetMap[f.charAt(e)] = e;
        }

        encode(f) {
          let e = (0, r.arrayify)(f);
          if (0 === e.length) return "";
          let t = [0];

          for (let f = 0; f < e.length; ++f) {
            let r = e[f];

            for (let f = 0; f < t.length; ++f) r += t[f] << 8, t[f] = r % this.base, r = r / this.base | 0;

            for (; r > 0;) t.push(r % this.base), r = r / this.base | 0;
          }

          let n = "";

          for (let f = 0; 0 === e[f] && f < e.length - 1; ++f) n += this._leader;

          for (let f = t.length - 1; f >= 0; --f) n += this.alphabet[t[f]];

          return n;
        }

        decode(f) {
          if ("string" != typeof f) throw new TypeError("Expected String");
          let e = [];
          if (0 === f.length) return new Uint8Array(e);
          e.push(0);

          for (let t = 0; t < f.length; t++) {
            let r = this._alphabetMap[f[t]];
            if (void 0 === r) throw new Error("Non-base" + this.base + " character");
            let n = r;

            for (let f = 0; f < e.length; ++f) n += e[f] * this.base, e[f] = 255 & n, n >>= 8;

            for (; n > 0;) e.push(255 & n), n >>= 8;
          }

          for (let t = 0; f[t] === this._leader && t < f.length - 1; ++t) e.push(0);

          return (0, r.arrayify)(new Uint8Array(e.reverse()));
        }

      }

      const a = new i("abcdefghijklmnopqrstuvwxyz234567"),
            o = new i("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
    },
    8794: (f, e, t) => {
      "use strict";

      t.d(e, {
        i: () => r
      });
      const r = "bignumber/5.6.0";
    },
    2593: (f, e, t) => {
      "use strict";

      t.d(e, {
        O$: () => h,
        Zm: () => b,
        g$: () => v,
        t2: () => w
      });
      var r = t(3550),
          n = t.n(r),
          i = t(3286),
          a = t(711),
          o = t(8794),
          s = n().BN;
      const u = new a.Logger(o.i),
            c = {},
            d = 9007199254740991;

      function b(f) {
        return null != f && (h.isBigNumber(f) || "number" == typeof f && f % 1 == 0 || "string" == typeof f && !!f.match(/^-?[0-9]+$/) || (0, i.isHexString)(f) || "bigint" == typeof f || (0, i.isBytes)(f));
      }

      let l = !1;

      class h {
        constructor(f, e) {
          u.checkNew(new.target, h), f !== c && u.throwError("cannot call constructor directly; use BigNumber.from", a.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new (BigNumber)"
          }), this._hex = e, this._isBigNumber = !0, Object.freeze(this);
        }

        fromTwos(f) {
          return m(y(this).fromTwos(f));
        }

        toTwos(f) {
          return m(y(this).toTwos(f));
        }

        abs() {
          return "-" === this._hex[0] ? h.from(this._hex.substring(1)) : this;
        }

        add(f) {
          return m(y(this).add(y(f)));
        }

        sub(f) {
          return m(y(this).sub(y(f)));
        }

        div(f) {
          return h.from(f).isZero() && g("division-by-zero", "div"), m(y(this).div(y(f)));
        }

        mul(f) {
          return m(y(this).mul(y(f)));
        }

        mod(f) {
          const e = y(f);
          return e.isNeg() && g("division-by-zero", "mod"), m(y(this).umod(e));
        }

        pow(f) {
          const e = y(f);
          return e.isNeg() && g("negative-power", "pow"), m(y(this).pow(e));
        }

        and(f) {
          const e = y(f);
          return (this.isNegative() || e.isNeg()) && g("unbound-bitwise-result", "and"), m(y(this).and(e));
        }

        or(f) {
          const e = y(f);
          return (this.isNegative() || e.isNeg()) && g("unbound-bitwise-result", "or"), m(y(this).or(e));
        }

        xor(f) {
          const e = y(f);
          return (this.isNegative() || e.isNeg()) && g("unbound-bitwise-result", "xor"), m(y(this).xor(e));
        }

        mask(f) {
          return (this.isNegative() || f < 0) && g("negative-width", "mask"), m(y(this).maskn(f));
        }

        shl(f) {
          return (this.isNegative() || f < 0) && g("negative-width", "shl"), m(y(this).shln(f));
        }

        shr(f) {
          return (this.isNegative() || f < 0) && g("negative-width", "shr"), m(y(this).shrn(f));
        }

        eq(f) {
          return y(this).eq(y(f));
        }

        lt(f) {
          return y(this).lt(y(f));
        }

        lte(f) {
          return y(this).lte(y(f));
        }

        gt(f) {
          return y(this).gt(y(f));
        }

        gte(f) {
          return y(this).gte(y(f));
        }

        isNegative() {
          return "-" === this._hex[0];
        }

        isZero() {
          return y(this).isZero();
        }

        toNumber() {
          try {
            return y(this).toNumber();
          } catch (f) {
            g("overflow", "toNumber", this.toString());
          }

          return null;
        }

        toBigInt() {
          try {
            return BigInt(this.toString());
          } catch (f) {}

          return u.throwError("this platform does not support BigInt", a.Logger.errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
          });
        }

        toString() {
          return arguments.length > 0 && (10 === arguments[0] ? l || (l = !0, u.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : 16 === arguments[0] ? u.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", a.Logger.errors.UNEXPECTED_ARGUMENT, {}) : u.throwError("BigNumber.toString does not accept parameters", a.Logger.errors.UNEXPECTED_ARGUMENT, {})), y(this).toString(10);
        }

        toHexString() {
          return this._hex;
        }

        toJSON(f) {
          return {
            type: "BigNumber",
            hex: this.toHexString()
          };
        }

        static from(f) {
          if (f instanceof h) return f;
          if ("string" == typeof f) return f.match(/^-?0x[0-9a-f]+$/i) ? new h(c, p(f)) : f.match(/^-?[0-9]+$/) ? new h(c, p(new s(f))) : u.throwArgumentError("invalid BigNumber string", "value", f);
          if ("number" == typeof f) return f % 1 && g("underflow", "BigNumber.from", f), (f >= d || f <= -d) && g("overflow", "BigNumber.from", f), h.from(String(f));
          const e = f;
          if ("bigint" == typeof e) return h.from(e.toString());
          if ((0, i.isBytes)(e)) return h.from((0, i.hexlify)(e));
          if (e) if (e.toHexString) {
            const f = e.toHexString();
            if ("string" == typeof f) return h.from(f);
          } else {
            let f = e._hex;
            if (null == f && "BigNumber" === e.type && (f = e.hex), "string" == typeof f && ((0, i.isHexString)(f) || "-" === f[0] && (0, i.isHexString)(f.substring(1)))) return h.from(f);
          }
          return u.throwArgumentError("invalid BigNumber value", "value", f);
        }

        static isBigNumber(f) {
          return !(!f || !f._isBigNumber);
        }

      }

      function p(f) {
        if ("string" != typeof f) return p(f.toString(16));
        if ("-" === f[0]) return "-" === (f = f.substring(1))[0] && u.throwArgumentError("invalid hex", "value", f), "0x00" === (f = p(f)) ? f : "-" + f;
        if ("0x" !== f.substring(0, 2) && (f = "0x" + f), "0x" === f) return "0x00";

        for (f.length % 2 && (f = "0x0" + f.substring(2)); f.length > 4 && "0x00" === f.substring(0, 4);) f = "0x" + f.substring(4);

        return f;
      }

      function m(f) {
        return h.from(p(f));
      }

      function y(f) {
        const e = h.from(f).toHexString();
        return "-" === e[0] ? new s("-" + e.substring(3), 16) : new s(e.substring(2), 16);
      }

      function g(f, e, t) {
        const r = {
          fault: f,
          operation: e
        };
        return null != t && (r.value = t), u.throwError(f, a.Logger.errors.NUMERIC_FAULT, r);
      }

      function v(f) {
        return new s(f, 36).toString(16);
      }

      function w(f) {
        return new s(f, 16).toString(36);
      }
    },
    3286: (f, e, t) => {
      "use strict";

      t.r(e), t.d(e, {
        arrayify: () => u,
        concat: () => c,
        hexConcat: () => g,
        hexDataLength: () => m,
        hexDataSlice: () => y,
        hexStripZeros: () => w,
        hexValue: () => v,
        hexZeroPad: () => E,
        hexlify: () => p,
        isBytes: () => s,
        isBytesLike: () => a,
        isHexString: () => l,
        joinSignature: () => A,
        splitSignature: () => S,
        stripZeros: () => d,
        zeroPad: () => b
      });
      const r = new (t(711).Logger)("bytes/5.6.1");

      function n(f) {
        return !!f.toHexString;
      }

      function i(f) {
        return f.slice || (f.slice = function () {
          const e = Array.prototype.slice.call(arguments);
          return i(new Uint8Array(Array.prototype.slice.apply(f, e)));
        }), f;
      }

      function a(f) {
        return l(f) && !(f.length % 2) || s(f);
      }

      function o(f) {
        return "number" == typeof f && f == f && f % 1 == 0;
      }

      function s(f) {
        if (null == f) return !1;
        if (f.constructor === Uint8Array) return !0;
        if ("string" == typeof f) return !1;
        if (!o(f.length) || f.length < 0) return !1;

        for (let e = 0; e < f.length; e++) {
          const t = f[e];
          if (!o(t) || t < 0 || t >= 256) return !1;
        }

        return !0;
      }

      function u(f, e) {
        if (e || (e = {}), "number" == typeof f) {
          r.checkSafeUint53(f, "invalid arrayify value");
          const e = [];

          for (; f;) e.unshift(255 & f), f = parseInt(String(f / 256));

          return 0 === e.length && e.push(0), i(new Uint8Array(e));
        }

        if (e.allowMissingPrefix && "string" == typeof f && "0x" !== f.substring(0, 2) && (f = "0x" + f), n(f) && (f = f.toHexString()), l(f)) {
          let t = f.substring(2);
          t.length % 2 && ("left" === e.hexPad ? t = "0" + t : "right" === e.hexPad ? t += "0" : r.throwArgumentError("hex data is odd-length", "value", f));
          const n = [];

          for (let f = 0; f < t.length; f += 2) n.push(parseInt(t.substring(f, f + 2), 16));

          return i(new Uint8Array(n));
        }

        return s(f) ? i(new Uint8Array(f)) : r.throwArgumentError("invalid arrayify value", "value", f);
      }

      function c(f) {
        const e = f.map(f => u(f)),
              t = e.reduce((f, e) => f + e.length, 0),
              r = new Uint8Array(t);
        return e.reduce((f, e) => (r.set(e, f), f + e.length), 0), i(r);
      }

      function d(f) {
        let e = u(f);
        if (0 === e.length) return e;
        let t = 0;

        for (; t < e.length && 0 === e[t];) t++;

        return t && (e = e.slice(t)), e;
      }

      function b(f, e) {
        (f = u(f)).length > e && r.throwArgumentError("value out of range", "value", arguments[0]);
        const t = new Uint8Array(e);
        return t.set(f, e - f.length), i(t);
      }

      function l(f, e) {
        return !("string" != typeof f || !f.match(/^0x[0-9A-Fa-f]*$/)) && (!e || f.length === 2 + 2 * e);
      }

      const h = "0123456789abcdef";

      function p(f, e) {
        if (e || (e = {}), "number" == typeof f) {
          r.checkSafeUint53(f, "invalid hexlify value");
          let e = "";

          for (; f;) e = h[15 & f] + e, f = Math.floor(f / 16);

          return e.length ? (e.length % 2 && (e = "0" + e), "0x" + e) : "0x00";
        }

        if ("bigint" == typeof f) return (f = f.toString(16)).length % 2 ? "0x0" + f : "0x" + f;
        if (e.allowMissingPrefix && "string" == typeof f && "0x" !== f.substring(0, 2) && (f = "0x" + f), n(f)) return f.toHexString();
        if (l(f)) return f.length % 2 && ("left" === e.hexPad ? f = "0x0" + f.substring(2) : "right" === e.hexPad ? f += "0" : r.throwArgumentError("hex data is odd-length", "value", f)), f.toLowerCase();

        if (s(f)) {
          let e = "0x";

          for (let t = 0; t < f.length; t++) {
            let r = f[t];
            e += h[(240 & r) >> 4] + h[15 & r];
          }

          return e;
        }

        return r.throwArgumentError("invalid hexlify value", "value", f);
      }

      function m(f) {
        if ("string" != typeof f) f = p(f);else if (!l(f) || f.length % 2) return null;
        return (f.length - 2) / 2;
      }

      function y(f, e, t) {
        return "string" != typeof f ? f = p(f) : (!l(f) || f.length % 2) && r.throwArgumentError("invalid hexData", "value", f), e = 2 + 2 * e, null != t ? "0x" + f.substring(e, 2 + 2 * t) : "0x" + f.substring(e);
      }

      function g(f) {
        let e = "0x";
        return f.forEach(f => {
          e += p(f).substring(2);
        }), e;
      }

      function v(f) {
        const e = w(p(f, {
          hexPad: "left"
        }));
        return "0x" === e ? "0x0" : e;
      }

      function w(f) {
        "string" != typeof f && (f = p(f)), l(f) || r.throwArgumentError("invalid hex string", "value", f), f = f.substring(2);
        let e = 0;

        for (; e < f.length && "0" === f[e];) e++;

        return "0x" + f.substring(e);
      }

      function E(f, e) {
        for ("string" != typeof f ? f = p(f) : l(f) || r.throwArgumentError("invalid hex string", "value", f), f.length > 2 * e + 2 && r.throwArgumentError("value out of range", "value", arguments[1]); f.length < 2 * e + 2;) f = "0x0" + f.substring(2);

        return f;
      }

      function S(f) {
        const e = {
          r: "0x",
          s: "0x",
          _vs: "0x",
          recoveryParam: 0,
          v: 0,
          yParityAndS: "0x",
          compact: "0x"
        };

        if (a(f)) {
          let t = u(f);
          64 === t.length ? (e.v = 27 + (t[32] >> 7), t[32] &= 127, e.r = p(t.slice(0, 32)), e.s = p(t.slice(32, 64))) : 65 === t.length ? (e.r = p(t.slice(0, 32)), e.s = p(t.slice(32, 64)), e.v = t[64]) : r.throwArgumentError("invalid signature string", "signature", f), e.v < 27 && (0 === e.v || 1 === e.v ? e.v += 27 : r.throwArgumentError("signature invalid v byte", "signature", f)), e.recoveryParam = 1 - e.v % 2, e.recoveryParam && (t[32] |= 128), e._vs = p(t.slice(32, 64));
        } else {
          if (e.r = f.r, e.s = f.s, e.v = f.v, e.recoveryParam = f.recoveryParam, e._vs = f._vs, null != e._vs) {
            const t = b(u(e._vs), 32);
            e._vs = p(t);
            const n = t[0] >= 128 ? 1 : 0;
            null == e.recoveryParam ? e.recoveryParam = n : e.recoveryParam !== n && r.throwArgumentError("signature recoveryParam mismatch _vs", "signature", f), t[0] &= 127;
            const i = p(t);
            null == e.s ? e.s = i : e.s !== i && r.throwArgumentError("signature v mismatch _vs", "signature", f);
          }

          if (null == e.recoveryParam) null == e.v ? r.throwArgumentError("signature missing v and recoveryParam", "signature", f) : 0 === e.v || 1 === e.v ? e.recoveryParam = e.v : e.recoveryParam = 1 - e.v % 2;else if (null == e.v) e.v = 27 + e.recoveryParam;else {
            const t = 0 === e.v || 1 === e.v ? e.v : 1 - e.v % 2;
            e.recoveryParam !== t && r.throwArgumentError("signature recoveryParam mismatch v", "signature", f);
          }
          null != e.r && l(e.r) ? e.r = E(e.r, 32) : r.throwArgumentError("signature missing or invalid r", "signature", f), null != e.s && l(e.s) ? e.s = E(e.s, 32) : r.throwArgumentError("signature missing or invalid s", "signature", f);
          const t = u(e.s);
          t[0] >= 128 && r.throwArgumentError("signature s out of range", "signature", f), e.recoveryParam && (t[0] |= 128);
          const n = p(t);
          e._vs && (l(e._vs) || r.throwArgumentError("signature invalid _vs", "signature", f), e._vs = E(e._vs, 32)), null == e._vs ? e._vs = n : e._vs !== n && r.throwArgumentError("signature _vs mismatch v and s", "signature", f);
        }

        return e.yParityAndS = e._vs, e.compact = e.r + e.yParityAndS.substring(2), e;
      }

      function A(f) {
        return p(c([(f = S(f)).r, f.s, f.recoveryParam ? "0x1c" : "0x1b"]));
      }
    },
    1046: (f, e, t) => {
      "use strict";

      t.d(e, {
        Bz: () => o,
        _Y: () => i,
        fh: () => a,
        tL: () => n
      });
      var r = t(2593);
      const n = r.O$.from(-1),
            i = r.O$.from(0),
            a = r.O$.from(1),
            o = r.O$.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    },
    5644: (f, e, t) => {
      "use strict";

      t.d(e, {
        i: () => r
      });
      const r = "hash/5.6.0";
    },
    2046: (f, e, t) => {
      "use strict";

      t.d(e, {
        id: () => i
      });
      var r = t(8197),
          n = t(4242);

      function i(f) {
        return (0, r.keccak256)((0, n.Y0)(f));
      }
    },
    4225: (f, e, t) => {
      "use strict";

      t.r(e), t.d(e, {
        _TypedDataEncoder: () => y.E,
        dnsEncode: () => p,
        hashMessage: () => m.r,
        id: () => r.id,
        isValidName: () => l,
        messagePrefix: () => m.B,
        namehash: () => h
      });
      var r = t(2046),
          n = t(3286),
          i = t(5637),
          a = t(4242),
          o = t(8197),
          s = t(711),
          u = t(5644);
      const c = new s.Logger(u.i),
            d = new Uint8Array(32);
      d.fill(0);
      const b = new RegExp("^((.*)\\.)?([^.]+)$");

      function l(f) {
        try {
          const e = f.split(".");

          for (let f = 0; f < e.length; f++) if (0 === (0, i.Ll)(e[f]).length) throw new Error("empty");

          return !0;
        } catch (f) {}

        return !1;
      }

      function h(f) {
        "string" != typeof f && c.throwArgumentError("invalid ENS name; not a string", "name", f);
        let e = f,
            t = d;

        for (; e.length;) {
          const r = e.match(b);
          null != r && "" !== r[2] || c.throwArgumentError("invalid ENS address; missing component", "name", f);
          const s = (0, a.Y0)((0, i.Ll)(r[3]));
          t = (0, o.keccak256)((0, n.concat)([t, (0, o.keccak256)(s)])), e = r[2] || "";
        }

        return (0, n.hexlify)(t);
      }

      function p(f) {
        return (0, n.hexlify)((0, n.concat)(f.split(".").map(f => {
          const e = (0, a.Y0)("_" + (0, i.Ll)(f));
          return e[0] = e.length - 1, e;
        }))) + "00";
      }

      var m = t(3684),
          y = t(7827);
    },
    3684: (f, e, t) => {
      "use strict";

      t.d(e, {
        B: () => a,
        r: () => o
      });
      var r = t(3286),
          n = t(8197),
          i = t(4242);
      const a = "Ethereum Signed Message:\n";

      function o(f) {
        return "string" == typeof f && (f = (0, i.Y0)(f)), (0, n.keccak256)((0, r.concat)([(0, i.Y0)(a), (0, i.Y0)(String(f.length)), f]));
      }
    },
    7827: (f, e, t) => {
      "use strict";

      t.d(e, {
        E: () => M
      });

      var r = t(4594),
          n = t(2593),
          i = t(3286),
          a = t(8197),
          o = t(3587),
          s = t(711),
          u = t(5644),
          c = t(2046),
          d = function (f, e, t, r) {
        return new (t || (t = Promise))(function (n, i) {
          function a(f) {
            try {
              s(r.next(f));
            } catch (f) {
              i(f);
            }
          }

          function o(f) {
            try {
              s(r.throw(f));
            } catch (f) {
              i(f);
            }
          }

          function s(f) {
            var e;
            f.done ? n(f.value) : (e = f.value, e instanceof t ? e : new t(function (f) {
              f(e);
            })).then(a, o);
          }

          s((r = r.apply(f, e || [])).next());
        });
      };

      const b = new s.Logger(u.i),
            l = new Uint8Array(32);
      l.fill(0);
      const h = n.O$.from(-1),
            p = n.O$.from(0),
            m = n.O$.from(1),
            y = n.O$.from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
      const g = (0, i.hexZeroPad)(m.toHexString(), 32),
            v = (0, i.hexZeroPad)(p.toHexString(), 32),
            w = {
        name: "string",
        version: "string",
        chainId: "uint256",
        verifyingContract: "address",
        salt: "bytes32"
      },
            E = ["name", "version", "chainId", "verifyingContract", "salt"];

      function S(f) {
        return function (e) {
          return "string" != typeof e && b.throwArgumentError(`invalid domain value for ${JSON.stringify(f)}`, `domain.${f}`, e), e;
        };
      }

      const A = {
        name: S("name"),
        version: S("version"),
        chainId: function (f) {
          try {
            return n.O$.from(f).toString();
          } catch (f) {}

          return b.throwArgumentError('invalid domain value for "chainId"', "domain.chainId", f);
        },
        verifyingContract: function (f) {
          try {
            return (0, r.getAddress)(f).toLowerCase();
          } catch (f) {}

          return b.throwArgumentError('invalid domain value "verifyingContract"', "domain.verifyingContract", f);
        },
        salt: function (f) {
          try {
            const e = (0, i.arrayify)(f);
            if (32 !== e.length) throw new Error("bad length");
            return (0, i.hexlify)(e);
          } catch (f) {}

          return b.throwArgumentError('invalid domain value "salt"', "domain.salt", f);
        }
      };

      function x(f) {
        {
          const e = f.match(/^(u?)int(\d*)$/);

          if (e) {
            const t = "" === e[1],
                  r = parseInt(e[2] || "256");
            (r % 8 != 0 || r > 256 || e[2] && e[2] !== String(r)) && b.throwArgumentError("invalid numeric width", "type", f);
            const a = y.mask(t ? r - 1 : r),
                  o = t ? a.add(m).mul(h) : p;
            return function (e) {
              const t = n.O$.from(e);
              return (t.lt(o) || t.gt(a)) && b.throwArgumentError(`value out-of-bounds for ${f}`, "value", e), (0, i.hexZeroPad)(t.toTwos(256).toHexString(), 32);
            };
          }
        }
        {
          const e = f.match(/^bytes(\d+)$/);

          if (e) {
            const t = parseInt(e[1]);
            return (0 === t || t > 32 || e[1] !== String(t)) && b.throwArgumentError("invalid bytes width", "type", f), function (e) {
              return (0, i.arrayify)(e).length !== t && b.throwArgumentError(`invalid length for ${f}`, "value", e), function (f) {
                const e = (0, i.arrayify)(f),
                      t = e.length % 32;
                return t ? (0, i.hexConcat)([e, l.slice(t)]) : (0, i.hexlify)(e);
              }(e);
            };
          }
        }

        switch (f) {
          case "address":
            return function (f) {
              return (0, i.hexZeroPad)((0, r.getAddress)(f), 32);
            };

          case "bool":
            return function (f) {
              return f ? g : v;
            };

          case "bytes":
            return function (f) {
              return (0, a.keccak256)(f);
            };

          case "string":
            return function (f) {
              return (0, c.id)(f);
            };
        }

        return null;
      }

      function _(f, e) {
        return `${f}(${e.map(({
          name: f,
          type: e
        }) => e + " " + f).join(",")})`;
      }

      class M {
        constructor(f) {
          (0, o.defineReadOnly)(this, "types", Object.freeze((0, o.deepCopy)(f))), (0, o.defineReadOnly)(this, "_encoderCache", {}), (0, o.defineReadOnly)(this, "_types", {});
          const e = {},
                t = {},
                r = {};
          Object.keys(f).forEach(f => {
            e[f] = {}, t[f] = [], r[f] = {};
          });

          for (const r in f) {
            const n = {};
            f[r].forEach(i => {
              n[i.name] && b.throwArgumentError(`duplicate variable name ${JSON.stringify(i.name)} in ${JSON.stringify(r)}`, "types", f), n[i.name] = !0;
              const a = i.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
              a === r && b.throwArgumentError(`circular type reference to ${JSON.stringify(a)}`, "types", f);
              x(a) || (t[a] || b.throwArgumentError(`unknown type ${JSON.stringify(a)}`, "types", f), t[a].push(r), e[r][a] = !0);
            });
          }

          const n = Object.keys(t).filter(f => 0 === t[f].length);
          0 === n.length ? b.throwArgumentError("missing primary type", "types", f) : n.length > 1 && b.throwArgumentError(`ambiguous primary types or unused types: ${n.map(f => JSON.stringify(f)).join(", ")}`, "types", f), (0, o.defineReadOnly)(this, "primaryType", n[0]), function n(i, a) {
            a[i] && b.throwArgumentError(`circular type reference to ${JSON.stringify(i)}`, "types", f), a[i] = !0, Object.keys(e[i]).forEach(f => {
              t[f] && (n(f, a), Object.keys(a).forEach(e => {
                r[e][f] = !0;
              }));
            }), delete a[i];
          }(this.primaryType, {});

          for (const e in r) {
            const t = Object.keys(r[e]);
            t.sort(), this._types[e] = _(e, f[e]) + t.map(e => _(e, f[e])).join("");
          }
        }

        getEncoder(f) {
          let e = this._encoderCache[f];
          return e || (e = this._encoderCache[f] = this._getEncoder(f)), e;
        }

        _getEncoder(f) {
          {
            const e = x(f);
            if (e) return e;
          }
          const e = f.match(/^(.*)(\x5b(\d*)\x5d)$/);

          if (e) {
            const f = e[1],
                  t = this.getEncoder(f),
                  r = parseInt(e[3]);
            return e => {
              r >= 0 && e.length !== r && b.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", e);
              let n = e.map(t);
              return this._types[f] && (n = n.map(a.keccak256)), (0, a.keccak256)((0, i.hexConcat)(n));
            };
          }

          const t = this.types[f];

          if (t) {
            const e = (0, c.id)(this._types[f]);
            return f => {
              const r = t.map(({
                name: e,
                type: t
              }) => {
                const r = this.getEncoder(t)(f[e]);
                return this._types[t] ? (0, a.keccak256)(r) : r;
              });
              return r.unshift(e), (0, i.hexConcat)(r);
            };
          }

          return b.throwArgumentError(`unknown type: ${f}`, "type", f);
        }

        encodeType(f) {
          const e = this._types[f];
          return e || b.throwArgumentError(`unknown type: ${JSON.stringify(f)}`, "name", f), e;
        }

        encodeData(f, e) {
          return this.getEncoder(f)(e);
        }

        hashStruct(f, e) {
          return (0, a.keccak256)(this.encodeData(f, e));
        }

        encode(f) {
          return this.encodeData(this.primaryType, f);
        }

        hash(f) {
          return this.hashStruct(this.primaryType, f);
        }

        _visit(f, e, t) {
          if (x(f)) return t(f, e);
          const r = f.match(/^(.*)(\x5b(\d*)\x5d)$/);

          if (r) {
            const f = r[1],
                  n = parseInt(r[3]);
            return n >= 0 && e.length !== n && b.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", e), e.map(e => this._visit(f, e, t));
          }

          const n = this.types[f];
          return n ? n.reduce((f, {
            name: r,
            type: n
          }) => (f[r] = this._visit(n, e[r], t), f), {}) : b.throwArgumentError(`unknown type: ${f}`, "type", f);
        }

        visit(f, e) {
          return this._visit(this.primaryType, f, e);
        }

        static from(f) {
          return new M(f);
        }

        static getPrimaryType(f) {
          return M.from(f).primaryType;
        }

        static hashStruct(f, e, t) {
          return M.from(e).hashStruct(f, t);
        }

        static hashDomain(f) {
          const e = [];

          for (const t in f) {
            const r = w[t];
            r || b.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(t)}`, "domain", f), e.push({
              name: t,
              type: r
            });
          }

          return e.sort((f, e) => E.indexOf(f.name) - E.indexOf(e.name)), M.hashStruct("EIP712Domain", {
            EIP712Domain: e
          }, f);
        }

        static encode(f, e, t) {
          return (0, i.hexConcat)(["0x1901", M.hashDomain(f), M.from(e).hash(t)]);
        }

        static hash(f, e, t) {
          return (0, a.keccak256)(M.encode(f, e, t));
        }

        static resolveNames(f, e, t, r) {
          return d(this, void 0, void 0, function* () {
            f = (0, o.shallowCopy)(f);
            const n = {};
            f.verifyingContract && !(0, i.isHexString)(f.verifyingContract, 20) && (n[f.verifyingContract] = "0x");
            const a = M.from(e);
            a.visit(t, (f, e) => ("address" !== f || (0, i.isHexString)(e, 20) || (n[e] = "0x"), e));

            for (const f in n) n[f] = yield r(f);

            return f.verifyingContract && n[f.verifyingContract] && (f.verifyingContract = n[f.verifyingContract]), t = a.visit(t, (f, e) => "address" === f && n[e] ? n[e] : e), {
              domain: f,
              value: t
            };
          });
        }

        static getPayload(f, e, t) {
          M.hashDomain(f);
          const r = {},
                a = [];
          E.forEach(e => {
            const t = f[e];
            null != t && (r[e] = A[e](t), a.push({
              name: e,
              type: w[e]
            }));
          });
          const s = M.from(e),
                u = (0, o.shallowCopy)(e);
          return u.EIP712Domain ? b.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", e) : u.EIP712Domain = a, s.encode(t), {
            types: u,
            domain: r,
            primaryType: s.primaryType,
            message: s.visit(t, (f, e) => {
              if (f.match(/^bytes(\d*)/)) return (0, i.hexlify)((0, i.arrayify)(e));
              if (f.match(/^u?int/)) return n.O$.from(e).toString();

              switch (f) {
                case "address":
                  return e.toLowerCase();

                case "bool":
                  return !!e;

                case "string":
                  return "string" != typeof e && b.throwArgumentError("invalid string", "value", e), e;
              }

              return b.throwArgumentError("unsupported type", "type", f);
            })
          };
        }

      }
    },
    4692: (f, e, t) => {
      "use strict";

      t.r(e), t.d(e, {
        HDNode: () => R,
        defaultPath: () => C,
        entropyToMnemonic: () => I,
        getAccountPath: () => B,
        isValidMnemonic: () => F,
        mnemonicToEntropy: () => k,
        mnemonicToSeed: () => N
      });
      var r = t(7727),
          n = t(3286),
          i = t(2593),
          a = t(4242),
          o = t(5306),
          s = t(3587),
          u = t(2768),
          c = t(3951),
          d = t(1261),
          b = t(4377),
          l = t(2046),
          h = t(711);
      const p = new h.Logger("wordlists/5.6.0");

      class m {
        constructor(f) {
          p.checkAbstract(new.target, m), (0, s.defineReadOnly)(this, "locale", f);
        }

        split(f) {
          return f.toLowerCase().split(/ +/g);
        }

        join(f) {
          return f.join(" ");
        }

        static check(f) {
          const e = [];

          for (let t = 0; t < 2048; t++) {
            const r = f.getWord(t);
            if (t !== f.getWordIndex(r)) return "0x";
            e.push(r);
          }

          return (0, l.id)(e.join("\n") + "\n");
        }

        static register(f, e) {
          e || (e = f.locale);
        }

      }

      let y = null;

      function g(f) {
        if (null == y && (y = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo".replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" "), "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60" !== m.check(f))) throw y = null, new Error("BIP39 Wordlist for en (English) FAILED");
      }

      const v = new class extends m {
        constructor() {
          super("en");
        }

        getWord(f) {
          return g(this), y[f];
        }

        getWordIndex(f) {
          return g(this), y.indexOf(f);
        }

      }();
      m.register(v);
      const w = {
        en: v
      },
            E = new h.Logger("hdnode/5.6.0"),
            S = i.O$.from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
            A = (0, a.Y0)("Bitcoin seed"),
            x = 2147483648;

      function _(f) {
        return (1 << f) - 1 << 8 - f;
      }

      function M(f) {
        return (0, n.hexZeroPad)((0, n.hexlify)(f), 32);
      }

      function P(f) {
        return r.Base58.encode((0, n.concat)([f, (0, n.hexDataSlice)((0, c.JQ)((0, c.JQ)(f)), 0, 4)]));
      }

      function T(f) {
        if (null == f) return w.en;

        if ("string" == typeof f) {
          const e = w[f];
          return null == e && E.throwArgumentError("unknown locale", "wordlist", f), e;
        }

        return f;
      }

      const O = {},
            C = "m/44'/60'/0'/0/0";

      class R {
        constructor(f, e, t, r, i, a, o, d) {
          if (E.checkNew(new.target, R), f !== O) throw new Error("HDNode constructor cannot be called directly");

          if (e) {
            const f = new u.SigningKey(e);
            (0, s.defineReadOnly)(this, "privateKey", f.privateKey), (0, s.defineReadOnly)(this, "publicKey", f.compressedPublicKey);
          } else (0, s.defineReadOnly)(this, "privateKey", null), (0, s.defineReadOnly)(this, "publicKey", (0, n.hexlify)(t));

          (0, s.defineReadOnly)(this, "parentFingerprint", r), (0, s.defineReadOnly)(this, "fingerprint", (0, n.hexDataSlice)((0, c.bP)((0, c.JQ)(this.publicKey)), 0, 4)), (0, s.defineReadOnly)(this, "address", (0, b.computeAddress)(this.publicKey)), (0, s.defineReadOnly)(this, "chainCode", i), (0, s.defineReadOnly)(this, "index", a), (0, s.defineReadOnly)(this, "depth", o), null == d ? ((0, s.defineReadOnly)(this, "mnemonic", null), (0, s.defineReadOnly)(this, "path", null)) : "string" == typeof d ? ((0, s.defineReadOnly)(this, "mnemonic", null), (0, s.defineReadOnly)(this, "path", d)) : ((0, s.defineReadOnly)(this, "mnemonic", d), (0, s.defineReadOnly)(this, "path", d.path));
        }

        get extendedKey() {
          if (this.depth >= 256) throw new Error("Depth too large!");
          return P((0, n.concat)([null != this.privateKey ? "0x0488ADE4" : "0x0488B21E", (0, n.hexlify)(this.depth), this.parentFingerprint, (0, n.hexZeroPad)((0, n.hexlify)(this.index), 4), this.chainCode, null != this.privateKey ? (0, n.concat)(["0x00", this.privateKey]) : this.publicKey]));
        }

        neuter() {
          return new R(O, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
        }

        _derive(f) {
          if (f > 4294967295) throw new Error("invalid index - " + String(f));
          let e = this.path;
          e && (e += "/" + (2147483647 & f));
          const t = new Uint8Array(37);

          if (f & x) {
            if (!this.privateKey) throw new Error("cannot derive child of neutered node");
            t.set((0, n.arrayify)(this.privateKey), 1), e && (e += "'");
          } else t.set((0, n.arrayify)(this.publicKey));

          for (let e = 24; e >= 0; e -= 8) t[33 + (e >> 3)] = f >> 24 - e & 255;

          const r = (0, n.arrayify)((0, c.Gy)(d.p.sha512, this.chainCode, t)),
                a = r.slice(0, 32),
                o = r.slice(32);
          let s = null,
              b = null;
          if (this.privateKey) s = M(i.O$.from(a).add(this.privateKey).mod(S));else {
            b = new u.SigningKey((0, n.hexlify)(a))._addPoint(this.publicKey);
          }
          let l = e;
          const h = this.mnemonic;
          return h && (l = Object.freeze({
            phrase: h.phrase,
            path: e,
            locale: h.locale || "en"
          })), new R(O, s, b, this.fingerprint, M(o), f, this.depth + 1, l);
        }

        derivePath(f) {
          const e = f.split("/");
          if (0 === e.length || "m" === e[0] && 0 !== this.depth) throw new Error("invalid path - " + f);
          "m" === e[0] && e.shift();
          let t = this;

          for (let f = 0; f < e.length; f++) {
            const r = e[f];

            if (r.match(/^[0-9]+'$/)) {
              const f = parseInt(r.substring(0, r.length - 1));
              if (f >= x) throw new Error("invalid path index - " + r);
              t = t._derive(x + f);
            } else {
              if (!r.match(/^[0-9]+$/)) throw new Error("invalid path component - " + r);
              {
                const f = parseInt(r);
                if (f >= x) throw new Error("invalid path index - " + r);
                t = t._derive(f);
              }
            }
          }

          return t;
        }

        static _fromSeed(f, e) {
          const t = (0, n.arrayify)(f);
          if (t.length < 16 || t.length > 64) throw new Error("invalid seed");
          const r = (0, n.arrayify)((0, c.Gy)(d.p.sha512, A, t));
          return new R(O, M(r.slice(0, 32)), null, "0x00000000", M(r.slice(32)), 0, 0, e);
        }

        static fromMnemonic(f, e, t) {
          return f = I(k(f, t = T(t)), t), R._fromSeed(N(f, e), {
            phrase: f,
            path: "m",
            locale: t.locale
          });
        }

        static fromSeed(f) {
          return R._fromSeed(f, null);
        }

        static fromExtendedKey(f) {
          const e = r.Base58.decode(f);
          82 === e.length && P(e.slice(0, 78)) === f || E.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
          const t = e[4],
                i = (0, n.hexlify)(e.slice(5, 9)),
                a = parseInt((0, n.hexlify)(e.slice(9, 13)).substring(2), 16),
                o = (0, n.hexlify)(e.slice(13, 45)),
                s = e.slice(45, 78);

          switch ((0, n.hexlify)(e.slice(0, 4))) {
            case "0x0488b21e":
            case "0x043587cf":
              return new R(O, null, (0, n.hexlify)(s), i, o, a, t, null);

            case "0x0488ade4":
            case "0x04358394 ":
              if (0 !== s[0]) break;
              return new R(O, (0, n.hexlify)(s.slice(1)), null, i, o, a, t, null);
          }

          return E.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
        }

      }

      function N(f, e) {
        e || (e = "");
        const t = (0, a.Y0)("mnemonic" + e, a.Uj.NFKD);
        return (0, o.n)((0, a.Y0)(f, a.Uj.NFKD), t, 2048, 64, "sha512");
      }

      function k(f, e) {
        e = T(e), E.checkNormalize();
        const t = e.split(f);
        if (t.length % 3 != 0) throw new Error("invalid mnemonic");
        const r = (0, n.arrayify)(new Uint8Array(Math.ceil(11 * t.length / 8)));
        let i = 0;

        for (let f = 0; f < t.length; f++) {
          let n = e.getWordIndex(t[f].normalize("NFKD"));
          if (-1 === n) throw new Error("invalid mnemonic");

          for (let f = 0; f < 11; f++) n & 1 << 10 - f && (r[i >> 3] |= 1 << 7 - i % 8), i++;
        }

        const a = 32 * t.length / 3,
              o = _(t.length / 3);

        if (((0, n.arrayify)((0, c.JQ)(r.slice(0, a / 8)))[0] & o) !== (r[r.length - 1] & o)) throw new Error("invalid checksum");
        return (0, n.hexlify)(r.slice(0, a / 8));
      }

      function I(f, e) {
        if (e = T(e), (f = (0, n.arrayify)(f)).length % 4 != 0 || f.length < 16 || f.length > 32) throw new Error("invalid entropy");
        const t = [0];
        let r = 11;

        for (let e = 0; e < f.length; e++) r > 8 ? (t[t.length - 1] <<= 8, t[t.length - 1] |= f[e], r -= 8) : (t[t.length - 1] <<= r, t[t.length - 1] |= f[e] >> 8 - r, t.push(f[e] & (1 << 8 - r) - 1), r += 3);

        const i = f.length / 4,
              a = (0, n.arrayify)((0, c.JQ)(f))[0] & _(i);

        return t[t.length - 1] <<= i, t[t.length - 1] |= a >> 8 - i, e.join(t.map(f => e.getWord(f)));
      }

      function F(f, e) {
        try {
          return k(f, e), !0;
        } catch (f) {}

        return !1;
      }

      function B(f) {
        return ("number" != typeof f || f < 0 || f >= x || f % 1) && E.throwArgumentError("invalid account index", "index", f), `m/44'/60'/${f}'/0/0`;
      }
    },
    9816: (f, e, t) => {
      "use strict";

      t.d(e, {
        i: () => r
      });
      const r = "json-wallets/5.6.0";
    },
    6883: (f, e, t) => {
      "use strict";

      t.r(e), t.d(e, {
        decryptCrowdsale: () => m,
        decryptJsonWallet: () => E,
        decryptJsonWalletSync: () => S,
        decryptKeystore: () => w.pe,
        decryptKeystoreSync: () => w.hb,
        encryptKeystore: () => w.HI,
        getJsonWalletAddress: () => v,
        isCrowdsaleWallet: () => y,
        isKeystoreWallet: () => g
      });
      var r = t(8826),
          n = t.n(r),
          i = t(4594),
          a = t(3286),
          o = t(8197),
          s = t(5306),
          u = t(4242),
          c = t(3587),
          d = t(711),
          b = t(9816),
          l = t(7013);
      const h = new d.Logger(b.i);

      class p extends c.Description {
        isCrowdsaleAccount(f) {
          return !(!f || !f._isCrowdsaleAccount);
        }

      }

      function m(f, e) {
        const t = JSON.parse(f);
        e = (0, l.Ij)(e);
        const r = (0, i.getAddress)((0, l.gx)(t, "ethaddr")),
              c = (0, l.p3)((0, l.gx)(t, "encseed"));
        c && c.length % 16 == 0 || h.throwArgumentError("invalid encseed", "json", f);
        const d = (0, a.arrayify)((0, s.n)(e, e, 2e3, 32, "sha256")).slice(0, 16),
              b = c.slice(0, 16),
              m = c.slice(16),
              y = new (n().ModeOfOperation.cbc)(d, b),
              g = n().padding.pkcs7.strip((0, a.arrayify)(y.decrypt(m)));
        let v = "";

        for (let f = 0; f < g.length; f++) v += String.fromCharCode(g[f]);

        const w = (0, u.Y0)(v),
              E = (0, o.keccak256)(w);
        return new p({
          _isCrowdsaleAccount: !0,
          address: r,
          privateKey: E
        });
      }

      function y(f) {
        let e = null;

        try {
          e = JSON.parse(f);
        } catch (f) {
          return !1;
        }

        return e.encseed && e.ethaddr;
      }

      function g(f) {
        let e = null;

        try {
          e = JSON.parse(f);
        } catch (f) {
          return !1;
        }

        return !(!e.version || parseInt(e.version) !== e.version || 3 !== parseInt(e.version));
      }

      function v(f) {
        if (y(f)) try {
          return (0, i.getAddress)(JSON.parse(f).ethaddr);
        } catch (f) {
          return null;
        }
        if (g(f)) try {
          return (0, i.getAddress)(JSON.parse(f).address);
        } catch (f) {
          return null;
        }
        return null;
      }

      var w = t(1964);

      function E(f, e, t) {
        if (y(f)) {
          t && t(0);
          const r = m(f, e);
          return t && t(1), Promise.resolve(r);
        }

        return g(f) ? (0, w.pe)(f, e, t) : Promise.reject(new Error("invalid JSON wallet"));
      }

      function S(f, e) {
        if (y(f)) return m(f, e);
        if (g(f)) return (0, w.hb)(f, e);
        throw new Error("invalid JSON wallet");
      }
    },
    1964: (f, e, t) => {
      "use strict";

      t.d(e, {
        HI: () => T,
        hb: () => M,
        pe: () => P
      });

      var r = t(8826),
          n = t.n(r),
          i = t(7635),
          a = t.n(i),
          o = t(4594),
          s = t(3286),
          u = t(4692),
          c = t(8197),
          d = t(5306),
          b = t(4478),
          l = t(3587),
          h = t(4377),
          p = t(7013),
          m = t(711),
          y = t(9816),
          g = function (f, e, t, r) {
        return new (t || (t = Promise))(function (n, i) {
          function a(f) {
            try {
              s(r.next(f));
            } catch (f) {
              i(f);
            }
          }

          function o(f) {
            try {
              s(r.throw(f));
            } catch (f) {
              i(f);
            }
          }

          function s(f) {
            var e;
            f.done ? n(f.value) : (e = f.value, e instanceof t ? e : new t(function (f) {
              f(e);
            })).then(a, o);
          }

          s((r = r.apply(f, e || [])).next());
        });
      };

      const v = new m.Logger(y.i);

      function w(f) {
        return null != f && f.mnemonic && f.mnemonic.phrase;
      }

      class E extends l.Description {
        isKeystoreAccount(f) {
          return !(!f || !f._isKeystoreAccount);
        }

      }

      function S(f, e) {
        const t = (0, p.p3)((0, p.gx)(f, "crypto/ciphertext"));
        if ((0, s.hexlify)((0, c.keccak256)((0, s.concat)([e.slice(16, 32), t]))).substring(2) !== (0, p.gx)(f, "crypto/mac").toLowerCase()) throw new Error("invalid password");

        const r = function (f, e, t) {
          if ("aes-128-ctr" === (0, p.gx)(f, "crypto/cipher")) {
            const r = (0, p.p3)((0, p.gx)(f, "crypto/cipherparams/iv")),
                  i = new (n().Counter)(r),
                  a = new (n().ModeOfOperation.ctr)(e, i);
            return (0, s.arrayify)(a.decrypt(t));
          }

          return null;
        }(f, e.slice(0, 16), t);

        r || v.throwError("unsupported cipher", m.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "decrypt"
        });
        const i = e.slice(32, 64),
              a = (0, h.computeAddress)(r);

        if (f.address) {
          let e = f.address.toLowerCase();
          if ("0x" !== e.substring(0, 2) && (e = "0x" + e), (0, o.getAddress)(e) !== a) throw new Error("address mismatch");
        }

        const d = {
          _isKeystoreAccount: !0,
          address: a,
          privateKey: (0, s.hexlify)(r)
        };

        if ("0.1" === (0, p.gx)(f, "x-ethers/version")) {
          const e = (0, p.p3)((0, p.gx)(f, "x-ethers/mnemonicCiphertext")),
                t = (0, p.p3)((0, p.gx)(f, "x-ethers/mnemonicCounter")),
                r = new (n().Counter)(t),
                a = new (n().ModeOfOperation.ctr)(i, r),
                o = (0, p.gx)(f, "x-ethers/path") || u.defaultPath,
                c = (0, p.gx)(f, "x-ethers/locale") || "en",
                b = (0, s.arrayify)(a.decrypt(e));

          try {
            const f = (0, u.entropyToMnemonic)(b, c),
                  e = u.HDNode.fromMnemonic(f, null, c).derivePath(o);
            if (e.privateKey != d.privateKey) throw new Error("mnemonic mismatch");
            d.mnemonic = e.mnemonic;
          } catch (f) {
            if (f.code !== m.Logger.errors.INVALID_ARGUMENT || "wordlist" !== f.argument) throw f;
          }
        }

        return new E(d);
      }

      function A(f, e, t, r, n) {
        return (0, s.arrayify)((0, d.n)(f, e, t, r, n));
      }

      function x(f, e, t, r, n) {
        return Promise.resolve(A(f, e, t, r, n));
      }

      function _(f, e, t, r, n) {
        const i = (0, p.Ij)(e),
              a = (0, p.gx)(f, "crypto/kdf");

        if (a && "string" == typeof a) {
          const e = function (f, e) {
            return v.throwArgumentError("invalid key-derivation function parameters", f, e);
          };

          if ("scrypt" === a.toLowerCase()) {
            const t = (0, p.p3)((0, p.gx)(f, "crypto/kdfparams/salt")),
                  o = parseInt((0, p.gx)(f, "crypto/kdfparams/n")),
                  s = parseInt((0, p.gx)(f, "crypto/kdfparams/r")),
                  u = parseInt((0, p.gx)(f, "crypto/kdfparams/p"));
            o && s && u || e("kdf", a), 0 != (o & o - 1) && e("N", o);
            const c = parseInt((0, p.gx)(f, "crypto/kdfparams/dklen"));
            return 32 !== c && e("dklen", c), r(i, t, o, s, u, 64, n);
          }

          if ("pbkdf2" === a.toLowerCase()) {
            const r = (0, p.p3)((0, p.gx)(f, "crypto/kdfparams/salt"));
            let n = null;
            const a = (0, p.gx)(f, "crypto/kdfparams/prf");
            "hmac-sha256" === a ? n = "sha256" : "hmac-sha512" === a ? n = "sha512" : e("prf", a);
            const o = parseInt((0, p.gx)(f, "crypto/kdfparams/c")),
                  s = parseInt((0, p.gx)(f, "crypto/kdfparams/dklen"));
            return 32 !== s && e("dklen", s), t(i, r, o, s, n);
          }
        }

        return v.throwArgumentError("unsupported key-derivation function", "kdf", a);
      }

      function M(f, e) {
        const t = JSON.parse(f);
        return S(t, _(t, e, A, a().syncScrypt));
      }

      function P(f, e, t) {
        return g(this, void 0, void 0, function* () {
          const r = JSON.parse(f);
          return S(r, yield _(r, e, x, a().scrypt, t));
        });
      }

      function T(f, e, t, r) {
        try {
          if ((0, o.getAddress)(f.address) !== (0, h.computeAddress)(f.privateKey)) throw new Error("address/privateKey mismatch");

          if (w(f)) {
            const e = f.mnemonic;
            if (u.HDNode.fromMnemonic(e.phrase, null, e.locale).derivePath(e.path || u.defaultPath).privateKey != f.privateKey) throw new Error("mnemonic mismatch");
          }
        } catch (f) {
          return Promise.reject(f);
        }

        "function" != typeof t || r || (r = t, t = {}), t || (t = {});
        const i = (0, s.arrayify)(f.privateKey),
              d = (0, p.Ij)(e);
        let l = null,
            m = null,
            y = null;

        if (w(f)) {
          const e = f.mnemonic;
          l = (0, s.arrayify)((0, u.mnemonicToEntropy)(e.phrase, e.locale || "en")), m = e.path || u.defaultPath, y = e.locale || "en";
        }

        let g = t.client;
        g || (g = "ethers.js");
        let v = null;
        v = t.salt ? (0, s.arrayify)(t.salt) : (0, b.O)(32);
        let E = null;

        if (t.iv) {
          if (E = (0, s.arrayify)(t.iv), 16 !== E.length) throw new Error("invalid iv");
        } else E = (0, b.O)(16);

        let S = null;

        if (t.uuid) {
          if (S = (0, s.arrayify)(t.uuid), 16 !== S.length) throw new Error("invalid uuid");
        } else S = (0, b.O)(16);

        let A = 1 << 17,
            x = 8,
            _ = 1;
        return t.scrypt && (t.scrypt.N && (A = t.scrypt.N), t.scrypt.r && (x = t.scrypt.r), t.scrypt.p && (_ = t.scrypt.p)), a().scrypt(d, v, A, x, _, 64, r).then(e => {
          const t = (e = (0, s.arrayify)(e)).slice(0, 16),
                r = e.slice(16, 32),
                a = e.slice(32, 64),
                o = new (n().Counter)(E),
                u = new (n().ModeOfOperation.ctr)(t, o),
                d = (0, s.arrayify)(u.encrypt(i)),
                h = (0, c.keccak256)((0, s.concat)([r, d])),
                w = {
            address: f.address.substring(2).toLowerCase(),
            id: (0, p.EH)(S),
            version: 3,
            Crypto: {
              cipher: "aes-128-ctr",
              cipherparams: {
                iv: (0, s.hexlify)(E).substring(2)
              },
              ciphertext: (0, s.hexlify)(d).substring(2),
              kdf: "scrypt",
              kdfparams: {
                salt: (0, s.hexlify)(v).substring(2),
                n: A,
                dklen: 32,
                p: _,
                r: x
              },
              mac: h.substring(2)
            }
          };

          if (l) {
            const f = (0, b.O)(16),
                  e = new (n().Counter)(f),
                  t = new (n().ModeOfOperation.ctr)(a, e),
                  r = (0, s.arrayify)(t.encrypt(l)),
                  i = new Date(),
                  o = i.getUTCFullYear() + "-" + (0, p.VP)(i.getUTCMonth() + 1, 2) + "-" + (0, p.VP)(i.getUTCDate(), 2) + "T" + (0, p.VP)(i.getUTCHours(), 2) + "-" + (0, p.VP)(i.getUTCMinutes(), 2) + "-" + (0, p.VP)(i.getUTCSeconds(), 2) + ".0Z";
            w["x-ethers"] = {
              client: g,
              gethFilename: "UTC--" + o + "--" + w.address,
              mnemonicCounter: (0, s.hexlify)(f).substring(2),
              mnemonicCiphertext: (0, s.hexlify)(r).substring(2),
              path: m,
              locale: y,
              version: "0.1"
            };
          }

          return JSON.stringify(w);
        });
      }
    },
    7013: (f, e, t) => {
      "use strict";

      t.d(e, {
        EH: () => u,
        Ij: () => o,
        VP: () => a,
        gx: () => s,
        p3: () => i
      });
      var r = t(3286),
          n = t(4242);

      function i(f) {
        return "string" == typeof f && "0x" !== f.substring(0, 2) && (f = "0x" + f), (0, r.arrayify)(f);
      }

      function a(f, e) {
        for (f = String(f); f.length < e;) f = "0" + f;

        return f;
      }

      function o(f) {
        return "string" == typeof f ? (0, n.Y0)(f, n.Uj.NFKC) : (0, r.arrayify)(f);
      }

      function s(f, e) {
        let t = f;
        const r = e.toLowerCase().split("/");

        for (let f = 0; f < r.length; f++) {
          let e = null;

          for (const n in t) if (n.toLowerCase() === r[f]) {
            e = t[n];
            break;
          }

          if (null === e) return null;
          t = e;
        }

        return t;
      }

      function u(f) {
        const e = (0, r.arrayify)(f);
        e[6] = 15 & e[6] | 64, e[8] = 63 & e[8] | 128;
        const t = (0, r.hexlify)(e);
        return [t.substring(2, 10), t.substring(10, 14), t.substring(14, 18), t.substring(18, 22), t.substring(22, 34)].join("-");
      }
    },
    8197: (f, e, t) => {
      "use strict";

      t.r(e), t.d(e, {
        keccak256: () => a
      });
      var r = t(1094),
          n = t.n(r),
          i = t(3286);

      function a(f) {
        return "0x" + n().keccak_256((0, i.arrayify)(f));
      }
    },
    711: (f, e, t) => {
      "use strict";

      t.r(e), t.d(e, {
        ErrorCode: () => c,
        LogLevel: () => u,
        Logger: () => b
      });
      let r = !1,
          n = !1;
      const i = {
        debug: 1,
        default: 2,
        info: 2,
        warning: 3,
        error: 4,
        off: 5
      };
      let a = i.default,
          o = null;

      const s = function () {
        try {
          const f = [];
          if (["NFD", "NFC", "NFKD", "NFKC"].forEach(e => {
            try {
              if ("test" !== "test".normalize(e)) throw new Error("bad normalize");
            } catch (t) {
              f.push(e);
            }
          }), f.length) throw new Error("missing " + f.join(", "));
          if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769)) throw new Error("broken implementation");
        } catch (f) {
          return f.message;
        }

        return null;
      }();

      var u, c;
      !function (f) {
        f.DEBUG = "DEBUG", f.INFO = "INFO", f.WARNING = "WARNING", f.ERROR = "ERROR", f.OFF = "OFF";
      }(u || (u = {})), function (f) {
        f.UNKNOWN_ERROR = "UNKNOWN_ERROR", f.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", f.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", f.NETWORK_ERROR = "NETWORK_ERROR", f.SERVER_ERROR = "SERVER_ERROR", f.TIMEOUT = "TIMEOUT", f.BUFFER_OVERRUN = "BUFFER_OVERRUN", f.NUMERIC_FAULT = "NUMERIC_FAULT", f.MISSING_NEW = "MISSING_NEW", f.INVALID_ARGUMENT = "INVALID_ARGUMENT", f.MISSING_ARGUMENT = "MISSING_ARGUMENT", f.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", f.CALL_EXCEPTION = "CALL_EXCEPTION", f.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", f.NONCE_EXPIRED = "NONCE_EXPIRED", f.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", f.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", f.TRANSACTION_REPLACED = "TRANSACTION_REPLACED";
      }(c || (c = {}));
      const d = "0123456789abcdef";

      class b {
        constructor(f) {
          Object.defineProperty(this, "version", {
            enumerable: !0,
            value: f,
            writable: !1
          });
        }

        _log(f, e) {
          const t = f.toLowerCase();
          null == i[t] && this.throwArgumentError("invalid log level name", "logLevel", f), a > i[t] || console.log.apply(console, e);
        }

        debug(...f) {
          this._log(b.levels.DEBUG, f);
        }

        info(...f) {
          this._log(b.levels.INFO, f);
        }

        warn(...f) {
          this._log(b.levels.WARNING, f);
        }

        makeError(f, e, t) {
          if (n) return this.makeError("censored error", e, {});
          e || (e = b.errors.UNKNOWN_ERROR), t || (t = {});
          const r = [];
          Object.keys(t).forEach(f => {
            const e = t[f];

            try {
              if (e instanceof Uint8Array) {
                let t = "";

                for (let f = 0; f < e.length; f++) t += d[e[f] >> 4], t += d[15 & e[f]];

                r.push(f + "=Uint8Array(0x" + t + ")");
              } else r.push(f + "=" + JSON.stringify(e));
            } catch (e) {
              r.push(f + "=" + JSON.stringify(t[f].toString()));
            }
          }), r.push(`code=${e}`), r.push(`version=${this.version}`);
          const i = f;
          let a = "";

          switch (e) {
            case c.NUMERIC_FAULT:
              {
                a = "NUMERIC_FAULT";
                const e = f;

                switch (e) {
                  case "overflow":
                  case "underflow":
                  case "division-by-zero":
                    a += "-" + e;
                    break;

                  case "negative-power":
                  case "negative-width":
                    a += "-unsupported";
                    break;

                  case "unbound-bitwise-result":
                    a += "-unbound-result";
                }

                break;
              }

            case c.CALL_EXCEPTION:
            case c.INSUFFICIENT_FUNDS:
            case c.MISSING_NEW:
            case c.NONCE_EXPIRED:
            case c.REPLACEMENT_UNDERPRICED:
            case c.TRANSACTION_REPLACED:
            case c.UNPREDICTABLE_GAS_LIMIT:
              a = e;
          }

          a && (f += " [ See: https://links.ethers.org/v5-errors-" + a + " ]"), r.length && (f += " (" + r.join(", ") + ")");
          const o = new Error(f);
          return o.reason = i, o.code = e, Object.keys(t).forEach(function (f) {
            o[f] = t[f];
          }), o;
        }

        throwError(f, e, t) {
          throw this.makeError(f, e, t);
        }

        throwArgumentError(f, e, t) {
          return this.throwError(f, b.errors.INVALID_ARGUMENT, {
            argument: e,
            value: t
          });
        }

        assert(f, e, t, r) {
          f || this.throwError(e, t, r);
        }

        assertArgument(f, e, t, r) {
          f || this.throwArgumentError(e, t, r);
        }

        checkNormalize(f) {
          null == f && (f = "platform missing String.prototype.normalize"), s && this.throwError("platform missing String.prototype.normalize", b.errors.UNSUPPORTED_OPERATION, {
            operation: "String.prototype.normalize",
            form: s
          });
        }

        checkSafeUint53(f, e) {
          "number" == typeof f && (null == e && (e = "value not safe"), (f < 0 || f >= 9007199254740991) && this.throwError(e, b.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "out-of-safe-range",
            value: f
          }), f % 1 && this.throwError(e, b.errors.NUMERIC_FAULT, {
            operation: "checkSafeInteger",
            fault: "non-integer",
            value: f
          }));
        }

        checkArgumentCount(f, e, t) {
          t = t ? ": " + t : "", f < e && this.throwError("missing argument" + t, b.errors.MISSING_ARGUMENT, {
            count: f,
            expectedCount: e
          }), f > e && this.throwError("too many arguments" + t, b.errors.UNEXPECTED_ARGUMENT, {
            count: f,
            expectedCount: e
          });
        }

        checkNew(f, e) {
          f !== Object && null != f || this.throwError("missing new", b.errors.MISSING_NEW, {
            name: e.name
          });
        }

        checkAbstract(f, e) {
          f === e ? this.throwError("cannot instantiate abstract class " + JSON.stringify(e.name) + " directly; use a sub-class", b.errors.UNSUPPORTED_OPERATION, {
            name: f.name,
            operation: "new"
          }) : f !== Object && null != f || this.throwError("missing new", b.errors.MISSING_NEW, {
            name: e.name
          });
        }

        static globalLogger() {
          return o || (o = new b("logger/5.6.0")), o;
        }

        static setCensorship(f, e) {
          if (!f && e && this.globalLogger().throwError("cannot permanently disable censorship", b.errors.UNSUPPORTED_OPERATION, {
            operation: "setCensorship"
          }), r) {
            if (!f) return;
            this.globalLogger().throwError("error censorship permanent", b.errors.UNSUPPORTED_OPERATION, {
              operation: "setCensorship"
            });
          }

          n = !!f, r = !!e;
        }

        static setLogLevel(f) {
          const e = i[f.toLowerCase()];
          null != e ? a = e : b.globalLogger().warn("invalid log level - " + f);
        }

        static from(f) {
          return new b(f);
        }

      }

      b.errors = c, b.levels = u;
    },
    5306: (f, e, t) => {
      "use strict";

      t.d(e, {
        n: () => i
      });
      var r = t(3286),
          n = t(3951);

      function i(f, e, t, i, a) {
        let o;
        f = (0, r.arrayify)(f), e = (0, r.arrayify)(e);
        let s = 1;
        const u = new Uint8Array(i),
              c = new Uint8Array(e.length + 4);
        let d, b;
        c.set(e);

        for (let l = 1; l <= s; l++) {
          c[e.length] = l >> 24 & 255, c[e.length + 1] = l >> 16 & 255, c[e.length + 2] = l >> 8 & 255, c[e.length + 3] = 255 & l;
          let h = (0, r.arrayify)((0, n.Gy)(a, f, c));
          o || (o = h.length, b = new Uint8Array(o), s = Math.ceil(i / o), d = i - (s - 1) * o), b.set(h);

          for (let e = 1; e < t; e++) {
            h = (0, r.arrayify)((0, n.Gy)(a, f, h));

            for (let f = 0; f < o; f++) b[f] ^= h[f];
          }

          const p = (l - 1) * o,
                m = l === s ? d : o;
          u.set((0, r.arrayify)(b).slice(0, m), p);
        }

        return (0, r.hexlify)(u);
      }
    },
    3587: (f, e, t) => {
      "use strict";

      t.r(e), t.d(e, {
        Description: () => p,
        checkProperties: () => u,
        deepCopy: () => h,
        defineReadOnly: () => a,
        getStatic: () => o,
        resolveProperties: () => s,
        shallowCopy: () => c
      });
      var r = t(711);

      var n = function (f, e, t, r) {
        return new (t || (t = Promise))(function (n, i) {
          function a(f) {
            try {
              s(r.next(f));
            } catch (f) {
              i(f);
            }
          }

          function o(f) {
            try {
              s(r.throw(f));
            } catch (f) {
              i(f);
            }
          }

          function s(f) {
            var e;
            f.done ? n(f.value) : (e = f.value, e instanceof t ? e : new t(function (f) {
              f(e);
            })).then(a, o);
          }

          s((r = r.apply(f, e || [])).next());
        });
      };

      const i = new r.Logger("properties/5.6.0");

      function a(f, e, t) {
        Object.defineProperty(f, e, {
          enumerable: !0,
          value: t,
          writable: !1
        });
      }

      function o(f, e) {
        for (let t = 0; t < 32; t++) {
          if (f[e]) return f[e];
          if (!f.prototype || "object" != typeof f.prototype) break;
          f = Object.getPrototypeOf(f.prototype).constructor;
        }

        return null;
      }

      function s(f) {
        return n(this, void 0, void 0, function* () {
          const e = Object.keys(f).map(e => {
            const t = f[e];
            return Promise.resolve(t).then(f => ({
              key: e,
              value: f
            }));
          });
          return (yield Promise.all(e)).reduce((f, e) => (f[e.key] = e.value, f), {});
        });
      }

      function u(f, e) {
        f && "object" == typeof f || i.throwArgumentError("invalid object", "object", f), Object.keys(f).forEach(t => {
          e[t] || i.throwArgumentError("invalid object key - " + t, "transaction:" + t, f);
        });
      }

      function c(f) {
        const e = {};

        for (const t in f) e[t] = f[t];

        return e;
      }

      const d = {
        bigint: !0,
        boolean: !0,
        function: !0,
        number: !0,
        string: !0
      };

      function b(f) {
        if (null == f || d[typeof f]) return !0;

        if (Array.isArray(f) || "object" == typeof f) {
          if (!Object.isFrozen(f)) return !1;
          const e = Object.keys(f);

          for (let t = 0; t < e.length; t++) {
            let r = null;

            try {
              r = f[e[t]];
            } catch (f) {
              continue;
            }

            if (!b(r)) return !1;
          }

          return !0;
        }

        return i.throwArgumentError("Cannot deepCopy " + typeof f, "object", f);
      }

      function l(f) {
        if (b(f)) return f;
        if (Array.isArray(f)) return Object.freeze(f.map(f => h(f)));

        if ("object" == typeof f) {
          const e = {};

          for (const t in f) {
            const r = f[t];
            void 0 !== r && a(e, t, h(r));
          }

          return e;
        }

        return i.throwArgumentError("Cannot deepCopy " + typeof f, "object", f);
      }

      function h(f) {
        return l(f);
      }

      class p {
        constructor(f) {
          for (const e in f) this[e] = h(f[e]);
        }

      }
    },
    7986: (f, e, t) => {
      "use strict";

      t.r(e), t.d(e, {
        randomBytes: () => r.O,
        shuffled: () => n
      });
      var r = t(4478);

      function n(f) {
        for (let e = (f = f.slice()).length - 1; e > 0; e--) {
          const t = Math.floor(Math.random() * (e + 1)),
                r = f[e];
          f[e] = f[t], f[t] = r;
        }

        return f;
      }
    },
    4478: (f, e, t) => {
      "use strict";

      t.d(e, {
        O: () => s
      });
      var r = t(3286),
          n = t(711);
      const i = new n.Logger("random/5.6.0");

      const a = function () {
        if ("undefined" != typeof self) return self;
        if ("undefined" != typeof window) return window;
        if (void 0 !== t.g) return t.g;
        throw new Error("unable to locate global object");
      }();

      let o = a.crypto || a.msCrypto;

      function s(f) {
        (f <= 0 || f > 1024 || f % 1 || f != f) && i.throwArgumentError("invalid length", "length", f);
        const e = new Uint8Array(f);
        return o.getRandomValues(e), (0, r.arrayify)(e);
      }

      o && o.getRandomValues || (i.warn("WARNING: Missing strong random number source"), o = {
        getRandomValues: function (f) {
          return i.throwError("no secure random source avaialble", n.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "crypto.getRandomValues"
          });
        }
      });
    },
    1843: (f, e, t) => {
      "use strict";

      t.r(e), t.d(e, {
        decode: () => b,
        encode: () => u
      });
      var r = t(3286),
          n = t(711);
      const i = new n.Logger("rlp/5.6.0");

      function a(f) {
        const e = [];

        for (; f;) e.unshift(255 & f), f >>= 8;

        return e;
      }

      function o(f, e, t) {
        let r = 0;

        for (let n = 0; n < t; n++) r = 256 * r + f[e + n];

        return r;
      }

      function s(f) {
        if (Array.isArray(f)) {
          let e = [];
          if (f.forEach(function (f) {
            e = e.concat(s(f));
          }), e.length <= 55) return e.unshift(192 + e.length), e;
          const t = a(e.length);
          return t.unshift(247 + t.length), t.concat(e);
        }

        (0, r.isBytesLike)(f) || i.throwArgumentError("RLP object must be BytesLike", "object", f);
        const e = Array.prototype.slice.call((0, r.arrayify)(f));
        if (1 === e.length && e[0] <= 127) return e;
        if (e.length <= 55) return e.unshift(128 + e.length), e;
        const t = a(e.length);
        return t.unshift(183 + t.length), t.concat(e);
      }

      function u(f) {
        return (0, r.hexlify)(s(f));
      }

      function c(f, e, t, r) {
        const a = [];

        for (; t < e + 1 + r;) {
          const o = d(f, t);
          a.push(o.result), (t += o.consumed) > e + 1 + r && i.throwError("child data too short", n.Logger.errors.BUFFER_OVERRUN, {});
        }

        return {
          consumed: 1 + r,
          result: a
        };
      }

      function d(f, e) {
        if (0 === f.length && i.throwError("data too short", n.Logger.errors.BUFFER_OVERRUN, {}), f[e] >= 248) {
          const t = f[e] - 247;
          e + 1 + t > f.length && i.throwError("data short segment too short", n.Logger.errors.BUFFER_OVERRUN, {});
          const r = o(f, e + 1, t);
          return e + 1 + t + r > f.length && i.throwError("data long segment too short", n.Logger.errors.BUFFER_OVERRUN, {}), c(f, e, e + 1 + t, t + r);
        }

        if (f[e] >= 192) {
          const t = f[e] - 192;
          return e + 1 + t > f.length && i.throwError("data array too short", n.Logger.errors.BUFFER_OVERRUN, {}), c(f, e, e + 1, t);
        }

        if (f[e] >= 184) {
          const t = f[e] - 183;
          e + 1 + t > f.length && i.throwError("data array too short", n.Logger.errors.BUFFER_OVERRUN, {});
          const a = o(f, e + 1, t);
          e + 1 + t + a > f.length && i.throwError("data array too short", n.Logger.errors.BUFFER_OVERRUN, {});
          return {
            consumed: 1 + t + a,
            result: (0, r.hexlify)(f.slice(e + 1 + t, e + 1 + t + a))
          };
        }

        if (f[e] >= 128) {
          const t = f[e] - 128;
          e + 1 + t > f.length && i.throwError("data too short", n.Logger.errors.BUFFER_OVERRUN, {});
          return {
            consumed: 1 + t,
            result: (0, r.hexlify)(f.slice(e + 1, e + 1 + t))
          };
        }

        return {
          consumed: 1,
          result: (0, r.hexlify)(f[e])
        };
      }

      function b(f) {
        const e = (0, r.arrayify)(f),
              t = d(e, 0);
        return t.consumed !== e.length && i.throwArgumentError("invalid rlp data", "data", f), t.result;
      }
    },
    1278: (f, e, t) => {
      "use strict";

      t.r(e), t.d(e, {
        SupportedAlgorithm: () => n.p,
        computeHmac: () => r.Gy,
        ripemd160: () => r.bP,
        sha256: () => r.JQ,
        sha512: () => r.o
      });
      var r = t(3951),
          n = t(1261);
    },
    3951: (f, e, t) => {
      "use strict";

      t.d(e, {
        Gy: () => b,
        bP: () => u,
        JQ: () => c,
        o: () => d
      });
      var r = t(3715),
          n = t.n(r),
          i = t(3286),
          a = t(1261),
          o = t(711);
      const s = new o.Logger("sha2/5.6.0");

      function u(f) {
        return "0x" + n().ripemd160().update((0, i.arrayify)(f)).digest("hex");
      }

      function c(f) {
        return "0x" + n().sha256().update((0, i.arrayify)(f)).digest("hex");
      }

      function d(f) {
        return "0x" + n().sha512().update((0, i.arrayify)(f)).digest("hex");
      }

      function b(f, e, t) {
        return a.p[f] || s.throwError("unsupported algorithm " + f, o.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "hmac",
          algorithm: f
        }), "0x" + n().hmac(n()[f], (0, i.arrayify)(e)).update((0, i.arrayify)(t)).digest("hex");
      }
    },
    1261: (f, e, t) => {
      "use strict";

      var r;
      t.d(e, {
        p: () => r
      }), function (f) {
        f.sha256 = "sha256", f.sha512 = "sha512";
      }(r || (r = {}));
    },
    2768: (f, e, t) => {
      "use strict";

      t.r(e), t.d(e, {
        SigningKey: () => $,
        computePublicKey: () => Z,
        recoverPublicKey: () => J
      });
      var r = t(3550),
          n = t.n(r),
          i = t(3715),
          a = t.n(i);
      "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== t.g ? t.g : "undefined" != typeof self && self;

      function o(f, e, t) {
        return t = {
          path: e,
          exports: {},
          require: function (f, e) {
            return function () {
              throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
            }(null == e && t.path);
          }
        }, f(t, t.exports), t.exports;
      }

      var s = u;

      function u(f, e) {
        if (!f) throw new Error(e || "Assertion failed");
      }

      u.equal = function (f, e, t) {
        if (f != e) throw new Error(t || "Assertion failed: " + f + " != " + e);
      };

      var c = o(function (f, e) {
        var t = e;

        function r(f) {
          return 1 === f.length ? "0" + f : f;
        }

        function n(f) {
          for (var e = "", t = 0; t < f.length; t++) e += r(f[t].toString(16));

          return e;
        }

        t.toArray = function (f, e) {
          if (Array.isArray(f)) return f.slice();
          if (!f) return [];
          var t = [];

          if ("string" != typeof f) {
            for (var r = 0; r < f.length; r++) t[r] = 0 | f[r];

            return t;
          }

          if ("hex" === e) {
            (f = f.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (f = "0" + f);

            for (r = 0; r < f.length; r += 2) t.push(parseInt(f[r] + f[r + 1], 16));
          } else for (r = 0; r < f.length; r++) {
            var n = f.charCodeAt(r),
                i = n >> 8,
                a = 255 & n;
            i ? t.push(i, a) : t.push(a);
          }

          return t;
        }, t.zero2 = r, t.toHex = n, t.encode = function (f, e) {
          return "hex" === e ? n(f) : f;
        };
      }),
          d = o(function (f, e) {
        var t = e;
        t.assert = s, t.toArray = c.toArray, t.zero2 = c.zero2, t.toHex = c.toHex, t.encode = c.encode, t.getNAF = function (f, e, t) {
          var r = new Array(Math.max(f.bitLength(), t) + 1);
          r.fill(0);

          for (var n = 1 << e + 1, i = f.clone(), a = 0; a < r.length; a++) {
            var o,
                s = i.andln(n - 1);
            i.isOdd() ? (o = s > (n >> 1) - 1 ? (n >> 1) - s : s, i.isubn(o)) : o = 0, r[a] = o, i.iushrn(1);
          }

          return r;
        }, t.getJSF = function (f, e) {
          var t = [[], []];
          f = f.clone(), e = e.clone();

          for (var r, n = 0, i = 0; f.cmpn(-n) > 0 || e.cmpn(-i) > 0;) {
            var a,
                o,
                s = f.andln(3) + n & 3,
                u = e.andln(3) + i & 3;
            3 === s && (s = -1), 3 === u && (u = -1), a = 0 == (1 & s) ? 0 : 3 !== (r = f.andln(7) + n & 7) && 5 !== r || 2 !== u ? s : -s, t[0].push(a), o = 0 == (1 & u) ? 0 : 3 !== (r = e.andln(7) + i & 7) && 5 !== r || 2 !== s ? u : -u, t[1].push(o), 2 * n === a + 1 && (n = 1 - n), 2 * i === o + 1 && (i = 1 - i), f.iushrn(1), e.iushrn(1);
          }

          return t;
        }, t.cachedProperty = function (f, e, t) {
          var r = "_" + e;

          f.prototype[e] = function () {
            return void 0 !== this[r] ? this[r] : this[r] = t.call(this);
          };
        }, t.parseBytes = function (f) {
          return "string" == typeof f ? t.toArray(f, "hex") : f;
        }, t.intFromLE = function (f) {
          return new (n())(f, "hex", "le");
        };
      }),
          b = d.getNAF,
          l = d.getJSF,
          h = d.assert;

      function p(f, e) {
        this.type = f, this.p = new (n())(e.p, 16), this.red = e.prime ? n().red(e.prime) : n().mont(this.p), this.zero = new (n())(0).toRed(this.red), this.one = new (n())(1).toRed(this.red), this.two = new (n())(2).toRed(this.red), this.n = e.n && new (n())(e.n, 16), this.g = e.g && this.pointFromJSON(e.g, e.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
        var t = this.n && this.p.div(this.n);
        !t || t.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
      }

      var m = p;

      function y(f, e) {
        this.curve = f, this.type = e, this.precomputed = null;
      }

      p.prototype.point = function () {
        throw new Error("Not implemented");
      }, p.prototype.validate = function () {
        throw new Error("Not implemented");
      }, p.prototype._fixedNafMul = function (f, e) {
        h(f.precomputed);

        var t = f._getDoubles(),
            r = b(e, 1, this._bitLength),
            n = (1 << t.step + 1) - (t.step % 2 == 0 ? 2 : 1);

        n /= 3;
        var i,
            a,
            o = [];

        for (i = 0; i < r.length; i += t.step) {
          a = 0;

          for (var s = i + t.step - 1; s >= i; s--) a = (a << 1) + r[s];

          o.push(a);
        }

        for (var u = this.jpoint(null, null, null), c = this.jpoint(null, null, null), d = n; d > 0; d--) {
          for (i = 0; i < o.length; i++) (a = o[i]) === d ? c = c.mixedAdd(t.points[i]) : a === -d && (c = c.mixedAdd(t.points[i].neg()));

          u = u.add(c);
        }

        return u.toP();
      }, p.prototype._wnafMul = function (f, e) {
        var t = 4,
            r = f._getNAFPoints(t);

        t = r.wnd;

        for (var n = r.points, i = b(e, t, this._bitLength), a = this.jpoint(null, null, null), o = i.length - 1; o >= 0; o--) {
          for (var s = 0; o >= 0 && 0 === i[o]; o--) s++;

          if (o >= 0 && s++, a = a.dblp(s), o < 0) break;
          var u = i[o];
          h(0 !== u), a = "affine" === f.type ? u > 0 ? a.mixedAdd(n[u - 1 >> 1]) : a.mixedAdd(n[-u - 1 >> 1].neg()) : u > 0 ? a.add(n[u - 1 >> 1]) : a.add(n[-u - 1 >> 1].neg());
        }

        return "affine" === f.type ? a.toP() : a;
      }, p.prototype._wnafMulAdd = function (f, e, t, r, n) {
        var i,
            a,
            o,
            s = this._wnafT1,
            u = this._wnafT2,
            c = this._wnafT3,
            d = 0;

        for (i = 0; i < r; i++) {
          var h = (o = e[i])._getNAFPoints(f);

          s[i] = h.wnd, u[i] = h.points;
        }

        for (i = r - 1; i >= 1; i -= 2) {
          var p = i - 1,
              m = i;

          if (1 === s[p] && 1 === s[m]) {
            var y = [e[p], null, null, e[m]];
            0 === e[p].y.cmp(e[m].y) ? (y[1] = e[p].add(e[m]), y[2] = e[p].toJ().mixedAdd(e[m].neg())) : 0 === e[p].y.cmp(e[m].y.redNeg()) ? (y[1] = e[p].toJ().mixedAdd(e[m]), y[2] = e[p].add(e[m].neg())) : (y[1] = e[p].toJ().mixedAdd(e[m]), y[2] = e[p].toJ().mixedAdd(e[m].neg()));
            var g = [-3, -1, -5, -7, 0, 7, 5, 1, 3],
                v = l(t[p], t[m]);

            for (d = Math.max(v[0].length, d), c[p] = new Array(d), c[m] = new Array(d), a = 0; a < d; a++) {
              var w = 0 | v[0][a],
                  E = 0 | v[1][a];
              c[p][a] = g[3 * (w + 1) + (E + 1)], c[m][a] = 0, u[p] = y;
            }
          } else c[p] = b(t[p], s[p], this._bitLength), c[m] = b(t[m], s[m], this._bitLength), d = Math.max(c[p].length, d), d = Math.max(c[m].length, d);
        }

        var S = this.jpoint(null, null, null),
            A = this._wnafT4;

        for (i = d; i >= 0; i--) {
          for (var x = 0; i >= 0;) {
            var _ = !0;

            for (a = 0; a < r; a++) A[a] = 0 | c[a][i], 0 !== A[a] && (_ = !1);

            if (!_) break;
            x++, i--;
          }

          if (i >= 0 && x++, S = S.dblp(x), i < 0) break;

          for (a = 0; a < r; a++) {
            var M = A[a];
            0 !== M && (M > 0 ? o = u[a][M - 1 >> 1] : M < 0 && (o = u[a][-M - 1 >> 1].neg()), S = "affine" === o.type ? S.mixedAdd(o) : S.add(o));
          }
        }

        for (i = 0; i < r; i++) u[i] = null;

        return n ? S : S.toP();
      }, p.BasePoint = y, y.prototype.eq = function () {
        throw new Error("Not implemented");
      }, y.prototype.validate = function () {
        return this.curve.validate(this);
      }, p.prototype.decodePoint = function (f, e) {
        f = d.toArray(f, e);
        var t = this.p.byteLength();
        if ((4 === f[0] || 6 === f[0] || 7 === f[0]) && f.length - 1 == 2 * t) return 6 === f[0] ? h(f[f.length - 1] % 2 == 0) : 7 === f[0] && h(f[f.length - 1] % 2 == 1), this.point(f.slice(1, 1 + t), f.slice(1 + t, 1 + 2 * t));
        if ((2 === f[0] || 3 === f[0]) && f.length - 1 === t) return this.pointFromX(f.slice(1, 1 + t), 3 === f[0]);
        throw new Error("Unknown point format");
      }, y.prototype.encodeCompressed = function (f) {
        return this.encode(f, !0);
      }, y.prototype._encode = function (f) {
        var e = this.curve.p.byteLength(),
            t = this.getX().toArray("be", e);
        return f ? [this.getY().isEven() ? 2 : 3].concat(t) : [4].concat(t, this.getY().toArray("be", e));
      }, y.prototype.encode = function (f, e) {
        return d.encode(this._encode(e), f);
      }, y.prototype.precompute = function (f) {
        if (this.precomputed) return this;
        var e = {
          doubles: null,
          naf: null,
          beta: null
        };
        return e.naf = this._getNAFPoints(8), e.doubles = this._getDoubles(4, f), e.beta = this._getBeta(), this.precomputed = e, this;
      }, y.prototype._hasDoubles = function (f) {
        if (!this.precomputed) return !1;
        var e = this.precomputed.doubles;
        return !!e && e.points.length >= Math.ceil((f.bitLength() + 1) / e.step);
      }, y.prototype._getDoubles = function (f, e) {
        if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;

        for (var t = [this], r = this, n = 0; n < e; n += f) {
          for (var i = 0; i < f; i++) r = r.dbl();

          t.push(r);
        }

        return {
          step: f,
          points: t
        };
      }, y.prototype._getNAFPoints = function (f) {
        if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;

        for (var e = [this], t = (1 << f) - 1, r = 1 === t ? null : this.dbl(), n = 1; n < t; n++) e[n] = e[n - 1].add(r);

        return {
          wnd: f,
          points: e
        };
      }, y.prototype._getBeta = function () {
        return null;
      }, y.prototype.dblp = function (f) {
        for (var e = this, t = 0; t < f; t++) e = e.dbl();

        return e;
      };
      var g = o(function (f) {
        "function" == typeof Object.create ? f.exports = function (f, e) {
          e && (f.super_ = e, f.prototype = Object.create(e.prototype, {
            constructor: {
              value: f,
              enumerable: !1,
              writable: !0,
              configurable: !0
            }
          }));
        } : f.exports = function (f, e) {
          if (e) {
            f.super_ = e;

            var t = function () {};

            t.prototype = e.prototype, f.prototype = new t(), f.prototype.constructor = f;
          }
        };
      }),
          v = d.assert;

      function w(f) {
        m.call(this, "short", f), this.a = new (n())(f.a, 16).toRed(this.red), this.b = new (n())(f.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = 0 === this.a.fromRed().cmpn(0), this.threeA = 0 === this.a.fromRed().sub(this.p).cmpn(-3), this.endo = this._getEndomorphism(f), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
      }

      g(w, m);
      var E = w;

      function S(f, e, t, r) {
        m.BasePoint.call(this, f, "affine"), null === e && null === t ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new (n())(e, 16), this.y = new (n())(t, 16), r && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
      }

      function A(f, e, t, r) {
        m.BasePoint.call(this, f, "jacobian"), null === e && null === t && null === r ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new (n())(0)) : (this.x = new (n())(e, 16), this.y = new (n())(t, 16), this.z = new (n())(r, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
      }

      w.prototype._getEndomorphism = function (f) {
        if (this.zeroA && this.g && this.n && 1 === this.p.modn(3)) {
          var e, t;
          if (f.beta) e = new (n())(f.beta, 16).toRed(this.red);else {
            var r = this._getEndoRoots(this.p);

            e = (e = r[0].cmp(r[1]) < 0 ? r[0] : r[1]).toRed(this.red);
          }
          if (f.lambda) t = new (n())(f.lambda, 16);else {
            var i = this._getEndoRoots(this.n);

            0 === this.g.mul(i[0]).x.cmp(this.g.x.redMul(e)) ? t = i[0] : (t = i[1], v(0 === this.g.mul(t).x.cmp(this.g.x.redMul(e))));
          }
          return {
            beta: e,
            lambda: t,
            basis: f.basis ? f.basis.map(function (f) {
              return {
                a: new (n())(f.a, 16),
                b: new (n())(f.b, 16)
              };
            }) : this._getEndoBasis(t)
          };
        }
      }, w.prototype._getEndoRoots = function (f) {
        var e = f === this.p ? this.red : n().mont(f),
            t = new (n())(2).toRed(e).redInvm(),
            r = t.redNeg(),
            i = new (n())(3).toRed(e).redNeg().redSqrt().redMul(t);
        return [r.redAdd(i).fromRed(), r.redSub(i).fromRed()];
      }, w.prototype._getEndoBasis = function (f) {
        for (var e, t, r, i, a, o, s, u, c, d = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), b = f, l = this.n.clone(), h = new (n())(1), p = new (n())(0), m = new (n())(0), y = new (n())(1), g = 0; 0 !== b.cmpn(0);) {
          var v = l.div(b);
          u = l.sub(v.mul(b)), c = m.sub(v.mul(h));
          var w = y.sub(v.mul(p));
          if (!r && u.cmp(d) < 0) e = s.neg(), t = h, r = u.neg(), i = c;else if (r && 2 == ++g) break;
          s = u, l = b, b = u, m = h, h = c, y = p, p = w;
        }

        a = u.neg(), o = c;
        var E = r.sqr().add(i.sqr());
        return a.sqr().add(o.sqr()).cmp(E) >= 0 && (a = e, o = t), r.negative && (r = r.neg(), i = i.neg()), a.negative && (a = a.neg(), o = o.neg()), [{
          a: r,
          b: i
        }, {
          a,
          b: o
        }];
      }, w.prototype._endoSplit = function (f) {
        var e = this.endo.basis,
            t = e[0],
            r = e[1],
            n = r.b.mul(f).divRound(this.n),
            i = t.b.neg().mul(f).divRound(this.n),
            a = n.mul(t.a),
            o = i.mul(r.a),
            s = n.mul(t.b),
            u = i.mul(r.b);
        return {
          k1: f.sub(a).sub(o),
          k2: s.add(u).neg()
        };
      }, w.prototype.pointFromX = function (f, e) {
        (f = new (n())(f, 16)).red || (f = f.toRed(this.red));
        var t = f.redSqr().redMul(f).redIAdd(f.redMul(this.a)).redIAdd(this.b),
            r = t.redSqrt();
        if (0 !== r.redSqr().redSub(t).cmp(this.zero)) throw new Error("invalid point");
        var i = r.fromRed().isOdd();
        return (e && !i || !e && i) && (r = r.redNeg()), this.point(f, r);
      }, w.prototype.validate = function (f) {
        if (f.inf) return !0;
        var e = f.x,
            t = f.y,
            r = this.a.redMul(e),
            n = e.redSqr().redMul(e).redIAdd(r).redIAdd(this.b);
        return 0 === t.redSqr().redISub(n).cmpn(0);
      }, w.prototype._endoWnafMulAdd = function (f, e, t) {
        for (var r = this._endoWnafT1, n = this._endoWnafT2, i = 0; i < f.length; i++) {
          var a = this._endoSplit(e[i]),
              o = f[i],
              s = o._getBeta();

          a.k1.negative && (a.k1.ineg(), o = o.neg(!0)), a.k2.negative && (a.k2.ineg(), s = s.neg(!0)), r[2 * i] = o, r[2 * i + 1] = s, n[2 * i] = a.k1, n[2 * i + 1] = a.k2;
        }

        for (var u = this._wnafMulAdd(1, r, n, 2 * i, t), c = 0; c < 2 * i; c++) r[c] = null, n[c] = null;

        return u;
      }, g(S, m.BasePoint), w.prototype.point = function (f, e, t) {
        return new S(this, f, e, t);
      }, w.prototype.pointFromJSON = function (f, e) {
        return S.fromJSON(this, f, e);
      }, S.prototype._getBeta = function () {
        if (this.curve.endo) {
          var f = this.precomputed;
          if (f && f.beta) return f.beta;
          var e = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);

          if (f) {
            var t = this.curve,
                r = function (f) {
              return t.point(f.x.redMul(t.endo.beta), f.y);
            };

            f.beta = e, e.precomputed = {
              beta: null,
              naf: f.naf && {
                wnd: f.naf.wnd,
                points: f.naf.points.map(r)
              },
              doubles: f.doubles && {
                step: f.doubles.step,
                points: f.doubles.points.map(r)
              }
            };
          }

          return e;
        }
      }, S.prototype.toJSON = function () {
        return this.precomputed ? [this.x, this.y, this.precomputed && {
          doubles: this.precomputed.doubles && {
            step: this.precomputed.doubles.step,
            points: this.precomputed.doubles.points.slice(1)
          },
          naf: this.precomputed.naf && {
            wnd: this.precomputed.naf.wnd,
            points: this.precomputed.naf.points.slice(1)
          }
        }] : [this.x, this.y];
      }, S.fromJSON = function (f, e, t) {
        "string" == typeof e && (e = JSON.parse(e));
        var r = f.point(e[0], e[1], t);
        if (!e[2]) return r;

        function n(e) {
          return f.point(e[0], e[1], t);
        }

        var i = e[2];
        return r.precomputed = {
          beta: null,
          doubles: i.doubles && {
            step: i.doubles.step,
            points: [r].concat(i.doubles.points.map(n))
          },
          naf: i.naf && {
            wnd: i.naf.wnd,
            points: [r].concat(i.naf.points.map(n))
          }
        }, r;
      }, S.prototype.inspect = function () {
        return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
      }, S.prototype.isInfinity = function () {
        return this.inf;
      }, S.prototype.add = function (f) {
        if (this.inf) return f;
        if (f.inf) return this;
        if (this.eq(f)) return this.dbl();
        if (this.neg().eq(f)) return this.curve.point(null, null);
        if (0 === this.x.cmp(f.x)) return this.curve.point(null, null);
        var e = this.y.redSub(f.y);
        0 !== e.cmpn(0) && (e = e.redMul(this.x.redSub(f.x).redInvm()));
        var t = e.redSqr().redISub(this.x).redISub(f.x),
            r = e.redMul(this.x.redSub(t)).redISub(this.y);
        return this.curve.point(t, r);
      }, S.prototype.dbl = function () {
        if (this.inf) return this;
        var f = this.y.redAdd(this.y);
        if (0 === f.cmpn(0)) return this.curve.point(null, null);
        var e = this.curve.a,
            t = this.x.redSqr(),
            r = f.redInvm(),
            n = t.redAdd(t).redIAdd(t).redIAdd(e).redMul(r),
            i = n.redSqr().redISub(this.x.redAdd(this.x)),
            a = n.redMul(this.x.redSub(i)).redISub(this.y);
        return this.curve.point(i, a);
      }, S.prototype.getX = function () {
        return this.x.fromRed();
      }, S.prototype.getY = function () {
        return this.y.fromRed();
      }, S.prototype.mul = function (f) {
        return f = new (n())(f, 16), this.isInfinity() ? this : this._hasDoubles(f) ? this.curve._fixedNafMul(this, f) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [f]) : this.curve._wnafMul(this, f);
      }, S.prototype.mulAdd = function (f, e, t) {
        var r = [this, e],
            n = [f, t];
        return this.curve.endo ? this.curve._endoWnafMulAdd(r, n) : this.curve._wnafMulAdd(1, r, n, 2);
      }, S.prototype.jmulAdd = function (f, e, t) {
        var r = [this, e],
            n = [f, t];
        return this.curve.endo ? this.curve._endoWnafMulAdd(r, n, !0) : this.curve._wnafMulAdd(1, r, n, 2, !0);
      }, S.prototype.eq = function (f) {
        return this === f || this.inf === f.inf && (this.inf || 0 === this.x.cmp(f.x) && 0 === this.y.cmp(f.y));
      }, S.prototype.neg = function (f) {
        if (this.inf) return this;
        var e = this.curve.point(this.x, this.y.redNeg());

        if (f && this.precomputed) {
          var t = this.precomputed,
              r = function (f) {
            return f.neg();
          };

          e.precomputed = {
            naf: t.naf && {
              wnd: t.naf.wnd,
              points: t.naf.points.map(r)
            },
            doubles: t.doubles && {
              step: t.doubles.step,
              points: t.doubles.points.map(r)
            }
          };
        }

        return e;
      }, S.prototype.toJ = function () {
        return this.inf ? this.curve.jpoint(null, null, null) : this.curve.jpoint(this.x, this.y, this.curve.one);
      }, g(A, m.BasePoint), w.prototype.jpoint = function (f, e, t) {
        return new A(this, f, e, t);
      }, A.prototype.toP = function () {
        if (this.isInfinity()) return this.curve.point(null, null);
        var f = this.z.redInvm(),
            e = f.redSqr(),
            t = this.x.redMul(e),
            r = this.y.redMul(e).redMul(f);
        return this.curve.point(t, r);
      }, A.prototype.neg = function () {
        return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
      }, A.prototype.add = function (f) {
        if (this.isInfinity()) return f;
        if (f.isInfinity()) return this;
        var e = f.z.redSqr(),
            t = this.z.redSqr(),
            r = this.x.redMul(e),
            n = f.x.redMul(t),
            i = this.y.redMul(e.redMul(f.z)),
            a = f.y.redMul(t.redMul(this.z)),
            o = r.redSub(n),
            s = i.redSub(a);
        if (0 === o.cmpn(0)) return 0 !== s.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
        var u = o.redSqr(),
            c = u.redMul(o),
            d = r.redMul(u),
            b = s.redSqr().redIAdd(c).redISub(d).redISub(d),
            l = s.redMul(d.redISub(b)).redISub(i.redMul(c)),
            h = this.z.redMul(f.z).redMul(o);
        return this.curve.jpoint(b, l, h);
      }, A.prototype.mixedAdd = function (f) {
        if (this.isInfinity()) return f.toJ();
        if (f.isInfinity()) return this;
        var e = this.z.redSqr(),
            t = this.x,
            r = f.x.redMul(e),
            n = this.y,
            i = f.y.redMul(e).redMul(this.z),
            a = t.redSub(r),
            o = n.redSub(i);
        if (0 === a.cmpn(0)) return 0 !== o.cmpn(0) ? this.curve.jpoint(null, null, null) : this.dbl();
        var s = a.redSqr(),
            u = s.redMul(a),
            c = t.redMul(s),
            d = o.redSqr().redIAdd(u).redISub(c).redISub(c),
            b = o.redMul(c.redISub(d)).redISub(n.redMul(u)),
            l = this.z.redMul(a);
        return this.curve.jpoint(d, b, l);
      }, A.prototype.dblp = function (f) {
        if (0 === f) return this;
        if (this.isInfinity()) return this;
        if (!f) return this.dbl();
        var e;

        if (this.curve.zeroA || this.curve.threeA) {
          var t = this;

          for (e = 0; e < f; e++) t = t.dbl();

          return t;
        }

        var r = this.curve.a,
            n = this.curve.tinv,
            i = this.x,
            a = this.y,
            o = this.z,
            s = o.redSqr().redSqr(),
            u = a.redAdd(a);

        for (e = 0; e < f; e++) {
          var c = i.redSqr(),
              d = u.redSqr(),
              b = d.redSqr(),
              l = c.redAdd(c).redIAdd(c).redIAdd(r.redMul(s)),
              h = i.redMul(d),
              p = l.redSqr().redISub(h.redAdd(h)),
              m = h.redISub(p),
              y = l.redMul(m);
          y = y.redIAdd(y).redISub(b);
          var g = u.redMul(o);
          e + 1 < f && (s = s.redMul(b)), i = p, o = g, u = y;
        }

        return this.curve.jpoint(i, u.redMul(n), o);
      }, A.prototype.dbl = function () {
        return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
      }, A.prototype._zeroDbl = function () {
        var f, e, t;

        if (this.zOne) {
          var r = this.x.redSqr(),
              n = this.y.redSqr(),
              i = n.redSqr(),
              a = this.x.redAdd(n).redSqr().redISub(r).redISub(i);
          a = a.redIAdd(a);
          var o = r.redAdd(r).redIAdd(r),
              s = o.redSqr().redISub(a).redISub(a),
              u = i.redIAdd(i);
          u = (u = u.redIAdd(u)).redIAdd(u), f = s, e = o.redMul(a.redISub(s)).redISub(u), t = this.y.redAdd(this.y);
        } else {
          var c = this.x.redSqr(),
              d = this.y.redSqr(),
              b = d.redSqr(),
              l = this.x.redAdd(d).redSqr().redISub(c).redISub(b);
          l = l.redIAdd(l);
          var h = c.redAdd(c).redIAdd(c),
              p = h.redSqr(),
              m = b.redIAdd(b);
          m = (m = m.redIAdd(m)).redIAdd(m), f = p.redISub(l).redISub(l), e = h.redMul(l.redISub(f)).redISub(m), t = (t = this.y.redMul(this.z)).redIAdd(t);
        }

        return this.curve.jpoint(f, e, t);
      }, A.prototype._threeDbl = function () {
        var f, e, t;

        if (this.zOne) {
          var r = this.x.redSqr(),
              n = this.y.redSqr(),
              i = n.redSqr(),
              a = this.x.redAdd(n).redSqr().redISub(r).redISub(i);
          a = a.redIAdd(a);
          var o = r.redAdd(r).redIAdd(r).redIAdd(this.curve.a),
              s = o.redSqr().redISub(a).redISub(a);
          f = s;
          var u = i.redIAdd(i);
          u = (u = u.redIAdd(u)).redIAdd(u), e = o.redMul(a.redISub(s)).redISub(u), t = this.y.redAdd(this.y);
        } else {
          var c = this.z.redSqr(),
              d = this.y.redSqr(),
              b = this.x.redMul(d),
              l = this.x.redSub(c).redMul(this.x.redAdd(c));
          l = l.redAdd(l).redIAdd(l);
          var h = b.redIAdd(b),
              p = (h = h.redIAdd(h)).redAdd(h);
          f = l.redSqr().redISub(p), t = this.y.redAdd(this.z).redSqr().redISub(d).redISub(c);
          var m = d.redSqr();
          m = (m = (m = m.redIAdd(m)).redIAdd(m)).redIAdd(m), e = l.redMul(h.redISub(f)).redISub(m);
        }

        return this.curve.jpoint(f, e, t);
      }, A.prototype._dbl = function () {
        var f = this.curve.a,
            e = this.x,
            t = this.y,
            r = this.z,
            n = r.redSqr().redSqr(),
            i = e.redSqr(),
            a = t.redSqr(),
            o = i.redAdd(i).redIAdd(i).redIAdd(f.redMul(n)),
            s = e.redAdd(e),
            u = (s = s.redIAdd(s)).redMul(a),
            c = o.redSqr().redISub(u.redAdd(u)),
            d = u.redISub(c),
            b = a.redSqr();
        b = (b = (b = b.redIAdd(b)).redIAdd(b)).redIAdd(b);
        var l = o.redMul(d).redISub(b),
            h = t.redAdd(t).redMul(r);
        return this.curve.jpoint(c, l, h);
      }, A.prototype.trpl = function () {
        if (!this.curve.zeroA) return this.dbl().add(this);
        var f = this.x.redSqr(),
            e = this.y.redSqr(),
            t = this.z.redSqr(),
            r = e.redSqr(),
            n = f.redAdd(f).redIAdd(f),
            i = n.redSqr(),
            a = this.x.redAdd(e).redSqr().redISub(f).redISub(r),
            o = (a = (a = (a = a.redIAdd(a)).redAdd(a).redIAdd(a)).redISub(i)).redSqr(),
            s = r.redIAdd(r);
        s = (s = (s = s.redIAdd(s)).redIAdd(s)).redIAdd(s);
        var u = n.redIAdd(a).redSqr().redISub(i).redISub(o).redISub(s),
            c = e.redMul(u);
        c = (c = c.redIAdd(c)).redIAdd(c);
        var d = this.x.redMul(o).redISub(c);
        d = (d = d.redIAdd(d)).redIAdd(d);
        var b = this.y.redMul(u.redMul(s.redISub(u)).redISub(a.redMul(o)));
        b = (b = (b = b.redIAdd(b)).redIAdd(b)).redIAdd(b);
        var l = this.z.redAdd(a).redSqr().redISub(t).redISub(o);
        return this.curve.jpoint(d, b, l);
      }, A.prototype.mul = function (f, e) {
        return f = new (n())(f, e), this.curve._wnafMul(this, f);
      }, A.prototype.eq = function (f) {
        if ("affine" === f.type) return this.eq(f.toJ());
        if (this === f) return !0;
        var e = this.z.redSqr(),
            t = f.z.redSqr();
        if (0 !== this.x.redMul(t).redISub(f.x.redMul(e)).cmpn(0)) return !1;
        var r = e.redMul(this.z),
            n = t.redMul(f.z);
        return 0 === this.y.redMul(n).redISub(f.y.redMul(r)).cmpn(0);
      }, A.prototype.eqXToP = function (f) {
        var e = this.z.redSqr(),
            t = f.toRed(this.curve.red).redMul(e);
        if (0 === this.x.cmp(t)) return !0;

        for (var r = f.clone(), n = this.curve.redN.redMul(e);;) {
          if (r.iadd(this.curve.n), r.cmp(this.curve.p) >= 0) return !1;
          if (t.redIAdd(n), 0 === this.x.cmp(t)) return !0;
        }
      }, A.prototype.inspect = function () {
        return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
      }, A.prototype.isInfinity = function () {
        return 0 === this.z.cmpn(0);
      };

      var x = o(function (f, e) {
        var t = e;
        t.base = m, t.short = E, t.mont = null, t.edwards = null;
      }),
          _ = o(function (f, e) {
        var t,
            r = e,
            n = d.assert;

        function i(f) {
          "short" === f.type ? this.curve = new x.short(f) : "edwards" === f.type ? this.curve = new x.edwards(f) : this.curve = new x.mont(f), this.g = this.curve.g, this.n = this.curve.n, this.hash = f.hash, n(this.g.validate(), "Invalid curve"), n(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
        }

        function o(f, e) {
          Object.defineProperty(r, f, {
            configurable: !0,
            enumerable: !0,
            get: function () {
              var t = new i(e);
              return Object.defineProperty(r, f, {
                configurable: !0,
                enumerable: !0,
                value: t
              }), t;
            }
          });
        }

        r.PresetCurve = i, o("p192", {
          type: "short",
          prime: "p192",
          p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
          a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
          b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
          n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
          hash: a().sha256,
          gRed: !1,
          g: ["188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012", "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"]
        }), o("p224", {
          type: "short",
          prime: "p224",
          p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
          a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
          b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
          n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
          hash: a().sha256,
          gRed: !1,
          g: ["b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21", "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"]
        }), o("p256", {
          type: "short",
          prime: null,
          p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
          a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
          b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
          n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
          hash: a().sha256,
          gRed: !1,
          g: ["6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296", "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"]
        }), o("p384", {
          type: "short",
          prime: null,
          p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
          a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
          b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
          n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
          hash: a().sha384,
          gRed: !1,
          g: ["aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7", "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"]
        }), o("p521", {
          type: "short",
          prime: null,
          p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
          a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
          b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
          n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
          hash: a().sha512,
          gRed: !1,
          g: ["000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66", "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"]
        }), o("curve25519", {
          type: "mont",
          prime: "p25519",
          p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
          a: "76d06",
          b: "1",
          n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
          hash: a().sha256,
          gRed: !1,
          g: ["9"]
        }), o("ed25519", {
          type: "edwards",
          prime: "p25519",
          p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
          a: "-1",
          c: "1",
          d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
          n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
          hash: a().sha256,
          gRed: !1,
          g: ["216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a", "6666666666666666666666666666666666666666666666666666666666666658"]
        });

        try {
          t = null.crash();
        } catch (f) {
          t = void 0;
        }

        o("secp256k1", {
          type: "short",
          prime: "k256",
          p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
          a: "0",
          b: "7",
          n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
          h: "1",
          hash: a().sha256,
          beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
          lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
          basis: [{
            a: "3086d221a7d46bcde86c90e49284eb15",
            b: "-e4437ed6010e88286f547fa90abfe4c3"
          }, {
            a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
            b: "3086d221a7d46bcde86c90e49284eb15"
          }],
          gRed: !1,
          g: ["79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798", "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8", t]
        });
      });

      function M(f) {
        if (!(this instanceof M)) return new M(f);
        this.hash = f.hash, this.predResist = !!f.predResist, this.outLen = this.hash.outSize, this.minEntropy = f.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
        var e = c.toArray(f.entropy, f.entropyEnc || "hex"),
            t = c.toArray(f.nonce, f.nonceEnc || "hex"),
            r = c.toArray(f.pers, f.persEnc || "hex");
        s(e.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._init(e, t, r);
      }

      var P = M;
      M.prototype._init = function (f, e, t) {
        var r = f.concat(e).concat(t);
        this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);

        for (var n = 0; n < this.V.length; n++) this.K[n] = 0, this.V[n] = 1;

        this._update(r), this._reseed = 1, this.reseedInterval = 281474976710656;
      }, M.prototype._hmac = function () {
        return new (a().hmac)(this.hash, this.K);
      }, M.prototype._update = function (f) {
        var e = this._hmac().update(this.V).update([0]);

        f && (e = e.update(f)), this.K = e.digest(), this.V = this._hmac().update(this.V).digest(), f && (this.K = this._hmac().update(this.V).update([1]).update(f).digest(), this.V = this._hmac().update(this.V).digest());
      }, M.prototype.reseed = function (f, e, t, r) {
        "string" != typeof e && (r = t, t = e, e = null), f = c.toArray(f, e), t = c.toArray(t, r), s(f.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits"), this._update(f.concat(t || [])), this._reseed = 1;
      }, M.prototype.generate = function (f, e, t, r) {
        if (this._reseed > this.reseedInterval) throw new Error("Reseed is required");
        "string" != typeof e && (r = t, t = e, e = null), t && (t = c.toArray(t, r || "hex"), this._update(t));

        for (var n = []; n.length < f;) this.V = this._hmac().update(this.V).digest(), n = n.concat(this.V);

        var i = n.slice(0, f);
        return this._update(t), this._reseed++, c.encode(i, e);
      };
      var T = d.assert;

      function O(f, e) {
        this.ec = f, this.priv = null, this.pub = null, e.priv && this._importPrivate(e.priv, e.privEnc), e.pub && this._importPublic(e.pub, e.pubEnc);
      }

      var C = O;
      O.fromPublic = function (f, e, t) {
        return e instanceof O ? e : new O(f, {
          pub: e,
          pubEnc: t
        });
      }, O.fromPrivate = function (f, e, t) {
        return e instanceof O ? e : new O(f, {
          priv: e,
          privEnc: t
        });
      }, O.prototype.validate = function () {
        var f = this.getPublic();
        return f.isInfinity() ? {
          result: !1,
          reason: "Invalid public key"
        } : f.validate() ? f.mul(this.ec.curve.n).isInfinity() ? {
          result: !0,
          reason: null
        } : {
          result: !1,
          reason: "Public key * N != O"
        } : {
          result: !1,
          reason: "Public key is not a point"
        };
      }, O.prototype.getPublic = function (f, e) {
        return "string" == typeof f && (e = f, f = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), e ? this.pub.encode(e, f) : this.pub;
      }, O.prototype.getPrivate = function (f) {
        return "hex" === f ? this.priv.toString(16, 2) : this.priv;
      }, O.prototype._importPrivate = function (f, e) {
        this.priv = new (n())(f, e || 16), this.priv = this.priv.umod(this.ec.curve.n);
      }, O.prototype._importPublic = function (f, e) {
        if (f.x || f.y) return "mont" === this.ec.curve.type ? T(f.x, "Need x coordinate") : "short" !== this.ec.curve.type && "edwards" !== this.ec.curve.type || T(f.x && f.y, "Need both x and y coordinate"), void (this.pub = this.ec.curve.point(f.x, f.y));
        this.pub = this.ec.curve.decodePoint(f, e);
      }, O.prototype.derive = function (f) {
        return f.validate() || T(f.validate(), "public point not validated"), f.mul(this.priv).getX();
      }, O.prototype.sign = function (f, e, t) {
        return this.ec.sign(f, this, e, t);
      }, O.prototype.verify = function (f, e) {
        return this.ec.verify(f, e, this);
      }, O.prototype.inspect = function () {
        return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
      };
      var R = d.assert;

      function N(f, e) {
        if (f instanceof N) return f;
        this._importDER(f, e) || (R(f.r && f.s, "Signature without r or s"), this.r = new (n())(f.r, 16), this.s = new (n())(f.s, 16), void 0 === f.recoveryParam ? this.recoveryParam = null : this.recoveryParam = f.recoveryParam);
      }

      var k = N;

      function I() {
        this.place = 0;
      }

      function F(f, e) {
        var t = f[e.place++];
        if (!(128 & t)) return t;
        var r = 15 & t;
        if (0 === r || r > 4) return !1;

        for (var n = 0, i = 0, a = e.place; i < r; i++, a++) n <<= 8, n |= f[a], n >>>= 0;

        return !(n <= 127) && (e.place = a, n);
      }

      function B(f) {
        for (var e = 0, t = f.length - 1; !f[e] && !(128 & f[e + 1]) && e < t;) e++;

        return 0 === e ? f : f.slice(e);
      }

      function L(f, e) {
        if (e < 128) f.push(e);else {
          var t = 1 + (Math.log(e) / Math.LN2 >>> 3);

          for (f.push(128 | t); --t;) f.push(e >>> (t << 3) & 255);

          f.push(e);
        }
      }

      N.prototype._importDER = function (f, e) {
        f = d.toArray(f, e);
        var t = new I();
        if (48 !== f[t.place++]) return !1;
        var r = F(f, t);
        if (!1 === r) return !1;
        if (r + t.place !== f.length) return !1;
        if (2 !== f[t.place++]) return !1;
        var i = F(f, t);
        if (!1 === i) return !1;
        var a = f.slice(t.place, i + t.place);
        if (t.place += i, 2 !== f[t.place++]) return !1;
        var o = F(f, t);
        if (!1 === o) return !1;
        if (f.length !== o + t.place) return !1;
        var s = f.slice(t.place, o + t.place);

        if (0 === a[0]) {
          if (!(128 & a[1])) return !1;
          a = a.slice(1);
        }

        if (0 === s[0]) {
          if (!(128 & s[1])) return !1;
          s = s.slice(1);
        }

        return this.r = new (n())(a), this.s = new (n())(s), this.recoveryParam = null, !0;
      }, N.prototype.toDER = function (f) {
        var e = this.r.toArray(),
            t = this.s.toArray();

        for (128 & e[0] && (e = [0].concat(e)), 128 & t[0] && (t = [0].concat(t)), e = B(e), t = B(t); !(t[0] || 128 & t[1]);) t = t.slice(1);

        var r = [2];
        L(r, e.length), (r = r.concat(e)).push(2), L(r, t.length);
        var n = r.concat(t),
            i = [48];
        return L(i, n.length), i = i.concat(n), d.encode(i, f);
      };

      var D = function () {
        throw new Error("unsupported");
      },
          U = d.assert;

      function j(f) {
        if (!(this instanceof j)) return new j(f);
        "string" == typeof f && (U(Object.prototype.hasOwnProperty.call(_, f), "Unknown curve " + f), f = _[f]), f instanceof _.PresetCurve && (f = {
          curve: f
        }), this.curve = f.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = f.curve.g, this.g.precompute(f.curve.n.bitLength() + 1), this.hash = f.hash || f.curve.hash;
      }

      var z = j;
      j.prototype.keyPair = function (f) {
        return new C(this, f);
      }, j.prototype.keyFromPrivate = function (f, e) {
        return C.fromPrivate(this, f, e);
      }, j.prototype.keyFromPublic = function (f, e) {
        return C.fromPublic(this, f, e);
      }, j.prototype.genKeyPair = function (f) {
        f || (f = {});

        for (var e = new P({
          hash: this.hash,
          pers: f.pers,
          persEnc: f.persEnc || "utf8",
          entropy: f.entropy || D(this.hash.hmacStrength),
          entropyEnc: f.entropy && f.entropyEnc || "utf8",
          nonce: this.n.toArray()
        }), t = this.n.byteLength(), r = this.n.sub(new (n())(2));;) {
          var i = new (n())(e.generate(t));
          if (!(i.cmp(r) > 0)) return i.iaddn(1), this.keyFromPrivate(i);
        }
      }, j.prototype._truncateToN = function (f, e) {
        var t = 8 * f.byteLength() - this.n.bitLength();
        return t > 0 && (f = f.ushrn(t)), !e && f.cmp(this.n) >= 0 ? f.sub(this.n) : f;
      }, j.prototype.sign = function (f, e, t, r) {
        "object" == typeof t && (r = t, t = null), r || (r = {}), e = this.keyFromPrivate(e, t), f = this._truncateToN(new (n())(f, 16));

        for (var i = this.n.byteLength(), a = e.getPrivate().toArray("be", i), o = f.toArray("be", i), s = new P({
          hash: this.hash,
          entropy: a,
          nonce: o,
          pers: r.pers,
          persEnc: r.persEnc || "utf8"
        }), u = this.n.sub(new (n())(1)), c = 0;; c++) {
          var d = r.k ? r.k(c) : new (n())(s.generate(this.n.byteLength()));

          if (!((d = this._truncateToN(d, !0)).cmpn(1) <= 0 || d.cmp(u) >= 0)) {
            var b = this.g.mul(d);

            if (!b.isInfinity()) {
              var l = b.getX(),
                  h = l.umod(this.n);

              if (0 !== h.cmpn(0)) {
                var p = d.invm(this.n).mul(h.mul(e.getPrivate()).iadd(f));

                if (0 !== (p = p.umod(this.n)).cmpn(0)) {
                  var m = (b.getY().isOdd() ? 1 : 0) | (0 !== l.cmp(h) ? 2 : 0);
                  return r.canonical && p.cmp(this.nh) > 0 && (p = this.n.sub(p), m ^= 1), new k({
                    r: h,
                    s: p,
                    recoveryParam: m
                  });
                }
              }
            }
          }
        }
      }, j.prototype.verify = function (f, e, t, r) {
        f = this._truncateToN(new (n())(f, 16)), t = this.keyFromPublic(t, r);
        var i = (e = new k(e, "hex")).r,
            a = e.s;
        if (i.cmpn(1) < 0 || i.cmp(this.n) >= 0) return !1;
        if (a.cmpn(1) < 0 || a.cmp(this.n) >= 0) return !1;
        var o,
            s = a.invm(this.n),
            u = s.mul(f).umod(this.n),
            c = s.mul(i).umod(this.n);
        return this.curve._maxwellTrick ? !(o = this.g.jmulAdd(u, t.getPublic(), c)).isInfinity() && o.eqXToP(i) : !(o = this.g.mulAdd(u, t.getPublic(), c)).isInfinity() && 0 === o.getX().umod(this.n).cmp(i);
      }, j.prototype.recoverPubKey = function (f, e, t, r) {
        U((3 & t) === t, "The recovery param is more than two bits"), e = new k(e, r);
        var i = this.n,
            a = new (n())(f),
            o = e.r,
            s = e.s,
            u = 1 & t,
            c = t >> 1;
        if (o.cmp(this.curve.p.umod(this.curve.n)) >= 0 && c) throw new Error("Unable to find sencond key candinate");
        o = c ? this.curve.pointFromX(o.add(this.curve.n), u) : this.curve.pointFromX(o, u);
        var d = e.r.invm(i),
            b = i.sub(a).mul(d).umod(i),
            l = s.mul(d).umod(i);
        return this.g.mulAdd(b, o, l);
      }, j.prototype.getKeyRecoveryParam = function (f, e, t, r) {
        if (null !== (e = new k(e, r)).recoveryParam) return e.recoveryParam;

        for (var n = 0; n < 4; n++) {
          var i;

          try {
            i = this.recoverPubKey(f, e, n);
          } catch (f) {
            continue;
          }

          if (i.eq(t)) return n;
        }

        throw new Error("Unable to find valid recovery factor");
      };
      var G = o(function (f, e) {
        var t = e;
        t.version = "6.5.4", t.utils = d, t.rand = function () {
          throw new Error("unsupported");
        }, t.curve = x, t.curves = _, t.ec = z, t.eddsa = null;
      }).ec,
          K = t(3286),
          V = t(3587);
      const H = new (t(711).Logger)("signing-key/5.6.0");
      let q = null;

      function W() {
        return q || (q = new G("secp256k1")), q;
      }

      class $ {
        constructor(f) {
          (0, V.defineReadOnly)(this, "curve", "secp256k1"), (0, V.defineReadOnly)(this, "privateKey", (0, K.hexlify)(f));
          const e = W().keyFromPrivate((0, K.arrayify)(this.privateKey));
          (0, V.defineReadOnly)(this, "publicKey", "0x" + e.getPublic(!1, "hex")), (0, V.defineReadOnly)(this, "compressedPublicKey", "0x" + e.getPublic(!0, "hex")), (0, V.defineReadOnly)(this, "_isSigningKey", !0);
        }

        _addPoint(f) {
          const e = W().keyFromPublic((0, K.arrayify)(this.publicKey)),
                t = W().keyFromPublic((0, K.arrayify)(f));
          return "0x" + e.pub.add(t.pub).encodeCompressed("hex");
        }

        signDigest(f) {
          const e = W().keyFromPrivate((0, K.arrayify)(this.privateKey)),
                t = (0, K.arrayify)(f);
          32 !== t.length && H.throwArgumentError("bad digest length", "digest", f);
          const r = e.sign(t, {
            canonical: !0
          });
          return (0, K.splitSignature)({
            recoveryParam: r.recoveryParam,
            r: (0, K.hexZeroPad)("0x" + r.r.toString(16), 32),
            s: (0, K.hexZeroPad)("0x" + r.s.toString(16), 32)
          });
        }

        computeSharedSecret(f) {
          const e = W().keyFromPrivate((0, K.arrayify)(this.privateKey)),
                t = W().keyFromPublic((0, K.arrayify)(Z(f)));
          return (0, K.hexZeroPad)("0x" + e.derive(t.getPublic()).toString(16), 32);
        }

        static isSigningKey(f) {
          return !(!f || !f._isSigningKey);
        }

      }

      function J(f, e) {
        const t = (0, K.splitSignature)(e),
              r = {
          r: (0, K.arrayify)(t.r),
          s: (0, K.arrayify)(t.s)
        };
        return "0x" + W().recoverPubKey((0, K.arrayify)(f), r, t.recoveryParam).encode("hex", !1);
      }

      function Z(f, e) {
        const t = (0, K.arrayify)(f);

        if (32 === t.length) {
          const f = new $(t);
          return e ? "0x" + W().keyFromPrivate(t).getPublic(!0, "hex") : f.publicKey;
        }

        return 33 === t.length ? e ? (0, K.hexlify)(t) : "0x" + W().keyFromPublic(t).getPublic(!1, "hex") : 65 === t.length ? e ? "0x" + W().keyFromPublic(t).getPublic(!0, "hex") : (0, K.hexlify)(t) : H.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
      }
    },
    3777: (f, e, t) => {
      "use strict";

      t.r(e), t.d(e, {
        keccak256: () => p,
        pack: () => h,
        sha256: () => m
      });
      var r = t(2593),
          n = t(3286),
          i = t(8197),
          a = t(3951),
          o = t(4242),
          s = t(711);
      const u = new RegExp("^bytes([0-9]+)$"),
            c = new RegExp("^(u?int)([0-9]*)$"),
            d = new RegExp("^(.*)\\[([0-9]*)\\]$"),
            b = new s.Logger("solidity/5.6.0");

      function l(f, e, t) {
        switch (f) {
          case "address":
            return t ? (0, n.zeroPad)(e, 32) : (0, n.arrayify)(e);

          case "string":
            return (0, o.Y0)(e);

          case "bytes":
            return (0, n.arrayify)(e);

          case "bool":
            return e = e ? "0x01" : "0x00", t ? (0, n.zeroPad)(e, 32) : (0, n.arrayify)(e);
        }

        let i = f.match(c);

        if (i) {
          let a = parseInt(i[2] || "256");
          return (i[2] && String(a) !== i[2] || a % 8 != 0 || 0 === a || a > 256) && b.throwArgumentError("invalid number type", "type", f), t && (a = 256), e = r.O$.from(e).toTwos(a), (0, n.zeroPad)(e, a / 8);
        }

        if (i = f.match(u), i) {
          const r = parseInt(i[1]);
          return (String(r) !== i[1] || 0 === r || r > 32) && b.throwArgumentError("invalid bytes type", "type", f), (0, n.arrayify)(e).byteLength !== r && b.throwArgumentError(`invalid value for ${f}`, "value", e), t ? (0, n.arrayify)((e + "0000000000000000000000000000000000000000000000000000000000000000").substring(0, 66)) : e;
        }

        if (i = f.match(d), i && Array.isArray(e)) {
          const t = i[1];
          parseInt(i[2] || String(e.length)) != e.length && b.throwArgumentError(`invalid array length for ${f}`, "value", e);
          const r = [];
          return e.forEach(function (f) {
            r.push(l(t, f, !0));
          }), (0, n.concat)(r);
        }

        return b.throwArgumentError("invalid type", "type", f);
      }

      function h(f, e) {
        f.length != e.length && b.throwArgumentError("wrong number of values; expected ${ types.length }", "values", e);
        const t = [];
        return f.forEach(function (f, r) {
          t.push(l(f, e[r]));
        }), (0, n.hexlify)((0, n.concat)(t));
      }

      function p(f, e) {
        return (0, i.keccak256)(h(f, e));
      }

      function m(f, e) {
        return (0, a.JQ)(h(f, e));
      }
    },
    5637: (f, e, t) => {
      "use strict";

      t.d(e, {
        Ll: () => h
      });
      var r = t(4242);

      function n(f, e) {
        e || (e = function (f) {
          return [parseInt(f, 16)];
        });
        let t = 0,
            r = {};
        return f.split(",").forEach(f => {
          let n = f.split(":");
          t += parseInt(n[0], 16), r[t] = e(n[1]);
        }), r;
      }

      function i(f) {
        let e = 0;
        return f.split(",").map(f => {
          let t = f.split("-");
          1 === t.length ? t[1] = "0" : "" === t[1] && (t[1] = "1");
          let r = e + parseInt(t[0], 16);
          return e = parseInt(t[1], 16), {
            l: r,
            h: e
          };
        });
      }

      function a(f, e) {
        let t = 0;

        for (let r = 0; r < e.length; r++) {
          let n = e[r];

          if (t += n.l, f >= t && f <= t + n.h && (f - t) % (n.d || 1) == 0) {
            if (n.e && -1 !== n.e.indexOf(f - t)) continue;
            return n;
          }
        }

        return null;
      }

      const o = i("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d"),
            s = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map(f => parseInt(f, 16)),
            u = [{
        h: 25,
        s: 32,
        l: 65
      }, {
        h: 30,
        s: 32,
        e: [23],
        l: 127
      }, {
        h: 54,
        s: 1,
        e: [48],
        l: 64,
        d: 2
      }, {
        h: 14,
        s: 1,
        l: 57,
        d: 2
      }, {
        h: 44,
        s: 1,
        l: 17,
        d: 2
      }, {
        h: 10,
        s: 1,
        e: [2, 6, 8],
        l: 61,
        d: 2
      }, {
        h: 16,
        s: 1,
        l: 68,
        d: 2
      }, {
        h: 84,
        s: 1,
        e: [18, 24, 66],
        l: 19,
        d: 2
      }, {
        h: 26,
        s: 32,
        e: [17],
        l: 435
      }, {
        h: 22,
        s: 1,
        l: 71,
        d: 2
      }, {
        h: 15,
        s: 80,
        l: 40
      }, {
        h: 31,
        s: 32,
        l: 16
      }, {
        h: 32,
        s: 1,
        l: 80,
        d: 2
      }, {
        h: 52,
        s: 1,
        l: 42,
        d: 2
      }, {
        h: 12,
        s: 1,
        l: 55,
        d: 2
      }, {
        h: 40,
        s: 1,
        e: [38],
        l: 15,
        d: 2
      }, {
        h: 14,
        s: 1,
        l: 48,
        d: 2
      }, {
        h: 37,
        s: 48,
        l: 49
      }, {
        h: 148,
        s: 1,
        l: 6351,
        d: 2
      }, {
        h: 88,
        s: 1,
        l: 160,
        d: 2
      }, {
        h: 15,
        s: 16,
        l: 704
      }, {
        h: 25,
        s: 26,
        l: 854
      }, {
        h: 25,
        s: 32,
        l: 55915
      }, {
        h: 37,
        s: 40,
        l: 1247
      }, {
        h: 25,
        s: -119711,
        l: 53248
      }, {
        h: 25,
        s: -119763,
        l: 52
      }, {
        h: 25,
        s: -119815,
        l: 52
      }, {
        h: 25,
        s: -119867,
        e: [1, 4, 5, 7, 8, 11, 12, 17],
        l: 52
      }, {
        h: 25,
        s: -119919,
        l: 52
      }, {
        h: 24,
        s: -119971,
        e: [2, 7, 8, 17],
        l: 52
      }, {
        h: 24,
        s: -120023,
        e: [2, 7, 13, 15, 16, 17],
        l: 52
      }, {
        h: 25,
        s: -120075,
        l: 52
      }, {
        h: 25,
        s: -120127,
        l: 52
      }, {
        h: 25,
        s: -120179,
        l: 52
      }, {
        h: 25,
        s: -120231,
        l: 52
      }, {
        h: 25,
        s: -120283,
        l: 52
      }, {
        h: 25,
        s: -120335,
        l: 52
      }, {
        h: 24,
        s: -119543,
        e: [17],
        l: 56
      }, {
        h: 24,
        s: -119601,
        e: [17],
        l: 58
      }, {
        h: 24,
        s: -119659,
        e: [17],
        l: 58
      }, {
        h: 24,
        s: -119717,
        e: [17],
        l: 58
      }, {
        h: 24,
        s: -119775,
        e: [17],
        l: 58
      }],
            c = n("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3"),
            d = n("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7"),
            b = n("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", function (f) {
        if (f.length % 4 != 0) throw new Error("bad data");
        let e = [];

        for (let t = 0; t < f.length; t += 4) e.push(parseInt(f.substring(t, t + 4), 16));

        return e;
      }),
            l = i("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");

      function h(f) {
        if (f.match(/^[a-z0-9-]*$/i) && f.length <= 59) return f.toLowerCase();
        let e = (0, r.XL)(f);
        var t;
        t = e.map(f => {
          if (s.indexOf(f) >= 0) return [];
          if (f >= 65024 && f <= 65039) return [];

          let e = function (f) {
            let e = a(f, u);
            if (e) return [f + e.s];
            let t = c[f];
            if (t) return t;
            let r = d[f];
            return r ? [f + r[0]] : b[f] || null;
          }(f);

          return e || [f];
        }), e = t.reduce((f, e) => (e.forEach(e => {
          f.push(e);
        }), f), []), e = (0, r.XL)((0, r.uu)(e), r.Uj.NFKC), e.forEach(f => {
          if (a(f, l)) throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
        }), e.forEach(f => {
          if (a(f, o)) throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
        });
        let n = (0, r.uu)(e);
        if ("-" === n.substring(0, 1) || "--" === n.substring(2, 4) || "-" === n.substring(n.length - 1)) throw new Error("invalid hyphen");
        if (n.length > 63) throw new Error("too long");
        return n;
      }
    },
    4044: (f, e, t) => {
      "use strict";

      t.r(e), t.d(e, {
        UnicodeNormalizationForm: () => n.Uj,
        Utf8ErrorFuncs: () => n.te,
        Utf8ErrorReason: () => n.Uw,
        _toEscapedUtf8String: () => n.U$,
        formatBytes32String: () => i,
        nameprep: () => o.Ll,
        parseBytes32String: () => a,
        toUtf8Bytes: () => n.Y0,
        toUtf8CodePoints: () => n.XL,
        toUtf8String: () => n.ZN
      });
      var r = t(3286),
          n = t(4242);

      function i(f) {
        const e = (0, n.Y0)(f);
        if (e.length > 31) throw new Error("bytes32 string must be less than 32 bytes");
        return (0, r.hexlify)((0, r.concat)([e, "0x0000000000000000000000000000000000000000000000000000000000000000"]).slice(0, 32));
      }

      function a(f) {
        const e = (0, r.arrayify)(f);
        if (32 !== e.length) throw new Error("invalid bytes32 - not 32 bytes long");
        if (0 !== e[31]) throw new Error("invalid bytes32 string - no null terminator");
        let t = 31;

        for (; 0 === e[t - 1];) t--;

        return (0, n.ZN)(e.slice(0, t));
      }

      var o = t(5637);
    },
    4242: (f, e, t) => {
      "use strict";

      t.d(e, {
        Uj: () => i,
        te: () => s,
        Uw: () => a,
        U$: () => b,
        uu: () => l,
        Y0: () => c,
        XL: () => p,
        ZN: () => h
      });
      var r = t(3286);
      const n = new (t(711).Logger)("strings/5.6.0");
      var i, a;

      function o(f, e, t, r, n) {
        if (f === a.BAD_PREFIX || f === a.UNEXPECTED_CONTINUE) {
          let f = 0;

          for (let r = e + 1; r < t.length && t[r] >> 6 == 2; r++) f++;

          return f;
        }

        return f === a.OVERRUN ? t.length - e - 1 : 0;
      }

      !function (f) {
        f.current = "", f.NFC = "NFC", f.NFD = "NFD", f.NFKC = "NFKC", f.NFKD = "NFKD";
      }(i || (i = {})), function (f) {
        f.UNEXPECTED_CONTINUE = "unexpected continuation byte", f.BAD_PREFIX = "bad codepoint prefix", f.OVERRUN = "string overrun", f.MISSING_CONTINUE = "missing continuation byte", f.OUT_OF_RANGE = "out of UTF-8 range", f.UTF16_SURROGATE = "UTF-16 surrogate", f.OVERLONG = "overlong representation";
      }(a || (a = {}));
      const s = Object.freeze({
        error: function (f, e, t, r, i) {
          return n.throwArgumentError(`invalid codepoint at offset ${e}; ${f}`, "bytes", t);
        },
        ignore: o,
        replace: function (f, e, t, r, n) {
          return f === a.OVERLONG ? (r.push(n), 0) : (r.push(65533), o(f, e, t));
        }
      });

      function u(f, e) {
        null == e && (e = s.error), f = (0, r.arrayify)(f);
        const t = [];
        let n = 0;

        for (; n < f.length;) {
          const r = f[n++];

          if (r >> 7 == 0) {
            t.push(r);
            continue;
          }

          let i = null,
              o = null;
          if (192 == (224 & r)) i = 1, o = 127;else if (224 == (240 & r)) i = 2, o = 2047;else {
            if (240 != (248 & r)) {
              n += e(128 == (192 & r) ? a.UNEXPECTED_CONTINUE : a.BAD_PREFIX, n - 1, f, t);
              continue;
            }

            i = 3, o = 65535;
          }

          if (n - 1 + i >= f.length) {
            n += e(a.OVERRUN, n - 1, f, t);
            continue;
          }

          let s = r & (1 << 8 - i - 1) - 1;

          for (let r = 0; r < i; r++) {
            let r = f[n];

            if (128 != (192 & r)) {
              n += e(a.MISSING_CONTINUE, n, f, t), s = null;
              break;
            }

            s = s << 6 | 63 & r, n++;
          }

          null !== s && (s > 1114111 ? n += e(a.OUT_OF_RANGE, n - 1 - i, f, t, s) : s >= 55296 && s <= 57343 ? n += e(a.UTF16_SURROGATE, n - 1 - i, f, t, s) : s <= o ? n += e(a.OVERLONG, n - 1 - i, f, t, s) : t.push(s));
        }

        return t;
      }

      function c(f, e = i.current) {
        e != i.current && (n.checkNormalize(), f = f.normalize(e));
        let t = [];

        for (let e = 0; e < f.length; e++) {
          const r = f.charCodeAt(e);
          if (r < 128) t.push(r);else if (r < 2048) t.push(r >> 6 | 192), t.push(63 & r | 128);else if (55296 == (64512 & r)) {
            e++;
            const n = f.charCodeAt(e);
            if (e >= f.length || 56320 != (64512 & n)) throw new Error("invalid utf-8 string");
            const i = 65536 + ((1023 & r) << 10) + (1023 & n);
            t.push(i >> 18 | 240), t.push(i >> 12 & 63 | 128), t.push(i >> 6 & 63 | 128), t.push(63 & i | 128);
          } else t.push(r >> 12 | 224), t.push(r >> 6 & 63 | 128), t.push(63 & r | 128);
        }

        return (0, r.arrayify)(t);
      }

      function d(f) {
        const e = "0000" + f.toString(16);
        return "\\u" + e.substring(e.length - 4);
      }

      function b(f, e) {
        return '"' + u(f, e).map(f => {
          if (f < 256) {
            switch (f) {
              case 8:
                return "\\b";

              case 9:
                return "\\t";

              case 10:
                return "\\n";

              case 13:
                return "\\r";

              case 34:
                return '\\"';

              case 92:
                return "\\\\";
            }

            if (f >= 32 && f < 127) return String.fromCharCode(f);
          }

          return f <= 65535 ? d(f) : d(55296 + ((f -= 65536) >> 10 & 1023)) + d(56320 + (1023 & f));
        }).join("") + '"';
      }

      function l(f) {
        return f.map(f => f <= 65535 ? String.fromCharCode(f) : (f -= 65536, String.fromCharCode(55296 + (f >> 10 & 1023), 56320 + (1023 & f)))).join("");
      }

      function h(f, e) {
        return l(u(f, e));
      }

      function p(f, e = i.current) {
        return u(c(f, e));
      }
    },
    4377: (f, e, t) => {
      "use strict";

      t.r(e), t.d(e, {
        TransactionTypes: () => l,
        accessListify: () => S,
        computeAddress: () => g,
        parse: () => T,
        recoverAddress: () => v,
        serialize: () => M
      });
      var r = t(4594),
          n = t(2593),
          i = t(3286),
          a = t(1046),
          o = t(8197),
          s = t(3587),
          u = t(1843),
          c = t(2768),
          d = t(711);
      const b = new d.Logger("transactions/5.6.0");
      var l;

      function h(f) {
        return "0x" === f ? null : (0, r.getAddress)(f);
      }

      function p(f) {
        return "0x" === f ? a._Y : n.O$.from(f);
      }

      !function (f) {
        f[f.legacy = 0] = "legacy", f[f.eip2930 = 1] = "eip2930", f[f.eip1559 = 2] = "eip1559";
      }(l || (l = {}));
      const m = [{
        name: "nonce",
        maxLength: 32,
        numeric: !0
      }, {
        name: "gasPrice",
        maxLength: 32,
        numeric: !0
      }, {
        name: "gasLimit",
        maxLength: 32,
        numeric: !0
      }, {
        name: "to",
        length: 20
      }, {
        name: "value",
        maxLength: 32,
        numeric: !0
      }, {
        name: "data"
      }],
            y = {
        chainId: !0,
        data: !0,
        gasLimit: !0,
        gasPrice: !0,
        nonce: !0,
        to: !0,
        type: !0,
        value: !0
      };

      function g(f) {
        const e = (0, c.computePublicKey)(f);
        return (0, r.getAddress)((0, i.hexDataSlice)((0, o.keccak256)((0, i.hexDataSlice)(e, 1)), 12));
      }

      function v(f, e) {
        return g((0, c.recoverPublicKey)((0, i.arrayify)(f), e));
      }

      function w(f, e) {
        const t = (0, i.stripZeros)(n.O$.from(f).toHexString());
        return t.length > 32 && b.throwArgumentError("invalid length for " + e, "transaction:" + e, f), t;
      }

      function E(f, e) {
        return {
          address: (0, r.getAddress)(f),
          storageKeys: (e || []).map((e, t) => (32 !== (0, i.hexDataLength)(e) && b.throwArgumentError("invalid access list storageKey", `accessList[${f}:${t}]`, e), e.toLowerCase()))
        };
      }

      function S(f) {
        if (Array.isArray(f)) return f.map((f, e) => Array.isArray(f) ? (f.length > 2 && b.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${e}]`, f), E(f[0], f[1])) : E(f.address, f.storageKeys));
        const e = Object.keys(f).map(e => {
          const t = f[e].reduce((f, e) => (f[e] = !0, f), {});
          return E(e, Object.keys(t).sort());
        });
        return e.sort((f, e) => f.address.localeCompare(e.address)), e;
      }

      function A(f) {
        return S(f).map(f => [f.address, f.storageKeys]);
      }

      function x(f, e) {
        if (null != f.gasPrice) {
          const e = n.O$.from(f.gasPrice),
                t = n.O$.from(f.maxFeePerGas || 0);
          e.eq(t) || b.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
            gasPrice: e,
            maxFeePerGas: t
          });
        }

        const t = [w(f.chainId || 0, "chainId"), w(f.nonce || 0, "nonce"), w(f.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"), w(f.maxFeePerGas || 0, "maxFeePerGas"), w(f.gasLimit || 0, "gasLimit"), null != f.to ? (0, r.getAddress)(f.to) : "0x", w(f.value || 0, "value"), f.data || "0x", A(f.accessList || [])];

        if (e) {
          const f = (0, i.splitSignature)(e);
          t.push(w(f.recoveryParam, "recoveryParam")), t.push((0, i.stripZeros)(f.r)), t.push((0, i.stripZeros)(f.s));
        }

        return (0, i.hexConcat)(["0x02", u.encode(t)]);
      }

      function _(f, e) {
        const t = [w(f.chainId || 0, "chainId"), w(f.nonce || 0, "nonce"), w(f.gasPrice || 0, "gasPrice"), w(f.gasLimit || 0, "gasLimit"), null != f.to ? (0, r.getAddress)(f.to) : "0x", w(f.value || 0, "value"), f.data || "0x", A(f.accessList || [])];

        if (e) {
          const f = (0, i.splitSignature)(e);
          t.push(w(f.recoveryParam, "recoveryParam")), t.push((0, i.stripZeros)(f.r)), t.push((0, i.stripZeros)(f.s));
        }

        return (0, i.hexConcat)(["0x01", u.encode(t)]);
      }

      function M(f, e) {
        if (null == f.type || 0 === f.type) return null != f.accessList && b.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", f), function (f, e) {
          (0, s.checkProperties)(f, y);
          const t = [];
          m.forEach(function (e) {
            let r = f[e.name] || [];
            const n = {};
            e.numeric && (n.hexPad = "left"), r = (0, i.arrayify)((0, i.hexlify)(r, n)), e.length && r.length !== e.length && r.length > 0 && b.throwArgumentError("invalid length for " + e.name, "transaction:" + e.name, r), e.maxLength && (r = (0, i.stripZeros)(r), r.length > e.maxLength && b.throwArgumentError("invalid length for " + e.name, "transaction:" + e.name, r)), t.push((0, i.hexlify)(r));
          });
          let r = 0;
          if (null != f.chainId ? (r = f.chainId, "number" != typeof r && b.throwArgumentError("invalid transaction.chainId", "transaction", f)) : e && !(0, i.isBytesLike)(e) && e.v > 28 && (r = Math.floor((e.v - 35) / 2)), 0 !== r && (t.push((0, i.hexlify)(r)), t.push("0x"), t.push("0x")), !e) return u.encode(t);
          const n = (0, i.splitSignature)(e);
          let a = 27 + n.recoveryParam;
          return 0 !== r ? (t.pop(), t.pop(), t.pop(), a += 2 * r + 8, n.v > 28 && n.v !== a && b.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", e)) : n.v !== a && b.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", e), t.push((0, i.hexlify)(a)), t.push((0, i.stripZeros)((0, i.arrayify)(n.r))), t.push((0, i.stripZeros)((0, i.arrayify)(n.s))), u.encode(t);
        }(f, e);

        switch (f.type) {
          case 1:
            return _(f, e);

          case 2:
            return x(f, e);
        }

        return b.throwError(`unsupported transaction type: ${f.type}`, d.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "serializeTransaction",
          transactionType: f.type
        });
      }

      function P(f, e, t) {
        try {
          const t = p(e[0]).toNumber();
          if (0 !== t && 1 !== t) throw new Error("bad recid");
          f.v = t;
        } catch (f) {
          b.throwArgumentError("invalid v for transaction type: 1", "v", e[0]);
        }

        f.r = (0, i.hexZeroPad)(e[1], 32), f.s = (0, i.hexZeroPad)(e[2], 32);

        try {
          const e = (0, o.keccak256)(t(f));
          f.from = v(e, {
            r: f.r,
            s: f.s,
            recoveryParam: f.v
          });
        } catch (f) {
          console.log(f);
        }
      }

      function T(f) {
        const e = (0, i.arrayify)(f);
        if (e[0] > 127) return function (f) {
          const e = u.decode(f);
          9 !== e.length && 6 !== e.length && b.throwArgumentError("invalid raw transaction", "rawTransaction", f);
          const t = {
            nonce: p(e[0]).toNumber(),
            gasPrice: p(e[1]),
            gasLimit: p(e[2]),
            to: h(e[3]),
            value: p(e[4]),
            data: e[5],
            chainId: 0
          };
          if (6 === e.length) return t;

          try {
            t.v = n.O$.from(e[6]).toNumber();
          } catch (f) {
            return console.log(f), t;
          }

          if (t.r = (0, i.hexZeroPad)(e[7], 32), t.s = (0, i.hexZeroPad)(e[8], 32), n.O$.from(t.r).isZero() && n.O$.from(t.s).isZero()) t.chainId = t.v, t.v = 0;else {
            t.chainId = Math.floor((t.v - 35) / 2), t.chainId < 0 && (t.chainId = 0);
            let r = t.v - 27;
            const n = e.slice(0, 6);
            0 !== t.chainId && (n.push((0, i.hexlify)(t.chainId)), n.push("0x"), n.push("0x"), r -= 2 * t.chainId + 8);
            const a = (0, o.keccak256)(u.encode(n));

            try {
              t.from = v(a, {
                r: (0, i.hexlify)(t.r),
                s: (0, i.hexlify)(t.s),
                recoveryParam: r
              });
            } catch (f) {
              console.log(f);
            }

            t.hash = (0, o.keccak256)(f);
          }
          return t.type = null, t;
        }(e);

        switch (e[0]) {
          case 1:
            return function (f) {
              const e = u.decode(f.slice(1));
              8 !== e.length && 11 !== e.length && b.throwArgumentError("invalid component count for transaction type: 1", "payload", (0, i.hexlify)(f));
              const t = {
                type: 1,
                chainId: p(e[0]).toNumber(),
                nonce: p(e[1]).toNumber(),
                gasPrice: p(e[2]),
                gasLimit: p(e[3]),
                to: h(e[4]),
                value: p(e[5]),
                data: e[6],
                accessList: S(e[7])
              };
              return 8 === e.length || (t.hash = (0, o.keccak256)(f), P(t, e.slice(8), _)), t;
            }(e);

          case 2:
            return function (f) {
              const e = u.decode(f.slice(1));
              9 !== e.length && 12 !== e.length && b.throwArgumentError("invalid component count for transaction type: 2", "payload", (0, i.hexlify)(f));
              const t = p(e[2]),
                    r = p(e[3]),
                    n = {
                type: 2,
                chainId: p(e[0]).toNumber(),
                nonce: p(e[1]).toNumber(),
                maxPriorityFeePerGas: t,
                maxFeePerGas: r,
                gasPrice: null,
                gasLimit: p(e[4]),
                to: h(e[5]),
                value: p(e[6]),
                data: e[7],
                accessList: S(e[8])
              };
              return 9 === e.length || (n.hash = (0, o.keccak256)(f), P(n, e.slice(9), x)), n;
            }(e);
        }

        return b.throwError(`unsupported transaction type: ${e[0]}`, d.Logger.errors.UNSUPPORTED_OPERATION, {
          operation: "parseTransaction",
          transactionType: e[0]
        });
      }
    },
    7616: (f, e, t) => {
      "use strict";

      t.r(e), t.d(e, {
        commify: () => S,
        formatEther: () => _,
        formatUnits: () => A,
        parseEther: () => M,
        parseUnits: () => x
      });
      var r = t(3286),
          n = t(711),
          i = t(8794),
          a = t(2593);
      const o = new n.Logger(i.i),
            s = {},
            u = a.O$.from(0),
            c = a.O$.from(-1);

      function d(f, e, t, r) {
        const i = {
          fault: e,
          operation: t
        };
        return void 0 !== r && (i.value = r), o.throwError(f, n.Logger.errors.NUMERIC_FAULT, i);
      }

      let b = "0";

      for (; b.length < 256;) b += b;

      function l(f) {
        if ("number" != typeof f) try {
          f = a.O$.from(f).toNumber();
        } catch (f) {}
        return "number" == typeof f && f >= 0 && f <= 256 && !(f % 1) ? "1" + b.substring(0, f) : o.throwArgumentError("invalid decimal size", "decimals", f);
      }

      function h(f, e) {
        null == e && (e = 0);
        const t = l(e),
              r = (f = a.O$.from(f)).lt(u);
        r && (f = f.mul(c));
        let n = f.mod(t).toString();

        for (; n.length < t.length - 1;) n = "0" + n;

        n = n.match(/^([0-9]*[1-9]|0)(0*)/)[1];
        const i = f.div(t).toString();
        return f = 1 === t.length ? i : i + "." + n, r && (f = "-" + f), f;
      }

      function p(f, e) {
        null == e && (e = 0);
        const t = l(e);
        "string" == typeof f && f.match(/^-?[0-9.]+$/) || o.throwArgumentError("invalid decimal value", "value", f);
        const r = "-" === f.substring(0, 1);
        r && (f = f.substring(1)), "." === f && o.throwArgumentError("missing value", "value", f);
        const n = f.split(".");
        n.length > 2 && o.throwArgumentError("too many decimal points", "value", f);
        let i = n[0],
            s = n[1];

        for (i || (i = "0"), s || (s = "0"); "0" === s[s.length - 1];) s = s.substring(0, s.length - 1);

        for (s.length > t.length - 1 && d("fractional component exceeds decimals", "underflow", "parseFixed"), "" === s && (s = "0"); s.length < t.length - 1;) s += "0";

        const u = a.O$.from(i),
              b = a.O$.from(s);
        let h = u.mul(t).add(b);
        return r && (h = h.mul(c)), h;
      }

      class m {
        constructor(f, e, t, r) {
          f !== s && o.throwError("cannot use FixedFormat constructor; use FixedFormat.from", n.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
          }), this.signed = e, this.width = t, this.decimals = r, this.name = (e ? "" : "u") + "fixed" + String(t) + "x" + String(r), this._multiplier = l(r), Object.freeze(this);
        }

        static from(f) {
          if (f instanceof m) return f;
          "number" == typeof f && (f = `fixed128x${f}`);
          let e = !0,
              t = 128,
              r = 18;
          if ("string" == typeof f) {
            if ("fixed" === f) ;else if ("ufixed" === f) e = !1;else {
              const n = f.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
              n || o.throwArgumentError("invalid fixed format", "format", f), e = "u" !== n[1], t = parseInt(n[2]), r = parseInt(n[3]);
            }
          } else if (f) {
            const n = (e, t, r) => null == f[e] ? r : (typeof f[e] !== t && o.throwArgumentError("invalid fixed format (" + e + " not " + t + ")", "format." + e, f[e]), f[e]);

            e = n("signed", "boolean", e), t = n("width", "number", t), r = n("decimals", "number", r);
          }
          return t % 8 && o.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", t), r > 80 && o.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", r), new m(s, e, t, r);
        }

      }

      class y {
        constructor(f, e, t, r) {
          o.checkNew(new.target, y), f !== s && o.throwError("cannot use FixedNumber constructor; use FixedNumber.from", n.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: "new FixedFormat"
          }), this.format = r, this._hex = e, this._value = t, this._isFixedNumber = !0, Object.freeze(this);
        }

        _checkFormat(f) {
          this.format.name !== f.format.name && o.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", f);
        }

        addUnsafe(f) {
          this._checkFormat(f);

          const e = p(this._value, this.format.decimals),
                t = p(f._value, f.format.decimals);
          return y.fromValue(e.add(t), this.format.decimals, this.format);
        }

        subUnsafe(f) {
          this._checkFormat(f);

          const e = p(this._value, this.format.decimals),
                t = p(f._value, f.format.decimals);
          return y.fromValue(e.sub(t), this.format.decimals, this.format);
        }

        mulUnsafe(f) {
          this._checkFormat(f);

          const e = p(this._value, this.format.decimals),
                t = p(f._value, f.format.decimals);
          return y.fromValue(e.mul(t).div(this.format._multiplier), this.format.decimals, this.format);
        }

        divUnsafe(f) {
          this._checkFormat(f);

          const e = p(this._value, this.format.decimals),
                t = p(f._value, f.format.decimals);
          return y.fromValue(e.mul(this.format._multiplier).div(t), this.format.decimals, this.format);
        }

        floor() {
          const f = this.toString().split(".");
          1 === f.length && f.push("0");
          let e = y.from(f[0], this.format);
          const t = !f[1].match(/^(0*)$/);
          return this.isNegative() && t && (e = e.subUnsafe(g.toFormat(e.format))), e;
        }

        ceiling() {
          const f = this.toString().split(".");
          1 === f.length && f.push("0");
          let e = y.from(f[0], this.format);
          const t = !f[1].match(/^(0*)$/);
          return !this.isNegative() && t && (e = e.addUnsafe(g.toFormat(e.format))), e;
        }

        round(f) {
          null == f && (f = 0);
          const e = this.toString().split(".");
          if (1 === e.length && e.push("0"), (f < 0 || f > 80 || f % 1) && o.throwArgumentError("invalid decimal count", "decimals", f), e[1].length <= f) return this;
          const t = y.from("1" + b.substring(0, f), this.format),
                r = v.toFormat(this.format);
          return this.mulUnsafe(t).addUnsafe(r).floor().divUnsafe(t);
        }

        isZero() {
          return "0.0" === this._value || "0" === this._value;
        }

        isNegative() {
          return "-" === this._value[0];
        }

        toString() {
          return this._value;
        }

        toHexString(f) {
          if (null == f) return this._hex;
          f % 8 && o.throwArgumentError("invalid byte width", "width", f);
          const e = a.O$.from(this._hex).fromTwos(this.format.width).toTwos(f).toHexString();
          return (0, r.hexZeroPad)(e, f / 8);
        }

        toUnsafeFloat() {
          return parseFloat(this.toString());
        }

        toFormat(f) {
          return y.fromString(this._value, f);
        }

        static fromValue(f, e, t) {
          return null != t || null == e || (0, a.Zm)(e) || (t = e, e = null), null == e && (e = 0), null == t && (t = "fixed"), y.fromString(h(f, e), m.from(t));
        }

        static fromString(f, e) {
          null == e && (e = "fixed");
          const t = m.from(e),
                n = p(f, t.decimals);
          !t.signed && n.lt(u) && d("unsigned value cannot be negative", "overflow", "value", f);
          let i = null;
          t.signed ? i = n.toTwos(t.width).toHexString() : (i = n.toHexString(), i = (0, r.hexZeroPad)(i, t.width / 8));
          const a = h(n, t.decimals);
          return new y(s, i, a, t);
        }

        static fromBytes(f, e) {
          null == e && (e = "fixed");
          const t = m.from(e);
          if ((0, r.arrayify)(f).length > t.width / 8) throw new Error("overflow");
          let n = a.O$.from(f);
          t.signed && (n = n.fromTwos(t.width));
          const i = n.toTwos((t.signed ? 0 : 1) + t.width).toHexString(),
                o = h(n, t.decimals);
          return new y(s, i, o, t);
        }

        static from(f, e) {
          if ("string" == typeof f) return y.fromString(f, e);
          if ((0, r.isBytes)(f)) return y.fromBytes(f, e);

          try {
            return y.fromValue(f, 0, e);
          } catch (f) {
            if (f.code !== n.Logger.errors.INVALID_ARGUMENT) throw f;
          }

          return o.throwArgumentError("invalid FixedNumber value", "value", f);
        }

        static isFixedNumber(f) {
          return !(!f || !f._isFixedNumber);
        }

      }

      const g = y.from(1),
            v = y.from("0.5"),
            w = new n.Logger("units/5.6.0"),
            E = ["wei", "kwei", "mwei", "gwei", "szabo", "finney", "ether"];

      function S(f) {
        const e = String(f).split(".");
        (e.length > 2 || !e[0].match(/^-?[0-9]*$/) || e[1] && !e[1].match(/^[0-9]*$/) || "." === f || "-." === f) && w.throwArgumentError("invalid value", "value", f);
        let t = e[0],
            r = "";

        for ("-" === t.substring(0, 1) && (r = "-", t = t.substring(1)); "0" === t.substring(0, 1);) t = t.substring(1);

        "" === t && (t = "0");
        let n = "";

        for (2 === e.length && (n = "." + (e[1] || "0")); n.length > 2 && "0" === n[n.length - 1];) n = n.substring(0, n.length - 1);

        const i = [];

        for (; t.length;) {
          if (t.length <= 3) {
            i.unshift(t);
            break;
          }

          {
            const f = t.length - 3;
            i.unshift(t.substring(f)), t = t.substring(0, f);
          }
        }

        return r + i.join(",") + n;
      }

      function A(f, e) {
        if ("string" == typeof e) {
          const f = E.indexOf(e);
          -1 !== f && (e = 3 * f);
        }

        return h(f, null != e ? e : 18);
      }

      function x(f, e) {
        if ("string" != typeof f && w.throwArgumentError("value must be a string", "value", f), "string" == typeof e) {
          const f = E.indexOf(e);
          -1 !== f && (e = 3 * f);
        }

        return p(f, null != e ? e : 18);
      }

      function _(f) {
        return A(f, 18);
      }

      function M(f) {
        return x(f, 18);
      }
    },
    4280: (f, e, t) => {
      "use strict";

      t.r(e), t.d(e, {
        Wallet: () => P,
        verifyMessage: () => T,
        verifyTypedData: () => O
      });
      var r = t(4594),
          n = t(2593),
          i = t(3587),
          a = t(711);

      var o = function (f, e, t, r) {
        return new (t || (t = Promise))(function (n, i) {
          function a(f) {
            try {
              s(r.next(f));
            } catch (f) {
              i(f);
            }
          }

          function o(f) {
            try {
              s(r.throw(f));
            } catch (f) {
              i(f);
            }
          }

          function s(f) {
            var e;
            f.done ? n(f.value) : (e = f.value, e instanceof t ? e : new t(function (f) {
              f(e);
            })).then(a, o);
          }

          s((r = r.apply(f, e || [])).next());
        });
      };

      const s = new a.Logger("abstract-provider/5.6.0");

      class u {
        constructor() {
          s.checkAbstract(new.target, u), (0, i.defineReadOnly)(this, "_isProvider", !0);
        }

        getFeeData() {
          return o(this, void 0, void 0, function* () {
            const {
              block: f,
              gasPrice: e
            } = yield (0, i.resolveProperties)({
              block: this.getBlock("latest"),
              gasPrice: this.getGasPrice().catch(f => null)
            });
            let t = null,
                r = null;
            return f && f.baseFeePerGas && (r = n.O$.from("1500000000"), t = f.baseFeePerGas.mul(2).add(r)), {
              maxFeePerGas: t,
              maxPriorityFeePerGas: r,
              gasPrice: e
            };
          });
        }

        addListener(f, e) {
          return this.on(f, e);
        }

        removeListener(f, e) {
          return this.off(f, e);
        }

        static isProvider(f) {
          return !(!f || !f._isProvider);
        }

      }

      var c = function (f, e, t, r) {
        return new (t || (t = Promise))(function (n, i) {
          function a(f) {
            try {
              s(r.next(f));
            } catch (f) {
              i(f);
            }
          }

          function o(f) {
            try {
              s(r.throw(f));
            } catch (f) {
              i(f);
            }
          }

          function s(f) {
            var e;
            f.done ? n(f.value) : (e = f.value, e instanceof t ? e : new t(function (f) {
              f(e);
            })).then(a, o);
          }

          s((r = r.apply(f, e || [])).next());
        });
      };

      const d = new a.Logger("abstract-signer/5.6.0"),
            b = ["accessList", "ccipReadEnabled", "chainId", "customData", "data", "from", "gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "to", "type", "value"],
            l = [a.Logger.errors.INSUFFICIENT_FUNDS, a.Logger.errors.NONCE_EXPIRED, a.Logger.errors.REPLACEMENT_UNDERPRICED];

      class h {
        constructor() {
          d.checkAbstract(new.target, h), (0, i.defineReadOnly)(this, "_isSigner", !0);
        }

        getBalance(f) {
          return c(this, void 0, void 0, function* () {
            return this._checkProvider("getBalance"), yield this.provider.getBalance(this.getAddress(), f);
          });
        }

        getTransactionCount(f) {
          return c(this, void 0, void 0, function* () {
            return this._checkProvider("getTransactionCount"), yield this.provider.getTransactionCount(this.getAddress(), f);
          });
        }

        estimateGas(f) {
          return c(this, void 0, void 0, function* () {
            this._checkProvider("estimateGas");

            const e = yield (0, i.resolveProperties)(this.checkTransaction(f));
            return yield this.provider.estimateGas(e);
          });
        }

        call(f, e) {
          return c(this, void 0, void 0, function* () {
            this._checkProvider("call");

            const t = yield (0, i.resolveProperties)(this.checkTransaction(f));
            return yield this.provider.call(t, e);
          });
        }

        sendTransaction(f) {
          return c(this, void 0, void 0, function* () {
            this._checkProvider("sendTransaction");

            const e = yield this.populateTransaction(f),
                  t = yield this.signTransaction(e);
            return yield this.provider.sendTransaction(t);
          });
        }

        getChainId() {
          return c(this, void 0, void 0, function* () {
            this._checkProvider("getChainId");

            return (yield this.provider.getNetwork()).chainId;
          });
        }

        getGasPrice() {
          return c(this, void 0, void 0, function* () {
            return this._checkProvider("getGasPrice"), yield this.provider.getGasPrice();
          });
        }

        getFeeData() {
          return c(this, void 0, void 0, function* () {
            return this._checkProvider("getFeeData"), yield this.provider.getFeeData();
          });
        }

        resolveName(f) {
          return c(this, void 0, void 0, function* () {
            return this._checkProvider("resolveName"), yield this.provider.resolveName(f);
          });
        }

        checkTransaction(f) {
          for (const e in f) -1 === b.indexOf(e) && d.throwArgumentError("invalid transaction key: " + e, "transaction", f);

          const e = (0, i.shallowCopy)(f);
          return null == e.from ? e.from = this.getAddress() : e.from = Promise.all([Promise.resolve(e.from), this.getAddress()]).then(e => (e[0].toLowerCase() !== e[1].toLowerCase() && d.throwArgumentError("from address mismatch", "transaction", f), e[0])), e;
        }

        populateTransaction(f) {
          return c(this, void 0, void 0, function* () {
            const e = yield (0, i.resolveProperties)(this.checkTransaction(f));
            null != e.to && (e.to = Promise.resolve(e.to).then(f => c(this, void 0, void 0, function* () {
              if (null == f) return null;
              const e = yield this.resolveName(f);
              return null == e && d.throwArgumentError("provided ENS name resolves to null", "tx.to", f), e;
            })), e.to.catch(f => {}));
            const t = null != e.maxFeePerGas || null != e.maxPriorityFeePerGas;
            if (null == e.gasPrice || 2 !== e.type && !t ? 0 !== e.type && 1 !== e.type || !t || d.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", f) : d.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", f), 2 !== e.type && null != e.type || null == e.maxFeePerGas || null == e.maxPriorityFeePerGas) {
              if (0 === e.type || 1 === e.type) null == e.gasPrice && (e.gasPrice = this.getGasPrice());else {
                const f = yield this.getFeeData();
                if (null == e.type) {
                  if (null != f.maxFeePerGas && null != f.maxPriorityFeePerGas) {
                    if (e.type = 2, null != e.gasPrice) {
                      const f = e.gasPrice;
                      delete e.gasPrice, e.maxFeePerGas = f, e.maxPriorityFeePerGas = f;
                    } else null == e.maxFeePerGas && (e.maxFeePerGas = f.maxFeePerGas), null == e.maxPriorityFeePerGas && (e.maxPriorityFeePerGas = f.maxPriorityFeePerGas);
                  } else null != f.gasPrice ? (t && d.throwError("network does not support EIP-1559", a.Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "populateTransaction"
                  }), null == e.gasPrice && (e.gasPrice = f.gasPrice), e.type = 0) : d.throwError("failed to get consistent fee data", a.Logger.errors.UNSUPPORTED_OPERATION, {
                    operation: "signer.getFeeData"
                  });
                } else 2 === e.type && (null == e.maxFeePerGas && (e.maxFeePerGas = f.maxFeePerGas), null == e.maxPriorityFeePerGas && (e.maxPriorityFeePerGas = f.maxPriorityFeePerGas));
              }
            } else e.type = 2;
            return null == e.nonce && (e.nonce = this.getTransactionCount("pending")), null == e.gasLimit && (e.gasLimit = this.estimateGas(e).catch(f => {
              if (l.indexOf(f.code) >= 0) throw f;
              return d.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", a.Logger.errors.UNPREDICTABLE_GAS_LIMIT, {
                error: f,
                tx: e
              });
            })), null == e.chainId ? e.chainId = this.getChainId() : e.chainId = Promise.all([Promise.resolve(e.chainId), this.getChainId()]).then(e => (0 !== e[1] && e[0] !== e[1] && d.throwArgumentError("chainId address mismatch", "transaction", f), e[0])), yield (0, i.resolveProperties)(e);
          });
        }

        _checkProvider(f) {
          this.provider || d.throwError("missing provider", a.Logger.errors.UNSUPPORTED_OPERATION, {
            operation: f || "_checkProvider"
          });
        }

        static isSigner(f) {
          return !(!f || !f._isSigner);
        }

      }

      var p = t(3286),
          m = t(3684),
          y = t(7827),
          g = t(4692),
          v = t(8197),
          w = t(4478),
          E = t(2768),
          S = t(6883),
          A = t(1964),
          x = t(4377);

      var _ = function (f, e, t, r) {
        return new (t || (t = Promise))(function (n, i) {
          function a(f) {
            try {
              s(r.next(f));
            } catch (f) {
              i(f);
            }
          }

          function o(f) {
            try {
              s(r.throw(f));
            } catch (f) {
              i(f);
            }
          }

          function s(f) {
            var e;
            f.done ? n(f.value) : (e = f.value, e instanceof t ? e : new t(function (f) {
              f(e);
            })).then(a, o);
          }

          s((r = r.apply(f, e || [])).next());
        });
      };

      const M = new a.Logger("wallet/5.6.0");

      class P extends h {
        constructor(f, e) {
          if (M.checkNew(new.target, P), super(), null != (t = f) && (0, p.isHexString)(t.privateKey, 32) && null != t.address) {
            const e = new E.SigningKey(f.privateKey);

            if ((0, i.defineReadOnly)(this, "_signingKey", () => e), (0, i.defineReadOnly)(this, "address", (0, x.computeAddress)(this.publicKey)), this.address !== (0, r.getAddress)(f.address) && M.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]"), function (f) {
              const e = f.mnemonic;
              return e && e.phrase;
            }(f)) {
              const e = f.mnemonic;
              (0, i.defineReadOnly)(this, "_mnemonic", () => ({
                phrase: e.phrase,
                path: e.path || g.defaultPath,
                locale: e.locale || "en"
              }));
              const t = this.mnemonic,
                    r = g.HDNode.fromMnemonic(t.phrase, null, t.locale).derivePath(t.path);
              (0, x.computeAddress)(r.privateKey) !== this.address && M.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
            } else (0, i.defineReadOnly)(this, "_mnemonic", () => null);
          } else {
            if (E.SigningKey.isSigningKey(f)) "secp256k1" !== f.curve && M.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]"), (0, i.defineReadOnly)(this, "_signingKey", () => f);else {
              "string" == typeof f && f.match(/^[0-9a-f]*$/i) && 64 === f.length && (f = "0x" + f);
              const e = new E.SigningKey(f);
              (0, i.defineReadOnly)(this, "_signingKey", () => e);
            }
            (0, i.defineReadOnly)(this, "_mnemonic", () => null), (0, i.defineReadOnly)(this, "address", (0, x.computeAddress)(this.publicKey));
          }

          var t;
          e && !u.isProvider(e) && M.throwArgumentError("invalid provider", "provider", e), (0, i.defineReadOnly)(this, "provider", e || null);
        }

        get mnemonic() {
          return this._mnemonic();
        }

        get privateKey() {
          return this._signingKey().privateKey;
        }

        get publicKey() {
          return this._signingKey().publicKey;
        }

        getAddress() {
          return Promise.resolve(this.address);
        }

        connect(f) {
          return new P(this, f);
        }

        signTransaction(f) {
          return (0, i.resolveProperties)(f).then(e => {
            null != e.from && ((0, r.getAddress)(e.from) !== this.address && M.throwArgumentError("transaction from address mismatch", "transaction.from", f.from), delete e.from);

            const t = this._signingKey().signDigest((0, v.keccak256)((0, x.serialize)(e)));

            return (0, x.serialize)(e, t);
          });
        }

        signMessage(f) {
          return _(this, void 0, void 0, function* () {
            return (0, p.joinSignature)(this._signingKey().signDigest((0, m.r)(f)));
          });
        }

        _signTypedData(f, e, t) {
          return _(this, void 0, void 0, function* () {
            const r = yield y.E.resolveNames(f, e, t, f => (null == this.provider && M.throwError("cannot resolve ENS names without a provider", a.Logger.errors.UNSUPPORTED_OPERATION, {
              operation: "resolveName",
              value: f
            }), this.provider.resolveName(f)));
            return (0, p.joinSignature)(this._signingKey().signDigest(y.E.hash(r.domain, e, r.value)));
          });
        }

        encrypt(f, e, t) {
          if ("function" != typeof e || t || (t = e, e = {}), t && "function" != typeof t) throw new Error("invalid callback");
          return e || (e = {}), (0, A.HI)(this, f, e, t);
        }

        static createRandom(f) {
          let e = (0, w.O)(16);
          f || (f = {}), f.extraEntropy && (e = (0, p.arrayify)((0, p.hexDataSlice)((0, v.keccak256)((0, p.concat)([e, f.extraEntropy])), 0, 16)));
          const t = (0, g.entropyToMnemonic)(e, f.locale);
          return P.fromMnemonic(t, f.path, f.locale);
        }

        static fromEncryptedJson(f, e, t) {
          return (0, S.decryptJsonWallet)(f, e, t).then(f => new P(f));
        }

        static fromEncryptedJsonSync(f, e) {
          return new P((0, S.decryptJsonWalletSync)(f, e));
        }

        static fromMnemonic(f, e, t) {
          return e || (e = g.defaultPath), new P(g.HDNode.fromMnemonic(f, null, t).derivePath(e));
        }

      }

      function T(f, e) {
        return (0, x.recoverAddress)((0, m.r)(f), e);
      }

      function O(f, e, t, r) {
        return (0, x.recoverAddress)(y.E.hash(f, e, t), r);
      }
    },
    8341: (f, e, t) => {
      "use strict";

      t.r(e), t.d(e, {
        _fetchData: () => h,
        fetchJson: () => p,
        poll: () => m
      });
      var r = t(9567),
          n = t(3286),
          i = t(3587),
          a = t(4242),
          o = t(711);

      var s = function (f, e, t, r) {
        return new (t || (t = Promise))(function (n, i) {
          function a(f) {
            try {
              s(r.next(f));
            } catch (f) {
              i(f);
            }
          }

          function o(f) {
            try {
              s(r.throw(f));
            } catch (f) {
              i(f);
            }
          }

          function s(f) {
            var e;
            f.done ? n(f.value) : (e = f.value, e instanceof t ? e : new t(function (f) {
              f(e);
            })).then(a, o);
          }

          s((r = r.apply(f, e || [])).next());
        });
      };

      function u(f, e) {
        return s(this, void 0, void 0, function* () {
          null == e && (e = {});
          const t = {
            method: e.method || "GET",
            headers: e.headers || {},
            body: e.body || void 0
          };
          !0 !== e.skipFetchSetup && (t.mode = "cors", t.cache = "no-cache", t.credentials = "same-origin", t.redirect = "follow", t.referrer = "client");
          const r = yield fetch(f, t),
                i = yield r.arrayBuffer(),
                a = {};
          return r.headers.forEach ? r.headers.forEach((f, e) => {
            a[e.toLowerCase()] = f;
          }) : r.headers.keys().forEach(f => {
            a[f.toLowerCase()] = r.headers.get(f);
          }), {
            headers: a,
            statusCode: r.status,
            statusMessage: r.statusText,
            body: (0, n.arrayify)(new Uint8Array(i))
          };
        });
      }

      var c = function (f, e, t, r) {
        return new (t || (t = Promise))(function (n, i) {
          function a(f) {
            try {
              s(r.next(f));
            } catch (f) {
              i(f);
            }
          }

          function o(f) {
            try {
              s(r.throw(f));
            } catch (f) {
              i(f);
            }
          }

          function s(f) {
            var e;
            f.done ? n(f.value) : (e = f.value, e instanceof t ? e : new t(function (f) {
              f(e);
            })).then(a, o);
          }

          s((r = r.apply(f, e || [])).next());
        });
      };

      const d = new o.Logger("web/5.6.0");

      function b(f) {
        return new Promise(e => {
          setTimeout(e, f);
        });
      }

      function l(f, e) {
        if (null == f) return null;
        if ("string" == typeof f) return f;

        if ((0, n.isBytesLike)(f)) {
          if (e && ("text" === e.split("/")[0] || "application/json" === e.split(";")[0].trim())) try {
            return (0, a.ZN)(f);
          } catch (f) {}
          return (0, n.hexlify)(f);
        }

        return f;
      }

      function h(f, e, t) {
        const n = "object" == typeof f && null != f.throttleLimit ? f.throttleLimit : 12;
        d.assertArgument(n > 0 && n % 1 == 0, "invalid connection throttle limit", "connection.throttleLimit", n);
        const i = "object" == typeof f ? f.throttleCallback : null,
              s = "object" == typeof f && "number" == typeof f.throttleSlotInterval ? f.throttleSlotInterval : 100;
        d.assertArgument(s > 0 && s % 1 == 0, "invalid connection throttle slot interval", "connection.throttleSlotInterval", s);
        const h = "object" == typeof f && !!f.errorPassThrough,
              p = {};
        let m = null;
        const y = {
          method: "GET"
        };
        let g = !1,
            v = 12e4;
        if ("string" == typeof f) m = f;else if ("object" == typeof f) {
          if (null != f && null != f.url || d.throwArgumentError("missing URL", "connection.url", f), m = f.url, "number" == typeof f.timeout && f.timeout > 0 && (v = f.timeout), f.headers) for (const e in f.headers) p[e.toLowerCase()] = {
            key: e,
            value: String(f.headers[e])
          }, ["if-none-match", "if-modified-since"].indexOf(e.toLowerCase()) >= 0 && (g = !0);

          if (y.allowGzip = !!f.allowGzip, null != f.user && null != f.password) {
            "https:" !== m.substring(0, 6) && !0 !== f.allowInsecureAuthentication && d.throwError("basic authentication requires a secure https url", o.Logger.errors.INVALID_ARGUMENT, {
              argument: "url",
              url: m,
              user: f.user,
              password: "[REDACTED]"
            });
            const e = f.user + ":" + f.password;
            p.authorization = {
              key: "Authorization",
              value: "Basic " + (0, r.c)((0, a.Y0)(e))
            };
          }

          null != f.skipFetchSetup && (y.skipFetchSetup = !!f.skipFetchSetup);
        }
        const w = new RegExp("^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$", "i"),
              E = m ? m.match(w) : null;
        if (E) try {
          const f = {
            statusCode: 200,
            statusMessage: "OK",
            headers: {
              "content-type": E[1]
            },
            body: (0, r.J)(E[2])
          };
          let e = f.body;
          return t && (e = t(f.body, f)), Promise.resolve(e);
        } catch (f) {
          d.throwError("processing response error", o.Logger.errors.SERVER_ERROR, {
            body: l(E[1], E[2]),
            error: f,
            requestBody: null,
            requestMethod: "GET",
            url: m
          });
        }
        e && (y.method = "POST", y.body = e, null == p["content-type"] && (p["content-type"] = {
          key: "Content-Type",
          value: "application/octet-stream"
        }), null == p["content-length"] && (p["content-length"] = {
          key: "Content-Length",
          value: String(e.length)
        }));
        const S = {};
        Object.keys(p).forEach(f => {
          const e = p[f];
          S[e.key] = e.value;
        }), y.headers = S;

        const A = function () {
          let f = null;
          return {
            promise: new Promise(function (e, t) {
              v && (f = setTimeout(() => {
                null != f && (f = null, t(d.makeError("timeout", o.Logger.errors.TIMEOUT, {
                  requestBody: l(y.body, S["content-type"]),
                  requestMethod: y.method,
                  timeout: v,
                  url: m
                })));
              }, v));
            }),
            cancel: function () {
              null != f && (clearTimeout(f), f = null);
            }
          };
        }(),
              x = function () {
          return c(this, void 0, void 0, function* () {
            for (let f = 0; f < n; f++) {
              let e = null;

              try {
                if (e = yield u(m, y), f < n) if (301 === e.statusCode || 302 === e.statusCode) {
                  const f = e.headers.location || "";

                  if ("GET" === y.method && f.match(/^https:/)) {
                    m = e.headers.location;
                    continue;
                  }
                } else if (429 === e.statusCode) {
                  let t = !0;

                  if (i && (t = yield i(f, m)), t) {
                    let t = 0;
                    const r = e.headers["retry-after"];
                    t = "string" == typeof r && r.match(/^[1-9][0-9]*$/) ? 1e3 * parseInt(r) : s * parseInt(String(Math.random() * Math.pow(2, f))), yield b(t);
                    continue;
                  }
                }
              } catch (f) {
                e = f.response, null == e && (A.cancel(), d.throwError("missing response", o.Logger.errors.SERVER_ERROR, {
                  requestBody: l(y.body, S["content-type"]),
                  requestMethod: y.method,
                  serverError: f,
                  url: m
                }));
              }

              let r = e.body;
              if (g && 304 === e.statusCode ? r = null : !h && (e.statusCode < 200 || e.statusCode >= 300) && (A.cancel(), d.throwError("bad response", o.Logger.errors.SERVER_ERROR, {
                status: e.statusCode,
                headers: e.headers,
                body: l(r, e.headers ? e.headers["content-type"] : null),
                requestBody: l(y.body, S["content-type"]),
                requestMethod: y.method,
                url: m
              })), t) try {
                const f = yield t(r, e);
                return A.cancel(), f;
              } catch (t) {
                if (t.throttleRetry && f < n) {
                  let e = !0;

                  if (i && (e = yield i(f, m)), e) {
                    const e = s * parseInt(String(Math.random() * Math.pow(2, f)));
                    yield b(e);
                    continue;
                  }
                }

                A.cancel(), d.throwError("processing response error", o.Logger.errors.SERVER_ERROR, {
                  body: l(r, e.headers ? e.headers["content-type"] : null),
                  error: t,
                  requestBody: l(y.body, S["content-type"]),
                  requestMethod: y.method,
                  url: m
                });
              }
              return A.cancel(), r;
            }

            return d.throwError("failed response", o.Logger.errors.SERVER_ERROR, {
              requestBody: l(y.body, S["content-type"]),
              requestMethod: y.method,
              url: m
            });
          });
        }();

        return Promise.race([A.promise, x]);
      }

      function p(f, e, t) {
        let r = null;

        if (null != e) {
          r = (0, a.Y0)(e);
          const t = "string" == typeof f ? {
            url: f
          } : (0, i.shallowCopy)(f);

          if (t.headers) {
            0 !== Object.keys(t.headers).filter(f => "content-type" === f.toLowerCase()).length || (t.headers = (0, i.shallowCopy)(t.headers), t.headers["content-type"] = "application/json");
          } else t.headers = {
            "content-type": "application/json"
          };

          f = t;
        }

        return h(f, r, (f, e) => {
          let r = null;
          if (null != f) try {
            r = JSON.parse((0, a.ZN)(f));
          } catch (e) {
            d.throwError("invalid JSON", o.Logger.errors.SERVER_ERROR, {
              body: f,
              error: e
            });
          }
          return t && (r = t(r, e)), r;
        });
      }

      function m(f, e) {
        return e || (e = {}), null == (e = (0, i.shallowCopy)(e)).floor && (e.floor = 0), null == e.ceiling && (e.ceiling = 1e4), null == e.interval && (e.interval = 250), new Promise(function (t, r) {
          let n = null,
              i = !1;

          const a = () => !i && (i = !0, n && clearTimeout(n), !0);

          e.timeout && (n = setTimeout(() => {
            a() && r(new Error("timeout"));
          }, e.timeout));
          const o = e.retryLimit;
          let s = 0;
          !function n() {
            return f().then(function (f) {
              if (void 0 !== f) a() && t(f);else if (e.oncePoll) e.oncePoll.once("poll", n);else if (e.onceBlock) e.onceBlock.once("block", n);else if (!i) {
                if (s++, s > o) return void (a() && r(new Error("retry limit reached")));
                let f = e.interval * parseInt(String(Math.random() * Math.pow(2, s)));
                f < e.floor && (f = e.floor), f > e.ceiling && (f = e.ceiling), setTimeout(n, f);
              }
              return null;
            }, function (f) {
              a() && r(f);
            });
          }();
        });
      }
    },
    8826: function (f) {
      "use strict";

      !function (e) {
        function t(f) {
          return parseInt(f) === f;
        }

        function r(f) {
          if (!t(f.length)) return !1;

          for (var e = 0; e < f.length; e++) if (!t(f[e]) || f[e] < 0 || f[e] > 255) return !1;

          return !0;
        }

        function n(f, e) {
          if (f.buffer && ArrayBuffer.isView(f) && "Uint8Array" === f.name) return e && (f = f.slice ? f.slice() : Array.prototype.slice.call(f)), f;

          if (Array.isArray(f)) {
            if (!r(f)) throw new Error("Array contains invalid value: " + f);
            return new Uint8Array(f);
          }

          if (t(f.length) && r(f)) return new Uint8Array(f);
          throw new Error("unsupported array-like object");
        }

        function i(f) {
          return new Uint8Array(f);
        }

        function a(f, e, t, r, n) {
          null == r && null == n || (f = f.slice ? f.slice(r, n) : Array.prototype.slice.call(f, r, n)), e.set(f, t);
        }

        var o,
            s = {
          toBytes: function (f) {
            var e = [],
                t = 0;

            for (f = encodeURI(f); t < f.length;) {
              var r = f.charCodeAt(t++);
              37 === r ? (e.push(parseInt(f.substr(t, 2), 16)), t += 2) : e.push(r);
            }

            return n(e);
          },
          fromBytes: function (f) {
            for (var e = [], t = 0; t < f.length;) {
              var r = f[t];
              r < 128 ? (e.push(String.fromCharCode(r)), t++) : r > 191 && r < 224 ? (e.push(String.fromCharCode((31 & r) << 6 | 63 & f[t + 1])), t += 2) : (e.push(String.fromCharCode((15 & r) << 12 | (63 & f[t + 1]) << 6 | 63 & f[t + 2])), t += 3);
            }

            return e.join("");
          }
        },
            u = (o = "0123456789abcdef", {
          toBytes: function (f) {
            for (var e = [], t = 0; t < f.length; t += 2) e.push(parseInt(f.substr(t, 2), 16));

            return e;
          },
          fromBytes: function (f) {
            for (var e = [], t = 0; t < f.length; t++) {
              var r = f[t];
              e.push(o[(240 & r) >> 4] + o[15 & r]);
            }

            return e.join("");
          }
        }),
            c = {
          16: 10,
          24: 12,
          32: 14
        },
            d = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145],
            b = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22],
            l = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125],
            h = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986],
            p = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766],
            m = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126],
            y = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436],
            g = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890],
            v = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935],
            w = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600],
            E = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480],
            S = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795],
            A = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855],
            x = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150],
            _ = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];

        function M(f) {
          for (var e = [], t = 0; t < f.length; t += 4) e.push(f[t] << 24 | f[t + 1] << 16 | f[t + 2] << 8 | f[t + 3]);

          return e;
        }

        var P = function (f) {
          if (!(this instanceof P)) throw Error("AES must be instanitated with `new`");
          Object.defineProperty(this, "key", {
            value: n(f, !0)
          }), this._prepare();
        };

        P.prototype._prepare = function () {
          var f = c[this.key.length];
          if (null == f) throw new Error("invalid key size (must be 16, 24 or 32 bytes)");
          this._Ke = [], this._Kd = [];

          for (var e = 0; e <= f; e++) this._Ke.push([0, 0, 0, 0]), this._Kd.push([0, 0, 0, 0]);

          var t,
              r = 4 * (f + 1),
              n = this.key.length / 4,
              i = M(this.key);

          for (e = 0; e < n; e++) t = e >> 2, this._Ke[t][e % 4] = i[e], this._Kd[f - t][e % 4] = i[e];

          for (var a, o = 0, s = n; s < r;) {
            if (a = i[n - 1], i[0] ^= b[a >> 16 & 255] << 24 ^ b[a >> 8 & 255] << 16 ^ b[255 & a] << 8 ^ b[a >> 24 & 255] ^ d[o] << 24, o += 1, 8 != n) for (e = 1; e < n; e++) i[e] ^= i[e - 1];else {
              for (e = 1; e < n / 2; e++) i[e] ^= i[e - 1];

              a = i[n / 2 - 1], i[n / 2] ^= b[255 & a] ^ b[a >> 8 & 255] << 8 ^ b[a >> 16 & 255] << 16 ^ b[a >> 24 & 255] << 24;

              for (e = n / 2 + 1; e < n; e++) i[e] ^= i[e - 1];
            }

            for (e = 0; e < n && s < r;) u = s >> 2, l = s % 4, this._Ke[u][l] = i[e], this._Kd[f - u][l] = i[e++], s++;
          }

          for (var u = 1; u < f; u++) for (var l = 0; l < 4; l++) a = this._Kd[u][l], this._Kd[u][l] = S[a >> 24 & 255] ^ A[a >> 16 & 255] ^ x[a >> 8 & 255] ^ _[255 & a];
        }, P.prototype.encrypt = function (f) {
          if (16 != f.length) throw new Error("invalid plaintext size (must be 16 bytes)");

          for (var e = this._Ke.length - 1, t = [0, 0, 0, 0], r = M(f), n = 0; n < 4; n++) r[n] ^= this._Ke[0][n];

          for (var a = 1; a < e; a++) {
            for (n = 0; n < 4; n++) t[n] = h[r[n] >> 24 & 255] ^ p[r[(n + 1) % 4] >> 16 & 255] ^ m[r[(n + 2) % 4] >> 8 & 255] ^ y[255 & r[(n + 3) % 4]] ^ this._Ke[a][n];

            r = t.slice();
          }

          var o,
              s = i(16);

          for (n = 0; n < 4; n++) o = this._Ke[e][n], s[4 * n] = 255 & (b[r[n] >> 24 & 255] ^ o >> 24), s[4 * n + 1] = 255 & (b[r[(n + 1) % 4] >> 16 & 255] ^ o >> 16), s[4 * n + 2] = 255 & (b[r[(n + 2) % 4] >> 8 & 255] ^ o >> 8), s[4 * n + 3] = 255 & (b[255 & r[(n + 3) % 4]] ^ o);

          return s;
        }, P.prototype.decrypt = function (f) {
          if (16 != f.length) throw new Error("invalid ciphertext size (must be 16 bytes)");

          for (var e = this._Kd.length - 1, t = [0, 0, 0, 0], r = M(f), n = 0; n < 4; n++) r[n] ^= this._Kd[0][n];

          for (var a = 1; a < e; a++) {
            for (n = 0; n < 4; n++) t[n] = g[r[n] >> 24 & 255] ^ v[r[(n + 3) % 4] >> 16 & 255] ^ w[r[(n + 2) % 4] >> 8 & 255] ^ E[255 & r[(n + 1) % 4]] ^ this._Kd[a][n];

            r = t.slice();
          }

          var o,
              s = i(16);

          for (n = 0; n < 4; n++) o = this._Kd[e][n], s[4 * n] = 255 & (l[r[n] >> 24 & 255] ^ o >> 24), s[4 * n + 1] = 255 & (l[r[(n + 3) % 4] >> 16 & 255] ^ o >> 16), s[4 * n + 2] = 255 & (l[r[(n + 2) % 4] >> 8 & 255] ^ o >> 8), s[4 * n + 3] = 255 & (l[255 & r[(n + 1) % 4]] ^ o);

          return s;
        };

        var T = function (f) {
          if (!(this instanceof T)) throw Error("AES must be instanitated with `new`");
          this.description = "Electronic Code Block", this.name = "ecb", this._aes = new P(f);
        };

        T.prototype.encrypt = function (f) {
          if ((f = n(f)).length % 16 != 0) throw new Error("invalid plaintext size (must be multiple of 16 bytes)");

          for (var e = i(f.length), t = i(16), r = 0; r < f.length; r += 16) a(f, t, 0, r, r + 16), a(t = this._aes.encrypt(t), e, r);

          return e;
        }, T.prototype.decrypt = function (f) {
          if ((f = n(f)).length % 16 != 0) throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");

          for (var e = i(f.length), t = i(16), r = 0; r < f.length; r += 16) a(f, t, 0, r, r + 16), a(t = this._aes.decrypt(t), e, r);

          return e;
        };

        var O = function (f, e) {
          if (!(this instanceof O)) throw Error("AES must be instanitated with `new`");

          if (this.description = "Cipher Block Chaining", this.name = "cbc", e) {
            if (16 != e.length) throw new Error("invalid initialation vector size (must be 16 bytes)");
          } else e = i(16);

          this._lastCipherblock = n(e, !0), this._aes = new P(f);
        };

        O.prototype.encrypt = function (f) {
          if ((f = n(f)).length % 16 != 0) throw new Error("invalid plaintext size (must be multiple of 16 bytes)");

          for (var e = i(f.length), t = i(16), r = 0; r < f.length; r += 16) {
            a(f, t, 0, r, r + 16);

            for (var o = 0; o < 16; o++) t[o] ^= this._lastCipherblock[o];

            this._lastCipherblock = this._aes.encrypt(t), a(this._lastCipherblock, e, r);
          }

          return e;
        }, O.prototype.decrypt = function (f) {
          if ((f = n(f)).length % 16 != 0) throw new Error("invalid ciphertext size (must be multiple of 16 bytes)");

          for (var e = i(f.length), t = i(16), r = 0; r < f.length; r += 16) {
            a(f, t, 0, r, r + 16), t = this._aes.decrypt(t);

            for (var o = 0; o < 16; o++) e[r + o] = t[o] ^ this._lastCipherblock[o];

            a(f, this._lastCipherblock, 0, r, r + 16);
          }

          return e;
        };

        var C = function (f, e, t) {
          if (!(this instanceof C)) throw Error("AES must be instanitated with `new`");

          if (this.description = "Cipher Feedback", this.name = "cfb", e) {
            if (16 != e.length) throw new Error("invalid initialation vector size (must be 16 size)");
          } else e = i(16);

          t || (t = 1), this.segmentSize = t, this._shiftRegister = n(e, !0), this._aes = new P(f);
        };

        C.prototype.encrypt = function (f) {
          if (f.length % this.segmentSize != 0) throw new Error("invalid plaintext size (must be segmentSize bytes)");

          for (var e, t = n(f, !0), r = 0; r < t.length; r += this.segmentSize) {
            e = this._aes.encrypt(this._shiftRegister);

            for (var i = 0; i < this.segmentSize; i++) t[r + i] ^= e[i];

            a(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), a(t, this._shiftRegister, 16 - this.segmentSize, r, r + this.segmentSize);
          }

          return t;
        }, C.prototype.decrypt = function (f) {
          if (f.length % this.segmentSize != 0) throw new Error("invalid ciphertext size (must be segmentSize bytes)");

          for (var e, t = n(f, !0), r = 0; r < t.length; r += this.segmentSize) {
            e = this._aes.encrypt(this._shiftRegister);

            for (var i = 0; i < this.segmentSize; i++) t[r + i] ^= e[i];

            a(this._shiftRegister, this._shiftRegister, 0, this.segmentSize), a(f, this._shiftRegister, 16 - this.segmentSize, r, r + this.segmentSize);
          }

          return t;
        };

        var R = function (f, e) {
          if (!(this instanceof R)) throw Error("AES must be instanitated with `new`");

          if (this.description = "Output Feedback", this.name = "ofb", e) {
            if (16 != e.length) throw new Error("invalid initialation vector size (must be 16 bytes)");
          } else e = i(16);

          this._lastPrecipher = n(e, !0), this._lastPrecipherIndex = 16, this._aes = new P(f);
        };

        R.prototype.encrypt = function (f) {
          for (var e = n(f, !0), t = 0; t < e.length; t++) 16 === this._lastPrecipherIndex && (this._lastPrecipher = this._aes.encrypt(this._lastPrecipher), this._lastPrecipherIndex = 0), e[t] ^= this._lastPrecipher[this._lastPrecipherIndex++];

          return e;
        }, R.prototype.decrypt = R.prototype.encrypt;

        var N = function (f) {
          if (!(this instanceof N)) throw Error("Counter must be instanitated with `new`");
          0 === f || f || (f = 1), "number" == typeof f ? (this._counter = i(16), this.setValue(f)) : this.setBytes(f);
        };

        N.prototype.setValue = function (f) {
          if ("number" != typeof f || parseInt(f) != f) throw new Error("invalid counter value (must be an integer)");

          for (var e = 15; e >= 0; --e) this._counter[e] = f % 256, f >>= 8;
        }, N.prototype.setBytes = function (f) {
          if (16 != (f = n(f, !0)).length) throw new Error("invalid counter bytes size (must be 16 bytes)");
          this._counter = f;
        }, N.prototype.increment = function () {
          for (var f = 15; f >= 0; f--) {
            if (255 !== this._counter[f]) {
              this._counter[f]++;
              break;
            }

            this._counter[f] = 0;
          }
        };

        var k = function (f, e) {
          if (!(this instanceof k)) throw Error("AES must be instanitated with `new`");
          this.description = "Counter", this.name = "ctr", e instanceof N || (e = new N(e)), this._counter = e, this._remainingCounter = null, this._remainingCounterIndex = 16, this._aes = new P(f);
        };

        k.prototype.encrypt = function (f) {
          for (var e = n(f, !0), t = 0; t < e.length; t++) 16 === this._remainingCounterIndex && (this._remainingCounter = this._aes.encrypt(this._counter._counter), this._remainingCounterIndex = 0, this._counter.increment()), e[t] ^= this._remainingCounter[this._remainingCounterIndex++];

          return e;
        }, k.prototype.decrypt = k.prototype.encrypt;
        var I = {
          AES: P,
          Counter: N,
          ModeOfOperation: {
            ecb: T,
            cbc: O,
            cfb: C,
            ofb: R,
            ctr: k
          },
          utils: {
            hex: u,
            utf8: s
          },
          padding: {
            pkcs7: {
              pad: function (f) {
                var e = 16 - (f = n(f, !0)).length % 16,
                    t = i(f.length + e);
                a(f, t);

                for (var r = f.length; r < t.length; r++) t[r] = e;

                return t;
              },
              strip: function (f) {
                if ((f = n(f, !0)).length < 16) throw new Error("PKCS#7 invalid length");
                var e = f[f.length - 1];
                if (e > 16) throw new Error("PKCS#7 padding byte out of range");

                for (var t = f.length - e, r = 0; r < e; r++) if (f[t + r] !== e) throw new Error("PKCS#7 invalid padding byte");

                var o = i(t);
                return a(f, o, 0, 0, t), o;
              }
            }
          },
          _arrayTest: {
            coerceArray: n,
            createArray: i,
            copyArray: a
          }
        };
        f.exports = I;
      }();
    },
    3550: function (f, e, t) {
      !function (f, e) {
        "use strict";

        function r(f, e) {
          if (!f) throw new Error(e || "Assertion failed");
        }

        function n(f, e) {
          f.super_ = e;

          var t = function () {};

          t.prototype = e.prototype, f.prototype = new t(), f.prototype.constructor = f;
        }

        function i(f, e, t) {
          if (i.isBN(f)) return f;
          this.negative = 0, this.words = null, this.length = 0, this.red = null, null !== f && ("le" !== e && "be" !== e || (t = e, e = 10), this._init(f || 0, e || 10, t || "be"));
        }

        var a;
        "object" == typeof f ? f.exports = i : e.BN = i, i.BN = i, i.wordSize = 26;

        try {
          a = "undefined" != typeof window && void 0 !== window.Buffer ? window.Buffer : t(6601).Buffer;
        } catch (f) {}

        function o(f, e) {
          var t = f.charCodeAt(e);
          return t >= 65 && t <= 70 ? t - 55 : t >= 97 && t <= 102 ? t - 87 : t - 48 & 15;
        }

        function s(f, e, t) {
          var r = o(f, t);
          return t - 1 >= e && (r |= o(f, t - 1) << 4), r;
        }

        function u(f, e, t, r) {
          for (var n = 0, i = Math.min(f.length, t), a = e; a < i; a++) {
            var o = f.charCodeAt(a) - 48;
            n *= r, n += o >= 49 ? o - 49 + 10 : o >= 17 ? o - 17 + 10 : o;
          }

          return n;
        }

        i.isBN = function (f) {
          return f instanceof i || null !== f && "object" == typeof f && f.constructor.wordSize === i.wordSize && Array.isArray(f.words);
        }, i.max = function (f, e) {
          return f.cmp(e) > 0 ? f : e;
        }, i.min = function (f, e) {
          return f.cmp(e) < 0 ? f : e;
        }, i.prototype._init = function (f, e, t) {
          if ("number" == typeof f) return this._initNumber(f, e, t);
          if ("object" == typeof f) return this._initArray(f, e, t);
          "hex" === e && (e = 16), r(e === (0 | e) && e >= 2 && e <= 36);
          var n = 0;
          "-" === (f = f.toString().replace(/\s+/g, ""))[0] && (n++, this.negative = 1), n < f.length && (16 === e ? this._parseHex(f, n, t) : (this._parseBase(f, e, n), "le" === t && this._initArray(this.toArray(), e, t)));
        }, i.prototype._initNumber = function (f, e, t) {
          f < 0 && (this.negative = 1, f = -f), f < 67108864 ? (this.words = [67108863 & f], this.length = 1) : f < 4503599627370496 ? (this.words = [67108863 & f, f / 67108864 & 67108863], this.length = 2) : (r(f < 9007199254740992), this.words = [67108863 & f, f / 67108864 & 67108863, 1], this.length = 3), "le" === t && this._initArray(this.toArray(), e, t);
        }, i.prototype._initArray = function (f, e, t) {
          if (r("number" == typeof f.length), f.length <= 0) return this.words = [0], this.length = 1, this;
          this.length = Math.ceil(f.length / 3), this.words = new Array(this.length);

          for (var n = 0; n < this.length; n++) this.words[n] = 0;

          var i,
              a,
              o = 0;
          if ("be" === t) for (n = f.length - 1, i = 0; n >= 0; n -= 3) a = f[n] | f[n - 1] << 8 | f[n - 2] << 16, this.words[i] |= a << o & 67108863, this.words[i + 1] = a >>> 26 - o & 67108863, (o += 24) >= 26 && (o -= 26, i++);else if ("le" === t) for (n = 0, i = 0; n < f.length; n += 3) a = f[n] | f[n + 1] << 8 | f[n + 2] << 16, this.words[i] |= a << o & 67108863, this.words[i + 1] = a >>> 26 - o & 67108863, (o += 24) >= 26 && (o -= 26, i++);
          return this.strip();
        }, i.prototype._parseHex = function (f, e, t) {
          this.length = Math.ceil((f.length - e) / 6), this.words = new Array(this.length);

          for (var r = 0; r < this.length; r++) this.words[r] = 0;

          var n,
              i = 0,
              a = 0;
          if ("be" === t) for (r = f.length - 1; r >= e; r -= 2) n = s(f, e, r) << i, this.words[a] |= 67108863 & n, i >= 18 ? (i -= 18, a += 1, this.words[a] |= n >>> 26) : i += 8;else for (r = (f.length - e) % 2 == 0 ? e + 1 : e; r < f.length; r += 2) n = s(f, e, r) << i, this.words[a] |= 67108863 & n, i >= 18 ? (i -= 18, a += 1, this.words[a] |= n >>> 26) : i += 8;
          this.strip();
        }, i.prototype._parseBase = function (f, e, t) {
          this.words = [0], this.length = 1;

          for (var r = 0, n = 1; n <= 67108863; n *= e) r++;

          r--, n = n / e | 0;

          for (var i = f.length - t, a = i % r, o = Math.min(i, i - a) + t, s = 0, c = t; c < o; c += r) s = u(f, c, c + r, e), this.imuln(n), this.words[0] + s < 67108864 ? this.words[0] += s : this._iaddn(s);

          if (0 !== a) {
            var d = 1;

            for (s = u(f, c, f.length, e), c = 0; c < a; c++) d *= e;

            this.imuln(d), this.words[0] + s < 67108864 ? this.words[0] += s : this._iaddn(s);
          }

          this.strip();
        }, i.prototype.copy = function (f) {
          f.words = new Array(this.length);

          for (var e = 0; e < this.length; e++) f.words[e] = this.words[e];

          f.length = this.length, f.negative = this.negative, f.red = this.red;
        }, i.prototype.clone = function () {
          var f = new i(null);
          return this.copy(f), f;
        }, i.prototype._expand = function (f) {
          for (; this.length < f;) this.words[this.length++] = 0;

          return this;
        }, i.prototype.strip = function () {
          for (; this.length > 1 && 0 === this.words[this.length - 1];) this.length--;

          return this._normSign();
        }, i.prototype._normSign = function () {
          return 1 === this.length && 0 === this.words[0] && (this.negative = 0), this;
        }, i.prototype.inspect = function () {
          return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
        };
        var c = ["", "0", "00", "000", "0000", "00000", "000000", "0000000", "00000000", "000000000", "0000000000", "00000000000", "000000000000", "0000000000000", "00000000000000", "000000000000000", "0000000000000000", "00000000000000000", "000000000000000000", "0000000000000000000", "00000000000000000000", "000000000000000000000", "0000000000000000000000", "00000000000000000000000", "000000000000000000000000", "0000000000000000000000000"],
            d = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
            b = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 1e7, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64e6, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 243e5, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

        function l(f, e, t) {
          t.negative = e.negative ^ f.negative;
          var r = f.length + e.length | 0;
          t.length = r, r = r - 1 | 0;
          var n = 0 | f.words[0],
              i = 0 | e.words[0],
              a = n * i,
              o = 67108863 & a,
              s = a / 67108864 | 0;
          t.words[0] = o;

          for (var u = 1; u < r; u++) {
            for (var c = s >>> 26, d = 67108863 & s, b = Math.min(u, e.length - 1), l = Math.max(0, u - f.length + 1); l <= b; l++) {
              var h = u - l | 0;
              c += (a = (n = 0 | f.words[h]) * (i = 0 | e.words[l]) + d) / 67108864 | 0, d = 67108863 & a;
            }

            t.words[u] = 0 | d, s = 0 | c;
          }

          return 0 !== s ? t.words[u] = 0 | s : t.length--, t.strip();
        }

        i.prototype.toString = function (f, e) {
          var t;

          if (e = 0 | e || 1, 16 === (f = f || 10) || "hex" === f) {
            t = "";

            for (var n = 0, i = 0, a = 0; a < this.length; a++) {
              var o = this.words[a],
                  s = (16777215 & (o << n | i)).toString(16);
              t = 0 !== (i = o >>> 24 - n & 16777215) || a !== this.length - 1 ? c[6 - s.length] + s + t : s + t, (n += 2) >= 26 && (n -= 26, a--);
            }

            for (0 !== i && (t = i.toString(16) + t); t.length % e != 0;) t = "0" + t;

            return 0 !== this.negative && (t = "-" + t), t;
          }

          if (f === (0 | f) && f >= 2 && f <= 36) {
            var u = d[f],
                l = b[f];
            t = "";
            var h = this.clone();

            for (h.negative = 0; !h.isZero();) {
              var p = h.modn(l).toString(f);
              t = (h = h.idivn(l)).isZero() ? p + t : c[u - p.length] + p + t;
            }

            for (this.isZero() && (t = "0" + t); t.length % e != 0;) t = "0" + t;

            return 0 !== this.negative && (t = "-" + t), t;
          }

          r(!1, "Base should be between 2 and 36");
        }, i.prototype.toNumber = function () {
          var f = this.words[0];
          return 2 === this.length ? f += 67108864 * this.words[1] : 3 === this.length && 1 === this.words[2] ? f += 4503599627370496 + 67108864 * this.words[1] : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), 0 !== this.negative ? -f : f;
        }, i.prototype.toJSON = function () {
          return this.toString(16);
        }, i.prototype.toBuffer = function (f, e) {
          return r(void 0 !== a), this.toArrayLike(a, f, e);
        }, i.prototype.toArray = function (f, e) {
          return this.toArrayLike(Array, f, e);
        }, i.prototype.toArrayLike = function (f, e, t) {
          var n = this.byteLength(),
              i = t || Math.max(1, n);
          r(n <= i, "byte array longer than desired length"), r(i > 0, "Requested array length <= 0"), this.strip();
          var a,
              o,
              s = "le" === e,
              u = new f(i),
              c = this.clone();

          if (s) {
            for (o = 0; !c.isZero(); o++) a = c.andln(255), c.iushrn(8), u[o] = a;

            for (; o < i; o++) u[o] = 0;
          } else {
            for (o = 0; o < i - n; o++) u[o] = 0;

            for (o = 0; !c.isZero(); o++) a = c.andln(255), c.iushrn(8), u[i - o - 1] = a;
          }

          return u;
        }, Math.clz32 ? i.prototype._countBits = function (f) {
          return 32 - Math.clz32(f);
        } : i.prototype._countBits = function (f) {
          var e = f,
              t = 0;
          return e >= 4096 && (t += 13, e >>>= 13), e >= 64 && (t += 7, e >>>= 7), e >= 8 && (t += 4, e >>>= 4), e >= 2 && (t += 2, e >>>= 2), t + e;
        }, i.prototype._zeroBits = function (f) {
          if (0 === f) return 26;
          var e = f,
              t = 0;
          return 0 == (8191 & e) && (t += 13, e >>>= 13), 0 == (127 & e) && (t += 7, e >>>= 7), 0 == (15 & e) && (t += 4, e >>>= 4), 0 == (3 & e) && (t += 2, e >>>= 2), 0 == (1 & e) && t++, t;
        }, i.prototype.bitLength = function () {
          var f = this.words[this.length - 1],
              e = this._countBits(f);

          return 26 * (this.length - 1) + e;
        }, i.prototype.zeroBits = function () {
          if (this.isZero()) return 0;

          for (var f = 0, e = 0; e < this.length; e++) {
            var t = this._zeroBits(this.words[e]);

            if (f += t, 26 !== t) break;
          }

          return f;
        }, i.prototype.byteLength = function () {
          return Math.ceil(this.bitLength() / 8);
        }, i.prototype.toTwos = function (f) {
          return 0 !== this.negative ? this.abs().inotn(f).iaddn(1) : this.clone();
        }, i.prototype.fromTwos = function (f) {
          return this.testn(f - 1) ? this.notn(f).iaddn(1).ineg() : this.clone();
        }, i.prototype.isNeg = function () {
          return 0 !== this.negative;
        }, i.prototype.neg = function () {
          return this.clone().ineg();
        }, i.prototype.ineg = function () {
          return this.isZero() || (this.negative ^= 1), this;
        }, i.prototype.iuor = function (f) {
          for (; this.length < f.length;) this.words[this.length++] = 0;

          for (var e = 0; e < f.length; e++) this.words[e] = this.words[e] | f.words[e];

          return this.strip();
        }, i.prototype.ior = function (f) {
          return r(0 == (this.negative | f.negative)), this.iuor(f);
        }, i.prototype.or = function (f) {
          return this.length > f.length ? this.clone().ior(f) : f.clone().ior(this);
        }, i.prototype.uor = function (f) {
          return this.length > f.length ? this.clone().iuor(f) : f.clone().iuor(this);
        }, i.prototype.iuand = function (f) {
          var e;
          e = this.length > f.length ? f : this;

          for (var t = 0; t < e.length; t++) this.words[t] = this.words[t] & f.words[t];

          return this.length = e.length, this.strip();
        }, i.prototype.iand = function (f) {
          return r(0 == (this.negative | f.negative)), this.iuand(f);
        }, i.prototype.and = function (f) {
          return this.length > f.length ? this.clone().iand(f) : f.clone().iand(this);
        }, i.prototype.uand = function (f) {
          return this.length > f.length ? this.clone().iuand(f) : f.clone().iuand(this);
        }, i.prototype.iuxor = function (f) {
          var e, t;
          this.length > f.length ? (e = this, t = f) : (e = f, t = this);

          for (var r = 0; r < t.length; r++) this.words[r] = e.words[r] ^ t.words[r];

          if (this !== e) for (; r < e.length; r++) this.words[r] = e.words[r];
          return this.length = e.length, this.strip();
        }, i.prototype.ixor = function (f) {
          return r(0 == (this.negative | f.negative)), this.iuxor(f);
        }, i.prototype.xor = function (f) {
          return this.length > f.length ? this.clone().ixor(f) : f.clone().ixor(this);
        }, i.prototype.uxor = function (f) {
          return this.length > f.length ? this.clone().iuxor(f) : f.clone().iuxor(this);
        }, i.prototype.inotn = function (f) {
          r("number" == typeof f && f >= 0);
          var e = 0 | Math.ceil(f / 26),
              t = f % 26;
          this._expand(e), t > 0 && e--;

          for (var n = 0; n < e; n++) this.words[n] = 67108863 & ~this.words[n];

          return t > 0 && (this.words[n] = ~this.words[n] & 67108863 >> 26 - t), this.strip();
        }, i.prototype.notn = function (f) {
          return this.clone().inotn(f);
        }, i.prototype.setn = function (f, e) {
          r("number" == typeof f && f >= 0);
          var t = f / 26 | 0,
              n = f % 26;
          return this._expand(t + 1), this.words[t] = e ? this.words[t] | 1 << n : this.words[t] & ~(1 << n), this.strip();
        }, i.prototype.iadd = function (f) {
          var e, t, r;
          if (0 !== this.negative && 0 === f.negative) return this.negative = 0, e = this.isub(f), this.negative ^= 1, this._normSign();
          if (0 === this.negative && 0 !== f.negative) return f.negative = 0, e = this.isub(f), f.negative = 1, e._normSign();
          this.length > f.length ? (t = this, r = f) : (t = f, r = this);

          for (var n = 0, i = 0; i < r.length; i++) e = (0 | t.words[i]) + (0 | r.words[i]) + n, this.words[i] = 67108863 & e, n = e >>> 26;

          for (; 0 !== n && i < t.length; i++) e = (0 | t.words[i]) + n, this.words[i] = 67108863 & e, n = e >>> 26;

          if (this.length = t.length, 0 !== n) this.words[this.length] = n, this.length++;else if (t !== this) for (; i < t.length; i++) this.words[i] = t.words[i];
          return this;
        }, i.prototype.add = function (f) {
          var e;
          return 0 !== f.negative && 0 === this.negative ? (f.negative = 0, e = this.sub(f), f.negative ^= 1, e) : 0 === f.negative && 0 !== this.negative ? (this.negative = 0, e = f.sub(this), this.negative = 1, e) : this.length > f.length ? this.clone().iadd(f) : f.clone().iadd(this);
        }, i.prototype.isub = function (f) {
          if (0 !== f.negative) {
            f.negative = 0;
            var e = this.iadd(f);
            return f.negative = 1, e._normSign();
          }

          if (0 !== this.negative) return this.negative = 0, this.iadd(f), this.negative = 1, this._normSign();
          var t,
              r,
              n = this.cmp(f);
          if (0 === n) return this.negative = 0, this.length = 1, this.words[0] = 0, this;
          n > 0 ? (t = this, r = f) : (t = f, r = this);

          for (var i = 0, a = 0; a < r.length; a++) i = (e = (0 | t.words[a]) - (0 | r.words[a]) + i) >> 26, this.words[a] = 67108863 & e;

          for (; 0 !== i && a < t.length; a++) i = (e = (0 | t.words[a]) + i) >> 26, this.words[a] = 67108863 & e;

          if (0 === i && a < t.length && t !== this) for (; a < t.length; a++) this.words[a] = t.words[a];
          return this.length = Math.max(this.length, a), t !== this && (this.negative = 1), this.strip();
        }, i.prototype.sub = function (f) {
          return this.clone().isub(f);
        };

        var h = function (f, e, t) {
          var r,
              n,
              i,
              a = f.words,
              o = e.words,
              s = t.words,
              u = 0,
              c = 0 | a[0],
              d = 8191 & c,
              b = c >>> 13,
              l = 0 | a[1],
              h = 8191 & l,
              p = l >>> 13,
              m = 0 | a[2],
              y = 8191 & m,
              g = m >>> 13,
              v = 0 | a[3],
              w = 8191 & v,
              E = v >>> 13,
              S = 0 | a[4],
              A = 8191 & S,
              x = S >>> 13,
              _ = 0 | a[5],
              M = 8191 & _,
              P = _ >>> 13,
              T = 0 | a[6],
              O = 8191 & T,
              C = T >>> 13,
              R = 0 | a[7],
              N = 8191 & R,
              k = R >>> 13,
              I = 0 | a[8],
              F = 8191 & I,
              B = I >>> 13,
              L = 0 | a[9],
              D = 8191 & L,
              U = L >>> 13,
              j = 0 | o[0],
              z = 8191 & j,
              G = j >>> 13,
              K = 0 | o[1],
              V = 8191 & K,
              H = K >>> 13,
              q = 0 | o[2],
              W = 8191 & q,
              $ = q >>> 13,
              J = 0 | o[3],
              Z = 8191 & J,
              Y = J >>> 13,
              X = 0 | o[4],
              Q = 8191 & X,
              ff = X >>> 13,
              ef = 0 | o[5],
              tf = 8191 & ef,
              rf = ef >>> 13,
              nf = 0 | o[6],
              af = 8191 & nf,
              of = nf >>> 13,
              sf = 0 | o[7],
              uf = 8191 & sf,
              cf = sf >>> 13,
              df = 0 | o[8],
              bf = 8191 & df,
              lf = df >>> 13,
              hf = 0 | o[9],
              pf = 8191 & hf,
              mf = hf >>> 13;

          t.negative = f.negative ^ e.negative, t.length = 19;
          var yf = (u + (r = Math.imul(d, z)) | 0) + ((8191 & (n = (n = Math.imul(d, G)) + Math.imul(b, z) | 0)) << 13) | 0;
          u = ((i = Math.imul(b, G)) + (n >>> 13) | 0) + (yf >>> 26) | 0, yf &= 67108863, r = Math.imul(h, z), n = (n = Math.imul(h, G)) + Math.imul(p, z) | 0, i = Math.imul(p, G);
          var gf = (u + (r = r + Math.imul(d, V) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(d, H) | 0) + Math.imul(b, V) | 0)) << 13) | 0;
          u = ((i = i + Math.imul(b, H) | 0) + (n >>> 13) | 0) + (gf >>> 26) | 0, gf &= 67108863, r = Math.imul(y, z), n = (n = Math.imul(y, G)) + Math.imul(g, z) | 0, i = Math.imul(g, G), r = r + Math.imul(h, V) | 0, n = (n = n + Math.imul(h, H) | 0) + Math.imul(p, V) | 0, i = i + Math.imul(p, H) | 0;
          var vf = (u + (r = r + Math.imul(d, W) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(d, $) | 0) + Math.imul(b, W) | 0)) << 13) | 0;
          u = ((i = i + Math.imul(b, $) | 0) + (n >>> 13) | 0) + (vf >>> 26) | 0, vf &= 67108863, r = Math.imul(w, z), n = (n = Math.imul(w, G)) + Math.imul(E, z) | 0, i = Math.imul(E, G), r = r + Math.imul(y, V) | 0, n = (n = n + Math.imul(y, H) | 0) + Math.imul(g, V) | 0, i = i + Math.imul(g, H) | 0, r = r + Math.imul(h, W) | 0, n = (n = n + Math.imul(h, $) | 0) + Math.imul(p, W) | 0, i = i + Math.imul(p, $) | 0;
          var wf = (u + (r = r + Math.imul(d, Z) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(d, Y) | 0) + Math.imul(b, Z) | 0)) << 13) | 0;
          u = ((i = i + Math.imul(b, Y) | 0) + (n >>> 13) | 0) + (wf >>> 26) | 0, wf &= 67108863, r = Math.imul(A, z), n = (n = Math.imul(A, G)) + Math.imul(x, z) | 0, i = Math.imul(x, G), r = r + Math.imul(w, V) | 0, n = (n = n + Math.imul(w, H) | 0) + Math.imul(E, V) | 0, i = i + Math.imul(E, H) | 0, r = r + Math.imul(y, W) | 0, n = (n = n + Math.imul(y, $) | 0) + Math.imul(g, W) | 0, i = i + Math.imul(g, $) | 0, r = r + Math.imul(h, Z) | 0, n = (n = n + Math.imul(h, Y) | 0) + Math.imul(p, Z) | 0, i = i + Math.imul(p, Y) | 0;
          var Ef = (u + (r = r + Math.imul(d, Q) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(d, ff) | 0) + Math.imul(b, Q) | 0)) << 13) | 0;
          u = ((i = i + Math.imul(b, ff) | 0) + (n >>> 13) | 0) + (Ef >>> 26) | 0, Ef &= 67108863, r = Math.imul(M, z), n = (n = Math.imul(M, G)) + Math.imul(P, z) | 0, i = Math.imul(P, G), r = r + Math.imul(A, V) | 0, n = (n = n + Math.imul(A, H) | 0) + Math.imul(x, V) | 0, i = i + Math.imul(x, H) | 0, r = r + Math.imul(w, W) | 0, n = (n = n + Math.imul(w, $) | 0) + Math.imul(E, W) | 0, i = i + Math.imul(E, $) | 0, r = r + Math.imul(y, Z) | 0, n = (n = n + Math.imul(y, Y) | 0) + Math.imul(g, Z) | 0, i = i + Math.imul(g, Y) | 0, r = r + Math.imul(h, Q) | 0, n = (n = n + Math.imul(h, ff) | 0) + Math.imul(p, Q) | 0, i = i + Math.imul(p, ff) | 0;
          var Sf = (u + (r = r + Math.imul(d, tf) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(d, rf) | 0) + Math.imul(b, tf) | 0)) << 13) | 0;
          u = ((i = i + Math.imul(b, rf) | 0) + (n >>> 13) | 0) + (Sf >>> 26) | 0, Sf &= 67108863, r = Math.imul(O, z), n = (n = Math.imul(O, G)) + Math.imul(C, z) | 0, i = Math.imul(C, G), r = r + Math.imul(M, V) | 0, n = (n = n + Math.imul(M, H) | 0) + Math.imul(P, V) | 0, i = i + Math.imul(P, H) | 0, r = r + Math.imul(A, W) | 0, n = (n = n + Math.imul(A, $) | 0) + Math.imul(x, W) | 0, i = i + Math.imul(x, $) | 0, r = r + Math.imul(w, Z) | 0, n = (n = n + Math.imul(w, Y) | 0) + Math.imul(E, Z) | 0, i = i + Math.imul(E, Y) | 0, r = r + Math.imul(y, Q) | 0, n = (n = n + Math.imul(y, ff) | 0) + Math.imul(g, Q) | 0, i = i + Math.imul(g, ff) | 0, r = r + Math.imul(h, tf) | 0, n = (n = n + Math.imul(h, rf) | 0) + Math.imul(p, tf) | 0, i = i + Math.imul(p, rf) | 0;
          var Af = (u + (r = r + Math.imul(d, af) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(d, of) | 0) + Math.imul(b, af) | 0)) << 13) | 0;
          u = ((i = i + Math.imul(b, of) | 0) + (n >>> 13) | 0) + (Af >>> 26) | 0, Af &= 67108863, r = Math.imul(N, z), n = (n = Math.imul(N, G)) + Math.imul(k, z) | 0, i = Math.imul(k, G), r = r + Math.imul(O, V) | 0, n = (n = n + Math.imul(O, H) | 0) + Math.imul(C, V) | 0, i = i + Math.imul(C, H) | 0, r = r + Math.imul(M, W) | 0, n = (n = n + Math.imul(M, $) | 0) + Math.imul(P, W) | 0, i = i + Math.imul(P, $) | 0, r = r + Math.imul(A, Z) | 0, n = (n = n + Math.imul(A, Y) | 0) + Math.imul(x, Z) | 0, i = i + Math.imul(x, Y) | 0, r = r + Math.imul(w, Q) | 0, n = (n = n + Math.imul(w, ff) | 0) + Math.imul(E, Q) | 0, i = i + Math.imul(E, ff) | 0, r = r + Math.imul(y, tf) | 0, n = (n = n + Math.imul(y, rf) | 0) + Math.imul(g, tf) | 0, i = i + Math.imul(g, rf) | 0, r = r + Math.imul(h, af) | 0, n = (n = n + Math.imul(h, of) | 0) + Math.imul(p, af) | 0, i = i + Math.imul(p, of) | 0;
          var xf = (u + (r = r + Math.imul(d, uf) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(d, cf) | 0) + Math.imul(b, uf) | 0)) << 13) | 0;
          u = ((i = i + Math.imul(b, cf) | 0) + (n >>> 13) | 0) + (xf >>> 26) | 0, xf &= 67108863, r = Math.imul(F, z), n = (n = Math.imul(F, G)) + Math.imul(B, z) | 0, i = Math.imul(B, G), r = r + Math.imul(N, V) | 0, n = (n = n + Math.imul(N, H) | 0) + Math.imul(k, V) | 0, i = i + Math.imul(k, H) | 0, r = r + Math.imul(O, W) | 0, n = (n = n + Math.imul(O, $) | 0) + Math.imul(C, W) | 0, i = i + Math.imul(C, $) | 0, r = r + Math.imul(M, Z) | 0, n = (n = n + Math.imul(M, Y) | 0) + Math.imul(P, Z) | 0, i = i + Math.imul(P, Y) | 0, r = r + Math.imul(A, Q) | 0, n = (n = n + Math.imul(A, ff) | 0) + Math.imul(x, Q) | 0, i = i + Math.imul(x, ff) | 0, r = r + Math.imul(w, tf) | 0, n = (n = n + Math.imul(w, rf) | 0) + Math.imul(E, tf) | 0, i = i + Math.imul(E, rf) | 0, r = r + Math.imul(y, af) | 0, n = (n = n + Math.imul(y, of) | 0) + Math.imul(g, af) | 0, i = i + Math.imul(g, of) | 0, r = r + Math.imul(h, uf) | 0, n = (n = n + Math.imul(h, cf) | 0) + Math.imul(p, uf) | 0, i = i + Math.imul(p, cf) | 0;

          var _f = (u + (r = r + Math.imul(d, bf) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(d, lf) | 0) + Math.imul(b, bf) | 0)) << 13) | 0;

          u = ((i = i + Math.imul(b, lf) | 0) + (n >>> 13) | 0) + (_f >>> 26) | 0, _f &= 67108863, r = Math.imul(D, z), n = (n = Math.imul(D, G)) + Math.imul(U, z) | 0, i = Math.imul(U, G), r = r + Math.imul(F, V) | 0, n = (n = n + Math.imul(F, H) | 0) + Math.imul(B, V) | 0, i = i + Math.imul(B, H) | 0, r = r + Math.imul(N, W) | 0, n = (n = n + Math.imul(N, $) | 0) + Math.imul(k, W) | 0, i = i + Math.imul(k, $) | 0, r = r + Math.imul(O, Z) | 0, n = (n = n + Math.imul(O, Y) | 0) + Math.imul(C, Z) | 0, i = i + Math.imul(C, Y) | 0, r = r + Math.imul(M, Q) | 0, n = (n = n + Math.imul(M, ff) | 0) + Math.imul(P, Q) | 0, i = i + Math.imul(P, ff) | 0, r = r + Math.imul(A, tf) | 0, n = (n = n + Math.imul(A, rf) | 0) + Math.imul(x, tf) | 0, i = i + Math.imul(x, rf) | 0, r = r + Math.imul(w, af) | 0, n = (n = n + Math.imul(w, of) | 0) + Math.imul(E, af) | 0, i = i + Math.imul(E, of) | 0, r = r + Math.imul(y, uf) | 0, n = (n = n + Math.imul(y, cf) | 0) + Math.imul(g, uf) | 0, i = i + Math.imul(g, cf) | 0, r = r + Math.imul(h, bf) | 0, n = (n = n + Math.imul(h, lf) | 0) + Math.imul(p, bf) | 0, i = i + Math.imul(p, lf) | 0;
          var Mf = (u + (r = r + Math.imul(d, pf) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(d, mf) | 0) + Math.imul(b, pf) | 0)) << 13) | 0;
          u = ((i = i + Math.imul(b, mf) | 0) + (n >>> 13) | 0) + (Mf >>> 26) | 0, Mf &= 67108863, r = Math.imul(D, V), n = (n = Math.imul(D, H)) + Math.imul(U, V) | 0, i = Math.imul(U, H), r = r + Math.imul(F, W) | 0, n = (n = n + Math.imul(F, $) | 0) + Math.imul(B, W) | 0, i = i + Math.imul(B, $) | 0, r = r + Math.imul(N, Z) | 0, n = (n = n + Math.imul(N, Y) | 0) + Math.imul(k, Z) | 0, i = i + Math.imul(k, Y) | 0, r = r + Math.imul(O, Q) | 0, n = (n = n + Math.imul(O, ff) | 0) + Math.imul(C, Q) | 0, i = i + Math.imul(C, ff) | 0, r = r + Math.imul(M, tf) | 0, n = (n = n + Math.imul(M, rf) | 0) + Math.imul(P, tf) | 0, i = i + Math.imul(P, rf) | 0, r = r + Math.imul(A, af) | 0, n = (n = n + Math.imul(A, of) | 0) + Math.imul(x, af) | 0, i = i + Math.imul(x, of) | 0, r = r + Math.imul(w, uf) | 0, n = (n = n + Math.imul(w, cf) | 0) + Math.imul(E, uf) | 0, i = i + Math.imul(E, cf) | 0, r = r + Math.imul(y, bf) | 0, n = (n = n + Math.imul(y, lf) | 0) + Math.imul(g, bf) | 0, i = i + Math.imul(g, lf) | 0;
          var Pf = (u + (r = r + Math.imul(h, pf) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(h, mf) | 0) + Math.imul(p, pf) | 0)) << 13) | 0;
          u = ((i = i + Math.imul(p, mf) | 0) + (n >>> 13) | 0) + (Pf >>> 26) | 0, Pf &= 67108863, r = Math.imul(D, W), n = (n = Math.imul(D, $)) + Math.imul(U, W) | 0, i = Math.imul(U, $), r = r + Math.imul(F, Z) | 0, n = (n = n + Math.imul(F, Y) | 0) + Math.imul(B, Z) | 0, i = i + Math.imul(B, Y) | 0, r = r + Math.imul(N, Q) | 0, n = (n = n + Math.imul(N, ff) | 0) + Math.imul(k, Q) | 0, i = i + Math.imul(k, ff) | 0, r = r + Math.imul(O, tf) | 0, n = (n = n + Math.imul(O, rf) | 0) + Math.imul(C, tf) | 0, i = i + Math.imul(C, rf) | 0, r = r + Math.imul(M, af) | 0, n = (n = n + Math.imul(M, of) | 0) + Math.imul(P, af) | 0, i = i + Math.imul(P, of) | 0, r = r + Math.imul(A, uf) | 0, n = (n = n + Math.imul(A, cf) | 0) + Math.imul(x, uf) | 0, i = i + Math.imul(x, cf) | 0, r = r + Math.imul(w, bf) | 0, n = (n = n + Math.imul(w, lf) | 0) + Math.imul(E, bf) | 0, i = i + Math.imul(E, lf) | 0;
          var Tf = (u + (r = r + Math.imul(y, pf) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(y, mf) | 0) + Math.imul(g, pf) | 0)) << 13) | 0;
          u = ((i = i + Math.imul(g, mf) | 0) + (n >>> 13) | 0) + (Tf >>> 26) | 0, Tf &= 67108863, r = Math.imul(D, Z), n = (n = Math.imul(D, Y)) + Math.imul(U, Z) | 0, i = Math.imul(U, Y), r = r + Math.imul(F, Q) | 0, n = (n = n + Math.imul(F, ff) | 0) + Math.imul(B, Q) | 0, i = i + Math.imul(B, ff) | 0, r = r + Math.imul(N, tf) | 0, n = (n = n + Math.imul(N, rf) | 0) + Math.imul(k, tf) | 0, i = i + Math.imul(k, rf) | 0, r = r + Math.imul(O, af) | 0, n = (n = n + Math.imul(O, of) | 0) + Math.imul(C, af) | 0, i = i + Math.imul(C, of) | 0, r = r + Math.imul(M, uf) | 0, n = (n = n + Math.imul(M, cf) | 0) + Math.imul(P, uf) | 0, i = i + Math.imul(P, cf) | 0, r = r + Math.imul(A, bf) | 0, n = (n = n + Math.imul(A, lf) | 0) + Math.imul(x, bf) | 0, i = i + Math.imul(x, lf) | 0;
          var Of = (u + (r = r + Math.imul(w, pf) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(w, mf) | 0) + Math.imul(E, pf) | 0)) << 13) | 0;
          u = ((i = i + Math.imul(E, mf) | 0) + (n >>> 13) | 0) + (Of >>> 26) | 0, Of &= 67108863, r = Math.imul(D, Q), n = (n = Math.imul(D, ff)) + Math.imul(U, Q) | 0, i = Math.imul(U, ff), r = r + Math.imul(F, tf) | 0, n = (n = n + Math.imul(F, rf) | 0) + Math.imul(B, tf) | 0, i = i + Math.imul(B, rf) | 0, r = r + Math.imul(N, af) | 0, n = (n = n + Math.imul(N, of) | 0) + Math.imul(k, af) | 0, i = i + Math.imul(k, of) | 0, r = r + Math.imul(O, uf) | 0, n = (n = n + Math.imul(O, cf) | 0) + Math.imul(C, uf) | 0, i = i + Math.imul(C, cf) | 0, r = r + Math.imul(M, bf) | 0, n = (n = n + Math.imul(M, lf) | 0) + Math.imul(P, bf) | 0, i = i + Math.imul(P, lf) | 0;
          var Cf = (u + (r = r + Math.imul(A, pf) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(A, mf) | 0) + Math.imul(x, pf) | 0)) << 13) | 0;
          u = ((i = i + Math.imul(x, mf) | 0) + (n >>> 13) | 0) + (Cf >>> 26) | 0, Cf &= 67108863, r = Math.imul(D, tf), n = (n = Math.imul(D, rf)) + Math.imul(U, tf) | 0, i = Math.imul(U, rf), r = r + Math.imul(F, af) | 0, n = (n = n + Math.imul(F, of) | 0) + Math.imul(B, af) | 0, i = i + Math.imul(B, of) | 0, r = r + Math.imul(N, uf) | 0, n = (n = n + Math.imul(N, cf) | 0) + Math.imul(k, uf) | 0, i = i + Math.imul(k, cf) | 0, r = r + Math.imul(O, bf) | 0, n = (n = n + Math.imul(O, lf) | 0) + Math.imul(C, bf) | 0, i = i + Math.imul(C, lf) | 0;
          var Rf = (u + (r = r + Math.imul(M, pf) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(M, mf) | 0) + Math.imul(P, pf) | 0)) << 13) | 0;
          u = ((i = i + Math.imul(P, mf) | 0) + (n >>> 13) | 0) + (Rf >>> 26) | 0, Rf &= 67108863, r = Math.imul(D, af), n = (n = Math.imul(D, of)) + Math.imul(U, af) | 0, i = Math.imul(U, of), r = r + Math.imul(F, uf) | 0, n = (n = n + Math.imul(F, cf) | 0) + Math.imul(B, uf) | 0, i = i + Math.imul(B, cf) | 0, r = r + Math.imul(N, bf) | 0, n = (n = n + Math.imul(N, lf) | 0) + Math.imul(k, bf) | 0, i = i + Math.imul(k, lf) | 0;
          var Nf = (u + (r = r + Math.imul(O, pf) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(O, mf) | 0) + Math.imul(C, pf) | 0)) << 13) | 0;
          u = ((i = i + Math.imul(C, mf) | 0) + (n >>> 13) | 0) + (Nf >>> 26) | 0, Nf &= 67108863, r = Math.imul(D, uf), n = (n = Math.imul(D, cf)) + Math.imul(U, uf) | 0, i = Math.imul(U, cf), r = r + Math.imul(F, bf) | 0, n = (n = n + Math.imul(F, lf) | 0) + Math.imul(B, bf) | 0, i = i + Math.imul(B, lf) | 0;
          var kf = (u + (r = r + Math.imul(N, pf) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(N, mf) | 0) + Math.imul(k, pf) | 0)) << 13) | 0;
          u = ((i = i + Math.imul(k, mf) | 0) + (n >>> 13) | 0) + (kf >>> 26) | 0, kf &= 67108863, r = Math.imul(D, bf), n = (n = Math.imul(D, lf)) + Math.imul(U, bf) | 0, i = Math.imul(U, lf);
          var If = (u + (r = r + Math.imul(F, pf) | 0) | 0) + ((8191 & (n = (n = n + Math.imul(F, mf) | 0) + Math.imul(B, pf) | 0)) << 13) | 0;
          u = ((i = i + Math.imul(B, mf) | 0) + (n >>> 13) | 0) + (If >>> 26) | 0, If &= 67108863;
          var Ff = (u + (r = Math.imul(D, pf)) | 0) + ((8191 & (n = (n = Math.imul(D, mf)) + Math.imul(U, pf) | 0)) << 13) | 0;
          return u = ((i = Math.imul(U, mf)) + (n >>> 13) | 0) + (Ff >>> 26) | 0, Ff &= 67108863, s[0] = yf, s[1] = gf, s[2] = vf, s[3] = wf, s[4] = Ef, s[5] = Sf, s[6] = Af, s[7] = xf, s[8] = _f, s[9] = Mf, s[10] = Pf, s[11] = Tf, s[12] = Of, s[13] = Cf, s[14] = Rf, s[15] = Nf, s[16] = kf, s[17] = If, s[18] = Ff, 0 !== u && (s[19] = u, t.length++), t;
        };

        function p(f, e, t) {
          return new m().mulp(f, e, t);
        }

        function m(f, e) {
          this.x = f, this.y = e;
        }

        Math.imul || (h = l), i.prototype.mulTo = function (f, e) {
          var t,
              r = this.length + f.length;
          return t = 10 === this.length && 10 === f.length ? h(this, f, e) : r < 63 ? l(this, f, e) : r < 1024 ? function (f, e, t) {
            t.negative = e.negative ^ f.negative, t.length = f.length + e.length;

            for (var r = 0, n = 0, i = 0; i < t.length - 1; i++) {
              var a = n;
              n = 0;

              for (var o = 67108863 & r, s = Math.min(i, e.length - 1), u = Math.max(0, i - f.length + 1); u <= s; u++) {
                var c = i - u,
                    d = (0 | f.words[c]) * (0 | e.words[u]),
                    b = 67108863 & d;
                o = 67108863 & (b = b + o | 0), n += (a = (a = a + (d / 67108864 | 0) | 0) + (b >>> 26) | 0) >>> 26, a &= 67108863;
              }

              t.words[i] = o, r = a, a = n;
            }

            return 0 !== r ? t.words[i] = r : t.length--, t.strip();
          }(this, f, e) : p(this, f, e), t;
        }, m.prototype.makeRBT = function (f) {
          for (var e = new Array(f), t = i.prototype._countBits(f) - 1, r = 0; r < f; r++) e[r] = this.revBin(r, t, f);

          return e;
        }, m.prototype.revBin = function (f, e, t) {
          if (0 === f || f === t - 1) return f;

          for (var r = 0, n = 0; n < e; n++) r |= (1 & f) << e - n - 1, f >>= 1;

          return r;
        }, m.prototype.permute = function (f, e, t, r, n, i) {
          for (var a = 0; a < i; a++) r[a] = e[f[a]], n[a] = t[f[a]];
        }, m.prototype.transform = function (f, e, t, r, n, i) {
          this.permute(i, f, e, t, r, n);

          for (var a = 1; a < n; a <<= 1) for (var o = a << 1, s = Math.cos(2 * Math.PI / o), u = Math.sin(2 * Math.PI / o), c = 0; c < n; c += o) for (var d = s, b = u, l = 0; l < a; l++) {
            var h = t[c + l],
                p = r[c + l],
                m = t[c + l + a],
                y = r[c + l + a],
                g = d * m - b * y;
            y = d * y + b * m, m = g, t[c + l] = h + m, r[c + l] = p + y, t[c + l + a] = h - m, r[c + l + a] = p - y, l !== o && (g = s * d - u * b, b = s * b + u * d, d = g);
          }
        }, m.prototype.guessLen13b = function (f, e) {
          var t = 1 | Math.max(e, f),
              r = 1 & t,
              n = 0;

          for (t = t / 2 | 0; t; t >>>= 1) n++;

          return 1 << n + 1 + r;
        }, m.prototype.conjugate = function (f, e, t) {
          if (!(t <= 1)) for (var r = 0; r < t / 2; r++) {
            var n = f[r];
            f[r] = f[t - r - 1], f[t - r - 1] = n, n = e[r], e[r] = -e[t - r - 1], e[t - r - 1] = -n;
          }
        }, m.prototype.normalize13b = function (f, e) {
          for (var t = 0, r = 0; r < e / 2; r++) {
            var n = 8192 * Math.round(f[2 * r + 1] / e) + Math.round(f[2 * r] / e) + t;
            f[r] = 67108863 & n, t = n < 67108864 ? 0 : n / 67108864 | 0;
          }

          return f;
        }, m.prototype.convert13b = function (f, e, t, n) {
          for (var i = 0, a = 0; a < e; a++) i += 0 | f[a], t[2 * a] = 8191 & i, i >>>= 13, t[2 * a + 1] = 8191 & i, i >>>= 13;

          for (a = 2 * e; a < n; ++a) t[a] = 0;

          r(0 === i), r(0 == (-8192 & i));
        }, m.prototype.stub = function (f) {
          for (var e = new Array(f), t = 0; t < f; t++) e[t] = 0;

          return e;
        }, m.prototype.mulp = function (f, e, t) {
          var r = 2 * this.guessLen13b(f.length, e.length),
              n = this.makeRBT(r),
              i = this.stub(r),
              a = new Array(r),
              o = new Array(r),
              s = new Array(r),
              u = new Array(r),
              c = new Array(r),
              d = new Array(r),
              b = t.words;
          b.length = r, this.convert13b(f.words, f.length, a, r), this.convert13b(e.words, e.length, u, r), this.transform(a, i, o, s, r, n), this.transform(u, i, c, d, r, n);

          for (var l = 0; l < r; l++) {
            var h = o[l] * c[l] - s[l] * d[l];
            s[l] = o[l] * d[l] + s[l] * c[l], o[l] = h;
          }

          return this.conjugate(o, s, r), this.transform(o, s, b, i, r, n), this.conjugate(b, i, r), this.normalize13b(b, r), t.negative = f.negative ^ e.negative, t.length = f.length + e.length, t.strip();
        }, i.prototype.mul = function (f) {
          var e = new i(null);
          return e.words = new Array(this.length + f.length), this.mulTo(f, e);
        }, i.prototype.mulf = function (f) {
          var e = new i(null);
          return e.words = new Array(this.length + f.length), p(this, f, e);
        }, i.prototype.imul = function (f) {
          return this.clone().mulTo(f, this);
        }, i.prototype.imuln = function (f) {
          r("number" == typeof f), r(f < 67108864);

          for (var e = 0, t = 0; t < this.length; t++) {
            var n = (0 | this.words[t]) * f,
                i = (67108863 & n) + (67108863 & e);
            e >>= 26, e += n / 67108864 | 0, e += i >>> 26, this.words[t] = 67108863 & i;
          }

          return 0 !== e && (this.words[t] = e, this.length++), this;
        }, i.prototype.muln = function (f) {
          return this.clone().imuln(f);
        }, i.prototype.sqr = function () {
          return this.mul(this);
        }, i.prototype.isqr = function () {
          return this.imul(this.clone());
        }, i.prototype.pow = function (f) {
          var e = function (f) {
            for (var e = new Array(f.bitLength()), t = 0; t < e.length; t++) {
              var r = t / 26 | 0,
                  n = t % 26;
              e[t] = (f.words[r] & 1 << n) >>> n;
            }

            return e;
          }(f);

          if (0 === e.length) return new i(1);

          for (var t = this, r = 0; r < e.length && 0 === e[r]; r++, t = t.sqr());

          if (++r < e.length) for (var n = t.sqr(); r < e.length; r++, n = n.sqr()) 0 !== e[r] && (t = t.mul(n));
          return t;
        }, i.prototype.iushln = function (f) {
          r("number" == typeof f && f >= 0);
          var e,
              t = f % 26,
              n = (f - t) / 26,
              i = 67108863 >>> 26 - t << 26 - t;

          if (0 !== t) {
            var a = 0;

            for (e = 0; e < this.length; e++) {
              var o = this.words[e] & i,
                  s = (0 | this.words[e]) - o << t;
              this.words[e] = s | a, a = o >>> 26 - t;
            }

            a && (this.words[e] = a, this.length++);
          }

          if (0 !== n) {
            for (e = this.length - 1; e >= 0; e--) this.words[e + n] = this.words[e];

            for (e = 0; e < n; e++) this.words[e] = 0;

            this.length += n;
          }

          return this.strip();
        }, i.prototype.ishln = function (f) {
          return r(0 === this.negative), this.iushln(f);
        }, i.prototype.iushrn = function (f, e, t) {
          var n;
          r("number" == typeof f && f >= 0), n = e ? (e - e % 26) / 26 : 0;
          var i = f % 26,
              a = Math.min((f - i) / 26, this.length),
              o = 67108863 ^ 67108863 >>> i << i,
              s = t;

          if (n -= a, n = Math.max(0, n), s) {
            for (var u = 0; u < a; u++) s.words[u] = this.words[u];

            s.length = a;
          }

          if (0 === a) ;else if (this.length > a) for (this.length -= a, u = 0; u < this.length; u++) this.words[u] = this.words[u + a];else this.words[0] = 0, this.length = 1;
          var c = 0;

          for (u = this.length - 1; u >= 0 && (0 !== c || u >= n); u--) {
            var d = 0 | this.words[u];
            this.words[u] = c << 26 - i | d >>> i, c = d & o;
          }

          return s && 0 !== c && (s.words[s.length++] = c), 0 === this.length && (this.words[0] = 0, this.length = 1), this.strip();
        }, i.prototype.ishrn = function (f, e, t) {
          return r(0 === this.negative), this.iushrn(f, e, t);
        }, i.prototype.shln = function (f) {
          return this.clone().ishln(f);
        }, i.prototype.ushln = function (f) {
          return this.clone().iushln(f);
        }, i.prototype.shrn = function (f) {
          return this.clone().ishrn(f);
        }, i.prototype.ushrn = function (f) {
          return this.clone().iushrn(f);
        }, i.prototype.testn = function (f) {
          r("number" == typeof f && f >= 0);
          var e = f % 26,
              t = (f - e) / 26,
              n = 1 << e;
          return !(this.length <= t) && !!(this.words[t] & n);
        }, i.prototype.imaskn = function (f) {
          r("number" == typeof f && f >= 0);
          var e = f % 26,
              t = (f - e) / 26;
          if (r(0 === this.negative, "imaskn works only with positive numbers"), this.length <= t) return this;

          if (0 !== e && t++, this.length = Math.min(t, this.length), 0 !== e) {
            var n = 67108863 ^ 67108863 >>> e << e;
            this.words[this.length - 1] &= n;
          }

          return this.strip();
        }, i.prototype.maskn = function (f) {
          return this.clone().imaskn(f);
        }, i.prototype.iaddn = function (f) {
          return r("number" == typeof f), r(f < 67108864), f < 0 ? this.isubn(-f) : 0 !== this.negative ? 1 === this.length && (0 | this.words[0]) < f ? (this.words[0] = f - (0 | this.words[0]), this.negative = 0, this) : (this.negative = 0, this.isubn(f), this.negative = 1, this) : this._iaddn(f);
        }, i.prototype._iaddn = function (f) {
          this.words[0] += f;

          for (var e = 0; e < this.length && this.words[e] >= 67108864; e++) this.words[e] -= 67108864, e === this.length - 1 ? this.words[e + 1] = 1 : this.words[e + 1]++;

          return this.length = Math.max(this.length, e + 1), this;
        }, i.prototype.isubn = function (f) {
          if (r("number" == typeof f), r(f < 67108864), f < 0) return this.iaddn(-f);
          if (0 !== this.negative) return this.negative = 0, this.iaddn(f), this.negative = 1, this;
          if (this.words[0] -= f, 1 === this.length && this.words[0] < 0) this.words[0] = -this.words[0], this.negative = 1;else for (var e = 0; e < this.length && this.words[e] < 0; e++) this.words[e] += 67108864, this.words[e + 1] -= 1;
          return this.strip();
        }, i.prototype.addn = function (f) {
          return this.clone().iaddn(f);
        }, i.prototype.subn = function (f) {
          return this.clone().isubn(f);
        }, i.prototype.iabs = function () {
          return this.negative = 0, this;
        }, i.prototype.abs = function () {
          return this.clone().iabs();
        }, i.prototype._ishlnsubmul = function (f, e, t) {
          var n,
              i,
              a = f.length + t;

          this._expand(a);

          var o = 0;

          for (n = 0; n < f.length; n++) {
            i = (0 | this.words[n + t]) + o;
            var s = (0 | f.words[n]) * e;
            o = ((i -= 67108863 & s) >> 26) - (s / 67108864 | 0), this.words[n + t] = 67108863 & i;
          }

          for (; n < this.length - t; n++) o = (i = (0 | this.words[n + t]) + o) >> 26, this.words[n + t] = 67108863 & i;

          if (0 === o) return this.strip();

          for (r(-1 === o), o = 0, n = 0; n < this.length; n++) o = (i = -(0 | this.words[n]) + o) >> 26, this.words[n] = 67108863 & i;

          return this.negative = 1, this.strip();
        }, i.prototype._wordDiv = function (f, e) {
          var t = (this.length, f.length),
              r = this.clone(),
              n = f,
              a = 0 | n.words[n.length - 1];
          0 !== (t = 26 - this._countBits(a)) && (n = n.ushln(t), r.iushln(t), a = 0 | n.words[n.length - 1]);
          var o,
              s = r.length - n.length;

          if ("mod" !== e) {
            (o = new i(null)).length = s + 1, o.words = new Array(o.length);

            for (var u = 0; u < o.length; u++) o.words[u] = 0;
          }

          var c = r.clone()._ishlnsubmul(n, 1, s);

          0 === c.negative && (r = c, o && (o.words[s] = 1));

          for (var d = s - 1; d >= 0; d--) {
            var b = 67108864 * (0 | r.words[n.length + d]) + (0 | r.words[n.length + d - 1]);

            for (b = Math.min(b / a | 0, 67108863), r._ishlnsubmul(n, b, d); 0 !== r.negative;) b--, r.negative = 0, r._ishlnsubmul(n, 1, d), r.isZero() || (r.negative ^= 1);

            o && (o.words[d] = b);
          }

          return o && o.strip(), r.strip(), "div" !== e && 0 !== t && r.iushrn(t), {
            div: o || null,
            mod: r
          };
        }, i.prototype.divmod = function (f, e, t) {
          return r(!f.isZero()), this.isZero() ? {
            div: new i(0),
            mod: new i(0)
          } : 0 !== this.negative && 0 === f.negative ? (o = this.neg().divmod(f, e), "mod" !== e && (n = o.div.neg()), "div" !== e && (a = o.mod.neg(), t && 0 !== a.negative && a.iadd(f)), {
            div: n,
            mod: a
          }) : 0 === this.negative && 0 !== f.negative ? (o = this.divmod(f.neg(), e), "mod" !== e && (n = o.div.neg()), {
            div: n,
            mod: o.mod
          }) : 0 != (this.negative & f.negative) ? (o = this.neg().divmod(f.neg(), e), "div" !== e && (a = o.mod.neg(), t && 0 !== a.negative && a.isub(f)), {
            div: o.div,
            mod: a
          }) : f.length > this.length || this.cmp(f) < 0 ? {
            div: new i(0),
            mod: this
          } : 1 === f.length ? "div" === e ? {
            div: this.divn(f.words[0]),
            mod: null
          } : "mod" === e ? {
            div: null,
            mod: new i(this.modn(f.words[0]))
          } : {
            div: this.divn(f.words[0]),
            mod: new i(this.modn(f.words[0]))
          } : this._wordDiv(f, e);
          var n, a, o;
        }, i.prototype.div = function (f) {
          return this.divmod(f, "div", !1).div;
        }, i.prototype.mod = function (f) {
          return this.divmod(f, "mod", !1).mod;
        }, i.prototype.umod = function (f) {
          return this.divmod(f, "mod", !0).mod;
        }, i.prototype.divRound = function (f) {
          var e = this.divmod(f);
          if (e.mod.isZero()) return e.div;
          var t = 0 !== e.div.negative ? e.mod.isub(f) : e.mod,
              r = f.ushrn(1),
              n = f.andln(1),
              i = t.cmp(r);
          return i < 0 || 1 === n && 0 === i ? e.div : 0 !== e.div.negative ? e.div.isubn(1) : e.div.iaddn(1);
        }, i.prototype.modn = function (f) {
          r(f <= 67108863);

          for (var e = (1 << 26) % f, t = 0, n = this.length - 1; n >= 0; n--) t = (e * t + (0 | this.words[n])) % f;

          return t;
        }, i.prototype.idivn = function (f) {
          r(f <= 67108863);

          for (var e = 0, t = this.length - 1; t >= 0; t--) {
            var n = (0 | this.words[t]) + 67108864 * e;
            this.words[t] = n / f | 0, e = n % f;
          }

          return this.strip();
        }, i.prototype.divn = function (f) {
          return this.clone().idivn(f);
        }, i.prototype.egcd = function (f) {
          r(0 === f.negative), r(!f.isZero());
          var e = this,
              t = f.clone();
          e = 0 !== e.negative ? e.umod(f) : e.clone();

          for (var n = new i(1), a = new i(0), o = new i(0), s = new i(1), u = 0; e.isEven() && t.isEven();) e.iushrn(1), t.iushrn(1), ++u;

          for (var c = t.clone(), d = e.clone(); !e.isZero();) {
            for (var b = 0, l = 1; 0 == (e.words[0] & l) && b < 26; ++b, l <<= 1);

            if (b > 0) for (e.iushrn(b); b-- > 0;) (n.isOdd() || a.isOdd()) && (n.iadd(c), a.isub(d)), n.iushrn(1), a.iushrn(1);

            for (var h = 0, p = 1; 0 == (t.words[0] & p) && h < 26; ++h, p <<= 1);

            if (h > 0) for (t.iushrn(h); h-- > 0;) (o.isOdd() || s.isOdd()) && (o.iadd(c), s.isub(d)), o.iushrn(1), s.iushrn(1);
            e.cmp(t) >= 0 ? (e.isub(t), n.isub(o), a.isub(s)) : (t.isub(e), o.isub(n), s.isub(a));
          }

          return {
            a: o,
            b: s,
            gcd: t.iushln(u)
          };
        }, i.prototype._invmp = function (f) {
          r(0 === f.negative), r(!f.isZero());
          var e = this,
              t = f.clone();
          e = 0 !== e.negative ? e.umod(f) : e.clone();

          for (var n, a = new i(1), o = new i(0), s = t.clone(); e.cmpn(1) > 0 && t.cmpn(1) > 0;) {
            for (var u = 0, c = 1; 0 == (e.words[0] & c) && u < 26; ++u, c <<= 1);

            if (u > 0) for (e.iushrn(u); u-- > 0;) a.isOdd() && a.iadd(s), a.iushrn(1);

            for (var d = 0, b = 1; 0 == (t.words[0] & b) && d < 26; ++d, b <<= 1);

            if (d > 0) for (t.iushrn(d); d-- > 0;) o.isOdd() && o.iadd(s), o.iushrn(1);
            e.cmp(t) >= 0 ? (e.isub(t), a.isub(o)) : (t.isub(e), o.isub(a));
          }

          return (n = 0 === e.cmpn(1) ? a : o).cmpn(0) < 0 && n.iadd(f), n;
        }, i.prototype.gcd = function (f) {
          if (this.isZero()) return f.abs();
          if (f.isZero()) return this.abs();
          var e = this.clone(),
              t = f.clone();
          e.negative = 0, t.negative = 0;

          for (var r = 0; e.isEven() && t.isEven(); r++) e.iushrn(1), t.iushrn(1);

          for (;;) {
            for (; e.isEven();) e.iushrn(1);

            for (; t.isEven();) t.iushrn(1);

            var n = e.cmp(t);

            if (n < 0) {
              var i = e;
              e = t, t = i;
            } else if (0 === n || 0 === t.cmpn(1)) break;

            e.isub(t);
          }

          return t.iushln(r);
        }, i.prototype.invm = function (f) {
          return this.egcd(f).a.umod(f);
        }, i.prototype.isEven = function () {
          return 0 == (1 & this.words[0]);
        }, i.prototype.isOdd = function () {
          return 1 == (1 & this.words[0]);
        }, i.prototype.andln = function (f) {
          return this.words[0] & f;
        }, i.prototype.bincn = function (f) {
          r("number" == typeof f);
          var e = f % 26,
              t = (f - e) / 26,
              n = 1 << e;
          if (this.length <= t) return this._expand(t + 1), this.words[t] |= n, this;

          for (var i = n, a = t; 0 !== i && a < this.length; a++) {
            var o = 0 | this.words[a];
            i = (o += i) >>> 26, o &= 67108863, this.words[a] = o;
          }

          return 0 !== i && (this.words[a] = i, this.length++), this;
        }, i.prototype.isZero = function () {
          return 1 === this.length && 0 === this.words[0];
        }, i.prototype.cmpn = function (f) {
          var e,
              t = f < 0;
          if (0 !== this.negative && !t) return -1;
          if (0 === this.negative && t) return 1;
          if (this.strip(), this.length > 1) e = 1;else {
            t && (f = -f), r(f <= 67108863, "Number is too big");
            var n = 0 | this.words[0];
            e = n === f ? 0 : n < f ? -1 : 1;
          }
          return 0 !== this.negative ? 0 | -e : e;
        }, i.prototype.cmp = function (f) {
          if (0 !== this.negative && 0 === f.negative) return -1;
          if (0 === this.negative && 0 !== f.negative) return 1;
          var e = this.ucmp(f);
          return 0 !== this.negative ? 0 | -e : e;
        }, i.prototype.ucmp = function (f) {
          if (this.length > f.length) return 1;
          if (this.length < f.length) return -1;

          for (var e = 0, t = this.length - 1; t >= 0; t--) {
            var r = 0 | this.words[t],
                n = 0 | f.words[t];

            if (r !== n) {
              r < n ? e = -1 : r > n && (e = 1);
              break;
            }
          }

          return e;
        }, i.prototype.gtn = function (f) {
          return 1 === this.cmpn(f);
        }, i.prototype.gt = function (f) {
          return 1 === this.cmp(f);
        }, i.prototype.gten = function (f) {
          return this.cmpn(f) >= 0;
        }, i.prototype.gte = function (f) {
          return this.cmp(f) >= 0;
        }, i.prototype.ltn = function (f) {
          return -1 === this.cmpn(f);
        }, i.prototype.lt = function (f) {
          return -1 === this.cmp(f);
        }, i.prototype.lten = function (f) {
          return this.cmpn(f) <= 0;
        }, i.prototype.lte = function (f) {
          return this.cmp(f) <= 0;
        }, i.prototype.eqn = function (f) {
          return 0 === this.cmpn(f);
        }, i.prototype.eq = function (f) {
          return 0 === this.cmp(f);
        }, i.red = function (f) {
          return new A(f);
        }, i.prototype.toRed = function (f) {
          return r(!this.red, "Already a number in reduction context"), r(0 === this.negative, "red works only with positives"), f.convertTo(this)._forceRed(f);
        }, i.prototype.fromRed = function () {
          return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
        }, i.prototype._forceRed = function (f) {
          return this.red = f, this;
        }, i.prototype.forceRed = function (f) {
          return r(!this.red, "Already a number in reduction context"), this._forceRed(f);
        }, i.prototype.redAdd = function (f) {
          return r(this.red, "redAdd works only with red numbers"), this.red.add(this, f);
        }, i.prototype.redIAdd = function (f) {
          return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f);
        }, i.prototype.redSub = function (f) {
          return r(this.red, "redSub works only with red numbers"), this.red.sub(this, f);
        }, i.prototype.redISub = function (f) {
          return r(this.red, "redISub works only with red numbers"), this.red.isub(this, f);
        }, i.prototype.redShl = function (f) {
          return r(this.red, "redShl works only with red numbers"), this.red.shl(this, f);
        }, i.prototype.redMul = function (f) {
          return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.mul(this, f);
        }, i.prototype.redIMul = function (f) {
          return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.imul(this, f);
        }, i.prototype.redSqr = function () {
          return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
        }, i.prototype.redISqr = function () {
          return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
        }, i.prototype.redSqrt = function () {
          return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
        }, i.prototype.redInvm = function () {
          return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
        }, i.prototype.redNeg = function () {
          return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
        }, i.prototype.redPow = function (f) {
          return r(this.red && !f.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f);
        };
        var y = {
          k256: null,
          p224: null,
          p192: null,
          p25519: null
        };

        function g(f, e) {
          this.name = f, this.p = new i(e, 16), this.n = this.p.bitLength(), this.k = new i(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
        }

        function v() {
          g.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
        }

        function w() {
          g.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
        }

        function E() {
          g.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
        }

        function S() {
          g.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
        }

        function A(f) {
          if ("string" == typeof f) {
            var e = i._prime(f);

            this.m = e.p, this.prime = e;
          } else r(f.gtn(1), "modulus must be greater than 1"), this.m = f, this.prime = null;
        }

        function x(f) {
          A.call(this, f), this.shift = this.m.bitLength(), this.shift % 26 != 0 && (this.shift += 26 - this.shift % 26), this.r = new i(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
        }

        g.prototype._tmp = function () {
          var f = new i(null);
          return f.words = new Array(Math.ceil(this.n / 13)), f;
        }, g.prototype.ireduce = function (f) {
          var e,
              t = f;

          do {
            this.split(t, this.tmp), e = (t = (t = this.imulK(t)).iadd(this.tmp)).bitLength();
          } while (e > this.n);

          var r = e < this.n ? -1 : t.ucmp(this.p);
          return 0 === r ? (t.words[0] = 0, t.length = 1) : r > 0 ? t.isub(this.p) : void 0 !== t.strip ? t.strip() : t._strip(), t;
        }, g.prototype.split = function (f, e) {
          f.iushrn(this.n, 0, e);
        }, g.prototype.imulK = function (f) {
          return f.imul(this.k);
        }, n(v, g), v.prototype.split = function (f, e) {
          for (var t = 4194303, r = Math.min(f.length, 9), n = 0; n < r; n++) e.words[n] = f.words[n];

          if (e.length = r, f.length <= 9) return f.words[0] = 0, void (f.length = 1);
          var i = f.words[9];

          for (e.words[e.length++] = i & t, n = 10; n < f.length; n++) {
            var a = 0 | f.words[n];
            f.words[n - 10] = (a & t) << 4 | i >>> 22, i = a;
          }

          i >>>= 22, f.words[n - 10] = i, 0 === i && f.length > 10 ? f.length -= 10 : f.length -= 9;
        }, v.prototype.imulK = function (f) {
          f.words[f.length] = 0, f.words[f.length + 1] = 0, f.length += 2;

          for (var e = 0, t = 0; t < f.length; t++) {
            var r = 0 | f.words[t];
            e += 977 * r, f.words[t] = 67108863 & e, e = 64 * r + (e / 67108864 | 0);
          }

          return 0 === f.words[f.length - 1] && (f.length--, 0 === f.words[f.length - 1] && f.length--), f;
        }, n(w, g), n(E, g), n(S, g), S.prototype.imulK = function (f) {
          for (var e = 0, t = 0; t < f.length; t++) {
            var r = 19 * (0 | f.words[t]) + e,
                n = 67108863 & r;
            r >>>= 26, f.words[t] = n, e = r;
          }

          return 0 !== e && (f.words[f.length++] = e), f;
        }, i._prime = function (f) {
          if (y[f]) return y[f];
          var e;
          if ("k256" === f) e = new v();else if ("p224" === f) e = new w();else if ("p192" === f) e = new E();else {
            if ("p25519" !== f) throw new Error("Unknown prime " + f);
            e = new S();
          }
          return y[f] = e, e;
        }, A.prototype._verify1 = function (f) {
          r(0 === f.negative, "red works only with positives"), r(f.red, "red works only with red numbers");
        }, A.prototype._verify2 = function (f, e) {
          r(0 == (f.negative | e.negative), "red works only with positives"), r(f.red && f.red === e.red, "red works only with red numbers");
        }, A.prototype.imod = function (f) {
          return this.prime ? this.prime.ireduce(f)._forceRed(this) : f.umod(this.m)._forceRed(this);
        }, A.prototype.neg = function (f) {
          return f.isZero() ? f.clone() : this.m.sub(f)._forceRed(this);
        }, A.prototype.add = function (f, e) {
          this._verify2(f, e);

          var t = f.add(e);
          return t.cmp(this.m) >= 0 && t.isub(this.m), t._forceRed(this);
        }, A.prototype.iadd = function (f, e) {
          this._verify2(f, e);

          var t = f.iadd(e);
          return t.cmp(this.m) >= 0 && t.isub(this.m), t;
        }, A.prototype.sub = function (f, e) {
          this._verify2(f, e);

          var t = f.sub(e);
          return t.cmpn(0) < 0 && t.iadd(this.m), t._forceRed(this);
        }, A.prototype.isub = function (f, e) {
          this._verify2(f, e);

          var t = f.isub(e);
          return t.cmpn(0) < 0 && t.iadd(this.m), t;
        }, A.prototype.shl = function (f, e) {
          return this._verify1(f), this.imod(f.ushln(e));
        }, A.prototype.imul = function (f, e) {
          return this._verify2(f, e), this.imod(f.imul(e));
        }, A.prototype.mul = function (f, e) {
          return this._verify2(f, e), this.imod(f.mul(e));
        }, A.prototype.isqr = function (f) {
          return this.imul(f, f.clone());
        }, A.prototype.sqr = function (f) {
          return this.mul(f, f);
        }, A.prototype.sqrt = function (f) {
          if (f.isZero()) return f.clone();
          var e = this.m.andln(3);

          if (r(e % 2 == 1), 3 === e) {
            var t = this.m.add(new i(1)).iushrn(2);
            return this.pow(f, t);
          }

          for (var n = this.m.subn(1), a = 0; !n.isZero() && 0 === n.andln(1);) a++, n.iushrn(1);

          r(!n.isZero());
          var o = new i(1).toRed(this),
              s = o.redNeg(),
              u = this.m.subn(1).iushrn(1),
              c = this.m.bitLength();

          for (c = new i(2 * c * c).toRed(this); 0 !== this.pow(c, u).cmp(s);) c.redIAdd(s);

          for (var d = this.pow(c, n), b = this.pow(f, n.addn(1).iushrn(1)), l = this.pow(f, n), h = a; 0 !== l.cmp(o);) {
            for (var p = l, m = 0; 0 !== p.cmp(o); m++) p = p.redSqr();

            r(m < h);
            var y = this.pow(d, new i(1).iushln(h - m - 1));
            b = b.redMul(y), d = y.redSqr(), l = l.redMul(d), h = m;
          }

          return b;
        }, A.prototype.invm = function (f) {
          var e = f._invmp(this.m);

          return 0 !== e.negative ? (e.negative = 0, this.imod(e).redNeg()) : this.imod(e);
        }, A.prototype.pow = function (f, e) {
          if (e.isZero()) return new i(1).toRed(this);
          if (0 === e.cmpn(1)) return f.clone();
          var t = new Array(16);
          t[0] = new i(1).toRed(this), t[1] = f;

          for (var r = 2; r < t.length; r++) t[r] = this.mul(t[r - 1], f);

          var n = t[0],
              a = 0,
              o = 0,
              s = e.bitLength() % 26;

          for (0 === s && (s = 26), r = e.length - 1; r >= 0; r--) {
            for (var u = e.words[r], c = s - 1; c >= 0; c--) {
              var d = u >> c & 1;
              n !== t[0] && (n = this.sqr(n)), 0 !== d || 0 !== a ? (a <<= 1, a |= d, (4 === ++o || 0 === r && 0 === c) && (n = this.mul(n, t[a]), o = 0, a = 0)) : o = 0;
            }

            s = 26;
          }

          return n;
        }, A.prototype.convertTo = function (f) {
          var e = f.umod(this.m);
          return e === f ? e.clone() : e;
        }, A.prototype.convertFrom = function (f) {
          var e = f.clone();
          return e.red = null, e;
        }, i.mont = function (f) {
          return new x(f);
        }, n(x, A), x.prototype.convertTo = function (f) {
          return this.imod(f.ushln(this.shift));
        }, x.prototype.convertFrom = function (f) {
          var e = this.imod(f.mul(this.rinv));
          return e.red = null, e;
        }, x.prototype.imul = function (f, e) {
          if (f.isZero() || e.isZero()) return f.words[0] = 0, f.length = 1, f;
          var t = f.imul(e),
              r = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
              n = t.isub(r).iushrn(this.shift),
              i = n;
          return n.cmp(this.m) >= 0 ? i = n.isub(this.m) : n.cmpn(0) < 0 && (i = n.iadd(this.m)), i._forceRed(this);
        }, x.prototype.mul = function (f, e) {
          if (f.isZero() || e.isZero()) return new i(0)._forceRed(this);
          var t = f.mul(e),
              r = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m),
              n = t.isub(r).iushrn(this.shift),
              a = n;
          return n.cmp(this.m) >= 0 ? a = n.isub(this.m) : n.cmpn(0) < 0 && (a = n.iadd(this.m)), a._forceRed(this);
        }, x.prototype.invm = function (f) {
          return this.imod(f._invmp(this.m).mul(this.r2))._forceRed(this);
        };
      }(f = t.nmd(f), this);
    },
    6371: function (f, e, t) {
      "use strict";

      var r = this && this.__createBinding || (Object.create ? function (f, e, t, r) {
        void 0 === r && (r = t), Object.defineProperty(f, r, {
          enumerable: !0,
          get: function () {
            return e[t];
          }
        });
      } : function (f, e, t, r) {
        void 0 === r && (r = t), f[r] = e[t];
      }),
          n = this && this.__setModuleDefault || (Object.create ? function (f, e) {
        Object.defineProperty(f, "default", {
          enumerable: !0,
          value: e
        });
      } : function (f, e) {
        f.default = e;
      }),
          i = this && this.__importStar || function (f) {
        if (f && f.__esModule) return f;
        var e = {};
        if (null != f) for (var t in f) "default" !== t && Object.prototype.hasOwnProperty.call(f, t) && r(e, f, t);
        return n(e, f), e;
      };

      Object.defineProperty(e, "__esModule", {
        value: !0
      }), e.formatBytes32String = e.Utf8ErrorFuncs = e.toUtf8String = e.toUtf8CodePoints = e.toUtf8Bytes = e._toEscapedUtf8String = e.nameprep = e.hexDataSlice = e.hexDataLength = e.hexZeroPad = e.hexValue = e.hexStripZeros = e.hexConcat = e.isHexString = e.hexlify = e.base64 = e.base58 = e.TransactionDescription = e.LogDescription = e.Interface = e.SigningKey = e.HDNode = e.defaultPath = e.isBytesLike = e.isBytes = e.zeroPad = e.stripZeros = e.concat = e.arrayify = e.shallowCopy = e.resolveProperties = e.getStatic = e.defineReadOnly = e.deepCopy = e.checkProperties = e.poll = e.fetchJson = e._fetchData = e.RLP = e.Logger = e.checkResultErrors = e.FormatTypes = e.ParamType = e.FunctionFragment = e.EventFragment = e.ErrorFragment = e.ConstructorFragment = e.Fragment = e.defaultAbiCoder = e.AbiCoder = void 0, e.Indexed = e.Utf8ErrorReason = e.UnicodeNormalizationForm = e.SupportedAlgorithm = e.mnemonicToSeed = e.isValidMnemonic = e.entropyToMnemonic = e.mnemonicToEntropy = e.getAccountPath = e.verifyTypedData = e.verifyMessage = e.recoverPublicKey = e.computePublicKey = e.recoverAddress = e.computeAddress = e.getJsonWalletAddress = e.TransactionTypes = e.serializeTransaction = e.parseTransaction = e.accessListify = e.joinSignature = e.splitSignature = e.soliditySha256 = e.solidityKeccak256 = e.solidityPack = e.shuffled = e.randomBytes = e.sha512 = e.sha256 = e.ripemd160 = e.keccak256 = e.computeHmac = e.commify = e.parseUnits = e.formatUnits = e.parseEther = e.formatEther = e.isAddress = e.getCreate2Address = e.getContractAddress = e.getIcapAddress = e.getAddress = e._TypedDataEncoder = e.id = e.isValidName = e.namehash = e.hashMessage = e.dnsEncode = e.parseBytes32String = void 0;
      var a = t(3900);
      Object.defineProperty(e, "AbiCoder", {
        enumerable: !0,
        get: function () {
          return a.AbiCoder;
        }
      }), Object.defineProperty(e, "checkResultErrors", {
        enumerable: !0,
        get: function () {
          return a.checkResultErrors;
        }
      }), Object.defineProperty(e, "ConstructorFragment", {
        enumerable: !0,
        get: function () {
          return a.ConstructorFragment;
        }
      }), Object.defineProperty(e, "defaultAbiCoder", {
        enumerable: !0,
        get: function () {
          return a.defaultAbiCoder;
        }
      }), Object.defineProperty(e, "ErrorFragment", {
        enumerable: !0,
        get: function () {
          return a.ErrorFragment;
        }
      }), Object.defineProperty(e, "EventFragment", {
        enumerable: !0,
        get: function () {
          return a.EventFragment;
        }
      }), Object.defineProperty(e, "FormatTypes", {
        enumerable: !0,
        get: function () {
          return a.FormatTypes;
        }
      }), Object.defineProperty(e, "Fragment", {
        enumerable: !0,
        get: function () {
          return a.Fragment;
        }
      }), Object.defineProperty(e, "FunctionFragment", {
        enumerable: !0,
        get: function () {
          return a.FunctionFragment;
        }
      }), Object.defineProperty(e, "Indexed", {
        enumerable: !0,
        get: function () {
          return a.Indexed;
        }
      }), Object.defineProperty(e, "Interface", {
        enumerable: !0,
        get: function () {
          return a.Interface;
        }
      }), Object.defineProperty(e, "LogDescription", {
        enumerable: !0,
        get: function () {
          return a.LogDescription;
        }
      }), Object.defineProperty(e, "ParamType", {
        enumerable: !0,
        get: function () {
          return a.ParamType;
        }
      }), Object.defineProperty(e, "TransactionDescription", {
        enumerable: !0,
        get: function () {
          return a.TransactionDescription;
        }
      });
      var o = t(4594);
      Object.defineProperty(e, "getAddress", {
        enumerable: !0,
        get: function () {
          return o.getAddress;
        }
      }), Object.defineProperty(e, "getCreate2Address", {
        enumerable: !0,
        get: function () {
          return o.getCreate2Address;
        }
      }), Object.defineProperty(e, "getContractAddress", {
        enumerable: !0,
        get: function () {
          return o.getContractAddress;
        }
      }), Object.defineProperty(e, "getIcapAddress", {
        enumerable: !0,
        get: function () {
          return o.getIcapAddress;
        }
      }), Object.defineProperty(e, "isAddress", {
        enumerable: !0,
        get: function () {
          return o.isAddress;
        }
      });
      var s = i(t(4089));
      e.base64 = s;
      var u = t(7727);
      Object.defineProperty(e, "base58", {
        enumerable: !0,
        get: function () {
          return u.Base58;
        }
      });
      var c = t(3286);
      Object.defineProperty(e, "arrayify", {
        enumerable: !0,
        get: function () {
          return c.arrayify;
        }
      }), Object.defineProperty(e, "concat", {
        enumerable: !0,
        get: function () {
          return c.concat;
        }
      }), Object.defineProperty(e, "hexConcat", {
        enumerable: !0,
        get: function () {
          return c.hexConcat;
        }
      }), Object.defineProperty(e, "hexDataSlice", {
        enumerable: !0,
        get: function () {
          return c.hexDataSlice;
        }
      }), Object.defineProperty(e, "hexDataLength", {
        enumerable: !0,
        get: function () {
          return c.hexDataLength;
        }
      }), Object.defineProperty(e, "hexlify", {
        enumerable: !0,
        get: function () {
          return c.hexlify;
        }
      }), Object.defineProperty(e, "hexStripZeros", {
        enumerable: !0,
        get: function () {
          return c.hexStripZeros;
        }
      }), Object.defineProperty(e, "hexValue", {
        enumerable: !0,
        get: function () {
          return c.hexValue;
        }
      }), Object.defineProperty(e, "hexZeroPad", {
        enumerable: !0,
        get: function () {
          return c.hexZeroPad;
        }
      }), Object.defineProperty(e, "isBytes", {
        enumerable: !0,
        get: function () {
          return c.isBytes;
        }
      }), Object.defineProperty(e, "isBytesLike", {
        enumerable: !0,
        get: function () {
          return c.isBytesLike;
        }
      }), Object.defineProperty(e, "isHexString", {
        enumerable: !0,
        get: function () {
          return c.isHexString;
        }
      }), Object.defineProperty(e, "joinSignature", {
        enumerable: !0,
        get: function () {
          return c.joinSignature;
        }
      }), Object.defineProperty(e, "zeroPad", {
        enumerable: !0,
        get: function () {
          return c.zeroPad;
        }
      }), Object.defineProperty(e, "splitSignature", {
        enumerable: !0,
        get: function () {
          return c.splitSignature;
        }
      }), Object.defineProperty(e, "stripZeros", {
        enumerable: !0,
        get: function () {
          return c.stripZeros;
        }
      });
      var d = t(4225);
      Object.defineProperty(e, "_TypedDataEncoder", {
        enumerable: !0,
        get: function () {
          return d._TypedDataEncoder;
        }
      }), Object.defineProperty(e, "dnsEncode", {
        enumerable: !0,
        get: function () {
          return d.dnsEncode;
        }
      }), Object.defineProperty(e, "hashMessage", {
        enumerable: !0,
        get: function () {
          return d.hashMessage;
        }
      }), Object.defineProperty(e, "id", {
        enumerable: !0,
        get: function () {
          return d.id;
        }
      }), Object.defineProperty(e, "isValidName", {
        enumerable: !0,
        get: function () {
          return d.isValidName;
        }
      }), Object.defineProperty(e, "namehash", {
        enumerable: !0,
        get: function () {
          return d.namehash;
        }
      });
      var b = t(4692);
      Object.defineProperty(e, "defaultPath", {
        enumerable: !0,
        get: function () {
          return b.defaultPath;
        }
      }), Object.defineProperty(e, "entropyToMnemonic", {
        enumerable: !0,
        get: function () {
          return b.entropyToMnemonic;
        }
      }), Object.defineProperty(e, "getAccountPath", {
        enumerable: !0,
        get: function () {
          return b.getAccountPath;
        }
      }), Object.defineProperty(e, "HDNode", {
        enumerable: !0,
        get: function () {
          return b.HDNode;
        }
      }), Object.defineProperty(e, "isValidMnemonic", {
        enumerable: !0,
        get: function () {
          return b.isValidMnemonic;
        }
      }), Object.defineProperty(e, "mnemonicToEntropy", {
        enumerable: !0,
        get: function () {
          return b.mnemonicToEntropy;
        }
      }), Object.defineProperty(e, "mnemonicToSeed", {
        enumerable: !0,
        get: function () {
          return b.mnemonicToSeed;
        }
      });
      var l = t(6883);
      Object.defineProperty(e, "getJsonWalletAddress", {
        enumerable: !0,
        get: function () {
          return l.getJsonWalletAddress;
        }
      });
      var h = t(8197);
      Object.defineProperty(e, "keccak256", {
        enumerable: !0,
        get: function () {
          return h.keccak256;
        }
      });
      var p = t(711);
      Object.defineProperty(e, "Logger", {
        enumerable: !0,
        get: function () {
          return p.Logger;
        }
      });
      var m = t(1278);
      Object.defineProperty(e, "computeHmac", {
        enumerable: !0,
        get: function () {
          return m.computeHmac;
        }
      }), Object.defineProperty(e, "ripemd160", {
        enumerable: !0,
        get: function () {
          return m.ripemd160;
        }
      }), Object.defineProperty(e, "sha256", {
        enumerable: !0,
        get: function () {
          return m.sha256;
        }
      }), Object.defineProperty(e, "sha512", {
        enumerable: !0,
        get: function () {
          return m.sha512;
        }
      });
      var y = t(3777);
      Object.defineProperty(e, "solidityKeccak256", {
        enumerable: !0,
        get: function () {
          return y.keccak256;
        }
      }), Object.defineProperty(e, "solidityPack", {
        enumerable: !0,
        get: function () {
          return y.pack;
        }
      }), Object.defineProperty(e, "soliditySha256", {
        enumerable: !0,
        get: function () {
          return y.sha256;
        }
      });
      var g = t(7986);
      Object.defineProperty(e, "randomBytes", {
        enumerable: !0,
        get: function () {
          return g.randomBytes;
        }
      }), Object.defineProperty(e, "shuffled", {
        enumerable: !0,
        get: function () {
          return g.shuffled;
        }
      });
      var v = t(3587);
      Object.defineProperty(e, "checkProperties", {
        enumerable: !0,
        get: function () {
          return v.checkProperties;
        }
      }), Object.defineProperty(e, "deepCopy", {
        enumerable: !0,
        get: function () {
          return v.deepCopy;
        }
      }), Object.defineProperty(e, "defineReadOnly", {
        enumerable: !0,
        get: function () {
          return v.defineReadOnly;
        }
      }), Object.defineProperty(e, "getStatic", {
        enumerable: !0,
        get: function () {
          return v.getStatic;
        }
      }), Object.defineProperty(e, "resolveProperties", {
        enumerable: !0,
        get: function () {
          return v.resolveProperties;
        }
      }), Object.defineProperty(e, "shallowCopy", {
        enumerable: !0,
        get: function () {
          return v.shallowCopy;
        }
      });
      var w = i(t(1843));
      e.RLP = w;
      var E = t(2768);
      Object.defineProperty(e, "computePublicKey", {
        enumerable: !0,
        get: function () {
          return E.computePublicKey;
        }
      }), Object.defineProperty(e, "recoverPublicKey", {
        enumerable: !0,
        get: function () {
          return E.recoverPublicKey;
        }
      }), Object.defineProperty(e, "SigningKey", {
        enumerable: !0,
        get: function () {
          return E.SigningKey;
        }
      });
      var S = t(4044);
      Object.defineProperty(e, "formatBytes32String", {
        enumerable: !0,
        get: function () {
          return S.formatBytes32String;
        }
      }), Object.defineProperty(e, "nameprep", {
        enumerable: !0,
        get: function () {
          return S.nameprep;
        }
      }), Object.defineProperty(e, "parseBytes32String", {
        enumerable: !0,
        get: function () {
          return S.parseBytes32String;
        }
      }), Object.defineProperty(e, "_toEscapedUtf8String", {
        enumerable: !0,
        get: function () {
          return S._toEscapedUtf8String;
        }
      }), Object.defineProperty(e, "toUtf8Bytes", {
        enumerable: !0,
        get: function () {
          return S.toUtf8Bytes;
        }
      }), Object.defineProperty(e, "toUtf8CodePoints", {
        enumerable: !0,
        get: function () {
          return S.toUtf8CodePoints;
        }
      }), Object.defineProperty(e, "toUtf8String", {
        enumerable: !0,
        get: function () {
          return S.toUtf8String;
        }
      }), Object.defineProperty(e, "Utf8ErrorFuncs", {
        enumerable: !0,
        get: function () {
          return S.Utf8ErrorFuncs;
        }
      });
      var A = t(4377);
      Object.defineProperty(e, "accessListify", {
        enumerable: !0,
        get: function () {
          return A.accessListify;
        }
      }), Object.defineProperty(e, "computeAddress", {
        enumerable: !0,
        get: function () {
          return A.computeAddress;
        }
      }), Object.defineProperty(e, "parseTransaction", {
        enumerable: !0,
        get: function () {
          return A.parse;
        }
      }), Object.defineProperty(e, "recoverAddress", {
        enumerable: !0,
        get: function () {
          return A.recoverAddress;
        }
      }), Object.defineProperty(e, "serializeTransaction", {
        enumerable: !0,
        get: function () {
          return A.serialize;
        }
      }), Object.defineProperty(e, "TransactionTypes", {
        enumerable: !0,
        get: function () {
          return A.TransactionTypes;
        }
      });
      var x = t(7616);
      Object.defineProperty(e, "commify", {
        enumerable: !0,
        get: function () {
          return x.commify;
        }
      }), Object.defineProperty(e, "formatEther", {
        enumerable: !0,
        get: function () {
          return x.formatEther;
        }
      }), Object.defineProperty(e, "parseEther", {
        enumerable: !0,
        get: function () {
          return x.parseEther;
        }
      }), Object.defineProperty(e, "formatUnits", {
        enumerable: !0,
        get: function () {
          return x.formatUnits;
        }
      }), Object.defineProperty(e, "parseUnits", {
        enumerable: !0,
        get: function () {
          return x.parseUnits;
        }
      });

      var _ = t(4280);

      Object.defineProperty(e, "verifyMessage", {
        enumerable: !0,
        get: function () {
          return _.verifyMessage;
        }
      }), Object.defineProperty(e, "verifyTypedData", {
        enumerable: !0,
        get: function () {
          return _.verifyTypedData;
        }
      });
      var M = t(8341);
      Object.defineProperty(e, "_fetchData", {
        enumerable: !0,
        get: function () {
          return M._fetchData;
        }
      }), Object.defineProperty(e, "fetchJson", {
        enumerable: !0,
        get: function () {
          return M.fetchJson;
        }
      }), Object.defineProperty(e, "poll", {
        enumerable: !0,
        get: function () {
          return M.poll;
        }
      });
      var P = t(1278);
      Object.defineProperty(e, "SupportedAlgorithm", {
        enumerable: !0,
        get: function () {
          return P.SupportedAlgorithm;
        }
      });
      var T = t(4044);
      Object.defineProperty(e, "UnicodeNormalizationForm", {
        enumerable: !0,
        get: function () {
          return T.UnicodeNormalizationForm;
        }
      }), Object.defineProperty(e, "Utf8ErrorReason", {
        enumerable: !0,
        get: function () {
          return T.Utf8ErrorReason;
        }
      });
    },
    3715: (f, e, t) => {
      var r = e;
      r.utils = t(6436), r.common = t(5772), r.sha = t(9041), r.ripemd = t(2949), r.hmac = t(2344), r.sha1 = r.sha.sha1, r.sha256 = r.sha.sha256, r.sha224 = r.sha.sha224, r.sha384 = r.sha.sha384, r.sha512 = r.sha.sha512, r.ripemd160 = r.ripemd.ripemd160;
    },
    5772: (f, e, t) => {
      "use strict";

      var r = t(6436),
          n = t(9746);

      function i() {
        this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
      }

      e.BlockHash = i, i.prototype.update = function (f, e) {
        if (f = r.toArray(f, e), this.pending ? this.pending = this.pending.concat(f) : this.pending = f, this.pendingTotal += f.length, this.pending.length >= this._delta8) {
          var t = (f = this.pending).length % this._delta8;
          this.pending = f.slice(f.length - t, f.length), 0 === this.pending.length && (this.pending = null), f = r.join32(f, 0, f.length - t, this.endian);

          for (var n = 0; n < f.length; n += this._delta32) this._update(f, n, n + this._delta32);
        }

        return this;
      }, i.prototype.digest = function (f) {
        return this.update(this._pad()), n(null === this.pending), this._digest(f);
      }, i.prototype._pad = function () {
        var f = this.pendingTotal,
            e = this._delta8,
            t = e - (f + this.padLength) % e,
            r = new Array(t + this.padLength);
        r[0] = 128;

        for (var n = 1; n < t; n++) r[n] = 0;

        if (f <<= 3, "big" === this.endian) {
          for (var i = 8; i < this.padLength; i++) r[n++] = 0;

          r[n++] = 0, r[n++] = 0, r[n++] = 0, r[n++] = 0, r[n++] = f >>> 24 & 255, r[n++] = f >>> 16 & 255, r[n++] = f >>> 8 & 255, r[n++] = 255 & f;
        } else for (r[n++] = 255 & f, r[n++] = f >>> 8 & 255, r[n++] = f >>> 16 & 255, r[n++] = f >>> 24 & 255, r[n++] = 0, r[n++] = 0, r[n++] = 0, r[n++] = 0, i = 8; i < this.padLength; i++) r[n++] = 0;

        return r;
      };
    },
    2344: (f, e, t) => {
      "use strict";

      var r = t(6436),
          n = t(9746);

      function i(f, e, t) {
        if (!(this instanceof i)) return new i(f, e, t);
        this.Hash = f, this.blockSize = f.blockSize / 8, this.outSize = f.outSize / 8, this.inner = null, this.outer = null, this._init(r.toArray(e, t));
      }

      f.exports = i, i.prototype._init = function (f) {
        f.length > this.blockSize && (f = new this.Hash().update(f).digest()), n(f.length <= this.blockSize);

        for (var e = f.length; e < this.blockSize; e++) f.push(0);

        for (e = 0; e < f.length; e++) f[e] ^= 54;

        for (this.inner = new this.Hash().update(f), e = 0; e < f.length; e++) f[e] ^= 106;

        this.outer = new this.Hash().update(f);
      }, i.prototype.update = function (f, e) {
        return this.inner.update(f, e), this;
      }, i.prototype.digest = function (f) {
        return this.outer.update(this.inner.digest()), this.outer.digest(f);
      };
    },
    2949: (f, e, t) => {
      "use strict";

      var r = t(6436),
          n = t(5772),
          i = r.rotl32,
          a = r.sum32,
          o = r.sum32_3,
          s = r.sum32_4,
          u = n.BlockHash;

      function c() {
        if (!(this instanceof c)) return new c();
        u.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
      }

      function d(f, e, t, r) {
        return f <= 15 ? e ^ t ^ r : f <= 31 ? e & t | ~e & r : f <= 47 ? (e | ~t) ^ r : f <= 63 ? e & r | t & ~r : e ^ (t | ~r);
      }

      function b(f) {
        return f <= 15 ? 0 : f <= 31 ? 1518500249 : f <= 47 ? 1859775393 : f <= 63 ? 2400959708 : 2840853838;
      }

      function l(f) {
        return f <= 15 ? 1352829926 : f <= 31 ? 1548603684 : f <= 47 ? 1836072691 : f <= 63 ? 2053994217 : 0;
      }

      r.inherits(c, u), e.ripemd160 = c, c.blockSize = 512, c.outSize = 160, c.hmacStrength = 192, c.padLength = 64, c.prototype._update = function (f, e) {
        for (var t = this.h[0], r = this.h[1], n = this.h[2], u = this.h[3], c = this.h[4], g = t, v = r, w = n, E = u, S = c, A = 0; A < 80; A++) {
          var x = a(i(s(t, d(A, r, n, u), f[h[A] + e], b(A)), m[A]), c);
          t = c, c = u, u = i(n, 10), n = r, r = x, x = a(i(s(g, d(79 - A, v, w, E), f[p[A] + e], l(A)), y[A]), S), g = S, S = E, E = i(w, 10), w = v, v = x;
        }

        x = o(this.h[1], n, E), this.h[1] = o(this.h[2], u, S), this.h[2] = o(this.h[3], c, g), this.h[3] = o(this.h[4], t, v), this.h[4] = o(this.h[0], r, w), this.h[0] = x;
      }, c.prototype._digest = function (f) {
        return "hex" === f ? r.toHex32(this.h, "little") : r.split32(this.h, "little");
      };
      var h = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13],
          p = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11],
          m = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6],
          y = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
    },
    9041: (f, e, t) => {
      "use strict";

      e.sha1 = t(4761), e.sha224 = t(799), e.sha256 = t(9344), e.sha384 = t(772), e.sha512 = t(5900);
    },
    4761: (f, e, t) => {
      "use strict";

      var r = t(6436),
          n = t(5772),
          i = t(7038),
          a = r.rotl32,
          o = r.sum32,
          s = r.sum32_5,
          u = i.ft_1,
          c = n.BlockHash,
          d = [1518500249, 1859775393, 2400959708, 3395469782];

      function b() {
        if (!(this instanceof b)) return new b();
        c.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.W = new Array(80);
      }

      r.inherits(b, c), f.exports = b, b.blockSize = 512, b.outSize = 160, b.hmacStrength = 80, b.padLength = 64, b.prototype._update = function (f, e) {
        for (var t = this.W, r = 0; r < 16; r++) t[r] = f[e + r];

        for (; r < t.length; r++) t[r] = a(t[r - 3] ^ t[r - 8] ^ t[r - 14] ^ t[r - 16], 1);

        var n = this.h[0],
            i = this.h[1],
            c = this.h[2],
            b = this.h[3],
            l = this.h[4];

        for (r = 0; r < t.length; r++) {
          var h = ~~(r / 20),
              p = s(a(n, 5), u(h, i, c, b), l, t[r], d[h]);
          l = b, b = c, c = a(i, 30), i = n, n = p;
        }

        this.h[0] = o(this.h[0], n), this.h[1] = o(this.h[1], i), this.h[2] = o(this.h[2], c), this.h[3] = o(this.h[3], b), this.h[4] = o(this.h[4], l);
      }, b.prototype._digest = function (f) {
        return "hex" === f ? r.toHex32(this.h, "big") : r.split32(this.h, "big");
      };
    },
    799: (f, e, t) => {
      "use strict";

      var r = t(6436),
          n = t(9344);

      function i() {
        if (!(this instanceof i)) return new i();
        n.call(this), this.h = [3238371032, 914150663, 812702999, 4144912697, 4290775857, 1750603025, 1694076839, 3204075428];
      }

      r.inherits(i, n), f.exports = i, i.blockSize = 512, i.outSize = 224, i.hmacStrength = 192, i.padLength = 64, i.prototype._digest = function (f) {
        return "hex" === f ? r.toHex32(this.h.slice(0, 7), "big") : r.split32(this.h.slice(0, 7), "big");
      };
    },
    9344: (f, e, t) => {
      "use strict";

      var r = t(6436),
          n = t(5772),
          i = t(7038),
          a = t(9746),
          o = r.sum32,
          s = r.sum32_4,
          u = r.sum32_5,
          c = i.ch32,
          d = i.maj32,
          b = i.s0_256,
          l = i.s1_256,
          h = i.g0_256,
          p = i.g1_256,
          m = n.BlockHash,
          y = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];

      function g() {
        if (!(this instanceof g)) return new g();
        m.call(this), this.h = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225], this.k = y, this.W = new Array(64);
      }

      r.inherits(g, m), f.exports = g, g.blockSize = 512, g.outSize = 256, g.hmacStrength = 192, g.padLength = 64, g.prototype._update = function (f, e) {
        for (var t = this.W, r = 0; r < 16; r++) t[r] = f[e + r];

        for (; r < t.length; r++) t[r] = s(p(t[r - 2]), t[r - 7], h(t[r - 15]), t[r - 16]);

        var n = this.h[0],
            i = this.h[1],
            m = this.h[2],
            y = this.h[3],
            g = this.h[4],
            v = this.h[5],
            w = this.h[6],
            E = this.h[7];

        for (a(this.k.length === t.length), r = 0; r < t.length; r++) {
          var S = u(E, l(g), c(g, v, w), this.k[r], t[r]),
              A = o(b(n), d(n, i, m));
          E = w, w = v, v = g, g = o(y, S), y = m, m = i, i = n, n = o(S, A);
        }

        this.h[0] = o(this.h[0], n), this.h[1] = o(this.h[1], i), this.h[2] = o(this.h[2], m), this.h[3] = o(this.h[3], y), this.h[4] = o(this.h[4], g), this.h[5] = o(this.h[5], v), this.h[6] = o(this.h[6], w), this.h[7] = o(this.h[7], E);
      }, g.prototype._digest = function (f) {
        return "hex" === f ? r.toHex32(this.h, "big") : r.split32(this.h, "big");
      };
    },
    772: (f, e, t) => {
      "use strict";

      var r = t(6436),
          n = t(5900);

      function i() {
        if (!(this instanceof i)) return new i();
        n.call(this), this.h = [3418070365, 3238371032, 1654270250, 914150663, 2438529370, 812702999, 355462360, 4144912697, 1731405415, 4290775857, 2394180231, 1750603025, 3675008525, 1694076839, 1203062813, 3204075428];
      }

      r.inherits(i, n), f.exports = i, i.blockSize = 1024, i.outSize = 384, i.hmacStrength = 192, i.padLength = 128, i.prototype._digest = function (f) {
        return "hex" === f ? r.toHex32(this.h.slice(0, 12), "big") : r.split32(this.h.slice(0, 12), "big");
      };
    },
    5900: (f, e, t) => {
      "use strict";

      var r = t(6436),
          n = t(5772),
          i = t(9746),
          a = r.rotr64_hi,
          o = r.rotr64_lo,
          s = r.shr64_hi,
          u = r.shr64_lo,
          c = r.sum64,
          d = r.sum64_hi,
          b = r.sum64_lo,
          l = r.sum64_4_hi,
          h = r.sum64_4_lo,
          p = r.sum64_5_hi,
          m = r.sum64_5_lo,
          y = n.BlockHash,
          g = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];

      function v() {
        if (!(this instanceof v)) return new v();
        y.call(this), this.h = [1779033703, 4089235720, 3144134277, 2227873595, 1013904242, 4271175723, 2773480762, 1595750129, 1359893119, 2917565137, 2600822924, 725511199, 528734635, 4215389547, 1541459225, 327033209], this.k = g, this.W = new Array(160);
      }

      function w(f, e, t, r, n) {
        var i = f & t ^ ~f & n;
        return i < 0 && (i += 4294967296), i;
      }

      function E(f, e, t, r, n, i) {
        var a = e & r ^ ~e & i;
        return a < 0 && (a += 4294967296), a;
      }

      function S(f, e, t, r, n) {
        var i = f & t ^ f & n ^ t & n;
        return i < 0 && (i += 4294967296), i;
      }

      function A(f, e, t, r, n, i) {
        var a = e & r ^ e & i ^ r & i;
        return a < 0 && (a += 4294967296), a;
      }

      function x(f, e) {
        var t = a(f, e, 28) ^ a(e, f, 2) ^ a(e, f, 7);
        return t < 0 && (t += 4294967296), t;
      }

      function _(f, e) {
        var t = o(f, e, 28) ^ o(e, f, 2) ^ o(e, f, 7);
        return t < 0 && (t += 4294967296), t;
      }

      function M(f, e) {
        var t = a(f, e, 14) ^ a(f, e, 18) ^ a(e, f, 9);
        return t < 0 && (t += 4294967296), t;
      }

      function P(f, e) {
        var t = o(f, e, 14) ^ o(f, e, 18) ^ o(e, f, 9);
        return t < 0 && (t += 4294967296), t;
      }

      function T(f, e) {
        var t = a(f, e, 1) ^ a(f, e, 8) ^ s(f, e, 7);
        return t < 0 && (t += 4294967296), t;
      }

      function O(f, e) {
        var t = o(f, e, 1) ^ o(f, e, 8) ^ u(f, e, 7);
        return t < 0 && (t += 4294967296), t;
      }

      function C(f, e) {
        var t = a(f, e, 19) ^ a(e, f, 29) ^ s(f, e, 6);
        return t < 0 && (t += 4294967296), t;
      }

      function R(f, e) {
        var t = o(f, e, 19) ^ o(e, f, 29) ^ u(f, e, 6);
        return t < 0 && (t += 4294967296), t;
      }

      r.inherits(v, y), f.exports = v, v.blockSize = 1024, v.outSize = 512, v.hmacStrength = 192, v.padLength = 128, v.prototype._prepareBlock = function (f, e) {
        for (var t = this.W, r = 0; r < 32; r++) t[r] = f[e + r];

        for (; r < t.length; r += 2) {
          var n = C(t[r - 4], t[r - 3]),
              i = R(t[r - 4], t[r - 3]),
              a = t[r - 14],
              o = t[r - 13],
              s = T(t[r - 30], t[r - 29]),
              u = O(t[r - 30], t[r - 29]),
              c = t[r - 32],
              d = t[r - 31];
          t[r] = l(n, i, a, o, s, u, c, d), t[r + 1] = h(n, i, a, o, s, u, c, d);
        }
      }, v.prototype._update = function (f, e) {
        this._prepareBlock(f, e);

        var t = this.W,
            r = this.h[0],
            n = this.h[1],
            a = this.h[2],
            o = this.h[3],
            s = this.h[4],
            u = this.h[5],
            l = this.h[6],
            h = this.h[7],
            y = this.h[8],
            g = this.h[9],
            v = this.h[10],
            T = this.h[11],
            O = this.h[12],
            C = this.h[13],
            R = this.h[14],
            N = this.h[15];
        i(this.k.length === t.length);

        for (var k = 0; k < t.length; k += 2) {
          var I = R,
              F = N,
              B = M(y, g),
              L = P(y, g),
              D = w(y, g, v, T, O),
              U = E(y, g, v, T, O, C),
              j = this.k[k],
              z = this.k[k + 1],
              G = t[k],
              K = t[k + 1],
              V = p(I, F, B, L, D, U, j, z, G, K),
              H = m(I, F, B, L, D, U, j, z, G, K);
          I = x(r, n), F = _(r, n), B = S(r, n, a, o, s), L = A(r, n, a, o, s, u);
          var q = d(I, F, B, L),
              W = b(I, F, B, L);
          R = O, N = C, O = v, C = T, v = y, T = g, y = d(l, h, V, H), g = b(h, h, V, H), l = s, h = u, s = a, u = o, a = r, o = n, r = d(V, H, q, W), n = b(V, H, q, W);
        }

        c(this.h, 0, r, n), c(this.h, 2, a, o), c(this.h, 4, s, u), c(this.h, 6, l, h), c(this.h, 8, y, g), c(this.h, 10, v, T), c(this.h, 12, O, C), c(this.h, 14, R, N);
      }, v.prototype._digest = function (f) {
        return "hex" === f ? r.toHex32(this.h, "big") : r.split32(this.h, "big");
      };
    },
    7038: (f, e, t) => {
      "use strict";

      var r = t(6436).rotr32;

      function n(f, e, t) {
        return f & e ^ ~f & t;
      }

      function i(f, e, t) {
        return f & e ^ f & t ^ e & t;
      }

      function a(f, e, t) {
        return f ^ e ^ t;
      }

      e.ft_1 = function (f, e, t, r) {
        return 0 === f ? n(e, t, r) : 1 === f || 3 === f ? a(e, t, r) : 2 === f ? i(e, t, r) : void 0;
      }, e.ch32 = n, e.maj32 = i, e.p32 = a, e.s0_256 = function (f) {
        return r(f, 2) ^ r(f, 13) ^ r(f, 22);
      }, e.s1_256 = function (f) {
        return r(f, 6) ^ r(f, 11) ^ r(f, 25);
      }, e.g0_256 = function (f) {
        return r(f, 7) ^ r(f, 18) ^ f >>> 3;
      }, e.g1_256 = function (f) {
        return r(f, 17) ^ r(f, 19) ^ f >>> 10;
      };
    },
    6436: (f, e, t) => {
      "use strict";

      var r = t(9746),
          n = t(5717);

      function i(f, e) {
        return 55296 == (64512 & f.charCodeAt(e)) && !(e < 0 || e + 1 >= f.length) && 56320 == (64512 & f.charCodeAt(e + 1));
      }

      function a(f) {
        return (f >>> 24 | f >>> 8 & 65280 | f << 8 & 16711680 | (255 & f) << 24) >>> 0;
      }

      function o(f) {
        return 1 === f.length ? "0" + f : f;
      }

      function s(f) {
        return 7 === f.length ? "0" + f : 6 === f.length ? "00" + f : 5 === f.length ? "000" + f : 4 === f.length ? "0000" + f : 3 === f.length ? "00000" + f : 2 === f.length ? "000000" + f : 1 === f.length ? "0000000" + f : f;
      }

      e.inherits = n, e.toArray = function (f, e) {
        if (Array.isArray(f)) return f.slice();
        if (!f) return [];
        var t = [];
        if ("string" == typeof f) {
          if (e) {
            if ("hex" === e) for ((f = f.replace(/[^a-z0-9]+/gi, "")).length % 2 != 0 && (f = "0" + f), n = 0; n < f.length; n += 2) t.push(parseInt(f[n] + f[n + 1], 16));
          } else for (var r = 0, n = 0; n < f.length; n++) {
            var a = f.charCodeAt(n);
            a < 128 ? t[r++] = a : a < 2048 ? (t[r++] = a >> 6 | 192, t[r++] = 63 & a | 128) : i(f, n) ? (a = 65536 + ((1023 & a) << 10) + (1023 & f.charCodeAt(++n)), t[r++] = a >> 18 | 240, t[r++] = a >> 12 & 63 | 128, t[r++] = a >> 6 & 63 | 128, t[r++] = 63 & a | 128) : (t[r++] = a >> 12 | 224, t[r++] = a >> 6 & 63 | 128, t[r++] = 63 & a | 128);
          }
        } else for (n = 0; n < f.length; n++) t[n] = 0 | f[n];
        return t;
      }, e.toHex = function (f) {
        for (var e = "", t = 0; t < f.length; t++) e += o(f[t].toString(16));

        return e;
      }, e.htonl = a, e.toHex32 = function (f, e) {
        for (var t = "", r = 0; r < f.length; r++) {
          var n = f[r];
          "little" === e && (n = a(n)), t += s(n.toString(16));
        }

        return t;
      }, e.zero2 = o, e.zero8 = s, e.join32 = function (f, e, t, n) {
        var i = t - e;
        r(i % 4 == 0);

        for (var a = new Array(i / 4), o = 0, s = e; o < a.length; o++, s += 4) {
          var u;
          u = "big" === n ? f[s] << 24 | f[s + 1] << 16 | f[s + 2] << 8 | f[s + 3] : f[s + 3] << 24 | f[s + 2] << 16 | f[s + 1] << 8 | f[s], a[o] = u >>> 0;
        }

        return a;
      }, e.split32 = function (f, e) {
        for (var t = new Array(4 * f.length), r = 0, n = 0; r < f.length; r++, n += 4) {
          var i = f[r];
          "big" === e ? (t[n] = i >>> 24, t[n + 1] = i >>> 16 & 255, t[n + 2] = i >>> 8 & 255, t[n + 3] = 255 & i) : (t[n + 3] = i >>> 24, t[n + 2] = i >>> 16 & 255, t[n + 1] = i >>> 8 & 255, t[n] = 255 & i);
        }

        return t;
      }, e.rotr32 = function (f, e) {
        return f >>> e | f << 32 - e;
      }, e.rotl32 = function (f, e) {
        return f << e | f >>> 32 - e;
      }, e.sum32 = function (f, e) {
        return f + e >>> 0;
      }, e.sum32_3 = function (f, e, t) {
        return f + e + t >>> 0;
      }, e.sum32_4 = function (f, e, t, r) {
        return f + e + t + r >>> 0;
      }, e.sum32_5 = function (f, e, t, r, n) {
        return f + e + t + r + n >>> 0;
      }, e.sum64 = function (f, e, t, r) {
        var n = f[e],
            i = r + f[e + 1] >>> 0,
            a = (i < r ? 1 : 0) + t + n;
        f[e] = a >>> 0, f[e + 1] = i;
      }, e.sum64_hi = function (f, e, t, r) {
        return (e + r >>> 0 < e ? 1 : 0) + f + t >>> 0;
      }, e.sum64_lo = function (f, e, t, r) {
        return e + r >>> 0;
      }, e.sum64_4_hi = function (f, e, t, r, n, i, a, o) {
        var s = 0,
            u = e;
        return s += (u = u + r >>> 0) < e ? 1 : 0, s += (u = u + i >>> 0) < i ? 1 : 0, f + t + n + a + (s += (u = u + o >>> 0) < o ? 1 : 0) >>> 0;
      }, e.sum64_4_lo = function (f, e, t, r, n, i, a, o) {
        return e + r + i + o >>> 0;
      }, e.sum64_5_hi = function (f, e, t, r, n, i, a, o, s, u) {
        var c = 0,
            d = e;
        return c += (d = d + r >>> 0) < e ? 1 : 0, c += (d = d + i >>> 0) < i ? 1 : 0, c += (d = d + o >>> 0) < o ? 1 : 0, f + t + n + a + s + (c += (d = d + u >>> 0) < u ? 1 : 0) >>> 0;
      }, e.sum64_5_lo = function (f, e, t, r, n, i, a, o, s, u) {
        return e + r + i + o + u >>> 0;
      }, e.rotr64_hi = function (f, e, t) {
        return (e << 32 - t | f >>> t) >>> 0;
      }, e.rotr64_lo = function (f, e, t) {
        return (f << 32 - t | e >>> t) >>> 0;
      }, e.shr64_hi = function (f, e, t) {
        return f >>> t;
      }, e.shr64_lo = function (f, e, t) {
        return (f << 32 - t | e >>> t) >>> 0;
      };
    },
    5717: f => {
      "function" == typeof Object.create ? f.exports = function (f, e) {
        e && (f.super_ = e, f.prototype = Object.create(e.prototype, {
          constructor: {
            value: f,
            enumerable: !1,
            writable: !0,
            configurable: !0
          }
        }));
      } : f.exports = function (f, e) {
        if (e) {
          f.super_ = e;

          var t = function () {};

          t.prototype = e.prototype, f.prototype = new t(), f.prototype.constructor = f;
        }
      };
    },
    1094: (f, e, t) => {
      var r;
      /**
       * [js-sha3]{@link https://github.com/emn178/js-sha3}
       *
       * @version 0.8.0
       * @author Chen, Yi-Cyuan [emn178@gmail.com]
       * @copyright Chen, Yi-Cyuan 2015-2018
       * @license MIT
       */

      !function () {
        "use strict";

        var n = "input is invalid type",
            i = "object" == typeof window,
            a = i ? window : {};
        a.JS_SHA3_NO_WINDOW && (i = !1);
        var o = !i && "object" == typeof self;
        !a.JS_SHA3_NO_NODE_JS && "object" == typeof process && process.versions && process.versions.node ? a = t.g : o && (a = self);
        var s = !a.JS_SHA3_NO_COMMON_JS && f.exports,
            u = t.amdO,
            c = !a.JS_SHA3_NO_ARRAY_BUFFER && "undefined" != typeof ArrayBuffer,
            d = "0123456789abcdef".split(""),
            b = [4, 1024, 262144, 67108864],
            l = [0, 8, 16, 24],
            h = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648],
            p = [224, 256, 384, 512],
            m = [128, 256],
            y = ["hex", "buffer", "arrayBuffer", "array", "digest"],
            g = {
          128: 168,
          256: 136
        };
        !a.JS_SHA3_NO_NODE_JS && Array.isArray || (Array.isArray = function (f) {
          return "[object Array]" === Object.prototype.toString.call(f);
        }), !c || !a.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW && ArrayBuffer.isView || (ArrayBuffer.isView = function (f) {
          return "object" == typeof f && f.buffer && f.buffer.constructor === ArrayBuffer;
        });

        for (var v = function (f, e, t) {
          return function (r) {
            return new I(f, e, f).update(r)[t]();
          };
        }, w = function (f, e, t) {
          return function (r, n) {
            return new I(f, e, n).update(r)[t]();
          };
        }, E = function (f, e, t) {
          return function (e, r, n, i) {
            return M["cshake" + f].update(e, r, n, i)[t]();
          };
        }, S = function (f, e, t) {
          return function (e, r, n, i) {
            return M["kmac" + f].update(e, r, n, i)[t]();
          };
        }, A = function (f, e, t, r) {
          for (var n = 0; n < y.length; ++n) {
            var i = y[n];
            f[i] = e(t, r, i);
          }

          return f;
        }, x = function (f, e) {
          var t = v(f, e, "hex");
          return t.create = function () {
            return new I(f, e, f);
          }, t.update = function (f) {
            return t.create().update(f);
          }, A(t, v, f, e);
        }, _ = [{
          name: "keccak",
          padding: [1, 256, 65536, 16777216],
          bits: p,
          createMethod: x
        }, {
          name: "sha3",
          padding: [6, 1536, 393216, 100663296],
          bits: p,
          createMethod: x
        }, {
          name: "shake",
          padding: [31, 7936, 2031616, 520093696],
          bits: m,
          createMethod: function (f, e) {
            var t = w(f, e, "hex");
            return t.create = function (t) {
              return new I(f, e, t);
            }, t.update = function (f, e) {
              return t.create(e).update(f);
            }, A(t, w, f, e);
          }
        }, {
          name: "cshake",
          padding: b,
          bits: m,
          createMethod: function (f, e) {
            var t = g[f],
                r = E(f, 0, "hex");
            return r.create = function (r, n, i) {
              return n || i ? new I(f, e, r).bytepad([n, i], t) : M["shake" + f].create(r);
            }, r.update = function (f, e, t, n) {
              return r.create(e, t, n).update(f);
            }, A(r, E, f, e);
          }
        }, {
          name: "kmac",
          padding: b,
          bits: m,
          createMethod: function (f, e) {
            var t = g[f],
                r = S(f, 0, "hex");
            return r.create = function (r, n, i) {
              return new F(f, e, n).bytepad(["KMAC", i], t).bytepad([r], t);
            }, r.update = function (f, e, t, n) {
              return r.create(f, t, n).update(e);
            }, A(r, S, f, e);
          }
        }], M = {}, P = [], T = 0; T < _.length; ++T) for (var O = _[T], C = O.bits, R = 0; R < C.length; ++R) {
          var N = O.name + "_" + C[R];

          if (P.push(N), M[N] = O.createMethod(C[R], O.padding), "sha3" !== O.name) {
            var k = O.name + C[R];
            P.push(k), M[k] = M[N];
          }
        }

        function I(f, e, t) {
          this.blocks = [], this.s = [], this.padding = e, this.outputBits = t, this.reset = !0, this.finalized = !1, this.block = 0, this.start = 0, this.blockCount = 1600 - (f << 1) >> 5, this.byteCount = this.blockCount << 2, this.outputBlocks = t >> 5, this.extraBytes = (31 & t) >> 3;

          for (var r = 0; r < 50; ++r) this.s[r] = 0;
        }

        function F(f, e, t) {
          I.call(this, f, e, t);
        }

        I.prototype.update = function (f) {
          if (this.finalized) throw new Error("finalize already called");
          var e,
              t = typeof f;

          if ("string" !== t) {
            if ("object" !== t) throw new Error(n);
            if (null === f) throw new Error(n);
            if (c && f.constructor === ArrayBuffer) f = new Uint8Array(f);else if (!(Array.isArray(f) || c && ArrayBuffer.isView(f))) throw new Error(n);
            e = !0;
          }

          for (var r, i, a = this.blocks, o = this.byteCount, s = f.length, u = this.blockCount, d = 0, b = this.s; d < s;) {
            if (this.reset) for (this.reset = !1, a[0] = this.block, r = 1; r < u + 1; ++r) a[r] = 0;
            if (e) for (r = this.start; d < s && r < o; ++d) a[r >> 2] |= f[d] << l[3 & r++];else for (r = this.start; d < s && r < o; ++d) (i = f.charCodeAt(d)) < 128 ? a[r >> 2] |= i << l[3 & r++] : i < 2048 ? (a[r >> 2] |= (192 | i >> 6) << l[3 & r++], a[r >> 2] |= (128 | 63 & i) << l[3 & r++]) : i < 55296 || i >= 57344 ? (a[r >> 2] |= (224 | i >> 12) << l[3 & r++], a[r >> 2] |= (128 | i >> 6 & 63) << l[3 & r++], a[r >> 2] |= (128 | 63 & i) << l[3 & r++]) : (i = 65536 + ((1023 & i) << 10 | 1023 & f.charCodeAt(++d)), a[r >> 2] |= (240 | i >> 18) << l[3 & r++], a[r >> 2] |= (128 | i >> 12 & 63) << l[3 & r++], a[r >> 2] |= (128 | i >> 6 & 63) << l[3 & r++], a[r >> 2] |= (128 | 63 & i) << l[3 & r++]);

            if (this.lastByteIndex = r, r >= o) {
              for (this.start = r - o, this.block = a[u], r = 0; r < u; ++r) b[r] ^= a[r];

              B(b), this.reset = !0;
            } else this.start = r;
          }

          return this;
        }, I.prototype.encode = function (f, e) {
          var t = 255 & f,
              r = 1,
              n = [t];

          for (t = 255 & (f >>= 8); t > 0;) n.unshift(t), t = 255 & (f >>= 8), ++r;

          return e ? n.push(r) : n.unshift(r), this.update(n), n.length;
        }, I.prototype.encodeString = function (f) {
          var e,
              t = typeof f;

          if ("string" !== t) {
            if ("object" !== t) throw new Error(n);
            if (null === f) throw new Error(n);
            if (c && f.constructor === ArrayBuffer) f = new Uint8Array(f);else if (!(Array.isArray(f) || c && ArrayBuffer.isView(f))) throw new Error(n);
            e = !0;
          }

          var r = 0,
              i = f.length;
          if (e) r = i;else for (var a = 0; a < f.length; ++a) {
            var o = f.charCodeAt(a);
            o < 128 ? r += 1 : o < 2048 ? r += 2 : o < 55296 || o >= 57344 ? r += 3 : (o = 65536 + ((1023 & o) << 10 | 1023 & f.charCodeAt(++a)), r += 4);
          }
          return r += this.encode(8 * r), this.update(f), r;
        }, I.prototype.bytepad = function (f, e) {
          for (var t = this.encode(e), r = 0; r < f.length; ++r) t += this.encodeString(f[r]);

          var n = e - t % e,
              i = [];
          return i.length = n, this.update(i), this;
        }, I.prototype.finalize = function () {
          if (!this.finalized) {
            this.finalized = !0;
            var f = this.blocks,
                e = this.lastByteIndex,
                t = this.blockCount,
                r = this.s;
            if (f[e >> 2] |= this.padding[3 & e], this.lastByteIndex === this.byteCount) for (f[0] = f[t], e = 1; e < t + 1; ++e) f[e] = 0;

            for (f[t - 1] |= 2147483648, e = 0; e < t; ++e) r[e] ^= f[e];

            B(r);
          }
        }, I.prototype.toString = I.prototype.hex = function () {
          this.finalize();

          for (var f, e = this.blockCount, t = this.s, r = this.outputBlocks, n = this.extraBytes, i = 0, a = 0, o = ""; a < r;) {
            for (i = 0; i < e && a < r; ++i, ++a) f = t[i], o += d[f >> 4 & 15] + d[15 & f] + d[f >> 12 & 15] + d[f >> 8 & 15] + d[f >> 20 & 15] + d[f >> 16 & 15] + d[f >> 28 & 15] + d[f >> 24 & 15];

            a % e == 0 && (B(t), i = 0);
          }

          return n && (f = t[i], o += d[f >> 4 & 15] + d[15 & f], n > 1 && (o += d[f >> 12 & 15] + d[f >> 8 & 15]), n > 2 && (o += d[f >> 20 & 15] + d[f >> 16 & 15])), o;
        }, I.prototype.arrayBuffer = function () {
          this.finalize();
          var f,
              e = this.blockCount,
              t = this.s,
              r = this.outputBlocks,
              n = this.extraBytes,
              i = 0,
              a = 0,
              o = this.outputBits >> 3;
          f = n ? new ArrayBuffer(r + 1 << 2) : new ArrayBuffer(o);

          for (var s = new Uint32Array(f); a < r;) {
            for (i = 0; i < e && a < r; ++i, ++a) s[a] = t[i];

            a % e == 0 && B(t);
          }

          return n && (s[i] = t[i], f = f.slice(0, o)), f;
        }, I.prototype.buffer = I.prototype.arrayBuffer, I.prototype.digest = I.prototype.array = function () {
          this.finalize();

          for (var f, e, t = this.blockCount, r = this.s, n = this.outputBlocks, i = this.extraBytes, a = 0, o = 0, s = []; o < n;) {
            for (a = 0; a < t && o < n; ++a, ++o) f = o << 2, e = r[a], s[f] = 255 & e, s[f + 1] = e >> 8 & 255, s[f + 2] = e >> 16 & 255, s[f + 3] = e >> 24 & 255;

            o % t == 0 && B(r);
          }

          return i && (f = o << 2, e = r[a], s[f] = 255 & e, i > 1 && (s[f + 1] = e >> 8 & 255), i > 2 && (s[f + 2] = e >> 16 & 255)), s;
        }, F.prototype = new I(), F.prototype.finalize = function () {
          return this.encode(this.outputBits, !0), I.prototype.finalize.call(this);
        };

        var B = function (f) {
          var e, t, r, n, i, a, o, s, u, c, d, b, l, p, m, y, g, v, w, E, S, A, x, _, M, P, T, O, C, R, N, k, I, F, B, L, D, U, j, z, G, K, V, H, q, W, $, J, Z, Y, X, Q, ff, ef, tf, rf, nf, af, of, sf, uf, cf, df;

          for (r = 0; r < 48; r += 2) n = f[0] ^ f[10] ^ f[20] ^ f[30] ^ f[40], i = f[1] ^ f[11] ^ f[21] ^ f[31] ^ f[41], a = f[2] ^ f[12] ^ f[22] ^ f[32] ^ f[42], o = f[3] ^ f[13] ^ f[23] ^ f[33] ^ f[43], s = f[4] ^ f[14] ^ f[24] ^ f[34] ^ f[44], u = f[5] ^ f[15] ^ f[25] ^ f[35] ^ f[45], c = f[6] ^ f[16] ^ f[26] ^ f[36] ^ f[46], d = f[7] ^ f[17] ^ f[27] ^ f[37] ^ f[47], e = (b = f[8] ^ f[18] ^ f[28] ^ f[38] ^ f[48]) ^ (a << 1 | o >>> 31), t = (l = f[9] ^ f[19] ^ f[29] ^ f[39] ^ f[49]) ^ (o << 1 | a >>> 31), f[0] ^= e, f[1] ^= t, f[10] ^= e, f[11] ^= t, f[20] ^= e, f[21] ^= t, f[30] ^= e, f[31] ^= t, f[40] ^= e, f[41] ^= t, e = n ^ (s << 1 | u >>> 31), t = i ^ (u << 1 | s >>> 31), f[2] ^= e, f[3] ^= t, f[12] ^= e, f[13] ^= t, f[22] ^= e, f[23] ^= t, f[32] ^= e, f[33] ^= t, f[42] ^= e, f[43] ^= t, e = a ^ (c << 1 | d >>> 31), t = o ^ (d << 1 | c >>> 31), f[4] ^= e, f[5] ^= t, f[14] ^= e, f[15] ^= t, f[24] ^= e, f[25] ^= t, f[34] ^= e, f[35] ^= t, f[44] ^= e, f[45] ^= t, e = s ^ (b << 1 | l >>> 31), t = u ^ (l << 1 | b >>> 31), f[6] ^= e, f[7] ^= t, f[16] ^= e, f[17] ^= t, f[26] ^= e, f[27] ^= t, f[36] ^= e, f[37] ^= t, f[46] ^= e, f[47] ^= t, e = c ^ (n << 1 | i >>> 31), t = d ^ (i << 1 | n >>> 31), f[8] ^= e, f[9] ^= t, f[18] ^= e, f[19] ^= t, f[28] ^= e, f[29] ^= t, f[38] ^= e, f[39] ^= t, f[48] ^= e, f[49] ^= t, p = f[0], m = f[1], W = f[11] << 4 | f[10] >>> 28, $ = f[10] << 4 | f[11] >>> 28, O = f[20] << 3 | f[21] >>> 29, C = f[21] << 3 | f[20] >>> 29, sf = f[31] << 9 | f[30] >>> 23, uf = f[30] << 9 | f[31] >>> 23, K = f[40] << 18 | f[41] >>> 14, V = f[41] << 18 | f[40] >>> 14, F = f[2] << 1 | f[3] >>> 31, B = f[3] << 1 | f[2] >>> 31, y = f[13] << 12 | f[12] >>> 20, g = f[12] << 12 | f[13] >>> 20, J = f[22] << 10 | f[23] >>> 22, Z = f[23] << 10 | f[22] >>> 22, R = f[33] << 13 | f[32] >>> 19, N = f[32] << 13 | f[33] >>> 19, cf = f[42] << 2 | f[43] >>> 30, df = f[43] << 2 | f[42] >>> 30, ef = f[5] << 30 | f[4] >>> 2, tf = f[4] << 30 | f[5] >>> 2, L = f[14] << 6 | f[15] >>> 26, D = f[15] << 6 | f[14] >>> 26, v = f[25] << 11 | f[24] >>> 21, w = f[24] << 11 | f[25] >>> 21, Y = f[34] << 15 | f[35] >>> 17, X = f[35] << 15 | f[34] >>> 17, k = f[45] << 29 | f[44] >>> 3, I = f[44] << 29 | f[45] >>> 3, _ = f[6] << 28 | f[7] >>> 4, M = f[7] << 28 | f[6] >>> 4, rf = f[17] << 23 | f[16] >>> 9, nf = f[16] << 23 | f[17] >>> 9, U = f[26] << 25 | f[27] >>> 7, j = f[27] << 25 | f[26] >>> 7, E = f[36] << 21 | f[37] >>> 11, S = f[37] << 21 | f[36] >>> 11, Q = f[47] << 24 | f[46] >>> 8, ff = f[46] << 24 | f[47] >>> 8, H = f[8] << 27 | f[9] >>> 5, q = f[9] << 27 | f[8] >>> 5, P = f[18] << 20 | f[19] >>> 12, T = f[19] << 20 | f[18] >>> 12, af = f[29] << 7 | f[28] >>> 25, of = f[28] << 7 | f[29] >>> 25, z = f[38] << 8 | f[39] >>> 24, G = f[39] << 8 | f[38] >>> 24, A = f[48] << 14 | f[49] >>> 18, x = f[49] << 14 | f[48] >>> 18, f[0] = p ^ ~y & v, f[1] = m ^ ~g & w, f[10] = _ ^ ~P & O, f[11] = M ^ ~T & C, f[20] = F ^ ~L & U, f[21] = B ^ ~D & j, f[30] = H ^ ~W & J, f[31] = q ^ ~$ & Z, f[40] = ef ^ ~rf & af, f[41] = tf ^ ~nf & of, f[2] = y ^ ~v & E, f[3] = g ^ ~w & S, f[12] = P ^ ~O & R, f[13] = T ^ ~C & N, f[22] = L ^ ~U & z, f[23] = D ^ ~j & G, f[32] = W ^ ~J & Y, f[33] = $ ^ ~Z & X, f[42] = rf ^ ~af & sf, f[43] = nf ^ ~of & uf, f[4] = v ^ ~E & A, f[5] = w ^ ~S & x, f[14] = O ^ ~R & k, f[15] = C ^ ~N & I, f[24] = U ^ ~z & K, f[25] = j ^ ~G & V, f[34] = J ^ ~Y & Q, f[35] = Z ^ ~X & ff, f[44] = af ^ ~sf & cf, f[45] = of ^ ~uf & df, f[6] = E ^ ~A & p, f[7] = S ^ ~x & m, f[16] = R ^ ~k & _, f[17] = N ^ ~I & M, f[26] = z ^ ~K & F, f[27] = G ^ ~V & B, f[36] = Y ^ ~Q & H, f[37] = X ^ ~ff & q, f[46] = sf ^ ~cf & ef, f[47] = uf ^ ~df & tf, f[8] = A ^ ~p & y, f[9] = x ^ ~m & g, f[18] = k ^ ~_ & P, f[19] = I ^ ~M & T, f[28] = K ^ ~F & L, f[29] = V ^ ~B & D, f[38] = Q ^ ~H & W, f[39] = ff ^ ~q & $, f[48] = cf ^ ~ef & rf, f[49] = df ^ ~tf & nf, f[0] ^= h[r], f[1] ^= h[r + 1];
        };

        if (s) f.exports = M;else {
          for (T = 0; T < P.length; ++T) a[P[T]] = M[P[T]];

          u && (void 0 === (r = function () {
            return M;
          }.call(e, t, e, f)) || (f.exports = r));
        }
      }();
    },
    9746: f => {
      function e(f, e) {
        if (!f) throw new Error(e || "Assertion failed");
      }

      f.exports = e, e.equal = function (f, e, t) {
        if (f != e) throw new Error(t || "Assertion failed: " + f + " != " + e);
      };
    },
    7635: function (f) {
      "use strict";

      !function (e) {
        const t = 2147483647;

        function r(f) {
          const e = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
          let t = 1779033703,
              r = 3144134277,
              n = 1013904242,
              i = 2773480762,
              a = 1359893119,
              o = 2600822924,
              s = 528734635,
              u = 1541459225;
          const c = new Uint32Array(64);

          function d(f) {
            let d = 0,
                b = f.length;

            for (; b >= 64;) {
              let l,
                  h,
                  p,
                  m,
                  y,
                  g = t,
                  v = r,
                  w = n,
                  E = i,
                  S = a,
                  A = o,
                  x = s,
                  _ = u;

              for (h = 0; h < 16; h++) p = d + 4 * h, c[h] = (255 & f[p]) << 24 | (255 & f[p + 1]) << 16 | (255 & f[p + 2]) << 8 | 255 & f[p + 3];

              for (h = 16; h < 64; h++) l = c[h - 2], m = (l >>> 17 | l << 15) ^ (l >>> 19 | l << 13) ^ l >>> 10, l = c[h - 15], y = (l >>> 7 | l << 25) ^ (l >>> 18 | l << 14) ^ l >>> 3, c[h] = (m + c[h - 7] | 0) + (y + c[h - 16] | 0) | 0;

              for (h = 0; h < 64; h++) m = (((S >>> 6 | S << 26) ^ (S >>> 11 | S << 21) ^ (S >>> 25 | S << 7)) + (S & A ^ ~S & x) | 0) + (_ + (e[h] + c[h] | 0) | 0) | 0, y = ((g >>> 2 | g << 30) ^ (g >>> 13 | g << 19) ^ (g >>> 22 | g << 10)) + (g & v ^ g & w ^ v & w) | 0, _ = x, x = A, A = S, S = E + m | 0, E = w, w = v, v = g, g = m + y | 0;

              t = t + g | 0, r = r + v | 0, n = n + w | 0, i = i + E | 0, a = a + S | 0, o = o + A | 0, s = s + x | 0, u = u + _ | 0, d += 64, b -= 64;
            }
          }

          d(f);
          let b,
              l = f.length % 64,
              h = f.length / 536870912 | 0,
              p = f.length << 3,
              m = l < 56 ? 56 : 120,
              y = f.slice(f.length - l, f.length);

          for (y.push(128), b = l + 1; b < m; b++) y.push(0);

          return y.push(h >>> 24 & 255), y.push(h >>> 16 & 255), y.push(h >>> 8 & 255), y.push(h >>> 0 & 255), y.push(p >>> 24 & 255), y.push(p >>> 16 & 255), y.push(p >>> 8 & 255), y.push(p >>> 0 & 255), d(y), [t >>> 24 & 255, t >>> 16 & 255, t >>> 8 & 255, t >>> 0 & 255, r >>> 24 & 255, r >>> 16 & 255, r >>> 8 & 255, r >>> 0 & 255, n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, n >>> 0 & 255, i >>> 24 & 255, i >>> 16 & 255, i >>> 8 & 255, i >>> 0 & 255, a >>> 24 & 255, a >>> 16 & 255, a >>> 8 & 255, a >>> 0 & 255, o >>> 24 & 255, o >>> 16 & 255, o >>> 8 & 255, o >>> 0 & 255, s >>> 24 & 255, s >>> 16 & 255, s >>> 8 & 255, s >>> 0 & 255, u >>> 24 & 255, u >>> 16 & 255, u >>> 8 & 255, u >>> 0 & 255];
        }

        function n(f, e, t) {
          f = f.length <= 64 ? f : r(f);
          const n = 64 + e.length + 4,
                i = new Array(n),
                a = new Array(64);
          let o,
              s = [];

          for (o = 0; o < 64; o++) i[o] = 54;

          for (o = 0; o < f.length; o++) i[o] ^= f[o];

          for (o = 0; o < e.length; o++) i[64 + o] = e[o];

          for (o = n - 4; o < n; o++) i[o] = 0;

          for (o = 0; o < 64; o++) a[o] = 92;

          for (o = 0; o < f.length; o++) a[o] ^= f[o];

          function u() {
            for (let f = n - 1; f >= n - 4; f--) {
              if (i[f]++, i[f] <= 255) return;
              i[f] = 0;
            }
          }

          for (; t >= 32;) u(), s = s.concat(r(a.concat(r(i)))), t -= 32;

          return t > 0 && (u(), s = s.concat(r(a.concat(r(i))).slice(0, t))), s;
        }

        function i(f, e, t, r, n) {
          let i;

          for (u(f, 16 * (2 * t - 1), n, 0, 16), i = 0; i < 2 * t; i++) s(f, 16 * i, n, 16), o(n, r), u(n, 0, f, e + 16 * i, 16);

          for (i = 0; i < t; i++) u(f, e + 2 * i * 16, f, 16 * i, 16);

          for (i = 0; i < t; i++) u(f, e + 16 * (2 * i + 1), f, 16 * (i + t), 16);
        }

        function a(f, e) {
          return f << e | f >>> 32 - e;
        }

        function o(f, e) {
          u(f, 0, e, 0, 16);

          for (let f = 8; f > 0; f -= 2) e[4] ^= a(e[0] + e[12], 7), e[8] ^= a(e[4] + e[0], 9), e[12] ^= a(e[8] + e[4], 13), e[0] ^= a(e[12] + e[8], 18), e[9] ^= a(e[5] + e[1], 7), e[13] ^= a(e[9] + e[5], 9), e[1] ^= a(e[13] + e[9], 13), e[5] ^= a(e[1] + e[13], 18), e[14] ^= a(e[10] + e[6], 7), e[2] ^= a(e[14] + e[10], 9), e[6] ^= a(e[2] + e[14], 13), e[10] ^= a(e[6] + e[2], 18), e[3] ^= a(e[15] + e[11], 7), e[7] ^= a(e[3] + e[15], 9), e[11] ^= a(e[7] + e[3], 13), e[15] ^= a(e[11] + e[7], 18), e[1] ^= a(e[0] + e[3], 7), e[2] ^= a(e[1] + e[0], 9), e[3] ^= a(e[2] + e[1], 13), e[0] ^= a(e[3] + e[2], 18), e[6] ^= a(e[5] + e[4], 7), e[7] ^= a(e[6] + e[5], 9), e[4] ^= a(e[7] + e[6], 13), e[5] ^= a(e[4] + e[7], 18), e[11] ^= a(e[10] + e[9], 7), e[8] ^= a(e[11] + e[10], 9), e[9] ^= a(e[8] + e[11], 13), e[10] ^= a(e[9] + e[8], 18), e[12] ^= a(e[15] + e[14], 7), e[13] ^= a(e[12] + e[15], 9), e[14] ^= a(e[13] + e[12], 13), e[15] ^= a(e[14] + e[13], 18);

          for (let t = 0; t < 16; ++t) f[t] += e[t];
        }

        function s(f, e, t, r) {
          for (let n = 0; n < r; n++) t[n] ^= f[e + n];
        }

        function u(f, e, t, r, n) {
          for (; n--;) t[r++] = f[e++];
        }

        function c(f) {
          if (!f || "number" != typeof f.length) return !1;

          for (let e = 0; e < f.length; e++) {
            const t = f[e];
            if ("number" != typeof t || t % 1 || t < 0 || t >= 256) return !1;
          }

          return !0;
        }

        function d(f, e) {
          if ("number" != typeof f || f % 1) throw new Error("invalid " + e);
          return f;
        }

        function b(f, e, r, a, o, b, l) {
          if (r = d(r, "N"), a = d(a, "r"), o = d(o, "p"), b = d(b, "dkLen"), 0 === r || 0 != (r & r - 1)) throw new Error("N must be power of 2");
          if (r > t / 128 / a) throw new Error("N too large");
          if (a > t / 128 / o) throw new Error("r too large");
          if (!c(f)) throw new Error("password must be an array or buffer");
          if (f = Array.prototype.slice.call(f), !c(e)) throw new Error("salt must be an array or buffer");
          e = Array.prototype.slice.call(e);
          let h = n(f, e, 128 * o * a);
          const p = new Uint32Array(32 * o * a);

          for (let f = 0; f < p.length; f++) {
            const e = 4 * f;
            p[f] = (255 & h[e + 3]) << 24 | (255 & h[e + 2]) << 16 | (255 & h[e + 1]) << 8 | (255 & h[e + 0]) << 0;
          }

          const m = new Uint32Array(64 * a),
                y = new Uint32Array(32 * a * r),
                g = 32 * a,
                v = new Uint32Array(16),
                w = new Uint32Array(16),
                E = o * r * 2;
          let S,
              A,
              x = 0,
              _ = null,
              M = !1,
              P = 0,
              T = 0;

          const O = l ? parseInt(1e3 / a) : 4294967295,
                C = "undefined" != typeof setImmediate ? setImmediate : setTimeout,
                R = function () {
            if (M) return l(new Error("cancelled"), x / E);
            let e;

            switch (P) {
              case 0:
                A = 32 * T * a, u(p, A, m, 0, g), P = 1, S = 0;

              case 1:
                e = r - S, e > O && (e = O);

                for (let f = 0; f < e; f++) u(m, 0, y, (S + f) * g, g), i(m, g, a, v, w);

                if (S += e, x += e, l) {
                  const f = parseInt(1e3 * x / E);

                  if (f !== _) {
                    if (M = l(null, x / E), M) break;
                    _ = f;
                  }
                }

                if (S < r) break;
                S = 0, P = 2;

              case 2:
                e = r - S, e > O && (e = O);

                for (let f = 0; f < e; f++) {
                  const f = m[16 * (2 * a - 1)] & r - 1;
                  s(y, f * g, m, g), i(m, g, a, v, w);
                }

                if (S += e, x += e, l) {
                  const f = parseInt(1e3 * x / E);

                  if (f !== _) {
                    if (M = l(null, x / E), M) break;
                    _ = f;
                  }
                }

                if (S < r) break;

                if (u(m, 0, p, A, g), T++, T < o) {
                  P = 0;
                  break;
                }

                h = [];

                for (let f = 0; f < p.length; f++) h.push(p[f] >> 0 & 255), h.push(p[f] >> 8 & 255), h.push(p[f] >> 16 & 255), h.push(p[f] >> 24 & 255);

                const t = n(f, h, b);
                return l && l(null, 1, t), t;
            }

            l && C(R);
          };

          if (!l) for (;;) {
            const f = R();
            if (null != f) return f;
          }
          R();
        }

        const l = {
          scrypt: function (f, e, t, r, n, i, a) {
            return new Promise(function (o, s) {
              let u = 0;
              a && a(0), b(f, e, t, r, n, i, function (f, e, t) {
                if (f) s(f);else if (t) a && 1 !== u && a(1), o(new Uint8Array(t));else if (a && e !== u) return u = e, a(e);
              });
            });
          },
          syncScrypt: function (f, e, t, r, n, i) {
            return new Uint8Array(b(f, e, t, r, n, i));
          }
        };
        f.exports = l;
      }();
    },
    3711: (f, e) => {
      "use strict";

      Object.defineProperty(e, "__esModule", {
        value: !0
      }), e.NULL_ADDRESS = e.ENS_DOMAIN = void 0, e.ENS_DOMAIN = "fds", e.NULL_ADDRESS = "0x0000000000000000000000000000000000000000";
    },
    148: (f, e, t) => {
      "use strict";

      Object.defineProperty(e, "__esModule", {
        value: !0
      }), e.getEnvironmentConfig = e.ENVIRONMENT_CONFIGS = void 0;
      const r = t(5526);
      e.ENVIRONMENT_CONFIGS = {
        [r.Environments.LOCALHOST]: {
          rpcUrl: "http://127.0.0.1:9545/",
          contractAddresses: {
            ensRegistry: "0x26b4AFb60d6C903165150C6F0AA14F8016bE4aec",
            fdsRegistrar: "0x630589690929E9cdEFDeF0734717a9eF3Ec7Fcfe",
            publicResolver: "0xA94B7f0465E98609391C623d0560C5720a3f2D33"
          },
          performChecks: !1
        }
      }, e.getEnvironmentConfig = function (f) {
        return e.ENVIRONMENT_CONFIGS[f];
      };
    },
    4647: function (f, e, t) {
      "use strict";

      var r = this && this.__createBinding || (Object.create ? function (f, e, t, r) {
        void 0 === r && (r = t);
        var n = Object.getOwnPropertyDescriptor(e, t);
        n && !("get" in n ? !e.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0,
          get: function () {
            return e[t];
          }
        }), Object.defineProperty(f, r, n);
      } : function (f, e, t, r) {
        void 0 === r && (r = t), f[r] = e[t];
      }),
          n = this && this.__exportStar || function (f, e) {
        for (var t in f) "default" === t || Object.prototype.hasOwnProperty.call(e, t) || r(e, f, t);
      };

      Object.defineProperty(e, "__esModule", {
        value: !0
      }), n(t(3711), e), n(t(148), e);
    },
    4432: function (f, e, t) {
      "use strict";

      var r = this && this.__createBinding || (Object.create ? function (f, e, t, r) {
        void 0 === r && (r = t);
        var n = Object.getOwnPropertyDescriptor(e, t);
        n && !("get" in n ? !e.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0,
          get: function () {
            return e[t];
          }
        }), Object.defineProperty(f, r, n);
      } : function (f, e, t, r) {
        void 0 === r && (r = t), f[r] = e[t];
      }),
          n = this && this.__exportStar || function (f, e) {
        for (var t in f) "default" === t || Object.prototype.hasOwnProperty.call(e, t) || r(e, f, t);
      };

      Object.defineProperty(e, "__esModule", {
        value: !0
      }), n(t(4647), e), n(t(4754), e), n(t(5753), e);
    },
    6130: (f, e) => {
      "use strict";

      Object.defineProperty(e, "__esModule", {
        value: !0
      });
    },
    3552: (f, e) => {
      "use strict";

      Object.defineProperty(e, "__esModule", {
        value: !0
      });
    },
    5526: (f, e) => {
      "use strict";

      Object.defineProperty(e, "__esModule", {
        value: !0
      }), e.Environments = void 0, function (f) {
        f[f.LOCALHOST = 0] = "LOCALHOST";
      }(e.Environments || (e.Environments = {}));
    },
    7880: (f, e) => {
      "use strict";

      Object.defineProperty(e, "__esModule", {
        value: !0
      }), e.PUBLIC_KEY_PART_LENGTH = e.PUBLIC_KEY_LENGTH = e.ETH_ADDRESS_LENGTH = void 0, e.ETH_ADDRESS_LENGTH = 42, e.PUBLIC_KEY_LENGTH = 132, e.PUBLIC_KEY_PART_LENGTH = (e.PUBLIC_KEY_LENGTH - 4) / 2 + 2;
    },
    5753: function (f, e, t) {
      "use strict";

      var r = this && this.__createBinding || (Object.create ? function (f, e, t, r) {
        void 0 === r && (r = t);
        var n = Object.getOwnPropertyDescriptor(e, t);
        n && !("get" in n ? !e.__esModule : n.writable || n.configurable) || (n = {
          enumerable: !0,
          get: function () {
            return e[t];
          }
        }), Object.defineProperty(f, r, n);
      } : function (f, e, t, r) {
        void 0 === r && (r = t), f[r] = e[t];
      }),
          n = this && this.__exportStar || function (f, e) {
        for (var t in f) "default" === t || Object.prototype.hasOwnProperty.call(e, t) || r(e, f, t);
      };

      Object.defineProperty(e, "__esModule", {
        value: !0
      }), n(t(6130), e), n(t(5526), e), n(t(3552), e), n(t(7880), e);
    },
    4754: function (f, e, t) {
      "use strict";

      var r = this && this.__awaiter || function (f, e, t, r) {
        return new (t || (t = Promise))(function (n, i) {
          function a(f) {
            try {
              s(r.next(f));
            } catch (f) {
              i(f);
            }
          }

          function o(f) {
            try {
              s(r.throw(f));
            } catch (f) {
              i(f);
            }
          }

          function s(f) {
            var e;
            f.done ? n(f.value) : (e = f.value, e instanceof t ? e : new t(function (f) {
              f(e);
            })).then(a, o);
          }

          s((r = r.apply(f, e || [])).next());
        });
      },
          n = this && this.__importDefault || function (f) {
        return f && f.__esModule ? f : {
          default: f
        };
      };

      Object.defineProperty(e, "__esModule", {
        value: !0
      }), e.ENS = e.FDSRegistrarContract = e.PublicResolverContract = e.ENSRegistryContract = void 0;
      const i = t(8670),
            a = t(3711),
            o = t(148),
            s = t(3269),
            u = t(3732),
            c = t(5526),
            d = n(t(9710)),
            b = n(t(8362)),
            l = n(t(5985)),
            h = t(488),
            p = t(4291),
            {
        keccak256: m,
        toUtf8Bytes: y,
        namehash: g
      } = i.utils;
      e.ENSRegistryContract = d.default, e.PublicResolverContract = b.default, e.FDSRegistrarContract = l.default;
      const v = i.BigNumber.from("10000000000000000");

      class w {
        constructor(f = o.ENVIRONMENT_CONFIGS[c.Environments.LOCALHOST], t = null, r = a.ENS_DOMAIN) {
          this.config = f, this.domain = r, this._provider = new i.providers.JsonRpcProvider(f.rpcUrl);
          const {
            ensRegistry: n,
            fdsRegistrar: s,
            publicResolver: u
          } = f.contractAddresses;
          this._ensRegistryContract = new i.Contract(n, e.ENSRegistryContract.abi, this._provider), this._publicResolverContract = new i.Contract(u, e.PublicResolverContract.abi, this._provider), this._fdsRegistrarContract = new i.Contract(s, e.FDSRegistrarContract.abi, this._provider), t && this.connect(t);
        }

        get provider() {
          return this._provider;
        }

        connect(f) {
          this._publicResolverContract = this._publicResolverContract.connect(f), this._fdsRegistrarContract = this._fdsRegistrarContract.connect(f), this._ensRegistryContract = this._ensRegistryContract.connect(f);
        }

        getUsernameOwner(f) {
          return r(this, void 0, void 0, function* () {
            (0, h.assertUsername)(f);
            const e = this.hashUsername(f);
            return this._ensRegistryContract.owner(e);
          });
        }

        isUsernameAvailable(f) {
          return r(this, void 0, void 0, function* () {
            (0, h.assertUsername)(f);
            return (yield this.getUsernameOwner(f)) === a.NULL_ADDRESS;
          });
        }

        registerUsername(f, e, t, n = 86400) {
          return r(this, void 0, void 0, function* () {
            try {
              (0, h.assertUsername)(f);
              let r = a.NULL_ADDRESS;
              if (this.config.performChecks && (yield (0, p.checkMinBalance)(this.provider, e, v), r = yield this.getUsernameOwner(f), r !== a.NULL_ADDRESS && r !== e)) throw new Error(`ENS: Username ${f} is not available`);
              r === a.NULL_ADDRESS && (yield (0, s.waitTransaction)(this._fdsRegistrarContract.register(m(y(f)), e, n))), yield (0, s.waitTransaction)(this._ensRegistryContract.setResolver(this.hashUsername(f), this._publicResolverContract.address)), yield this.setPublicKey(f, t);
            } catch (f) {
              if (console.error(f), (0, p.isTxError)(f)) throw new Error((0, p.extractMessageFromFailedTx)(f));
              throw f;
            }
          });
        }

        getPublicKey(f) {
          return r(this, void 0, void 0, function* () {
            (0, h.assertUsername)(f);
            const [e, t] = yield this._publicResolverContract.pubkey(this.hashUsername(f)),
                  r = (0, u.joinPublicKey)(e, t);
            if (!(0, u.isPublicKeyValid)(r)) throw new Error("Public key is not set or is invalid");
            return r;
          });
        }

        getUserData(f) {
          return (0, h.assertUsername)(f), this._publicResolverContract.getAll(this.hashUsername(f));
        }

        setPublicKey(f, e) {
          (0, h.assertUsername)(f);
          const [t, r] = (0, u.splitPublicKey)(e);
          return (0, s.waitTransaction)(this._publicResolverContract.setPubkey(this.hashUsername(f), t, r));
        }

        hashUsername(f) {
          return g(`${f}.${this.domain}`);
        }

      }

      e.ENS = w, e.default = w;
    },
    2149: (f, e) => {
      "use strict";

      Object.defineProperty(e, "__esModule", {
        value: !0
      }), e.assert = void 0, e.assert = function (f, e) {
        if (!f) throw new Error(e);
      };
    },
    4291: function (f, e) {
      "use strict";

      var t = this && this.__awaiter || function (f, e, t, r) {
        return new (t || (t = Promise))(function (n, i) {
          function a(f) {
            try {
              s(r.next(f));
            } catch (f) {
              i(f);
            }
          }

          function o(f) {
            try {
              s(r.throw(f));
            } catch (f) {
              i(f);
            }
          }

          function s(f) {
            var e;
            f.done ? n(f.value) : (e = f.value, e instanceof t ? e : new t(function (f) {
              f(e);
            })).then(a, o);
          }

          s((r = r.apply(f, e || [])).next());
        });
      };

      function r(f) {
        var e, t;
        const r = f;
        return Boolean(r.id && "string" == typeof (null === (e = r.error) || void 0 === e ? void 0 : e.message) && (null === (t = r.error) || void 0 === t ? void 0 : t.message.indexOf("revert")) > 0);
      }

      function n(f) {
        const {
          message: e
        } = f.error;
        return e.substring(e.indexOf("revert") + 7);
      }

      Object.defineProperty(e, "__esModule", {
        value: !0
      }), e.extractMessageFromFailedTx = e.extractGanacheErrorMessage = e.isGanacheError = e.isTxError = e.checkMinBalance = void 0, e.checkMinBalance = function (f, e, r) {
        return t(this, void 0, void 0, function* () {
          if ((yield f.getBalance(e)) < r) throw new Error("Not enough funds");
        });
      }, e.isTxError = function (f) {
        const e = f;
        return Boolean(e.error && "string" == typeof e.code && "string" == typeof e.reason);
      }, e.isGanacheError = r, e.extractGanacheErrorMessage = n, e.extractMessageFromFailedTx = function (f) {
        const e = JSON.parse(f.error.body);
        if (r(e)) return n(e);
        throw e;
      };
    },
    488: (f, e, t) => {
      "use strict";

      Object.defineProperty(e, "__esModule", {
        value: !0
      }), e.assertUsername = e.isUsername = void 0;
      const r = t(2149);

      function n(f) {
        if (!f || "string" != typeof f) return !1;
        const e = f.match(/^[a-z0-9_-]*$/),
              t = f.match(/^[A-Z]*$/);
        return f.length < 83 && f.length > 3 && null !== e && e.length > 0 && null === t;
      }

      e.isUsername = n, e.assertUsername = function (f) {
        (0, r.assert)(n(f), "Username is not valid.");
      };
    },
    3732: (f, e, t) => {
      "use strict";

      Object.defineProperty(e, "__esModule", {
        value: !0
      }), e.joinPublicKey = e.splitPublicKey = e.isPublicKeyValid = e.isHexStringPublicKeyPart = e.isHexStringPublicKey = e.isHexString = void 0;
      const r = t(8670),
            n = t(6371),
            i = t(7880),
            a = t(2149),
            {
        hexStripZeros: o
      } = r.utils;

      function s(f) {
        return (0, n.isHexString)(f);
      }

      function u(f) {
        return s(f) && f.length === i.PUBLIC_KEY_LENGTH;
      }

      function c(f) {
        return s(f) && f.length === i.PUBLIC_KEY_PART_LENGTH;
      }

      function d(f) {
        return u(f) && "0x" !== o("0x" + f.substring(4));
      }

      e.isHexString = s, e.isHexStringPublicKey = u, e.isHexStringPublicKeyPart = c, e.isPublicKeyValid = d, e.splitPublicKey = function (f) {
        return (0, a.assert)(d(f), "Public key is not valid."), ["0x" + f.substring(4, i.PUBLIC_KEY_PART_LENGTH + 2), "0x" + f.substring(i.PUBLIC_KEY_PART_LENGTH + 2, i.PUBLIC_KEY_LENGTH + 2)];
      }, e.joinPublicKey = function (f, e) {
        return (0, a.assert)(c(f) && c(e), "One or both public key parts are not hex strings."), "0x04" + f.substring(2) + e.substring(2);
      };
    },
    3269: function (f, e) {
      "use strict";

      var t = this && this.__awaiter || function (f, e, t, r) {
        return new (t || (t = Promise))(function (n, i) {
          function a(f) {
            try {
              s(r.next(f));
            } catch (f) {
              i(f);
            }
          }

          function o(f) {
            try {
              s(r.throw(f));
            } catch (f) {
              i(f);
            }
          }

          function s(f) {
            var e;
            f.done ? n(f.value) : (e = f.value, e instanceof t ? e : new t(function (f) {
              f(e);
            })).then(a, o);
          }

          s((r = r.apply(f, e || [])).next());
        });
      };

      Object.defineProperty(e, "__esModule", {
        value: !0
      }), e.waitTransaction = void 0, e.waitTransaction = function (f) {
        return t(this, void 0, void 0, function* () {
          const e = yield f;
          yield e.wait();
        });
      };
    },
    8670: e => {
      "use strict";

      e.exports = f;
    },
    6601: () => {},
    9710: f => {
      "use strict";

      f.exports = JSON.parse('{"_format":"hh-sol-artifact-1","contractName":"ENSRegistry","sourceName":"contracts/ENSRegistry.sol","abi":[{"inputs":[],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":false,"internalType":"bool","name":"approved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":true,"internalType":"bytes32","name":"label","type":"bytes32"},{"indexed":false,"internalType":"address","name":"owner","type":"address"}],"name":"NewOwner","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"address","name":"resolver","type":"address"}],"name":"NewResolver","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"uint64","name":"ttl","type":"uint64"}],"name":"NewTTL","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"address","name":"owner","type":"address"}],"name":"Transfer","type":"event"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"recordExists","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"resolver","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"address","name":"owner","type":"address"}],"name":"setOwner","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"resolver","type":"address"},{"internalType":"uint64","name":"ttl","type":"uint64"}],"name":"setRecord","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"address","name":"resolver","type":"address"}],"name":"setResolver","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"bytes32","name":"label","type":"bytes32"},{"internalType":"address","name":"owner","type":"address"}],"name":"setSubnodeOwner","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"bytes32","name":"label","type":"bytes32"},{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"resolver","type":"address"},{"internalType":"uint64","name":"ttl","type":"uint64"}],"name":"setSubnodeRecord","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"},{"internalType":"uint64","name":"ttl","type":"uint64"}],"name":"setTTL","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"node","type":"bytes32"}],"name":"ttl","outputs":[{"internalType":"uint64","name":"","type":"uint64"}],"stateMutability":"view","type":"function"}],"bytecode":"0x608060405234801561001057600080fd5b50336000808060001b815260200190815260200160002060000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550610fd5806100776000396000f3fe608060405234801561001057600080fd5b50600436106100b45760003560e01c80635b0fc9c3116100715780635b0fc9c3146101b15780635ef2c7f0146101cd578063a22cb465146101e9578063cf40882314610205578063e985e9c514610221578063f79fe53814610251576100b4565b80630178b8bf146100b957806302571be3146100e957806306ab59231461011957806314ab90381461014957806316a25cbd146101655780631896f70a14610195575b600080fd5b6100d360048036038101906100ce9190610c28565b610281565b6040516100e09190610e71565b60405180910390f35b61010360048036038101906100fe9190610c28565b6102c0565b6040516101109190610e71565b60405180910390f35b610133600480360381019061012e9190610cf0565b610343565b6040516101409190610ea7565b60405180910390f35b610163600480360381019061015e9190610db6565b610435565b005b61017f600480360381019061017a9190610c28565b610522565b60405161018c9190610ec2565b60405180910390f35b6101af60048036038101906101aa9190610c51565b610555565b005b6101cb60048036038101906101c69190610c51565b61065a565b005b6101e760048036038101906101e29190610d3f565b610715565b005b61020360048036038101906101fe9190610bec565b610737565b005b61021f600480360381019061021a9190610c8d565b610834565b005b61023b60048036038101906102369190610bb0565b61084f565b6040516102489190610e8c565b60405180910390f35b61026b60048036038101906102669190610c28565b6108e3565b6040516102789190610e8c565b60405180910390f35b600080600083815260200190815260200160002060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050919050565b60008060008084815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690503073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16141561033957600091505061033e565b809150505b919050565b600083600080600083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690503373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16146103b857600080fd5b600086866040516020016103cd929190610e45565b6040516020818303038152906040528051906020012090506103ef8186610951565b85877fce0457fe73731f824cc272376169235128c118b49d344817417c6d108d155e82876040516104209190610e71565b60405180910390a38093505050509392505050565b81600080600083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690503373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16146104a857600080fd5b837f1d4f9bbfc9cab89d66e1a1562f2233ccbf1308cb4f63de2ead5787adddb8fa68846040516104d89190610ec2565b60405180910390a28260008086815260200190815260200160002060010160146101000a81548167ffffffffffffffff021916908367ffffffffffffffff16021790555050505050565b600080600083815260200190815260200160002060010160149054906101000a900467ffffffffffffffff169050919050565b81600080600083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690503373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16146105c857600080fd5b837f335721b01866dc23fbee8b6b2c7b1e14d6f05c28cd35a2c934239f94095602a0846040516105f89190610e71565b60405180910390a28260008086815260200190815260200160002060010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050505050565b81600080600083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690503373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16146106cd57600080fd5b6106d78484610951565b837fd4735d920b0f87494915f556dd9b54c8f309026070caea5c737245152564d266846040516107079190610e71565b60405180910390a250505050565b6000610722868686610343565b905061072f8184846109a9565b505050505050565b80600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055508173ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31836040516108289190610e8c565b60405180910390a35050565b61083e848461065a565b6108498483836109a9565b50505050565b6000600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16905092915050565b60008073ffffffffffffffffffffffffffffffffffffffff1660008084815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614159050919050565b8060008084815260200190815260200160002060000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505050565b60008084815260200190815260200160002060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1614610a9e578160008085815260200190815260200160002060010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550827f335721b01866dc23fbee8b6b2c7b1e14d6f05c28cd35a2c934239f94095602a083604051610a959190610e71565b60405180910390a25b60008084815260200190815260200160002060010160149054906101000a900467ffffffffffffffff1667ffffffffffffffff168167ffffffffffffffff1614610b57578060008085815260200190815260200160002060010160146101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550827f1d4f9bbfc9cab89d66e1a1562f2233ccbf1308cb4f63de2ead5787adddb8fa6882604051610b4e9190610ec2565b60405180910390a25b505050565b600081359050610b6b81610f43565b92915050565b600081359050610b8081610f5a565b92915050565b600081359050610b9581610f71565b92915050565b600081359050610baa81610f88565b92915050565b60008060408385031215610bc357600080fd5b6000610bd185828601610b5c565b9250506020610be285828601610b5c565b9150509250929050565b60008060408385031215610bff57600080fd5b6000610c0d85828601610b5c565b9250506020610c1e85828601610b71565b9150509250929050565b600060208284031215610c3a57600080fd5b6000610c4884828501610b86565b91505092915050565b60008060408385031215610c6457600080fd5b6000610c7285828601610b86565b9250506020610c8385828601610b5c565b9150509250929050565b60008060008060808587031215610ca357600080fd5b6000610cb187828801610b86565b9450506020610cc287828801610b5c565b9350506040610cd387828801610b5c565b9250506060610ce487828801610b9b565b91505092959194509250565b600080600060608486031215610d0557600080fd5b6000610d1386828701610b86565b9350506020610d2486828701610b86565b9250506040610d3586828701610b5c565b9150509250925092565b600080600080600060a08688031215610d5757600080fd5b6000610d6588828901610b86565b9550506020610d7688828901610b86565b9450506040610d8788828901610b5c565b9350506060610d9888828901610b5c565b9250506080610da988828901610b9b565b9150509295509295909350565b60008060408385031215610dc957600080fd5b6000610dd785828601610b86565b9250506020610de885828601610b9b565b9150509250929050565b610dfb81610edd565b82525050565b610e0a81610eef565b82525050565b610e1981610efb565b82525050565b610e30610e2b82610efb565b610f39565b82525050565b610e3f81610f25565b82525050565b6000610e518285610e1f565b602082019150610e618284610e1f565b6020820191508190509392505050565b6000602082019050610e866000830184610df2565b92915050565b6000602082019050610ea16000830184610e01565b92915050565b6000602082019050610ebc6000830184610e10565b92915050565b6000602082019050610ed76000830184610e36565b92915050565b6000610ee882610f05565b9050919050565b60008115159050919050565b6000819050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600067ffffffffffffffff82169050919050565b6000819050919050565b610f4c81610edd565b8114610f5757600080fd5b50565b610f6381610eef565b8114610f6e57600080fd5b50565b610f7a81610efb565b8114610f8557600080fd5b50565b610f9181610f25565b8114610f9c57600080fd5b5056fea26469706673582212207b290780492f1f5b9cb3bdc533d6b70a3276e01a487785409c93465ff06fda6b64736f6c63430008040033","deployedBytecode":"0x608060405234801561001057600080fd5b50600436106100b45760003560e01c80635b0fc9c3116100715780635b0fc9c3146101b15780635ef2c7f0146101cd578063a22cb465146101e9578063cf40882314610205578063e985e9c514610221578063f79fe53814610251576100b4565b80630178b8bf146100b957806302571be3146100e957806306ab59231461011957806314ab90381461014957806316a25cbd146101655780631896f70a14610195575b600080fd5b6100d360048036038101906100ce9190610c28565b610281565b6040516100e09190610e71565b60405180910390f35b61010360048036038101906100fe9190610c28565b6102c0565b6040516101109190610e71565b60405180910390f35b610133600480360381019061012e9190610cf0565b610343565b6040516101409190610ea7565b60405180910390f35b610163600480360381019061015e9190610db6565b610435565b005b61017f600480360381019061017a9190610c28565b610522565b60405161018c9190610ec2565b60405180910390f35b6101af60048036038101906101aa9190610c51565b610555565b005b6101cb60048036038101906101c69190610c51565b61065a565b005b6101e760048036038101906101e29190610d3f565b610715565b005b61020360048036038101906101fe9190610bec565b610737565b005b61021f600480360381019061021a9190610c8d565b610834565b005b61023b60048036038101906102369190610bb0565b61084f565b6040516102489190610e8c565b60405180910390f35b61026b60048036038101906102669190610c28565b6108e3565b6040516102789190610e8c565b60405180910390f35b600080600083815260200190815260200160002060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050919050565b60008060008084815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690503073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16141561033957600091505061033e565b809150505b919050565b600083600080600083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690503373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16146103b857600080fd5b600086866040516020016103cd929190610e45565b6040516020818303038152906040528051906020012090506103ef8186610951565b85877fce0457fe73731f824cc272376169235128c118b49d344817417c6d108d155e82876040516104209190610e71565b60405180910390a38093505050509392505050565b81600080600083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690503373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16146104a857600080fd5b837f1d4f9bbfc9cab89d66e1a1562f2233ccbf1308cb4f63de2ead5787adddb8fa68846040516104d89190610ec2565b60405180910390a28260008086815260200190815260200160002060010160146101000a81548167ffffffffffffffff021916908367ffffffffffffffff16021790555050505050565b600080600083815260200190815260200160002060010160149054906101000a900467ffffffffffffffff169050919050565b81600080600083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690503373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16146105c857600080fd5b837f335721b01866dc23fbee8b6b2c7b1e14d6f05c28cd35a2c934239f94095602a0846040516105f89190610e71565b60405180910390a28260008086815260200190815260200160002060010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050505050565b81600080600083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690503373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16146106cd57600080fd5b6106d78484610951565b837fd4735d920b0f87494915f556dd9b54c8f309026070caea5c737245152564d266846040516107079190610e71565b60405180910390a250505050565b6000610722868686610343565b905061072f8184846109a9565b505050505050565b80600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055508173ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c31836040516108289190610e8c565b60405180910390a35050565b61083e848461065a565b6108498483836109a9565b50505050565b6000600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16905092915050565b60008073ffffffffffffffffffffffffffffffffffffffff1660008084815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614159050919050565b8060008084815260200190815260200160002060000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505050565b60008084815260200190815260200160002060010160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1614610a9e578160008085815260200190815260200160002060010160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550827f335721b01866dc23fbee8b6b2c7b1e14d6f05c28cd35a2c934239f94095602a083604051610a959190610e71565b60405180910390a25b60008084815260200190815260200160002060010160149054906101000a900467ffffffffffffffff1667ffffffffffffffff168167ffffffffffffffff1614610b57578060008085815260200190815260200160002060010160146101000a81548167ffffffffffffffff021916908367ffffffffffffffff160217905550827f1d4f9bbfc9cab89d66e1a1562f2233ccbf1308cb4f63de2ead5787adddb8fa6882604051610b4e9190610ec2565b60405180910390a25b505050565b600081359050610b6b81610f43565b92915050565b600081359050610b8081610f5a565b92915050565b600081359050610b9581610f71565b92915050565b600081359050610baa81610f88565b92915050565b60008060408385031215610bc357600080fd5b6000610bd185828601610b5c565b9250506020610be285828601610b5c565b9150509250929050565b60008060408385031215610bff57600080fd5b6000610c0d85828601610b5c565b9250506020610c1e85828601610b71565b9150509250929050565b600060208284031215610c3a57600080fd5b6000610c4884828501610b86565b91505092915050565b60008060408385031215610c6457600080fd5b6000610c7285828601610b86565b9250506020610c8385828601610b5c565b9150509250929050565b60008060008060808587031215610ca357600080fd5b6000610cb187828801610b86565b9450506020610cc287828801610b5c565b9350506040610cd387828801610b5c565b9250506060610ce487828801610b9b565b91505092959194509250565b600080600060608486031215610d0557600080fd5b6000610d1386828701610b86565b9350506020610d2486828701610b86565b9250506040610d3586828701610b5c565b9150509250925092565b600080600080600060a08688031215610d5757600080fd5b6000610d6588828901610b86565b9550506020610d7688828901610b86565b9450506040610d8788828901610b5c565b9350506060610d9888828901610b5c565b9250506080610da988828901610b9b565b9150509295509295909350565b60008060408385031215610dc957600080fd5b6000610dd785828601610b86565b9250506020610de885828601610b9b565b9150509250929050565b610dfb81610edd565b82525050565b610e0a81610eef565b82525050565b610e1981610efb565b82525050565b610e30610e2b82610efb565b610f39565b82525050565b610e3f81610f25565b82525050565b6000610e518285610e1f565b602082019150610e618284610e1f565b6020820191508190509392505050565b6000602082019050610e866000830184610df2565b92915050565b6000602082019050610ea16000830184610e01565b92915050565b6000602082019050610ebc6000830184610e10565b92915050565b6000602082019050610ed76000830184610e36565b92915050565b6000610ee882610f05565b9050919050565b60008115159050919050565b6000819050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600067ffffffffffffffff82169050919050565b6000819050919050565b610f4c81610edd565b8114610f5757600080fd5b50565b610f6381610eef565b8114610f6e57600080fd5b50565b610f7a81610efb565b8114610f8557600080fd5b50565b610f9181610f25565b8114610f9c57600080fd5b5056fea26469706673582212207b290780492f1f5b9cb3bdc533d6b70a3276e01a487785409c93465ff06fda6b64736f6c63430008040033","linkReferences":{},"deployedLinkReferences":{}}');
    },
    5985: f => {
      "use strict";

      f.exports = JSON.parse('{"_format":"hh-sol-artifact-1","contractName":"FDSRegistrar","sourceName":"contracts/FDSRegistrar.sol","abi":[{"inputs":[{"internalType":"contract ENS","name":"_ens","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"approved","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"operator","type":"address"},{"indexed":false,"internalType":"bool","name":"approved","type":"bool"}],"name":"ApprovalForAll","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"controller","type":"address"}],"name":"ControllerAdded","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"controller","type":"address"}],"name":"ControllerRemoved","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"id","type":"uint256"},{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":false,"internalType":"uint256","name":"expires","type":"uint256"}],"name":"NameMigrated","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"id","type":"uint256"},{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":false,"internalType":"uint256","name":"expires","type":"uint256"}],"name":"NameRegistered","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"uint256","name":"id","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"expires","type":"uint256"}],"name":"NameRenewed","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"previousOwner","type":"address"},{"indexed":true,"internalType":"address","name":"newOwner","type":"address"}],"name":"OwnershipTransferred","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":true,"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"Transfer","type":"event"},{"inputs":[],"name":"GRACE_PERIOD","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"controller","type":"address"}],"name":"addController","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"approve","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"available","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"baseNode","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"","type":"address"}],"name":"controllers","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"ens","outputs":[{"internalType":"contract ENS","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"getApproved","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"operator","type":"address"}],"name":"isApprovedForAll","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"}],"name":"nameExpires","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"owner","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"ownerOf","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"address","name":"owner","type":"address"}],"name":"reclaim","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"address","name":"owner","type":"address"},{"internalType":"uint256","name":"duration","type":"uint256"}],"name":"register","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"address","name":"owner","type":"address"},{"internalType":"uint256","name":"duration","type":"uint256"}],"name":"registerOnly","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"controller","type":"address"}],"name":"removeController","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"uint256","name":"id","type":"uint256"},{"internalType":"uint256","name":"duration","type":"uint256"}],"name":"renew","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"stateMutability":"nonpayable","type":"function"},{"inputs":[],"name":"renounceOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"},{"internalType":"bytes","name":"_data","type":"bytes"}],"name":"safeTransferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"operator","type":"address"},{"internalType":"bool","name":"approved","type":"bool"}],"name":"setApprovalForAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"resolver","type":"address"}],"name":"setResolver","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes4","name":"interfaceID","type":"bytes4"}],"name":"supportsInterface","outputs":[{"internalType":"bool","name":"","type":"bool"}],"stateMutability":"view","type":"function"},{"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"tokenURI","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"tokenId","type":"uint256"}],"name":"transferFrom","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"address","name":"newOwner","type":"address"}],"name":"transferOwnership","outputs":[],"stateMutability":"nonpayable","type":"function"}],"bytecode":"0x60806040523480156200001157600080fd5b5060405162003cc338038062003cc38339818101604052810190620000379190620002e0565b6040518060200160405280600081525060405180602001604052806000815250620000776200006b6200014d60201b60201c565b6200015560201b60201c565b81600190805190602001906200008f92919062000219565b508060029080519060200190620000a892919062000219565b50505080600760006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000801b60405160200162000101906200037e565b604051602081830303815290604052805190602001206040516020016200012a9291906200034e565b6040516020818303038152906040528051906020012060088190555050620004a4565b600033905090565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b8280546200022790620003f2565b90600052602060002090601f0160209004810192826200024b576000855562000297565b82601f106200026657805160ff191683800117855562000297565b8280016001018555821562000297579182015b828111156200029657825182559160200191906001019062000279565b5b509050620002a69190620002aa565b5090565b5b80821115620002c5576000816000905550600101620002ab565b5090565b600081519050620002da816200048a565b92915050565b600060208284031215620002f357600080fd5b60006200030384828501620002c9565b91505092915050565b620003216200031b82620003b4565b62000428565b82525050565b60006200033660038362000395565b9150620003438262000461565b600382019050919050565b60006200035c82856200030c565b6020820191506200036e82846200030c565b6020820191508190509392505050565b60006200038b8262000327565b9150819050919050565b600081905092915050565b6000620003ad82620003d2565b9050919050565b6000819050919050565b6000620003cb82620003a0565b9050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600060028204905060018216806200040b57607f821691505b6020821081141562000422576200042162000432565b5b50919050565b6000819050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b7f6664730000000000000000000000000000000000000000000000000000000000600082015250565b6200049581620003be565b8114620004a157600080fd5b50565b61380f80620004b46000396000f3fe608060405234801561001057600080fd5b50600436106101cf5760003560e01c806395d89b4111610104578063c87b56dd116100a2578063e985e9c511610071578063e985e9c514610552578063f2fde38b14610582578063f6a74ed71461059e578063fca247ac146105ba576101cf565b8063c87b56dd146104a4578063d6e4fa86146104d4578063da8c229e14610504578063ddf7fcb014610534576101cf565b8063a7fc7a07116100de578063a7fc7a071461041e578063b88d4fde1461043a578063c1a287e214610456578063c475abff14610474576101cf565b806395d89b41146103b457806396e494e8146103d2578063a22cb46514610402576101cf565b80633f15457f116101715780636352211e1161014b5780636352211e1461032c57806370a082311461035c578063715018a61461038c5780638da5cb5b14610396576101cf565b80633f15457f146102d657806342842e0e146102f45780634e543b2614610310576101cf565b8063095ea7b3116101ad578063095ea7b3146102525780630e297b451461026e57806323b872dd1461029e57806328ed4f6c146102ba576101cf565b806301ffc9a7146101d457806306fdde0314610204578063081812fc14610222575b600080fd5b6101ee60048036038101906101e991906127e5565b6105ea565b6040516101fb9190612cad565b60405180910390f35b61020c610834565b6040516102199190612d5e565b60405180910390f35b61023c60048036038101906102379190612837565b6108c6565b6040516102499190612c46565b60405180910390f35b61026c60048036038101906102679190612780565b61094b565b005b6102886004803603810190610283919061289c565b610a63565b6040516102959190612f60565b60405180910390f35b6102b860048036038101906102b3919061267a565b610a7b565b005b6102d460048036038101906102cf9190612860565b610adb565b005b6102de610ba9565b6040516102eb9190612d43565b60405180910390f35b61030e6004803603810190610309919061267a565b610bcf565b005b61032a60048036038101906103259190612615565b610bef565b005b61034660048036038101906103419190612837565b610cff565b6040516103539190612c46565b60405180910390f35b61037660048036038101906103719190612615565b610d30565b6040516103839190612f60565b60405180910390f35b610394610de8565b005b61039e610e70565b6040516103ab9190612c46565b60405180910390f35b6103bc610e99565b6040516103c99190612d5e565b60405180910390f35b6103ec60048036038101906103e79190612837565b610f2b565b6040516103f99190612cad565b60405180910390f35b61041c60048036038101906104179190612744565b610f58565b005b61043860048036038101906104339190612615565b610f6e565b005b610454600480360381019061044f91906126c9565b611088565b005b61045e6110ea565b60405161046b9190612f60565b60405180910390f35b61048e600480360381019061048991906128eb565b6110f1565b60405161049b9190612f60565b60405180910390f35b6104be60048036038101906104b99190612837565b6111f8565b6040516104cb9190612d5e565b60405180910390f35b6104ee60048036038101906104e99190612837565b61129f565b6040516104fb9190612f60565b60405180910390f35b61051e60048036038101906105199190612615565b6112bc565b60405161052b9190612cad565b60405180910390f35b61053c6112dc565b6040516105499190612cc8565b60405180910390f35b61056c6004803603810190610567919061263e565b6112e2565b6040516105799190612cad565b60405180910390f35b61059c60048036038101906105979190612615565b611376565b005b6105b860048036038101906105b39190612615565b61146e565b005b6105d460048036038101906105cf919061289c565b611588565b6040516105e19190612f60565b60405180910390f35b60007f01ffc9a7a5cef8baa21ed3c5c0d7e23accb804b619e9333b597f47a0d84076e27bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614806107c557507fb88d4fde60196325a28bb7f99a2582e0b46de55b18761e960c14ad7a320994657f42842e0eb38857a7775b4e7364b2775df7325074d088e7fb39590cd6281184ed7f23b872dd7302113369cda2901243429419bec145408fa8b352b3dd92b66c680b7fe985e9c5c6636c6879256001057b28ccac7718ef0ac56553ff9b926452cab8a37fa22cb4651ab9570f89bb516380c40ce76762284fb1f21337ceaf6adab99e7d4a7f081812fc55e34fdc7cf5d8b5cf4e3621fa6423fde952ec6ab24afdc0d85c0b2e7f095ea7b334ae44009aa867bfb386f5c3b4b443ac6f0ee573fa91c4608fbadfba7f6352211e6566aa027e75ac9dbf2423197fbd9b82b9d981a3ab367d355866aa1c7f70a08231b98ef4ca268c9cc3f6b4590e4bfec28280db06bb5d45e689f2a360be18181818181818187bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b8061082d57507f28ed4f6c74b219a5819055dfbcd2f1837c046c364cf01fabb6799e4f440d6f137bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b9050919050565b606060018054610843906131b3565b80601f016020809104026020016040519081016040528092919081815260200182805461086f906131b3565b80156108bc5780601f10610891576101008083540402835291602001916108bc565b820191906000526020600020905b81548152906001019060200180831161089f57829003601f168201915b5050505050905090565b60006108d1826115a0565b610910576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161090790612ec0565b60405180910390fd5b6005600083815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050919050565b60006109568261160c565b90508073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614156109c7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109be90612f20565b60405180910390fd5b8073ffffffffffffffffffffffffffffffffffffffff166109e66116be565b73ffffffffffffffffffffffffffffffffffffffff161480610a155750610a1481610a0f6116be565b6112e2565b5b610a54576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a4b90612e40565b60405180910390fd5b610a5e83836116c6565b505050565b6000610a72848484600061177f565b90509392505050565b610a8c610a866116be565b82611927565b610acb576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ac290612f40565b60405180910390fd5b610ad68383836119bc565b505050565b610ae53383611927565b610aee57600080fd5b600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166306ab59236008548460001b846040518463ffffffff1660e01b8152600401610b5293929190612d0c565b602060405180830381600087803b158015610b6c57600080fd5b505af1158015610b80573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ba491906127bc565b505050565b600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b610bea83838360405180602001604052806000815250611088565b505050565b610bf76116be565b73ffffffffffffffffffffffffffffffffffffffff16610c15610e70565b73ffffffffffffffffffffffffffffffffffffffff1614610c6b576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c6290612ee0565b60405180910390fd5b600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16631896f70a600854836040518363ffffffff1660e01b8152600401610cca929190612ce3565b600060405180830381600087803b158015610ce457600080fd5b505af1158015610cf8573d6000803e3d6000fd5b5050505050565b600042600a60008481526020019081526020016000205411610d2057600080fd5b610d298261160c565b9050919050565b60008073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff161415610da1576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610d9890612e60565b60405180910390fd5b600460008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b610df06116be565b73ffffffffffffffffffffffffffffffffffffffff16610e0e610e70565b73ffffffffffffffffffffffffffffffffffffffff1614610e64576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610e5b90612ee0565b60405180910390fd5b610e6e6000611c23565b565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b606060028054610ea8906131b3565b80601f0160208091040260200160405190810160405280929190818152602001828054610ed4906131b3565b8015610f215780601f10610ef657610100808354040283529160200191610f21565b820191906000526020600020905b815481529060010190602001808311610f0457829003601f168201915b5050505050905090565b6000426276a700600a600085815260200190815260200160002054610f509190613014565b109050919050565b610f6a610f636116be565b8383611ce7565b5050565b610f766116be565b73ffffffffffffffffffffffffffffffffffffffff16610f94610e70565b73ffffffffffffffffffffffffffffffffffffffff1614610fea576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610fe190612ee0565b60405180910390fd5b6001600960008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055508073ffffffffffffffffffffffffffffffffffffffff167f0a8bb31534c0ed46f380cb867bd5c803a189ced9a764e30b3a4991a9901d747460405160405180910390a250565b6110996110936116be565b83611927565b6110d8576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016110cf90612f40565b60405180910390fd5b6110e484848484611e54565b50505050565b6276a70081565b6000426276a700600a6000868152602001908152602001600020546111169190613014565b101561112157600080fd5b6276a700826111309190613014565b6276a70083600a6000878152602001908152602001600020546111539190613014565b61115d9190613014565b1161116757600080fd5b81600a6000858152602001908152602001600020600082825461118a9190613014565b92505081905550827f9b87a00e30f1ac65d898f070f8a3488fe60517182d0a2098e1b4b93a54aa9bd6600a6000868152602001908152602001600020546040516111d49190612f60565b60405180910390a2600a600084815260200190815260200160002054905092915050565b6060611203826115a0565b611242576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161123990612f00565b60405180910390fd5b600061124c611eb0565b9050600081511161126c5760405180602001604052806000815250611297565b8061127684611ec7565b604051602001611287929190612c22565b6040516020818303038152906040525b915050919050565b6000600a6000838152602001908152602001600020549050919050565b60096020528060005260406000206000915054906101000a900460ff1681565b60085481565b6000600660008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16905092915050565b61137e6116be565b73ffffffffffffffffffffffffffffffffffffffff1661139c610e70565b73ffffffffffffffffffffffffffffffffffffffff16146113f2576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016113e990612ee0565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161415611462576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161145990612da0565b60405180910390fd5b61146b81611c23565b50565b6114766116be565b73ffffffffffffffffffffffffffffffffffffffff16611494610e70565b73ffffffffffffffffffffffffffffffffffffffff16146114ea576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016114e190612ee0565b60405180910390fd5b6000600960008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055508073ffffffffffffffffffffffffffffffffffffffff167f33d83959be2573f5453b12eb9d43b3499bc57d96bd2f067ba44803c859e8111360405160405180910390a250565b6000611597848484600161177f565b90509392505050565b60008073ffffffffffffffffffffffffffffffffffffffff166003600084815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614159050919050565b6000806003600084815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614156116b5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016116ac90612e80565b60405180910390fd5b80915050919050565b600033905090565b816005600083815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550808273ffffffffffffffffffffffffffffffffffffffff166117398361160c565b73ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a45050565b60006276a700426117909190613014565b6276a70084426117a09190613014565b6117aa9190613014565b116117b457600080fd5b82426117c09190613014565b600a6000878152602001908152602001600020819055506117e0856115a0565b156117ef576117ee85612074565b5b6117f98486612191565b81156118b757600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166306ab59236008548760001b876040518463ffffffff1660e01b815260040161186393929190612d0c565b602060405180830381600087803b15801561187d57600080fd5b505af1158015611891573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118b591906127bc565b505b8373ffffffffffffffffffffffffffffffffffffffff16857fb3d987963d01b2f68493b4bdb130988f157ea43070d4ad840fee0466ed9370d985426118fc9190613014565b6040516119099190612f60565b60405180910390a3824261191d9190613014565b9050949350505050565b60008061193383610cff565b90508073ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1614806119a257508373ffffffffffffffffffffffffffffffffffffffff1661198a846108c6565b73ffffffffffffffffffffffffffffffffffffffff16145b806119b357506119b281856112e2565b5b91505092915050565b8273ffffffffffffffffffffffffffffffffffffffff166119dc8261160c565b73ffffffffffffffffffffffffffffffffffffffff1614611a32576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611a2990612dc0565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff161415611aa2576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611a9990612e00565b60405180910390fd5b611aad83838361236b565b611ab86000826116c6565b6001600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254611b08919061309b565b925050819055506001600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254611b5f9190613014565b92505081905550816003600083815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550808273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60405160405180910390a4611c1e838383612370565b505050565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff161415611d56576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611d4d90612e20565b60405180910390fd5b80600660008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055508173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c3183604051611e479190612cad565b60405180910390a3505050565b611e5f8484846119bc565b611e6b84848484612375565b611eaa576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611ea190612d80565b60405180910390fd5b50505050565b606060405180602001604052806000815250905090565b60606000821415611f0f576040518060400160405280600181526020017f3000000000000000000000000000000000000000000000000000000000000000815250905061206f565b600082905060005b60008214611f41578080611f2a90613216565b915050600a82611f3a919061306a565b9150611f17565b60008167ffffffffffffffff811115611f83577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f191660200182016040528015611fb55781602001600182028036833780820191505090505b5090505b6000851461206857600182611fce919061309b565b9150600a85611fdd919061325f565b6030611fe99190613014565b60f81b818381518110612025577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350600a85612061919061306a565b9450611fb9565b8093505050505b919050565b600061207f8261160c565b905061208d8160008461236b565b6120986000836116c6565b6001600460008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546120e8919061309b565b925050819055506003600083815260200190815260200160002060006101000a81549073ffffffffffffffffffffffffffffffffffffffff021916905581600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60405160405180910390a461218d81600084612370565b5050565b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff161415612201576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016121f890612ea0565b60405180910390fd5b61220a816115a0565b1561224a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161224190612de0565b60405180910390fd5b6122566000838361236b565b6001600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546122a69190613014565b92505081905550816003600083815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550808273ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60405160405180910390a461236760008383612370565b5050565b505050565b505050565b60006123968473ffffffffffffffffffffffffffffffffffffffff1661250c565b156124ff578373ffffffffffffffffffffffffffffffffffffffff1663150b7a026123bf6116be565b8786866040518563ffffffff1660e01b81526004016123e19493929190612c61565b602060405180830381600087803b1580156123fb57600080fd5b505af192505050801561242c57506040513d601f19601f82011682018060405250810190612429919061280e565b60015b6124af573d806000811461245c576040519150601f19603f3d011682016040523d82523d6000602084013e612461565b606091505b506000815114156124a7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161249e90612d80565b60405180910390fd5b805181602001fd5b63150b7a0260e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614915050612504565b600190505b949350505050565b6000808273ffffffffffffffffffffffffffffffffffffffff163b119050919050565b600061254261253d84612fa0565b612f7b565b90508281526020810184848401111561255a57600080fd5b612565848285613171565b509392505050565b60008135905061257c81613766565b92915050565b6000813590506125918161377d565b92915050565b6000815190506125a681613794565b92915050565b6000813590506125bb816137ab565b92915050565b6000815190506125d0816137ab565b92915050565b600082601f8301126125e757600080fd5b81356125f784826020860161252f565b91505092915050565b60008135905061260f816137c2565b92915050565b60006020828403121561262757600080fd5b60006126358482850161256d565b91505092915050565b6000806040838503121561265157600080fd5b600061265f8582860161256d565b92505060206126708582860161256d565b9150509250929050565b60008060006060848603121561268f57600080fd5b600061269d8682870161256d565b93505060206126ae8682870161256d565b92505060406126bf86828701612600565b9150509250925092565b600080600080608085870312156126df57600080fd5b60006126ed8782880161256d565b94505060206126fe8782880161256d565b935050604061270f87828801612600565b925050606085013567ffffffffffffffff81111561272c57600080fd5b612738878288016125d6565b91505092959194509250565b6000806040838503121561275757600080fd5b60006127658582860161256d565b925050602061277685828601612582565b9150509250929050565b6000806040838503121561279357600080fd5b60006127a18582860161256d565b92505060206127b285828601612600565b9150509250929050565b6000602082840312156127ce57600080fd5b60006127dc84828501612597565b91505092915050565b6000602082840312156127f757600080fd5b6000612805848285016125ac565b91505092915050565b60006020828403121561282057600080fd5b600061282e848285016125c1565b91505092915050565b60006020828403121561284957600080fd5b600061285784828501612600565b91505092915050565b6000806040838503121561287357600080fd5b600061288185828601612600565b92505060206128928582860161256d565b9150509250929050565b6000806000606084860312156128b157600080fd5b60006128bf86828701612600565b93505060206128d08682870161256d565b92505060406128e186828701612600565b9150509250925092565b600080604083850312156128fe57600080fd5b600061290c85828601612600565b925050602061291d85828601612600565b9150509250929050565b612930816130cf565b82525050565b61293f816130e1565b82525050565b61294e816130ed565b82525050565b600061295f82612fd1565b6129698185612fe7565b9350612979818560208601613180565b6129828161334c565b840191505092915050565b6129968161314d565b82525050565b60006129a782612fdc565b6129b18185612ff8565b93506129c1818560208601613180565b6129ca8161334c565b840191505092915050565b60006129e082612fdc565b6129ea8185613009565b93506129fa818560208601613180565b80840191505092915050565b6000612a13603283612ff8565b9150612a1e8261335d565b604082019050919050565b6000612a36602683612ff8565b9150612a41826133ac565b604082019050919050565b6000612a59602583612ff8565b9150612a64826133fb565b604082019050919050565b6000612a7c601c83612ff8565b9150612a878261344a565b602082019050919050565b6000612a9f602483612ff8565b9150612aaa82613473565b604082019050919050565b6000612ac2601983612ff8565b9150612acd826134c2565b602082019050919050565b6000612ae5603883612ff8565b9150612af0826134eb565b604082019050919050565b6000612b08602a83612ff8565b9150612b138261353a565b604082019050919050565b6000612b2b602983612ff8565b9150612b3682613589565b604082019050919050565b6000612b4e602083612ff8565b9150612b59826135d8565b602082019050919050565b6000612b71602c83612ff8565b9150612b7c82613601565b604082019050919050565b6000612b94602083612ff8565b9150612b9f82613650565b602082019050919050565b6000612bb7602f83612ff8565b9150612bc282613679565b604082019050919050565b6000612bda602183612ff8565b9150612be5826136c8565b604082019050919050565b6000612bfd603183612ff8565b9150612c0882613717565b604082019050919050565b612c1c81613143565b82525050565b6000612c2e82856129d5565b9150612c3a82846129d5565b91508190509392505050565b6000602082019050612c5b6000830184612927565b92915050565b6000608082019050612c766000830187612927565b612c836020830186612927565b612c906040830185612c13565b8181036060830152612ca28184612954565b905095945050505050565b6000602082019050612cc26000830184612936565b92915050565b6000602082019050612cdd6000830184612945565b92915050565b6000604082019050612cf86000830185612945565b612d056020830184612927565b9392505050565b6000606082019050612d216000830186612945565b612d2e6020830185612945565b612d3b6040830184612927565b949350505050565b6000602082019050612d58600083018461298d565b92915050565b60006020820190508181036000830152612d78818461299c565b905092915050565b60006020820190508181036000830152612d9981612a06565b9050919050565b60006020820190508181036000830152612db981612a29565b9050919050565b60006020820190508181036000830152612dd981612a4c565b9050919050565b60006020820190508181036000830152612df981612a6f565b9050919050565b60006020820190508181036000830152612e1981612a92565b9050919050565b60006020820190508181036000830152612e3981612ab5565b9050919050565b60006020820190508181036000830152612e5981612ad8565b9050919050565b60006020820190508181036000830152612e7981612afb565b9050919050565b60006020820190508181036000830152612e9981612b1e565b9050919050565b60006020820190508181036000830152612eb981612b41565b9050919050565b60006020820190508181036000830152612ed981612b64565b9050919050565b60006020820190508181036000830152612ef981612b87565b9050919050565b60006020820190508181036000830152612f1981612baa565b9050919050565b60006020820190508181036000830152612f3981612bcd565b9050919050565b60006020820190508181036000830152612f5981612bf0565b9050919050565b6000602082019050612f756000830184612c13565b92915050565b6000612f85612f96565b9050612f9182826131e5565b919050565b6000604051905090565b600067ffffffffffffffff821115612fbb57612fba61331d565b5b612fc48261334c565b9050602081019050919050565b600081519050919050565b600081519050919050565b600082825260208201905092915050565b600082825260208201905092915050565b600081905092915050565b600061301f82613143565b915061302a83613143565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0382111561305f5761305e613290565b5b828201905092915050565b600061307582613143565b915061308083613143565b9250826130905761308f6132bf565b5b828204905092915050565b60006130a682613143565b91506130b183613143565b9250828210156130c4576130c3613290565b5b828203905092915050565b60006130da82613123565b9050919050565b60008115159050919050565b6000819050919050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b60006131588261315f565b9050919050565b600061316a82613123565b9050919050565b82818337600083830152505050565b60005b8381101561319e578082015181840152602081019050613183565b838111156131ad576000848401525b50505050565b600060028204905060018216806131cb57607f821691505b602082108114156131df576131de6132ee565b5b50919050565b6131ee8261334c565b810181811067ffffffffffffffff8211171561320d5761320c61331d565b5b80604052505050565b600061322182613143565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82141561325457613253613290565b5b600182019050919050565b600061326a82613143565b915061327583613143565b925082613285576132846132bf565b5b828206905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000601f19601f8301169050919050565b7f4552433732313a207472616e7366657220746f206e6f6e20455243373231526560008201527f63656976657220696d706c656d656e7465720000000000000000000000000000602082015250565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160008201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b7f4552433732313a207472616e736665722066726f6d20696e636f72726563742060008201527f6f776e6572000000000000000000000000000000000000000000000000000000602082015250565b7f4552433732313a20746f6b656e20616c7265616479206d696e74656400000000600082015250565b7f4552433732313a207472616e7366657220746f20746865207a65726f2061646460008201527f7265737300000000000000000000000000000000000000000000000000000000602082015250565b7f4552433732313a20617070726f766520746f2063616c6c657200000000000000600082015250565b7f4552433732313a20617070726f76652063616c6c6572206973206e6f74206f7760008201527f6e6572206e6f7220617070726f76656420666f7220616c6c0000000000000000602082015250565b7f4552433732313a2062616c616e636520717565727920666f7220746865207a6560008201527f726f206164647265737300000000000000000000000000000000000000000000602082015250565b7f4552433732313a206f776e657220717565727920666f72206e6f6e657869737460008201527f656e7420746f6b656e0000000000000000000000000000000000000000000000602082015250565b7f4552433732313a206d696e7420746f20746865207a65726f2061646472657373600082015250565b7f4552433732313a20617070726f76656420717565727920666f72206e6f6e657860008201527f697374656e7420746f6b656e0000000000000000000000000000000000000000602082015250565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572600082015250565b7f4552433732314d657461646174613a2055524920717565727920666f72206e6f60008201527f6e6578697374656e7420746f6b656e0000000000000000000000000000000000602082015250565b7f4552433732313a20617070726f76616c20746f2063757272656e74206f776e6560008201527f7200000000000000000000000000000000000000000000000000000000000000602082015250565b7f4552433732313a207472616e736665722063616c6c6572206973206e6f74206f60008201527f776e6572206e6f7220617070726f766564000000000000000000000000000000602082015250565b61376f816130cf565b811461377a57600080fd5b50565b613786816130e1565b811461379157600080fd5b50565b61379d816130ed565b81146137a857600080fd5b50565b6137b4816130f7565b81146137bf57600080fd5b50565b6137cb81613143565b81146137d657600080fd5b5056fea26469706673582212202ac858e9544fce715a9b13b45d7c2a02b17bf4e52175ec0ea3e8ef3e5ddc2fee64736f6c63430008040033","deployedBytecode":"0x608060405234801561001057600080fd5b50600436106101cf5760003560e01c806395d89b4111610104578063c87b56dd116100a2578063e985e9c511610071578063e985e9c514610552578063f2fde38b14610582578063f6a74ed71461059e578063fca247ac146105ba576101cf565b8063c87b56dd146104a4578063d6e4fa86146104d4578063da8c229e14610504578063ddf7fcb014610534576101cf565b8063a7fc7a07116100de578063a7fc7a071461041e578063b88d4fde1461043a578063c1a287e214610456578063c475abff14610474576101cf565b806395d89b41146103b457806396e494e8146103d2578063a22cb46514610402576101cf565b80633f15457f116101715780636352211e1161014b5780636352211e1461032c57806370a082311461035c578063715018a61461038c5780638da5cb5b14610396576101cf565b80633f15457f146102d657806342842e0e146102f45780634e543b2614610310576101cf565b8063095ea7b3116101ad578063095ea7b3146102525780630e297b451461026e57806323b872dd1461029e57806328ed4f6c146102ba576101cf565b806301ffc9a7146101d457806306fdde0314610204578063081812fc14610222575b600080fd5b6101ee60048036038101906101e991906127e5565b6105ea565b6040516101fb9190612cad565b60405180910390f35b61020c610834565b6040516102199190612d5e565b60405180910390f35b61023c60048036038101906102379190612837565b6108c6565b6040516102499190612c46565b60405180910390f35b61026c60048036038101906102679190612780565b61094b565b005b6102886004803603810190610283919061289c565b610a63565b6040516102959190612f60565b60405180910390f35b6102b860048036038101906102b3919061267a565b610a7b565b005b6102d460048036038101906102cf9190612860565b610adb565b005b6102de610ba9565b6040516102eb9190612d43565b60405180910390f35b61030e6004803603810190610309919061267a565b610bcf565b005b61032a60048036038101906103259190612615565b610bef565b005b61034660048036038101906103419190612837565b610cff565b6040516103539190612c46565b60405180910390f35b61037660048036038101906103719190612615565b610d30565b6040516103839190612f60565b60405180910390f35b610394610de8565b005b61039e610e70565b6040516103ab9190612c46565b60405180910390f35b6103bc610e99565b6040516103c99190612d5e565b60405180910390f35b6103ec60048036038101906103e79190612837565b610f2b565b6040516103f99190612cad565b60405180910390f35b61041c60048036038101906104179190612744565b610f58565b005b61043860048036038101906104339190612615565b610f6e565b005b610454600480360381019061044f91906126c9565b611088565b005b61045e6110ea565b60405161046b9190612f60565b60405180910390f35b61048e600480360381019061048991906128eb565b6110f1565b60405161049b9190612f60565b60405180910390f35b6104be60048036038101906104b99190612837565b6111f8565b6040516104cb9190612d5e565b60405180910390f35b6104ee60048036038101906104e99190612837565b61129f565b6040516104fb9190612f60565b60405180910390f35b61051e60048036038101906105199190612615565b6112bc565b60405161052b9190612cad565b60405180910390f35b61053c6112dc565b6040516105499190612cc8565b60405180910390f35b61056c6004803603810190610567919061263e565b6112e2565b6040516105799190612cad565b60405180910390f35b61059c60048036038101906105979190612615565b611376565b005b6105b860048036038101906105b39190612615565b61146e565b005b6105d460048036038101906105cf919061289c565b611588565b6040516105e19190612f60565b60405180910390f35b60007f01ffc9a7a5cef8baa21ed3c5c0d7e23accb804b619e9333b597f47a0d84076e27bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614806107c557507fb88d4fde60196325a28bb7f99a2582e0b46de55b18761e960c14ad7a320994657f42842e0eb38857a7775b4e7364b2775df7325074d088e7fb39590cd6281184ed7f23b872dd7302113369cda2901243429419bec145408fa8b352b3dd92b66c680b7fe985e9c5c6636c6879256001057b28ccac7718ef0ac56553ff9b926452cab8a37fa22cb4651ab9570f89bb516380c40ce76762284fb1f21337ceaf6adab99e7d4a7f081812fc55e34fdc7cf5d8b5cf4e3621fa6423fde952ec6ab24afdc0d85c0b2e7f095ea7b334ae44009aa867bfb386f5c3b4b443ac6f0ee573fa91c4608fbadfba7f6352211e6566aa027e75ac9dbf2423197fbd9b82b9d981a3ab367d355866aa1c7f70a08231b98ef4ca268c9cc3f6b4590e4bfec28280db06bb5d45e689f2a360be18181818181818187bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b8061082d57507f28ed4f6c74b219a5819055dfbcd2f1837c046c364cf01fabb6799e4f440d6f137bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916827bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b9050919050565b606060018054610843906131b3565b80601f016020809104026020016040519081016040528092919081815260200182805461086f906131b3565b80156108bc5780601f10610891576101008083540402835291602001916108bc565b820191906000526020600020905b81548152906001019060200180831161089f57829003601f168201915b5050505050905090565b60006108d1826115a0565b610910576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161090790612ec0565b60405180910390fd5b6005600083815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050919050565b60006109568261160c565b90508073ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff1614156109c7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016109be90612f20565b60405180910390fd5b8073ffffffffffffffffffffffffffffffffffffffff166109e66116be565b73ffffffffffffffffffffffffffffffffffffffff161480610a155750610a1481610a0f6116be565b6112e2565b5b610a54576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610a4b90612e40565b60405180910390fd5b610a5e83836116c6565b505050565b6000610a72848484600061177f565b90509392505050565b610a8c610a866116be565b82611927565b610acb576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ac290612f40565b60405180910390fd5b610ad68383836119bc565b505050565b610ae53383611927565b610aee57600080fd5b600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166306ab59236008548460001b846040518463ffffffff1660e01b8152600401610b5293929190612d0c565b602060405180830381600087803b158015610b6c57600080fd5b505af1158015610b80573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ba491906127bc565b505050565b600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b610bea83838360405180602001604052806000815250611088565b505050565b610bf76116be565b73ffffffffffffffffffffffffffffffffffffffff16610c15610e70565b73ffffffffffffffffffffffffffffffffffffffff1614610c6b576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c6290612ee0565b60405180910390fd5b600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16631896f70a600854836040518363ffffffff1660e01b8152600401610cca929190612ce3565b600060405180830381600087803b158015610ce457600080fd5b505af1158015610cf8573d6000803e3d6000fd5b5050505050565b600042600a60008481526020019081526020016000205411610d2057600080fd5b610d298261160c565b9050919050565b60008073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff161415610da1576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610d9890612e60565b60405180910390fd5b600460008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b610df06116be565b73ffffffffffffffffffffffffffffffffffffffff16610e0e610e70565b73ffffffffffffffffffffffffffffffffffffffff1614610e64576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610e5b90612ee0565b60405180910390fd5b610e6e6000611c23565b565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905090565b606060028054610ea8906131b3565b80601f0160208091040260200160405190810160405280929190818152602001828054610ed4906131b3565b8015610f215780601f10610ef657610100808354040283529160200191610f21565b820191906000526020600020905b815481529060010190602001808311610f0457829003601f168201915b5050505050905090565b6000426276a700600a600085815260200190815260200160002054610f509190613014565b109050919050565b610f6a610f636116be565b8383611ce7565b5050565b610f766116be565b73ffffffffffffffffffffffffffffffffffffffff16610f94610e70565b73ffffffffffffffffffffffffffffffffffffffff1614610fea576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610fe190612ee0565b60405180910390fd5b6001600960008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055508073ffffffffffffffffffffffffffffffffffffffff167f0a8bb31534c0ed46f380cb867bd5c803a189ced9a764e30b3a4991a9901d747460405160405180910390a250565b6110996110936116be565b83611927565b6110d8576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016110cf90612f40565b60405180910390fd5b6110e484848484611e54565b50505050565b6276a70081565b6000426276a700600a6000868152602001908152602001600020546111169190613014565b101561112157600080fd5b6276a700826111309190613014565b6276a70083600a6000878152602001908152602001600020546111539190613014565b61115d9190613014565b1161116757600080fd5b81600a6000858152602001908152602001600020600082825461118a9190613014565b92505081905550827f9b87a00e30f1ac65d898f070f8a3488fe60517182d0a2098e1b4b93a54aa9bd6600a6000868152602001908152602001600020546040516111d49190612f60565b60405180910390a2600a600084815260200190815260200160002054905092915050565b6060611203826115a0565b611242576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161123990612f00565b60405180910390fd5b600061124c611eb0565b9050600081511161126c5760405180602001604052806000815250611297565b8061127684611ec7565b604051602001611287929190612c22565b6040516020818303038152906040525b915050919050565b6000600a6000838152602001908152602001600020549050919050565b60096020528060005260406000206000915054906101000a900460ff1681565b60085481565b6000600660008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16905092915050565b61137e6116be565b73ffffffffffffffffffffffffffffffffffffffff1661139c610e70565b73ffffffffffffffffffffffffffffffffffffffff16146113f2576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016113e990612ee0565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161415611462576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161145990612da0565b60405180910390fd5b61146b81611c23565b50565b6114766116be565b73ffffffffffffffffffffffffffffffffffffffff16611494610e70565b73ffffffffffffffffffffffffffffffffffffffff16146114ea576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016114e190612ee0565b60405180910390fd5b6000600960008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055508073ffffffffffffffffffffffffffffffffffffffff167f33d83959be2573f5453b12eb9d43b3499bc57d96bd2f067ba44803c859e8111360405160405180910390a250565b6000611597848484600161177f565b90509392505050565b60008073ffffffffffffffffffffffffffffffffffffffff166003600084815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1614159050919050565b6000806003600084815260200190815260200160002060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614156116b5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016116ac90612e80565b60405180910390fd5b80915050919050565b600033905090565b816005600083815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550808273ffffffffffffffffffffffffffffffffffffffff166117398361160c565b73ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92560405160405180910390a45050565b60006276a700426117909190613014565b6276a70084426117a09190613014565b6117aa9190613014565b116117b457600080fd5b82426117c09190613014565b600a6000878152602001908152602001600020819055506117e0856115a0565b156117ef576117ee85612074565b5b6117f98486612191565b81156118b757600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166306ab59236008548760001b876040518463ffffffff1660e01b815260040161186393929190612d0c565b602060405180830381600087803b15801561187d57600080fd5b505af1158015611891573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118b591906127bc565b505b8373ffffffffffffffffffffffffffffffffffffffff16857fb3d987963d01b2f68493b4bdb130988f157ea43070d4ad840fee0466ed9370d985426118fc9190613014565b6040516119099190612f60565b60405180910390a3824261191d9190613014565b9050949350505050565b60008061193383610cff565b90508073ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff1614806119a257508373ffffffffffffffffffffffffffffffffffffffff1661198a846108c6565b73ffffffffffffffffffffffffffffffffffffffff16145b806119b357506119b281856112e2565b5b91505092915050565b8273ffffffffffffffffffffffffffffffffffffffff166119dc8261160c565b73ffffffffffffffffffffffffffffffffffffffff1614611a32576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611a2990612dc0565b60405180910390fd5b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff161415611aa2576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611a9990612e00565b60405180910390fd5b611aad83838361236b565b611ab86000826116c6565b6001600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254611b08919061309b565b925050819055506001600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254611b5f9190613014565b92505081905550816003600083815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550808273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60405160405180910390a4611c1e838383612370565b505050565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050816000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508173ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8be0079c531659141344cd1fd0a4f28419497f9722a3daafe3b4186f6b6457e060405160405180910390a35050565b8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff161415611d56576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611d4d90612e20565b60405180910390fd5b80600660008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055508173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167f17307eab39ab6107e8899845ad3d59bd9653f200f220920489ca2b5937696c3183604051611e479190612cad565b60405180910390a3505050565b611e5f8484846119bc565b611e6b84848484612375565b611eaa576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611ea190612d80565b60405180910390fd5b50505050565b606060405180602001604052806000815250905090565b60606000821415611f0f576040518060400160405280600181526020017f3000000000000000000000000000000000000000000000000000000000000000815250905061206f565b600082905060005b60008214611f41578080611f2a90613216565b915050600a82611f3a919061306a565b9150611f17565b60008167ffffffffffffffff811115611f83577f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6040519080825280601f01601f191660200182016040528015611fb55781602001600182028036833780820191505090505b5090505b6000851461206857600182611fce919061309b565b9150600a85611fdd919061325f565b6030611fe99190613014565b60f81b818381518110612025577f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350600a85612061919061306a565b9450611fb9565b8093505050505b919050565b600061207f8261160c565b905061208d8160008461236b565b6120986000836116c6565b6001600460008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546120e8919061309b565b925050819055506003600083815260200190815260200160002060006101000a81549073ffffffffffffffffffffffffffffffffffffffff021916905581600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60405160405180910390a461218d81600084612370565b5050565b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff161415612201576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016121f890612ea0565b60405180910390fd5b61220a816115a0565b1561224a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161224190612de0565b60405180910390fd5b6122566000838361236b565b6001600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282546122a69190613014565b92505081905550816003600083815260200190815260200160002060006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550808273ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef60405160405180910390a461236760008383612370565b5050565b505050565b505050565b60006123968473ffffffffffffffffffffffffffffffffffffffff1661250c565b156124ff578373ffffffffffffffffffffffffffffffffffffffff1663150b7a026123bf6116be565b8786866040518563ffffffff1660e01b81526004016123e19493929190612c61565b602060405180830381600087803b1580156123fb57600080fd5b505af192505050801561242c57506040513d601f19601f82011682018060405250810190612429919061280e565b60015b6124af573d806000811461245c576040519150601f19603f3d011682016040523d82523d6000602084013e612461565b606091505b506000815114156124a7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161249e90612d80565b60405180910390fd5b805181602001fd5b63150b7a0260e01b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff191614915050612504565b600190505b949350505050565b6000808273ffffffffffffffffffffffffffffffffffffffff163b119050919050565b600061254261253d84612fa0565b612f7b565b90508281526020810184848401111561255a57600080fd5b612565848285613171565b509392505050565b60008135905061257c81613766565b92915050565b6000813590506125918161377d565b92915050565b6000815190506125a681613794565b92915050565b6000813590506125bb816137ab565b92915050565b6000815190506125d0816137ab565b92915050565b600082601f8301126125e757600080fd5b81356125f784826020860161252f565b91505092915050565b60008135905061260f816137c2565b92915050565b60006020828403121561262757600080fd5b60006126358482850161256d565b91505092915050565b6000806040838503121561265157600080fd5b600061265f8582860161256d565b92505060206126708582860161256d565b9150509250929050565b60008060006060848603121561268f57600080fd5b600061269d8682870161256d565b93505060206126ae8682870161256d565b92505060406126bf86828701612600565b9150509250925092565b600080600080608085870312156126df57600080fd5b60006126ed8782880161256d565b94505060206126fe8782880161256d565b935050604061270f87828801612600565b925050606085013567ffffffffffffffff81111561272c57600080fd5b612738878288016125d6565b91505092959194509250565b6000806040838503121561275757600080fd5b60006127658582860161256d565b925050602061277685828601612582565b9150509250929050565b6000806040838503121561279357600080fd5b60006127a18582860161256d565b92505060206127b285828601612600565b9150509250929050565b6000602082840312156127ce57600080fd5b60006127dc84828501612597565b91505092915050565b6000602082840312156127f757600080fd5b6000612805848285016125ac565b91505092915050565b60006020828403121561282057600080fd5b600061282e848285016125c1565b91505092915050565b60006020828403121561284957600080fd5b600061285784828501612600565b91505092915050565b6000806040838503121561287357600080fd5b600061288185828601612600565b92505060206128928582860161256d565b9150509250929050565b6000806000606084860312156128b157600080fd5b60006128bf86828701612600565b93505060206128d08682870161256d565b92505060406128e186828701612600565b9150509250925092565b600080604083850312156128fe57600080fd5b600061290c85828601612600565b925050602061291d85828601612600565b9150509250929050565b612930816130cf565b82525050565b61293f816130e1565b82525050565b61294e816130ed565b82525050565b600061295f82612fd1565b6129698185612fe7565b9350612979818560208601613180565b6129828161334c565b840191505092915050565b6129968161314d565b82525050565b60006129a782612fdc565b6129b18185612ff8565b93506129c1818560208601613180565b6129ca8161334c565b840191505092915050565b60006129e082612fdc565b6129ea8185613009565b93506129fa818560208601613180565b80840191505092915050565b6000612a13603283612ff8565b9150612a1e8261335d565b604082019050919050565b6000612a36602683612ff8565b9150612a41826133ac565b604082019050919050565b6000612a59602583612ff8565b9150612a64826133fb565b604082019050919050565b6000612a7c601c83612ff8565b9150612a878261344a565b602082019050919050565b6000612a9f602483612ff8565b9150612aaa82613473565b604082019050919050565b6000612ac2601983612ff8565b9150612acd826134c2565b602082019050919050565b6000612ae5603883612ff8565b9150612af0826134eb565b604082019050919050565b6000612b08602a83612ff8565b9150612b138261353a565b604082019050919050565b6000612b2b602983612ff8565b9150612b3682613589565b604082019050919050565b6000612b4e602083612ff8565b9150612b59826135d8565b602082019050919050565b6000612b71602c83612ff8565b9150612b7c82613601565b604082019050919050565b6000612b94602083612ff8565b9150612b9f82613650565b602082019050919050565b6000612bb7602f83612ff8565b9150612bc282613679565b604082019050919050565b6000612bda602183612ff8565b9150612be5826136c8565b604082019050919050565b6000612bfd603183612ff8565b9150612c0882613717565b604082019050919050565b612c1c81613143565b82525050565b6000612c2e82856129d5565b9150612c3a82846129d5565b91508190509392505050565b6000602082019050612c5b6000830184612927565b92915050565b6000608082019050612c766000830187612927565b612c836020830186612927565b612c906040830185612c13565b8181036060830152612ca28184612954565b905095945050505050565b6000602082019050612cc26000830184612936565b92915050565b6000602082019050612cdd6000830184612945565b92915050565b6000604082019050612cf86000830185612945565b612d056020830184612927565b9392505050565b6000606082019050612d216000830186612945565b612d2e6020830185612945565b612d3b6040830184612927565b949350505050565b6000602082019050612d58600083018461298d565b92915050565b60006020820190508181036000830152612d78818461299c565b905092915050565b60006020820190508181036000830152612d9981612a06565b9050919050565b60006020820190508181036000830152612db981612a29565b9050919050565b60006020820190508181036000830152612dd981612a4c565b9050919050565b60006020820190508181036000830152612df981612a6f565b9050919050565b60006020820190508181036000830152612e1981612a92565b9050919050565b60006020820190508181036000830152612e3981612ab5565b9050919050565b60006020820190508181036000830152612e5981612ad8565b9050919050565b60006020820190508181036000830152612e7981612afb565b9050919050565b60006020820190508181036000830152612e9981612b1e565b9050919050565b60006020820190508181036000830152612eb981612b41565b9050919050565b60006020820190508181036000830152612ed981612b64565b9050919050565b60006020820190508181036000830152612ef981612b87565b9050919050565b60006020820190508181036000830152612f1981612baa565b9050919050565b60006020820190508181036000830152612f3981612bcd565b9050919050565b60006020820190508181036000830152612f5981612bf0565b9050919050565b6000602082019050612f756000830184612c13565b92915050565b6000612f85612f96565b9050612f9182826131e5565b919050565b6000604051905090565b600067ffffffffffffffff821115612fbb57612fba61331d565b5b612fc48261334c565b9050602081019050919050565b600081519050919050565b600081519050919050565b600082825260208201905092915050565b600082825260208201905092915050565b600081905092915050565b600061301f82613143565b915061302a83613143565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0382111561305f5761305e613290565b5b828201905092915050565b600061307582613143565b915061308083613143565b9250826130905761308f6132bf565b5b828204905092915050565b60006130a682613143565b91506130b183613143565b9250828210156130c4576130c3613290565b5b828203905092915050565b60006130da82613123565b9050919050565b60008115159050919050565b6000819050919050565b60007fffffffff0000000000000000000000000000000000000000000000000000000082169050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b60006131588261315f565b9050919050565b600061316a82613123565b9050919050565b82818337600083830152505050565b60005b8381101561319e578082015181840152602081019050613183565b838111156131ad576000848401525b50505050565b600060028204905060018216806131cb57607f821691505b602082108114156131df576131de6132ee565b5b50919050565b6131ee8261334c565b810181811067ffffffffffffffff8211171561320d5761320c61331d565b5b80604052505050565b600061322182613143565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff82141561325457613253613290565b5b600182019050919050565b600061326a82613143565b915061327583613143565b925082613285576132846132bf565b5b828206905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000601f19601f8301169050919050565b7f4552433732313a207472616e7366657220746f206e6f6e20455243373231526560008201527f63656976657220696d706c656d656e7465720000000000000000000000000000602082015250565b7f4f776e61626c653a206e6577206f776e657220697320746865207a65726f206160008201527f6464726573730000000000000000000000000000000000000000000000000000602082015250565b7f4552433732313a207472616e736665722066726f6d20696e636f72726563742060008201527f6f776e6572000000000000000000000000000000000000000000000000000000602082015250565b7f4552433732313a20746f6b656e20616c7265616479206d696e74656400000000600082015250565b7f4552433732313a207472616e7366657220746f20746865207a65726f2061646460008201527f7265737300000000000000000000000000000000000000000000000000000000602082015250565b7f4552433732313a20617070726f766520746f2063616c6c657200000000000000600082015250565b7f4552433732313a20617070726f76652063616c6c6572206973206e6f74206f7760008201527f6e6572206e6f7220617070726f76656420666f7220616c6c0000000000000000602082015250565b7f4552433732313a2062616c616e636520717565727920666f7220746865207a6560008201527f726f206164647265737300000000000000000000000000000000000000000000602082015250565b7f4552433732313a206f776e657220717565727920666f72206e6f6e657869737460008201527f656e7420746f6b656e0000000000000000000000000000000000000000000000602082015250565b7f4552433732313a206d696e7420746f20746865207a65726f2061646472657373600082015250565b7f4552433732313a20617070726f76656420717565727920666f72206e6f6e657860008201527f697374656e7420746f6b656e0000000000000000000000000000000000000000602082015250565b7f4f776e61626c653a2063616c6c6572206973206e6f7420746865206f776e6572600082015250565b7f4552433732314d657461646174613a2055524920717565727920666f72206e6f60008201527f6e6578697374656e7420746f6b656e0000000000000000000000000000000000602082015250565b7f4552433732313a20617070726f76616c20746f2063757272656e74206f776e6560008201527f7200000000000000000000000000000000000000000000000000000000000000602082015250565b7f4552433732313a207472616e736665722063616c6c6572206973206e6f74206f60008201527f776e6572206e6f7220617070726f766564000000000000000000000000000000602082015250565b61376f816130cf565b811461377a57600080fd5b50565b613786816130e1565b811461379157600080fd5b50565b61379d816130ed565b81146137a857600080fd5b50565b6137b4816130f7565b81146137bf57600080fd5b50565b6137cb81613143565b81146137d657600080fd5b5056fea26469706673582212202ac858e9544fce715a9b13b45d7c2a02b17bf4e52175ec0ea3e8ef3e5ddc2fee64736f6c63430008040033","linkReferences":{},"deployedLinkReferences":{}}');
    },
    8362: f => {
      "use strict";

      f.exports = JSON.parse('{"_format":"hh-sol-artifact-1","contractName":"PublicResolver","sourceName":"contracts/PublicResolver.sol","abi":[{"inputs":[{"internalType":"contract ENS","name":"_ensAddr","type":"address"}],"stateMutability":"nonpayable","type":"constructor"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":true,"internalType":"uint256","name":"contentType","type":"uint256"}],"name":"ABIChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"address","name":"a","type":"address"}],"name":"AddrChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"bytes32","name":"hash","type":"bytes32"}],"name":"ContentChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"bytes","name":"hash","type":"bytes"}],"name":"MultihashChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"string","name":"name","type":"string"}],"name":"NameChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"bytes32","name":"x","type":"bytes32"},{"indexed":false,"internalType":"bytes32","name":"y","type":"bytes32"}],"name":"PubkeyChanged","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"bytes32","name":"node","type":"bytes32"},{"indexed":false,"internalType":"string","name":"indexedKey","type":"string"},{"indexed":false,"internalType":"string","name":"key","type":"string"}],"name":"TextChanged","type":"event"},{"inputs":[{"internalType":"bytes32","name":"_node","type":"bytes32"}],"name":"addr","outputs":[{"internalType":"address","name":"","type":"address"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_node","type":"bytes32"}],"name":"content","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_node","type":"bytes32"}],"name":"getAll","outputs":[{"internalType":"address","name":"_addr","type":"address"},{"internalType":"bytes32","name":"_content","type":"bytes32"},{"internalType":"bytes","name":"_multihash","type":"bytes"},{"internalType":"bytes32","name":"_x","type":"bytes32"},{"internalType":"bytes32","name":"_y","type":"bytes32"},{"internalType":"string","name":"_name","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_node","type":"bytes32"}],"name":"multihash","outputs":[{"internalType":"bytes","name":"","type":"bytes"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_node","type":"bytes32"}],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_node","type":"bytes32"}],"name":"pubkey","outputs":[{"internalType":"bytes32","name":"x","type":"bytes32"},{"internalType":"bytes32","name":"y","type":"bytes32"}],"stateMutability":"view","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_node","type":"bytes32"},{"internalType":"uint256","name":"_contentType","type":"uint256"},{"internalType":"bytes","name":"_data","type":"bytes"}],"name":"setABI","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_node","type":"bytes32"},{"internalType":"address","name":"_addr","type":"address"}],"name":"setAddr","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_node","type":"bytes32"},{"internalType":"address","name":"_addr","type":"address"},{"internalType":"bytes32","name":"_content","type":"bytes32"},{"internalType":"bytes","name":"_multihash","type":"bytes"},{"internalType":"bytes32","name":"_x","type":"bytes32"},{"internalType":"bytes32","name":"_y","type":"bytes32"},{"internalType":"string","name":"_name","type":"string"}],"name":"setAll","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_node","type":"bytes32"},{"internalType":"bytes32","name":"_hash","type":"bytes32"}],"name":"setContent","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_node","type":"bytes32"},{"internalType":"bytes","name":"_hash","type":"bytes"}],"name":"setMultihash","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_node","type":"bytes32"},{"internalType":"string","name":"_name","type":"string"}],"name":"setName","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_node","type":"bytes32"},{"internalType":"bytes32","name":"_x","type":"bytes32"},{"internalType":"bytes32","name":"_y","type":"bytes32"}],"name":"setPubkey","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_node","type":"bytes32"},{"internalType":"string","name":"_key","type":"string"},{"internalType":"string","name":"_value","type":"string"}],"name":"setText","outputs":[],"stateMutability":"nonpayable","type":"function"},{"inputs":[{"internalType":"bytes32","name":"_node","type":"bytes32"},{"internalType":"string","name":"_key","type":"string"}],"name":"text","outputs":[{"internalType":"string","name":"","type":"string"}],"stateMutability":"view","type":"function"}],"bytecode":"0x60806040523480156200001157600080fd5b506040516200210738038062002107833981810160405281019062000037919062000095565b806000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505062000123565b6000815190506200008f8162000109565b92915050565b600060208284031215620000a857600080fd5b6000620000b8848285016200007e565b91505092915050565b6000620000ce82620000e9565b9050919050565b6000620000e282620000c1565b9050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6200011481620000d5565b81146200012057600080fd5b50565b611fd480620001336000396000f3fe608060405234801561001057600080fd5b50600436106100f55760003560e01c80637737221311610097578063c869023311610066578063c86902331461027e578063d5fa2b00146102af578063e89401a1146102cb578063ed80e1f7146102fb576100f5565b8063773722131461020e5780639f3a206d1461022a578063aa4cb54714610246578063c3d014d614610262576100f5565b80633b3b57de116100d35780633b3b57de1461016257806359d1d43c14610192578063623195b0146101c2578063691f3431146101de576100f5565b806310f13a8c146100fa57806329cd62ea146101165780632dff694114610132575b600080fd5b610114600480360381019061010f9190611919565b610330565b005b610130600480360381019061012b9190611822565b6104ce565b005b61014c600480360381019061014791906116b3565b610667565b6040516101599190611ba7565b60405180910390f35b61017c600480360381019061017791906116b3565b610687565b6040516101899190611b1d565b60405180910390f35b6101ac60048036038101906101a791906118c5565b6106c7565b6040516101b99190611c0d565b60405180910390f35b6101dc60048036038101906101d79190611998565b61078c565b005b6101f860048036038101906101f391906116b3565b610964565b6040516102059190611c0d565b60405180910390f35b610228600480360381019061022391906118c5565b610a0c565b005b610244600480360381019061023f9190611718565b610b8b565b005b610260600480360381019061025b9190611871565b610cdf565b005b61027c600480360381019061027791906117e6565b610e5e565b005b610298600480360381019061029391906116b3565b610fcd565b6040516102a6929190611bc2565b60405180910390f35b6102c960048036038101906102c491906116dc565b61100d565b005b6102e560048036038101906102e091906116b3565b6111b6565b6040516102f29190611beb565b60405180910390f35b610315600480360381019061031091906116b3565b61125e565b60405161032796959493929190611b38565b60405180910390f35b823373ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166302571be3836040518263ffffffff1660e01b81526004016103a19190611ba7565b60206040518083038186803b1580156103b957600080fd5b505afa1580156103cd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103f1919061168a565b73ffffffffffffffffffffffffffffffffffffffff1614610447576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161043e90611c66565b60405180910390fd5b81600160008681526020019081526020016000206005018460405161046c9190611b06565b9081526020016040518091039020908051906020019061048d92919061143d565b50837fd8c9334b1a9c2f9da342a0a2b32629c1a229b6445dad78947f674b44444a755084856040516104c0929190611c2f565b60405180910390a250505050565b823373ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166302571be3836040518263ffffffff1660e01b815260040161053f9190611ba7565b60206040518083038186803b15801561055757600080fd5b505afa15801561056b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061058f919061168a565b73ffffffffffffffffffffffffffffffffffffffff16146105e5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105dc90611c66565b60405180910390fd5b604051806040016040528084815260200183815250600160008681526020019081526020016000206003016000820151816000015560208201518160010155905050837f1d6f5e03d3f63eb58751986629a5439baee5079ff04f345becb66e23eb154e468484604051610659929190611bc2565b60405180910390a250505050565b600060016000838152602001908152602001600020600101549050919050565b60006001600083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050919050565b606060016000848152602001908152602001600020600501826040516106ed9190611b06565b9081526020016040518091039020805461070690611e2c565b80601f016020809104026020016040519081016040528092919081815260200182805461073290611e2c565b801561077f5780601f106107545761010080835404028352916020019161077f565b820191906000526020600020905b81548152906001019060200180831161076257829003601f168201915b5050505050905092915050565b823373ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166302571be3836040518263ffffffff1660e01b81526004016107fd9190611ba7565b60206040518083038186803b15801561081557600080fd5b505afa158015610829573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061084d919061168a565b73ffffffffffffffffffffffffffffffffffffffff16146108a3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161089a90611c66565b60405180910390fd5b6000836001856108b39190611d70565b16146108f4576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108eb90611c86565b60405180910390fd5b81600160008681526020019081526020016000206006016000858152602001908152602001600020908051906020019061092f9291906114c3565b5082847faa121bbeef5f32f5961a2a28966e769023910fc9479059ee3495d4c1a696efe360405160405180910390a350505050565b606060016000838152602001908152602001600020600201805461098790611e2c565b80601f01602080910402602001604051908101604052809291908181526020018280546109b390611e2c565b8015610a005780601f106109d557610100808354040283529160200191610a00565b820191906000526020600020905b8154815290600101906020018083116109e357829003601f168201915b50505050509050919050565b813373ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166302571be3836040518263ffffffff1660e01b8152600401610a7d9190611ba7565b60206040518083038186803b158015610a9557600080fd5b505afa158015610aa9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610acd919061168a565b73ffffffffffffffffffffffffffffffffffffffff1614610b23576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b1a90611c66565b60405180910390fd5b81600160008581526020019081526020016000206002019080519060200190610b4d92919061143d565b50827fb7d29e911041e8d9b843369e890bcb72c9388692ba48b65ac54e7214c4c348f783604051610b7e9190611c0d565b60405180910390a2505050565b863373ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166302571be3836040518263ffffffff1660e01b8152600401610bfc9190611ba7565b60206040518083038186803b158015610c1457600080fd5b505afa158015610c28573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c4c919061168a565b73ffffffffffffffffffffffffffffffffffffffff1614610ca2576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c9990611c66565b60405180910390fd5b610cac888861100d565b610cb68887610e5e565b610cc08886610cdf565b610ccb8885856104ce565b610cd58883610a0c565b5050505050505050565b813373ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166302571be3836040518263ffffffff1660e01b8152600401610d509190611ba7565b60206040518083038186803b158015610d6857600080fd5b505afa158015610d7c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610da0919061168a565b73ffffffffffffffffffffffffffffffffffffffff1614610df6576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ded90611c66565b60405180910390fd5b81600160008581526020019081526020016000206007019080519060200190610e209291906114c3565b50827fc0b0fc07269fc2749adada3221c095a1d2187b2d075b51c915857b520f3a502183604051610e519190611beb565b60405180910390a2505050565b813373ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166302571be3836040518263ffffffff1660e01b8152600401610ecf9190611ba7565b60206040518083038186803b158015610ee757600080fd5b505afa158015610efb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f1f919061168a565b73ffffffffffffffffffffffffffffffffffffffff1614610f75576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610f6c90611c66565b60405180910390fd5b816001600085815260200190815260200160002060010181905550827f0424b6fe0d9c3bdbece0e7879dc241bb0c22e900be8b6c168b4ee08bd9bf83bc83604051610fc09190611ba7565b60405180910390a2505050565b6000806001600084815260200190815260200160002060030160000154600160008581526020019081526020016000206003016001015491509150915091565b813373ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166302571be3836040518263ffffffff1660e01b815260040161107e9190611ba7565b60206040518083038186803b15801561109657600080fd5b505afa1580156110aa573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110ce919061168a565b73ffffffffffffffffffffffffffffffffffffffff1614611124576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161111b90611c66565b60405180910390fd5b816001600085815260200190815260200160002060000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550827f52d7d861f09ab3d26239d492e8968629f95e9e318cf0b73bfddc441522a15fd2836040516111a99190611b1d565b60405180910390a2505050565b60606001600083815260200190815260200160002060070180546111d990611e2c565b80601f016020809104026020016040519081016040528092919081815260200182805461120590611e2c565b80156112525780601f1061122757610100808354040283529160200191611252565b820191906000526020600020905b81548152906001019060200180831161123557829003601f168201915b50505050509050919050565b600080606060008060606001600088815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169550600160008881526020019081526020016000206001015494506001600088815260200190815260200160002060070180546112db90611e2c565b80601f016020809104026020016040519081016040528092919081815260200182805461130790611e2c565b80156113545780601f1061132957610100808354040283529160200191611354565b820191906000526020600020905b81548152906001019060200180831161133757829003601f168201915b5050505050935060016000888152602001908152602001600020600301600001549250600160008881526020019081526020016000206003016001015491506001600088815260200190815260200160002060020180546113b490611e2c565b80601f01602080910402602001604051908101604052809291908181526020018280546113e090611e2c565b801561142d5780601f106114025761010080835404028352916020019161142d565b820191906000526020600020905b81548152906001019060200180831161141057829003601f168201915b5050505050905091939550919395565b82805461144990611e2c565b90600052602060002090601f01602090048101928261146b57600085556114b2565b82601f1061148457805160ff19168380011785556114b2565b828001600101855582156114b2579182015b828111156114b1578251825591602001919060010190611496565b5b5090506114bf9190611549565b5090565b8280546114cf90611e2c565b90600052602060002090601f0160209004810192826114f15760008555611538565b82601f1061150a57805160ff1916838001178555611538565b82800160010185558215611538579182015b8281111561153757825182559160200191906001019061151c565b5b5090506115459190611549565b5090565b5b8082111561156257600081600090555060010161154a565b5090565b600061157961157484611ccb565b611ca6565b90508281526020810184848401111561159157600080fd5b61159c848285611dea565b509392505050565b60006115b76115b284611cfc565b611ca6565b9050828152602081018484840111156115cf57600080fd5b6115da848285611dea565b509392505050565b6000813590506115f181611f59565b92915050565b60008151905061160681611f59565b92915050565b60008135905061161b81611f70565b92915050565b600082601f83011261163257600080fd5b8135611642848260208601611566565b91505092915050565b600082601f83011261165c57600080fd5b813561166c8482602086016115a4565b91505092915050565b60008135905061168481611f87565b92915050565b60006020828403121561169c57600080fd5b60006116aa848285016115f7565b91505092915050565b6000602082840312156116c557600080fd5b60006116d38482850161160c565b91505092915050565b600080604083850312156116ef57600080fd5b60006116fd8582860161160c565b925050602061170e858286016115e2565b9150509250929050565b600080600080600080600060e0888a03121561173357600080fd5b60006117418a828b0161160c565b97505060206117528a828b016115e2565b96505060406117638a828b0161160c565b955050606088013567ffffffffffffffff81111561178057600080fd5b61178c8a828b01611621565b945050608061179d8a828b0161160c565b93505060a06117ae8a828b0161160c565b92505060c088013567ffffffffffffffff8111156117cb57600080fd5b6117d78a828b0161164b565b91505092959891949750929550565b600080604083850312156117f957600080fd5b60006118078582860161160c565b92505060206118188582860161160c565b9150509250929050565b60008060006060848603121561183757600080fd5b60006118458682870161160c565b93505060206118568682870161160c565b92505060406118678682870161160c565b9150509250925092565b6000806040838503121561188457600080fd5b60006118928582860161160c565b925050602083013567ffffffffffffffff8111156118af57600080fd5b6118bb85828601611621565b9150509250929050565b600080604083850312156118d857600080fd5b60006118e68582860161160c565b925050602083013567ffffffffffffffff81111561190357600080fd5b61190f8582860161164b565b9150509250929050565b60008060006060848603121561192e57600080fd5b600061193c8682870161160c565b935050602084013567ffffffffffffffff81111561195957600080fd5b6119658682870161164b565b925050604084013567ffffffffffffffff81111561198257600080fd5b61198e8682870161164b565b9150509250925092565b6000806000606084860312156119ad57600080fd5b60006119bb8682870161160c565b93505060206119cc86828701611675565b925050604084013567ffffffffffffffff8111156119e957600080fd5b6119f586828701611621565b9150509250925092565b611a0881611da4565b82525050565b611a1781611db6565b82525050565b6000611a2882611d2d565b611a328185611d43565b9350611a42818560208601611df9565b611a4b81611f1c565b840191505092915050565b6000611a6182611d38565b611a6b8185611d54565b9350611a7b818560208601611df9565b611a8481611f1c565b840191505092915050565b6000611a9a82611d38565b611aa48185611d65565b9350611ab4818560208601611df9565b80840191505092915050565b6000611acd601383611d54565b9150611ad882611f2d565b602082019050919050565b6000611af0600083611d54565b9150611afb82611f56565b600082019050919050565b6000611b128284611a8f565b915081905092915050565b6000602082019050611b3260008301846119ff565b92915050565b600060c082019050611b4d60008301896119ff565b611b5a6020830188611a0e565b8181036040830152611b6c8187611a1d565b9050611b7b6060830186611a0e565b611b886080830185611a0e565b81810360a0830152611b9a8184611a56565b9050979650505050505050565b6000602082019050611bbc6000830184611a0e565b92915050565b6000604082019050611bd76000830185611a0e565b611be46020830184611a0e565b9392505050565b60006020820190508181036000830152611c058184611a1d565b905092915050565b60006020820190508181036000830152611c278184611a56565b905092915050565b60006040820190508181036000830152611c498185611a56565b90508181036020830152611c5d8184611a56565b90509392505050565b60006020820190508181036000830152611c7f81611ac0565b9050919050565b60006020820190508181036000830152611c9f81611ae3565b9050919050565b6000611cb0611cc1565b9050611cbc8282611e5e565b919050565b6000604051905090565b600067ffffffffffffffff821115611ce657611ce5611eed565b5b611cef82611f1c565b9050602081019050919050565b600067ffffffffffffffff821115611d1757611d16611eed565b5b611d2082611f1c565b9050602081019050919050565b600081519050919050565b600081519050919050565b600082825260208201905092915050565b600082825260208201905092915050565b600081905092915050565b6000611d7b82611de0565b9150611d8683611de0565b925082821015611d9957611d98611e8f565b5b828203905092915050565b6000611daf82611dc0565b9050919050565b6000819050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b82818337600083830152505050565b60005b83811015611e17578082015181840152602081019050611dfc565b83811115611e26576000848401525b50505050565b60006002820490506001821680611e4457607f821691505b60208210811415611e5857611e57611ebe565b5b50919050565b611e6782611f1c565b810181811067ffffffffffffffff82111715611e8657611e85611eed565b5b80604052505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000601f19601f8301169050919050565b7f4f776e6572206973206e6f742073656e64657200000000000000000000000000600082015250565b50565b611f6281611da4565b8114611f6d57600080fd5b50565b611f7981611db6565b8114611f8457600080fd5b50565b611f9081611de0565b8114611f9b57600080fd5b5056fea2646970667358221220bae0c05770682aa0d6ad384962c3018d8f30a77afb8d72e7916a6299cfff797f64736f6c63430008040033","deployedBytecode":"0x608060405234801561001057600080fd5b50600436106100f55760003560e01c80637737221311610097578063c869023311610066578063c86902331461027e578063d5fa2b00146102af578063e89401a1146102cb578063ed80e1f7146102fb576100f5565b8063773722131461020e5780639f3a206d1461022a578063aa4cb54714610246578063c3d014d614610262576100f5565b80633b3b57de116100d35780633b3b57de1461016257806359d1d43c14610192578063623195b0146101c2578063691f3431146101de576100f5565b806310f13a8c146100fa57806329cd62ea146101165780632dff694114610132575b600080fd5b610114600480360381019061010f9190611919565b610330565b005b610130600480360381019061012b9190611822565b6104ce565b005b61014c600480360381019061014791906116b3565b610667565b6040516101599190611ba7565b60405180910390f35b61017c600480360381019061017791906116b3565b610687565b6040516101899190611b1d565b60405180910390f35b6101ac60048036038101906101a791906118c5565b6106c7565b6040516101b99190611c0d565b60405180910390f35b6101dc60048036038101906101d79190611998565b61078c565b005b6101f860048036038101906101f391906116b3565b610964565b6040516102059190611c0d565b60405180910390f35b610228600480360381019061022391906118c5565b610a0c565b005b610244600480360381019061023f9190611718565b610b8b565b005b610260600480360381019061025b9190611871565b610cdf565b005b61027c600480360381019061027791906117e6565b610e5e565b005b610298600480360381019061029391906116b3565b610fcd565b6040516102a6929190611bc2565b60405180910390f35b6102c960048036038101906102c491906116dc565b61100d565b005b6102e560048036038101906102e091906116b3565b6111b6565b6040516102f29190611beb565b60405180910390f35b610315600480360381019061031091906116b3565b61125e565b60405161032796959493929190611b38565b60405180910390f35b823373ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166302571be3836040518263ffffffff1660e01b81526004016103a19190611ba7565b60206040518083038186803b1580156103b957600080fd5b505afa1580156103cd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103f1919061168a565b73ffffffffffffffffffffffffffffffffffffffff1614610447576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161043e90611c66565b60405180910390fd5b81600160008681526020019081526020016000206005018460405161046c9190611b06565b9081526020016040518091039020908051906020019061048d92919061143d565b50837fd8c9334b1a9c2f9da342a0a2b32629c1a229b6445dad78947f674b44444a755084856040516104c0929190611c2f565b60405180910390a250505050565b823373ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166302571be3836040518263ffffffff1660e01b815260040161053f9190611ba7565b60206040518083038186803b15801561055757600080fd5b505afa15801561056b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061058f919061168a565b73ffffffffffffffffffffffffffffffffffffffff16146105e5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016105dc90611c66565b60405180910390fd5b604051806040016040528084815260200183815250600160008681526020019081526020016000206003016000820151816000015560208201518160010155905050837f1d6f5e03d3f63eb58751986629a5439baee5079ff04f345becb66e23eb154e468484604051610659929190611bc2565b60405180910390a250505050565b600060016000838152602001908152602001600020600101549050919050565b60006001600083815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050919050565b606060016000848152602001908152602001600020600501826040516106ed9190611b06565b9081526020016040518091039020805461070690611e2c565b80601f016020809104026020016040519081016040528092919081815260200182805461073290611e2c565b801561077f5780601f106107545761010080835404028352916020019161077f565b820191906000526020600020905b81548152906001019060200180831161076257829003601f168201915b5050505050905092915050565b823373ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166302571be3836040518263ffffffff1660e01b81526004016107fd9190611ba7565b60206040518083038186803b15801561081557600080fd5b505afa158015610829573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061084d919061168a565b73ffffffffffffffffffffffffffffffffffffffff16146108a3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161089a90611c66565b60405180910390fd5b6000836001856108b39190611d70565b16146108f4576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016108eb90611c86565b60405180910390fd5b81600160008681526020019081526020016000206006016000858152602001908152602001600020908051906020019061092f9291906114c3565b5082847faa121bbeef5f32f5961a2a28966e769023910fc9479059ee3495d4c1a696efe360405160405180910390a350505050565b606060016000838152602001908152602001600020600201805461098790611e2c565b80601f01602080910402602001604051908101604052809291908181526020018280546109b390611e2c565b8015610a005780601f106109d557610100808354040283529160200191610a00565b820191906000526020600020905b8154815290600101906020018083116109e357829003601f168201915b50505050509050919050565b813373ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166302571be3836040518263ffffffff1660e01b8152600401610a7d9190611ba7565b60206040518083038186803b158015610a9557600080fd5b505afa158015610aa9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610acd919061168a565b73ffffffffffffffffffffffffffffffffffffffff1614610b23576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610b1a90611c66565b60405180910390fd5b81600160008581526020019081526020016000206002019080519060200190610b4d92919061143d565b50827fb7d29e911041e8d9b843369e890bcb72c9388692ba48b65ac54e7214c4c348f783604051610b7e9190611c0d565b60405180910390a2505050565b863373ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166302571be3836040518263ffffffff1660e01b8152600401610bfc9190611ba7565b60206040518083038186803b158015610c1457600080fd5b505afa158015610c28573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c4c919061168a565b73ffffffffffffffffffffffffffffffffffffffff1614610ca2576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610c9990611c66565b60405180910390fd5b610cac888861100d565b610cb68887610e5e565b610cc08886610cdf565b610ccb8885856104ce565b610cd58883610a0c565b5050505050505050565b813373ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166302571be3836040518263ffffffff1660e01b8152600401610d509190611ba7565b60206040518083038186803b158015610d6857600080fd5b505afa158015610d7c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610da0919061168a565b73ffffffffffffffffffffffffffffffffffffffff1614610df6576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ded90611c66565b60405180910390fd5b81600160008581526020019081526020016000206007019080519060200190610e209291906114c3565b50827fc0b0fc07269fc2749adada3221c095a1d2187b2d075b51c915857b520f3a502183604051610e519190611beb565b60405180910390a2505050565b813373ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166302571be3836040518263ffffffff1660e01b8152600401610ecf9190611ba7565b60206040518083038186803b158015610ee757600080fd5b505afa158015610efb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f1f919061168a565b73ffffffffffffffffffffffffffffffffffffffff1614610f75576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610f6c90611c66565b60405180910390fd5b816001600085815260200190815260200160002060010181905550827f0424b6fe0d9c3bdbece0e7879dc241bb0c22e900be8b6c168b4ee08bd9bf83bc83604051610fc09190611ba7565b60405180910390a2505050565b6000806001600084815260200190815260200160002060030160000154600160008581526020019081526020016000206003016001015491509150915091565b813373ffffffffffffffffffffffffffffffffffffffff1660008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166302571be3836040518263ffffffff1660e01b815260040161107e9190611ba7565b60206040518083038186803b15801561109657600080fd5b505afa1580156110aa573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110ce919061168a565b73ffffffffffffffffffffffffffffffffffffffff1614611124576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161111b90611c66565b60405180910390fd5b816001600085815260200190815260200160002060000160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550827f52d7d861f09ab3d26239d492e8968629f95e9e318cf0b73bfddc441522a15fd2836040516111a99190611b1d565b60405180910390a2505050565b60606001600083815260200190815260200160002060070180546111d990611e2c565b80601f016020809104026020016040519081016040528092919081815260200182805461120590611e2c565b80156112525780601f1061122757610100808354040283529160200191611252565b820191906000526020600020905b81548152906001019060200180831161123557829003601f168201915b50505050509050919050565b600080606060008060606001600088815260200190815260200160002060000160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169550600160008881526020019081526020016000206001015494506001600088815260200190815260200160002060070180546112db90611e2c565b80601f016020809104026020016040519081016040528092919081815260200182805461130790611e2c565b80156113545780601f1061132957610100808354040283529160200191611354565b820191906000526020600020905b81548152906001019060200180831161133757829003601f168201915b5050505050935060016000888152602001908152602001600020600301600001549250600160008881526020019081526020016000206003016001015491506001600088815260200190815260200160002060020180546113b490611e2c565b80601f01602080910402602001604051908101604052809291908181526020018280546113e090611e2c565b801561142d5780601f106114025761010080835404028352916020019161142d565b820191906000526020600020905b81548152906001019060200180831161141057829003601f168201915b5050505050905091939550919395565b82805461144990611e2c565b90600052602060002090601f01602090048101928261146b57600085556114b2565b82601f1061148457805160ff19168380011785556114b2565b828001600101855582156114b2579182015b828111156114b1578251825591602001919060010190611496565b5b5090506114bf9190611549565b5090565b8280546114cf90611e2c565b90600052602060002090601f0160209004810192826114f15760008555611538565b82601f1061150a57805160ff1916838001178555611538565b82800160010185558215611538579182015b8281111561153757825182559160200191906001019061151c565b5b5090506115459190611549565b5090565b5b8082111561156257600081600090555060010161154a565b5090565b600061157961157484611ccb565b611ca6565b90508281526020810184848401111561159157600080fd5b61159c848285611dea565b509392505050565b60006115b76115b284611cfc565b611ca6565b9050828152602081018484840111156115cf57600080fd5b6115da848285611dea565b509392505050565b6000813590506115f181611f59565b92915050565b60008151905061160681611f59565b92915050565b60008135905061161b81611f70565b92915050565b600082601f83011261163257600080fd5b8135611642848260208601611566565b91505092915050565b600082601f83011261165c57600080fd5b813561166c8482602086016115a4565b91505092915050565b60008135905061168481611f87565b92915050565b60006020828403121561169c57600080fd5b60006116aa848285016115f7565b91505092915050565b6000602082840312156116c557600080fd5b60006116d38482850161160c565b91505092915050565b600080604083850312156116ef57600080fd5b60006116fd8582860161160c565b925050602061170e858286016115e2565b9150509250929050565b600080600080600080600060e0888a03121561173357600080fd5b60006117418a828b0161160c565b97505060206117528a828b016115e2565b96505060406117638a828b0161160c565b955050606088013567ffffffffffffffff81111561178057600080fd5b61178c8a828b01611621565b945050608061179d8a828b0161160c565b93505060a06117ae8a828b0161160c565b92505060c088013567ffffffffffffffff8111156117cb57600080fd5b6117d78a828b0161164b565b91505092959891949750929550565b600080604083850312156117f957600080fd5b60006118078582860161160c565b92505060206118188582860161160c565b9150509250929050565b60008060006060848603121561183757600080fd5b60006118458682870161160c565b93505060206118568682870161160c565b92505060406118678682870161160c565b9150509250925092565b6000806040838503121561188457600080fd5b60006118928582860161160c565b925050602083013567ffffffffffffffff8111156118af57600080fd5b6118bb85828601611621565b9150509250929050565b600080604083850312156118d857600080fd5b60006118e68582860161160c565b925050602083013567ffffffffffffffff81111561190357600080fd5b61190f8582860161164b565b9150509250929050565b60008060006060848603121561192e57600080fd5b600061193c8682870161160c565b935050602084013567ffffffffffffffff81111561195957600080fd5b6119658682870161164b565b925050604084013567ffffffffffffffff81111561198257600080fd5b61198e8682870161164b565b9150509250925092565b6000806000606084860312156119ad57600080fd5b60006119bb8682870161160c565b93505060206119cc86828701611675565b925050604084013567ffffffffffffffff8111156119e957600080fd5b6119f586828701611621565b9150509250925092565b611a0881611da4565b82525050565b611a1781611db6565b82525050565b6000611a2882611d2d565b611a328185611d43565b9350611a42818560208601611df9565b611a4b81611f1c565b840191505092915050565b6000611a6182611d38565b611a6b8185611d54565b9350611a7b818560208601611df9565b611a8481611f1c565b840191505092915050565b6000611a9a82611d38565b611aa48185611d65565b9350611ab4818560208601611df9565b80840191505092915050565b6000611acd601383611d54565b9150611ad882611f2d565b602082019050919050565b6000611af0600083611d54565b9150611afb82611f56565b600082019050919050565b6000611b128284611a8f565b915081905092915050565b6000602082019050611b3260008301846119ff565b92915050565b600060c082019050611b4d60008301896119ff565b611b5a6020830188611a0e565b8181036040830152611b6c8187611a1d565b9050611b7b6060830186611a0e565b611b886080830185611a0e565b81810360a0830152611b9a8184611a56565b9050979650505050505050565b6000602082019050611bbc6000830184611a0e565b92915050565b6000604082019050611bd76000830185611a0e565b611be46020830184611a0e565b9392505050565b60006020820190508181036000830152611c058184611a1d565b905092915050565b60006020820190508181036000830152611c278184611a56565b905092915050565b60006040820190508181036000830152611c498185611a56565b90508181036020830152611c5d8184611a56565b90509392505050565b60006020820190508181036000830152611c7f81611ac0565b9050919050565b60006020820190508181036000830152611c9f81611ae3565b9050919050565b6000611cb0611cc1565b9050611cbc8282611e5e565b919050565b6000604051905090565b600067ffffffffffffffff821115611ce657611ce5611eed565b5b611cef82611f1c565b9050602081019050919050565b600067ffffffffffffffff821115611d1757611d16611eed565b5b611d2082611f1c565b9050602081019050919050565b600081519050919050565b600081519050919050565b600082825260208201905092915050565b600082825260208201905092915050565b600081905092915050565b6000611d7b82611de0565b9150611d8683611de0565b925082821015611d9957611d98611e8f565b5b828203905092915050565b6000611daf82611dc0565b9050919050565b6000819050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b82818337600083830152505050565b60005b83811015611e17578082015181840152602081019050611dfc565b83811115611e26576000848401525b50505050565b60006002820490506001821680611e4457607f821691505b60208210811415611e5857611e57611ebe565b5b50919050565b611e6782611f1c565b810181811067ffffffffffffffff82111715611e8657611e85611eed565b5b80604052505050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b6000601f19601f8301169050919050565b7f4f776e6572206973206e6f742073656e64657200000000000000000000000000600082015250565b50565b611f6281611da4565b8114611f6d57600080fd5b50565b611f7981611db6565b8114611f8457600080fd5b50565b611f9081611de0565b8114611f9b57600080fd5b5056fea2646970667358221220bae0c05770682aa0d6ad384962c3018d8f30a77afb8d72e7916a6299cfff797f64736f6c63430008040033","linkReferences":{},"deployedLinkReferences":{}}');
    }
  },
      t = {};

  function r(f) {
    var n = t[f];
    if (void 0 !== n) return n.exports;
    var i = t[f] = {
      id: f,
      loaded: !1,
      exports: {}
    };
    return e[f].call(i.exports, i, i.exports, r), i.loaded = !0, i.exports;
  }

  return r.amdO = {}, r.n = f => {
    var e = f && f.__esModule ? () => f.default : () => f;
    return r.d(e, {
      a: e
    }), e;
  }, r.d = (f, e) => {
    for (var t in e) r.o(e, t) && !r.o(f, t) && Object.defineProperty(f, t, {
      enumerable: !0,
      get: e[t]
    });
  }, r.g = function () {
    if ("object" == typeof globalThis) return globalThis;

    try {
      return this || new Function("return this")();
    } catch (f) {
      if ("object" == typeof window) return window;
    }
  }(), r.o = (f, e) => Object.prototype.hasOwnProperty.call(f, e), r.r = f => {
    "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(f, Symbol.toStringTag, {
      value: "Module"
    }), Object.defineProperty(f, "__esModule", {
      value: !0
    });
  }, r.nmd = f => (f.paths = [], f.children || (f.children = []), f), r(4432);
})());

/***/ }),

/***/ "./node_modules/aes-js/index.js":
/*!**************************************!*\
  !*** ./node_modules/aes-js/index.js ***!
  \**************************************/
/***/ (function(module) {

"use strict";


(function (root) {
  function checkInt(value) {
    return parseInt(value) === value;
  }

  function checkInts(arrayish) {
    if (!checkInt(arrayish.length)) {
      return false;
    }

    for (var i = 0; i < arrayish.length; i++) {
      if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {
        return false;
      }
    }

    return true;
  }

  function coerceArray(arg, copy) {
    // ArrayBuffer view
    if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === 'Uint8Array') {
      if (copy) {
        if (arg.slice) {
          arg = arg.slice();
        } else {
          arg = Array.prototype.slice.call(arg);
        }
      }

      return arg;
    } // It's an array; check it is a valid representation of a byte


    if (Array.isArray(arg)) {
      if (!checkInts(arg)) {
        throw new Error('Array contains invalid value: ' + arg);
      }

      return new Uint8Array(arg);
    } // Something else, but behaves like an array (maybe a Buffer? Arguments?)


    if (checkInt(arg.length) && checkInts(arg)) {
      return new Uint8Array(arg);
    }

    throw new Error('unsupported array-like object');
  }

  function createArray(length) {
    return new Uint8Array(length);
  }

  function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
    if (sourceStart != null || sourceEnd != null) {
      if (sourceArray.slice) {
        sourceArray = sourceArray.slice(sourceStart, sourceEnd);
      } else {
        sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
      }
    }

    targetArray.set(sourceArray, targetStart);
  }

  var convertUtf8 = function () {
    function toBytes(text) {
      var result = [],
          i = 0;
      text = encodeURI(text);

      while (i < text.length) {
        var c = text.charCodeAt(i++); // if it is a % sign, encode the following 2 bytes as a hex value

        if (c === 37) {
          result.push(parseInt(text.substr(i, 2), 16));
          i += 2; // otherwise, just the actual byte
        } else {
          result.push(c);
        }
      }

      return coerceArray(result);
    }

    function fromBytes(bytes) {
      var result = [],
          i = 0;

      while (i < bytes.length) {
        var c = bytes[i];

        if (c < 128) {
          result.push(String.fromCharCode(c));
          i++;
        } else if (c > 191 && c < 224) {
          result.push(String.fromCharCode((c & 0x1f) << 6 | bytes[i + 1] & 0x3f));
          i += 2;
        } else {
          result.push(String.fromCharCode((c & 0x0f) << 12 | (bytes[i + 1] & 0x3f) << 6 | bytes[i + 2] & 0x3f));
          i += 3;
        }
      }

      return result.join('');
    }

    return {
      toBytes: toBytes,
      fromBytes: fromBytes
    };
  }();

  var convertHex = function () {
    function toBytes(text) {
      var result = [];

      for (var i = 0; i < text.length; i += 2) {
        result.push(parseInt(text.substr(i, 2), 16));
      }

      return result;
    } // http://ixti.net/development/javascript/2011/11/11/base64-encodedecode-of-utf8-in-browser-with-js.html


    var Hex = '0123456789abcdef';

    function fromBytes(bytes) {
      var result = [];

      for (var i = 0; i < bytes.length; i++) {
        var v = bytes[i];
        result.push(Hex[(v & 0xf0) >> 4] + Hex[v & 0x0f]);
      }

      return result.join('');
    }

    return {
      toBytes: toBytes,
      fromBytes: fromBytes
    };
  }(); // Number of rounds by keysize


  var numberOfRounds = {
    16: 10,
    24: 12,
    32: 14
  }; // Round constant words

  var rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91]; // S-box and Inverse S-box (S is for Substitution)

  var S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];
  var Si = [0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d]; // Transformations for encryption

  var T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];
  var T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];
  var T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];
  var T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c]; // Transformations for decryption

  var T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];
  var T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];
  var T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];
  var T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0]; // Transformations for decryption key expansion

  var U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];
  var U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];
  var U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];
  var U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];

  function convertToInt32(bytes) {
    var result = [];

    for (var i = 0; i < bytes.length; i += 4) {
      result.push(bytes[i] << 24 | bytes[i + 1] << 16 | bytes[i + 2] << 8 | bytes[i + 3]);
    }

    return result;
  }

  var AES = function (key) {
    if (!(this instanceof AES)) {
      throw Error('AES must be instanitated with `new`');
    }

    Object.defineProperty(this, 'key', {
      value: coerceArray(key, true)
    });

    this._prepare();
  };

  AES.prototype._prepare = function () {
    var rounds = numberOfRounds[this.key.length];

    if (rounds == null) {
      throw new Error('invalid key size (must be 16, 24 or 32 bytes)');
    } // encryption round keys


    this._Ke = []; // decryption round keys

    this._Kd = [];

    for (var i = 0; i <= rounds; i++) {
      this._Ke.push([0, 0, 0, 0]);

      this._Kd.push([0, 0, 0, 0]);
    }

    var roundKeyCount = (rounds + 1) * 4;
    var KC = this.key.length / 4; // convert the key into ints

    var tk = convertToInt32(this.key); // copy values into round key arrays

    var index;

    for (var i = 0; i < KC; i++) {
      index = i >> 2;
      this._Ke[index][i % 4] = tk[i];
      this._Kd[rounds - index][i % 4] = tk[i];
    } // key expansion (fips-197 section 5.2)


    var rconpointer = 0;
    var t = KC,
        tt;

    while (t < roundKeyCount) {
      tt = tk[KC - 1];
      tk[0] ^= S[tt >> 16 & 0xFF] << 24 ^ S[tt >> 8 & 0xFF] << 16 ^ S[tt & 0xFF] << 8 ^ S[tt >> 24 & 0xFF] ^ rcon[rconpointer] << 24;
      rconpointer += 1; // key expansion (for non-256 bit)

      if (KC != 8) {
        for (var i = 1; i < KC; i++) {
          tk[i] ^= tk[i - 1];
        } // key expansion for 256-bit keys is "slightly different" (fips-197)

      } else {
        for (var i = 1; i < KC / 2; i++) {
          tk[i] ^= tk[i - 1];
        }

        tt = tk[KC / 2 - 1];
        tk[KC / 2] ^= S[tt & 0xFF] ^ S[tt >> 8 & 0xFF] << 8 ^ S[tt >> 16 & 0xFF] << 16 ^ S[tt >> 24 & 0xFF] << 24;

        for (var i = KC / 2 + 1; i < KC; i++) {
          tk[i] ^= tk[i - 1];
        }
      } // copy values into round key arrays


      var i = 0,
          r,
          c;

      while (i < KC && t < roundKeyCount) {
        r = t >> 2;
        c = t % 4;
        this._Ke[r][c] = tk[i];
        this._Kd[rounds - r][c] = tk[i++];
        t++;
      }
    } // inverse-cipher-ify the decryption round key (fips-197 section 5.3)


    for (var r = 1; r < rounds; r++) {
      for (var c = 0; c < 4; c++) {
        tt = this._Kd[r][c];
        this._Kd[r][c] = U1[tt >> 24 & 0xFF] ^ U2[tt >> 16 & 0xFF] ^ U3[tt >> 8 & 0xFF] ^ U4[tt & 0xFF];
      }
    }
  };

  AES.prototype.encrypt = function (plaintext) {
    if (plaintext.length != 16) {
      throw new Error('invalid plaintext size (must be 16 bytes)');
    }

    var rounds = this._Ke.length - 1;
    var a = [0, 0, 0, 0]; // convert plaintext to (ints ^ key)

    var t = convertToInt32(plaintext);

    for (var i = 0; i < 4; i++) {
      t[i] ^= this._Ke[0][i];
    } // apply round transforms


    for (var r = 1; r < rounds; r++) {
      for (var i = 0; i < 4; i++) {
        a[i] = T1[t[i] >> 24 & 0xff] ^ T2[t[(i + 1) % 4] >> 16 & 0xff] ^ T3[t[(i + 2) % 4] >> 8 & 0xff] ^ T4[t[(i + 3) % 4] & 0xff] ^ this._Ke[r][i];
      }

      t = a.slice();
    } // the last round is special


    var result = createArray(16),
        tt;

    for (var i = 0; i < 4; i++) {
      tt = this._Ke[rounds][i];
      result[4 * i] = (S[t[i] >> 24 & 0xff] ^ tt >> 24) & 0xff;
      result[4 * i + 1] = (S[t[(i + 1) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;
      result[4 * i + 2] = (S[t[(i + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;
      result[4 * i + 3] = (S[t[(i + 3) % 4] & 0xff] ^ tt) & 0xff;
    }

    return result;
  };

  AES.prototype.decrypt = function (ciphertext) {
    if (ciphertext.length != 16) {
      throw new Error('invalid ciphertext size (must be 16 bytes)');
    }

    var rounds = this._Kd.length - 1;
    var a = [0, 0, 0, 0]; // convert plaintext to (ints ^ key)

    var t = convertToInt32(ciphertext);

    for (var i = 0; i < 4; i++) {
      t[i] ^= this._Kd[0][i];
    } // apply round transforms


    for (var r = 1; r < rounds; r++) {
      for (var i = 0; i < 4; i++) {
        a[i] = T5[t[i] >> 24 & 0xff] ^ T6[t[(i + 3) % 4] >> 16 & 0xff] ^ T7[t[(i + 2) % 4] >> 8 & 0xff] ^ T8[t[(i + 1) % 4] & 0xff] ^ this._Kd[r][i];
      }

      t = a.slice();
    } // the last round is special


    var result = createArray(16),
        tt;

    for (var i = 0; i < 4; i++) {
      tt = this._Kd[rounds][i];
      result[4 * i] = (Si[t[i] >> 24 & 0xff] ^ tt >> 24) & 0xff;
      result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 0xff] ^ tt >> 16) & 0xff;
      result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 0xff] ^ tt >> 8) & 0xff;
      result[4 * i + 3] = (Si[t[(i + 1) % 4] & 0xff] ^ tt) & 0xff;
    }

    return result;
  };
  /**
   *  Mode Of Operation - Electonic Codebook (ECB)
   */


  var ModeOfOperationECB = function (key) {
    if (!(this instanceof ModeOfOperationECB)) {
      throw Error('AES must be instanitated with `new`');
    }

    this.description = "Electronic Code Block";
    this.name = "ecb";
    this._aes = new AES(key);
  };

  ModeOfOperationECB.prototype.encrypt = function (plaintext) {
    plaintext = coerceArray(plaintext);

    if (plaintext.length % 16 !== 0) {
      throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
    }

    var ciphertext = createArray(plaintext.length);
    var block = createArray(16);

    for (var i = 0; i < plaintext.length; i += 16) {
      copyArray(plaintext, block, 0, i, i + 16);
      block = this._aes.encrypt(block);
      copyArray(block, ciphertext, i);
    }

    return ciphertext;
  };

  ModeOfOperationECB.prototype.decrypt = function (ciphertext) {
    ciphertext = coerceArray(ciphertext);

    if (ciphertext.length % 16 !== 0) {
      throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
    }

    var plaintext = createArray(ciphertext.length);
    var block = createArray(16);

    for (var i = 0; i < ciphertext.length; i += 16) {
      copyArray(ciphertext, block, 0, i, i + 16);
      block = this._aes.decrypt(block);
      copyArray(block, plaintext, i);
    }

    return plaintext;
  };
  /**
   *  Mode Of Operation - Cipher Block Chaining (CBC)
   */


  var ModeOfOperationCBC = function (key, iv) {
    if (!(this instanceof ModeOfOperationCBC)) {
      throw Error('AES must be instanitated with `new`');
    }

    this.description = "Cipher Block Chaining";
    this.name = "cbc";

    if (!iv) {
      iv = createArray(16);
    } else if (iv.length != 16) {
      throw new Error('invalid initialation vector size (must be 16 bytes)');
    }

    this._lastCipherblock = coerceArray(iv, true);
    this._aes = new AES(key);
  };

  ModeOfOperationCBC.prototype.encrypt = function (plaintext) {
    plaintext = coerceArray(plaintext);

    if (plaintext.length % 16 !== 0) {
      throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
    }

    var ciphertext = createArray(plaintext.length);
    var block = createArray(16);

    for (var i = 0; i < plaintext.length; i += 16) {
      copyArray(plaintext, block, 0, i, i + 16);

      for (var j = 0; j < 16; j++) {
        block[j] ^= this._lastCipherblock[j];
      }

      this._lastCipherblock = this._aes.encrypt(block);
      copyArray(this._lastCipherblock, ciphertext, i);
    }

    return ciphertext;
  };

  ModeOfOperationCBC.prototype.decrypt = function (ciphertext) {
    ciphertext = coerceArray(ciphertext);

    if (ciphertext.length % 16 !== 0) {
      throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
    }

    var plaintext = createArray(ciphertext.length);
    var block = createArray(16);

    for (var i = 0; i < ciphertext.length; i += 16) {
      copyArray(ciphertext, block, 0, i, i + 16);
      block = this._aes.decrypt(block);

      for (var j = 0; j < 16; j++) {
        plaintext[i + j] = block[j] ^ this._lastCipherblock[j];
      }

      copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);
    }

    return plaintext;
  };
  /**
   *  Mode Of Operation - Cipher Feedback (CFB)
   */


  var ModeOfOperationCFB = function (key, iv, segmentSize) {
    if (!(this instanceof ModeOfOperationCFB)) {
      throw Error('AES must be instanitated with `new`');
    }

    this.description = "Cipher Feedback";
    this.name = "cfb";

    if (!iv) {
      iv = createArray(16);
    } else if (iv.length != 16) {
      throw new Error('invalid initialation vector size (must be 16 size)');
    }

    if (!segmentSize) {
      segmentSize = 1;
    }

    this.segmentSize = segmentSize;
    this._shiftRegister = coerceArray(iv, true);
    this._aes = new AES(key);
  };

  ModeOfOperationCFB.prototype.encrypt = function (plaintext) {
    if (plaintext.length % this.segmentSize != 0) {
      throw new Error('invalid plaintext size (must be segmentSize bytes)');
    }

    var encrypted = coerceArray(plaintext, true);
    var xorSegment;

    for (var i = 0; i < encrypted.length; i += this.segmentSize) {
      xorSegment = this._aes.encrypt(this._shiftRegister);

      for (var j = 0; j < this.segmentSize; j++) {
        encrypted[i + j] ^= xorSegment[j];
      } // Shift the register


      copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
      copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
    }

    return encrypted;
  };

  ModeOfOperationCFB.prototype.decrypt = function (ciphertext) {
    if (ciphertext.length % this.segmentSize != 0) {
      throw new Error('invalid ciphertext size (must be segmentSize bytes)');
    }

    var plaintext = coerceArray(ciphertext, true);
    var xorSegment;

    for (var i = 0; i < plaintext.length; i += this.segmentSize) {
      xorSegment = this._aes.encrypt(this._shiftRegister);

      for (var j = 0; j < this.segmentSize; j++) {
        plaintext[i + j] ^= xorSegment[j];
      } // Shift the register


      copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
      copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
    }

    return plaintext;
  };
  /**
   *  Mode Of Operation - Output Feedback (OFB)
   */


  var ModeOfOperationOFB = function (key, iv) {
    if (!(this instanceof ModeOfOperationOFB)) {
      throw Error('AES must be instanitated with `new`');
    }

    this.description = "Output Feedback";
    this.name = "ofb";

    if (!iv) {
      iv = createArray(16);
    } else if (iv.length != 16) {
      throw new Error('invalid initialation vector size (must be 16 bytes)');
    }

    this._lastPrecipher = coerceArray(iv, true);
    this._lastPrecipherIndex = 16;
    this._aes = new AES(key);
  };

  ModeOfOperationOFB.prototype.encrypt = function (plaintext) {
    var encrypted = coerceArray(plaintext, true);

    for (var i = 0; i < encrypted.length; i++) {
      if (this._lastPrecipherIndex === 16) {
        this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
        this._lastPrecipherIndex = 0;
      }

      encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];
    }

    return encrypted;
  }; // Decryption is symetric


  ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;
  /**
   *  Counter object for CTR common mode of operation
   */

  var Counter = function (initialValue) {
    if (!(this instanceof Counter)) {
      throw Error('Counter must be instanitated with `new`');
    } // We allow 0, but anything false-ish uses the default 1


    if (initialValue !== 0 && !initialValue) {
      initialValue = 1;
    }

    if (typeof initialValue === 'number') {
      this._counter = createArray(16);
      this.setValue(initialValue);
    } else {
      this.setBytes(initialValue);
    }
  };

  Counter.prototype.setValue = function (value) {
    if (typeof value !== 'number' || parseInt(value) != value) {
      throw new Error('invalid counter value (must be an integer)');
    }

    for (var index = 15; index >= 0; --index) {
      this._counter[index] = value % 256;
      value = value >> 8;
    }
  };

  Counter.prototype.setBytes = function (bytes) {
    bytes = coerceArray(bytes, true);

    if (bytes.length != 16) {
      throw new Error('invalid counter bytes size (must be 16 bytes)');
    }

    this._counter = bytes;
  };

  Counter.prototype.increment = function () {
    for (var i = 15; i >= 0; i--) {
      if (this._counter[i] === 255) {
        this._counter[i] = 0;
      } else {
        this._counter[i]++;
        break;
      }
    }
  };
  /**
   *  Mode Of Operation - Counter (CTR)
   */


  var ModeOfOperationCTR = function (key, counter) {
    if (!(this instanceof ModeOfOperationCTR)) {
      throw Error('AES must be instanitated with `new`');
    }

    this.description = "Counter";
    this.name = "ctr";

    if (!(counter instanceof Counter)) {
      counter = new Counter(counter);
    }

    this._counter = counter;
    this._remainingCounter = null;
    this._remainingCounterIndex = 16;
    this._aes = new AES(key);
  };

  ModeOfOperationCTR.prototype.encrypt = function (plaintext) {
    var encrypted = coerceArray(plaintext, true);

    for (var i = 0; i < encrypted.length; i++) {
      if (this._remainingCounterIndex === 16) {
        this._remainingCounter = this._aes.encrypt(this._counter._counter);
        this._remainingCounterIndex = 0;

        this._counter.increment();
      }

      encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];
    }

    return encrypted;
  }; // Decryption is symetric


  ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt; ///////////////////////
  // Padding
  // See:https://tools.ietf.org/html/rfc2315

  function pkcs7pad(data) {
    data = coerceArray(data, true);
    var padder = 16 - data.length % 16;
    var result = createArray(data.length + padder);
    copyArray(data, result);

    for (var i = data.length; i < result.length; i++) {
      result[i] = padder;
    }

    return result;
  }

  function pkcs7strip(data) {
    data = coerceArray(data, true);

    if (data.length < 16) {
      throw new Error('PKCS#7 invalid length');
    }

    var padder = data[data.length - 1];

    if (padder > 16) {
      throw new Error('PKCS#7 padding byte out of range');
    }

    var length = data.length - padder;

    for (var i = 0; i < padder; i++) {
      if (data[length + i] !== padder) {
        throw new Error('PKCS#7 invalid padding byte');
      }
    }

    var result = createArray(length);
    copyArray(data, result, 0, 0, length);
    return result;
  } ///////////////////////
  // Exporting
  // The block cipher


  var aesjs = {
    AES: AES,
    Counter: Counter,
    ModeOfOperation: {
      ecb: ModeOfOperationECB,
      cbc: ModeOfOperationCBC,
      cfb: ModeOfOperationCFB,
      ofb: ModeOfOperationOFB,
      ctr: ModeOfOperationCTR
    },
    utils: {
      hex: convertHex,
      utf8: convertUtf8
    },
    padding: {
      pkcs7: {
        pad: pkcs7pad,
        strip: pkcs7strip
      }
    },
    _arrayTest: {
      coerceArray: coerceArray,
      createArray: createArray,
      copyArray: copyArray
    }
  }; // node.js

  if (true) {
    module.exports = aesjs; // RequireJS/AMD
    // http://www.requirejs.org/docs/api.html
    // https://github.com/amdjs/amdjs-api/wiki/AMD
  } else {}
})(this);

/***/ }),

/***/ "./node_modules/bech32/index.js":
/*!**************************************!*\
  !*** ./node_modules/bech32/index.js ***!
  \**************************************/
/***/ ((module) => {

"use strict";


var ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'; // pre-compute lookup table

var ALPHABET_MAP = {};

for (var z = 0; z < ALPHABET.length; z++) {
  var x = ALPHABET.charAt(z);
  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous');
  ALPHABET_MAP[x] = z;
}

function polymodStep(pre) {
  var b = pre >> 25;
  return (pre & 0x1FFFFFF) << 5 ^ -(b >> 0 & 1) & 0x3b6a57b2 ^ -(b >> 1 & 1) & 0x26508e6d ^ -(b >> 2 & 1) & 0x1ea119fa ^ -(b >> 3 & 1) & 0x3d4233dd ^ -(b >> 4 & 1) & 0x2a1462b3;
}

function prefixChk(prefix) {
  var chk = 1;

  for (var i = 0; i < prefix.length; ++i) {
    var c = prefix.charCodeAt(i);
    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')';
    chk = polymodStep(chk) ^ c >> 5;
  }

  chk = polymodStep(chk);

  for (i = 0; i < prefix.length; ++i) {
    var v = prefix.charCodeAt(i);
    chk = polymodStep(chk) ^ v & 0x1f;
  }

  return chk;
}

function encode(prefix, words, LIMIT) {
  LIMIT = LIMIT || 90;
  if (prefix.length + 7 + words.length > LIMIT) throw new TypeError('Exceeds length limit');
  prefix = prefix.toLowerCase(); // determine chk mod

  var chk = prefixChk(prefix);
  if (typeof chk === 'string') throw new Error(chk);
  var result = prefix + '1';

  for (var i = 0; i < words.length; ++i) {
    var x = words[i];
    if (x >> 5 !== 0) throw new Error('Non 5-bit word');
    chk = polymodStep(chk) ^ x;
    result += ALPHABET.charAt(x);
  }

  for (i = 0; i < 6; ++i) {
    chk = polymodStep(chk);
  }

  chk ^= 1;

  for (i = 0; i < 6; ++i) {
    var v = chk >> (5 - i) * 5 & 0x1f;
    result += ALPHABET.charAt(v);
  }

  return result;
}

function __decode(str, LIMIT) {
  LIMIT = LIMIT || 90;
  if (str.length < 8) return str + ' too short';
  if (str.length > LIMIT) return 'Exceeds length limit'; // don't allow mixed case

  var lowered = str.toLowerCase();
  var uppered = str.toUpperCase();
  if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str;
  str = lowered;
  var split = str.lastIndexOf('1');
  if (split === -1) return 'No separator character for ' + str;
  if (split === 0) return 'Missing prefix for ' + str;
  var prefix = str.slice(0, split);
  var wordChars = str.slice(split + 1);
  if (wordChars.length < 6) return 'Data too short';
  var chk = prefixChk(prefix);
  if (typeof chk === 'string') return chk;
  var words = [];

  for (var i = 0; i < wordChars.length; ++i) {
    var c = wordChars.charAt(i);
    var v = ALPHABET_MAP[c];
    if (v === undefined) return 'Unknown character ' + c;
    chk = polymodStep(chk) ^ v; // not in the checksum?

    if (i + 6 >= wordChars.length) continue;
    words.push(v);
  }

  if (chk !== 1) return 'Invalid checksum for ' + str;
  return {
    prefix: prefix,
    words: words
  };
}

function decodeUnsafe() {
  var res = __decode.apply(null, arguments);

  if (typeof res === 'object') return res;
}

function decode(str) {
  var res = __decode.apply(null, arguments);

  if (typeof res === 'object') return res;
  throw new Error(res);
}

function convert(data, inBits, outBits, pad) {
  var value = 0;
  var bits = 0;
  var maxV = (1 << outBits) - 1;
  var result = [];

  for (var i = 0; i < data.length; ++i) {
    value = value << inBits | data[i];
    bits += inBits;

    while (bits >= outBits) {
      bits -= outBits;
      result.push(value >> bits & maxV);
    }
  }

  if (pad) {
    if (bits > 0) {
      result.push(value << outBits - bits & maxV);
    }
  } else {
    if (bits >= inBits) return 'Excess padding';
    if (value << outBits - bits & maxV) return 'Non-zero padding';
  }

  return result;
}

function toWordsUnsafe(bytes) {
  var res = convert(bytes, 8, 5, true);
  if (Array.isArray(res)) return res;
}

function toWords(bytes) {
  var res = convert(bytes, 8, 5, true);
  if (Array.isArray(res)) return res;
  throw new Error(res);
}

function fromWordsUnsafe(words) {
  var res = convert(words, 5, 8, false);
  if (Array.isArray(res)) return res;
}

function fromWords(words) {
  var res = convert(words, 5, 8, false);
  if (Array.isArray(res)) return res;
  throw new Error(res);
}

module.exports = {
  decodeUnsafe: decodeUnsafe,
  decode: decode,
  encode: encode,
  toWordsUnsafe: toWordsUnsafe,
  toWords: toWords,
  fromWordsUnsafe: fromWordsUnsafe,
  fromWords: fromWords
};

/***/ }),

/***/ "./node_modules/bn.js/lib/bn.js":
/*!**************************************!*\
  !*** ./node_modules/bn.js/lib/bn.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
(function (module, exports) {
  'use strict'; // Utils

  function assert(val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  } // Could use `inherits` module, but don't want to move from single file
  // architecture yet.


  function inherits(ctor, superCtor) {
    ctor.super_ = superCtor;

    var TempCtor = function () {};

    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  } // BN


  function BN(number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0; // Reduction context

    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }

  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;
  var Buffer;

  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = (__webpack_require__(/*! buffer */ "?8131").Buffer);
    }
  } catch (e) {}

  BN.isBN = function isBN(num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max(left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min(left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init(number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }

    assert(base === (base | 0) && base >= 2 && base <= 36);
    number = number.toString().replace(/\s+/g, '');
    var start = 0;

    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);

        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber(number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }

    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)

      this.words = [number & 0x3ffffff, number / 0x4000000 & 0x3ffffff, 1];
      this.length = 3;
    }

    if (endian !== 'le') return; // Reverse the bytes

    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray(number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');

    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);

    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;

    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
        this.words[j] |= w << off & 0x3ffffff;
        this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
        off += 24;

        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
        this.words[j] |= w << off & 0x3ffffff;
        this.words[j + 1] = w >>> 26 - off & 0x3ffffff;
        off += 24;

        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }

    return this.strip();
  };

  function parseHex4Bits(string, index) {
    var c = string.charCodeAt(index); // 'A' - 'F'

    if (c >= 65 && c <= 70) {
      return c - 55; // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87; // '0' - '9'
    } else {
      return c - 48 & 0xf;
    }
  }

  function parseHexByte(string, lowerBound, index) {
    var r = parseHex4Bits(string, index);

    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }

    return r;
  }

  BN.prototype._parseHex = function _parseHex(number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);

    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    } // 24-bits chunks


    var off = 0;
    var j = 0;
    var w;

    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;

        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;

      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;

        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase(str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);

    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;
      r *= mul; // 'a'

      if (c >= 49) {
        r += c - 49 + 0xa; // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa; // '0' - '9'
      } else {
        r += c;
      }
    }

    return r;
  }

  BN.prototype._parseBase = function _parseBase(number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1; // Find length of limb in base

    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }

    limbLen--;
    limbPow = limbPow / base | 0;
    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;
    var word = 0;

    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);
      this.imuln(limbPow);

      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);

      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy(dest) {
    dest.words = new Array(this.length);

    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }

    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone() {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand(size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }

    return this;
  }; // Remove leading `0` from `this`


  BN.prototype.strip = function strip() {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }

    return this._normSign();
  };

  BN.prototype._normSign = function _normSign() {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }

    return this;
  };

  BN.prototype.inspect = function inspect() {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };
  /*
   var zeros = [];
  var groupSizes = [];
  var groupBases = [];
   var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }
   */


  var zeros = ['', '0', '00', '000', '0000', '00000', '000000', '0000000', '00000000', '000000000', '0000000000', '00000000000', '000000000000', '0000000000000', '00000000000000', '000000000000000', '0000000000000000', '00000000000000000', '000000000000000000', '0000000000000000000', '00000000000000000000', '000000000000000000000', '0000000000000000000000', '00000000000000000000000', '000000000000000000000000', '0000000000000000000000000'];
  var groupSizes = [0, 0, 25, 16, 12, 11, 10, 9, 8, 8, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5];
  var groupBases = [0, 0, 33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216, 43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625, 16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632, 6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149, 24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176];

  BN.prototype.toString = function toString(base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;
    var out;

    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;

      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = ((w << off | carry) & 0xffffff).toString(16);
        carry = w >>> 24 - off & 0xffffff;

        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }

        off += 2;

        if (off >= 26) {
          off -= 26;
          i--;
        }
      }

      if (carry !== 0) {
        out = carry.toString(16) + out;
      }

      while (out.length % padding !== 0) {
        out = '0' + out;
      }

      if (this.negative !== 0) {
        out = '-' + out;
      }

      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base]; // var groupBase = Math.pow(base, groupSize);

      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;

      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }

      if (this.isZero()) {
        out = '0' + out;
      }

      while (out.length % padding !== 0) {
        out = '0' + out;
      }

      if (this.negative !== 0) {
        out = '-' + out;
      }

      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber() {
    var ret = this.words[0];

    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + this.words[1] * 0x4000000;
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }

    return this.negative !== 0 ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON() {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer(endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray(endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');
    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);
    var b, i;
    var q = this.clone();

    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);
        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);
        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits(w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits(w) {
      var t = w;
      var r = 0;

      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }

      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }

      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }

      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }

      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits(w) {
    // Short-cut
    if (w === 0) return 26;
    var t = w;
    var r = 0;

    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }

    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }

    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }

    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }

    if ((t & 0x1) === 0) {
      r++;
    }

    return r;
  }; // Return number of used bits in a BN


  BN.prototype.bitLength = function bitLength() {
    var w = this.words[this.length - 1];

    var hi = this._countBits(w);

    return (this.length - 1) * 26 + hi;
  };

  function toBitArray(num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
    }

    return w;
  } // Number of trailing zero bits


  BN.prototype.zeroBits = function zeroBits() {
    if (this.isZero()) return 0;
    var r = 0;

    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);

      r += b;
      if (b !== 26) break;
    }

    return r;
  };

  BN.prototype.byteLength = function byteLength() {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos(width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }

    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos(width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }

    return this.clone();
  };

  BN.prototype.isNeg = function isNeg() {
    return this.negative !== 0;
  }; // Return negative clone of `this`


  BN.prototype.neg = function neg() {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg() {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  }; // Or `num` with `this` in-place


  BN.prototype.iuor = function iuor(num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior(num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  }; // Or `num` with `this`


  BN.prototype.or = function or(num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor(num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  }; // And `num` with `this` in-place


  BN.prototype.iuand = function iuand(num) {
    // b = min-length(num, this)
    var b;

    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;
    return this.strip();
  };

  BN.prototype.iand = function iand(num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  }; // And `num` with `this`


  BN.prototype.and = function and(num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand(num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  }; // Xor `num` with `this` in-place


  BN.prototype.iuxor = function iuxor(num) {
    // a.length > b.length
    var a;
    var b;

    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;
    return this.strip();
  };

  BN.prototype.ixor = function ixor(num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  }; // Xor `num` with `this`


  BN.prototype.xor = function xor(num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor(num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  }; // Not ``this`` with ``width`` bitwidth


  BN.prototype.inotn = function inotn(width) {
    assert(typeof width === 'number' && width >= 0);
    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26; // Extend the buffer with leading zeroes

    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    } // Handle complete words


    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    } // Handle the residue


    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & 0x3ffffff >> 26 - bitsLeft;
    } // And remove leading zeroes


    return this.strip();
  };

  BN.prototype.notn = function notn(width) {
    return this.clone().inotn(width);
  }; // Set `bit` of `this`


  BN.prototype.setn = function setn(bit, val) {
    assert(typeof bit === 'number' && bit >= 0);
    var off = bit / 26 | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | 1 << wbit;
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  }; // Add `num` to `this` in-place


  BN.prototype.iadd = function iadd(num) {
    var r; // negative + positive

    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign(); // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    } // a.length > b.length


    var a, b;

    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;

    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;

    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++; // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  }; // Add `num` to `this`


  BN.prototype.add = function add(num) {
    var res;

    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);
    return num.clone().iadd(this);
  }; // Subtract `num` from `this` in-place


  BN.prototype.isub = function isub(num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign(); // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    } // At this point both numbers are positive


    var cmp = this.cmp(num); // Optimization - zeroify

    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    } // a > b


    var a, b;

    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;

    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    } // Copy rest of the words


    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  }; // Subtract `num` from `this`


  BN.prototype.sub = function sub(num) {
    return this.clone().isub(num);
  };

  function smallMulTo(self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = self.length + num.length | 0;
    out.length = len;
    len = len - 1 | 0; // Peel one iteration (compiler can't do it, because of code complexity)

    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;
    var lo = r & 0x3ffffff;
    var carry = r / 0x4000000 | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);

      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += r / 0x4000000 | 0;
        rword = r & 0x3ffffff;
      }

      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }

    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  } // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).


  var comb10MulTo = function comb10MulTo(self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;
    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */

    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = mid + Math.imul(ah0, bl0) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */

    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = mid + Math.imul(ah1, bl0) | 0;
    hi = Math.imul(ah1, bh0);
    lo = lo + Math.imul(al0, bl1) | 0;
    mid = mid + Math.imul(al0, bh1) | 0;
    mid = mid + Math.imul(ah0, bl1) | 0;
    hi = hi + Math.imul(ah0, bh1) | 0;
    var w1 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */

    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = mid + Math.imul(ah2, bl0) | 0;
    hi = Math.imul(ah2, bh0);
    lo = lo + Math.imul(al1, bl1) | 0;
    mid = mid + Math.imul(al1, bh1) | 0;
    mid = mid + Math.imul(ah1, bl1) | 0;
    hi = hi + Math.imul(ah1, bh1) | 0;
    lo = lo + Math.imul(al0, bl2) | 0;
    mid = mid + Math.imul(al0, bh2) | 0;
    mid = mid + Math.imul(ah0, bl2) | 0;
    hi = hi + Math.imul(ah0, bh2) | 0;
    var w2 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */

    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = mid + Math.imul(ah3, bl0) | 0;
    hi = Math.imul(ah3, bh0);
    lo = lo + Math.imul(al2, bl1) | 0;
    mid = mid + Math.imul(al2, bh1) | 0;
    mid = mid + Math.imul(ah2, bl1) | 0;
    hi = hi + Math.imul(ah2, bh1) | 0;
    lo = lo + Math.imul(al1, bl2) | 0;
    mid = mid + Math.imul(al1, bh2) | 0;
    mid = mid + Math.imul(ah1, bl2) | 0;
    hi = hi + Math.imul(ah1, bh2) | 0;
    lo = lo + Math.imul(al0, bl3) | 0;
    mid = mid + Math.imul(al0, bh3) | 0;
    mid = mid + Math.imul(ah0, bl3) | 0;
    hi = hi + Math.imul(ah0, bh3) | 0;
    var w3 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */

    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = mid + Math.imul(ah4, bl0) | 0;
    hi = Math.imul(ah4, bh0);
    lo = lo + Math.imul(al3, bl1) | 0;
    mid = mid + Math.imul(al3, bh1) | 0;
    mid = mid + Math.imul(ah3, bl1) | 0;
    hi = hi + Math.imul(ah3, bh1) | 0;
    lo = lo + Math.imul(al2, bl2) | 0;
    mid = mid + Math.imul(al2, bh2) | 0;
    mid = mid + Math.imul(ah2, bl2) | 0;
    hi = hi + Math.imul(ah2, bh2) | 0;
    lo = lo + Math.imul(al1, bl3) | 0;
    mid = mid + Math.imul(al1, bh3) | 0;
    mid = mid + Math.imul(ah1, bl3) | 0;
    hi = hi + Math.imul(ah1, bh3) | 0;
    lo = lo + Math.imul(al0, bl4) | 0;
    mid = mid + Math.imul(al0, bh4) | 0;
    mid = mid + Math.imul(ah0, bl4) | 0;
    hi = hi + Math.imul(ah0, bh4) | 0;
    var w4 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */

    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = mid + Math.imul(ah5, bl0) | 0;
    hi = Math.imul(ah5, bh0);
    lo = lo + Math.imul(al4, bl1) | 0;
    mid = mid + Math.imul(al4, bh1) | 0;
    mid = mid + Math.imul(ah4, bl1) | 0;
    hi = hi + Math.imul(ah4, bh1) | 0;
    lo = lo + Math.imul(al3, bl2) | 0;
    mid = mid + Math.imul(al3, bh2) | 0;
    mid = mid + Math.imul(ah3, bl2) | 0;
    hi = hi + Math.imul(ah3, bh2) | 0;
    lo = lo + Math.imul(al2, bl3) | 0;
    mid = mid + Math.imul(al2, bh3) | 0;
    mid = mid + Math.imul(ah2, bl3) | 0;
    hi = hi + Math.imul(ah2, bh3) | 0;
    lo = lo + Math.imul(al1, bl4) | 0;
    mid = mid + Math.imul(al1, bh4) | 0;
    mid = mid + Math.imul(ah1, bl4) | 0;
    hi = hi + Math.imul(ah1, bh4) | 0;
    lo = lo + Math.imul(al0, bl5) | 0;
    mid = mid + Math.imul(al0, bh5) | 0;
    mid = mid + Math.imul(ah0, bl5) | 0;
    hi = hi + Math.imul(ah0, bh5) | 0;
    var w5 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */

    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = mid + Math.imul(ah6, bl0) | 0;
    hi = Math.imul(ah6, bh0);
    lo = lo + Math.imul(al5, bl1) | 0;
    mid = mid + Math.imul(al5, bh1) | 0;
    mid = mid + Math.imul(ah5, bl1) | 0;
    hi = hi + Math.imul(ah5, bh1) | 0;
    lo = lo + Math.imul(al4, bl2) | 0;
    mid = mid + Math.imul(al4, bh2) | 0;
    mid = mid + Math.imul(ah4, bl2) | 0;
    hi = hi + Math.imul(ah4, bh2) | 0;
    lo = lo + Math.imul(al3, bl3) | 0;
    mid = mid + Math.imul(al3, bh3) | 0;
    mid = mid + Math.imul(ah3, bl3) | 0;
    hi = hi + Math.imul(ah3, bh3) | 0;
    lo = lo + Math.imul(al2, bl4) | 0;
    mid = mid + Math.imul(al2, bh4) | 0;
    mid = mid + Math.imul(ah2, bl4) | 0;
    hi = hi + Math.imul(ah2, bh4) | 0;
    lo = lo + Math.imul(al1, bl5) | 0;
    mid = mid + Math.imul(al1, bh5) | 0;
    mid = mid + Math.imul(ah1, bl5) | 0;
    hi = hi + Math.imul(ah1, bh5) | 0;
    lo = lo + Math.imul(al0, bl6) | 0;
    mid = mid + Math.imul(al0, bh6) | 0;
    mid = mid + Math.imul(ah0, bl6) | 0;
    hi = hi + Math.imul(ah0, bh6) | 0;
    var w6 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */

    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = mid + Math.imul(ah7, bl0) | 0;
    hi = Math.imul(ah7, bh0);
    lo = lo + Math.imul(al6, bl1) | 0;
    mid = mid + Math.imul(al6, bh1) | 0;
    mid = mid + Math.imul(ah6, bl1) | 0;
    hi = hi + Math.imul(ah6, bh1) | 0;
    lo = lo + Math.imul(al5, bl2) | 0;
    mid = mid + Math.imul(al5, bh2) | 0;
    mid = mid + Math.imul(ah5, bl2) | 0;
    hi = hi + Math.imul(ah5, bh2) | 0;
    lo = lo + Math.imul(al4, bl3) | 0;
    mid = mid + Math.imul(al4, bh3) | 0;
    mid = mid + Math.imul(ah4, bl3) | 0;
    hi = hi + Math.imul(ah4, bh3) | 0;
    lo = lo + Math.imul(al3, bl4) | 0;
    mid = mid + Math.imul(al3, bh4) | 0;
    mid = mid + Math.imul(ah3, bl4) | 0;
    hi = hi + Math.imul(ah3, bh4) | 0;
    lo = lo + Math.imul(al2, bl5) | 0;
    mid = mid + Math.imul(al2, bh5) | 0;
    mid = mid + Math.imul(ah2, bl5) | 0;
    hi = hi + Math.imul(ah2, bh5) | 0;
    lo = lo + Math.imul(al1, bl6) | 0;
    mid = mid + Math.imul(al1, bh6) | 0;
    mid = mid + Math.imul(ah1, bl6) | 0;
    hi = hi + Math.imul(ah1, bh6) | 0;
    lo = lo + Math.imul(al0, bl7) | 0;
    mid = mid + Math.imul(al0, bh7) | 0;
    mid = mid + Math.imul(ah0, bl7) | 0;
    hi = hi + Math.imul(ah0, bh7) | 0;
    var w7 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */

    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = mid + Math.imul(ah8, bl0) | 0;
    hi = Math.imul(ah8, bh0);
    lo = lo + Math.imul(al7, bl1) | 0;
    mid = mid + Math.imul(al7, bh1) | 0;
    mid = mid + Math.imul(ah7, bl1) | 0;
    hi = hi + Math.imul(ah7, bh1) | 0;
    lo = lo + Math.imul(al6, bl2) | 0;
    mid = mid + Math.imul(al6, bh2) | 0;
    mid = mid + Math.imul(ah6, bl2) | 0;
    hi = hi + Math.imul(ah6, bh2) | 0;
    lo = lo + Math.imul(al5, bl3) | 0;
    mid = mid + Math.imul(al5, bh3) | 0;
    mid = mid + Math.imul(ah5, bl3) | 0;
    hi = hi + Math.imul(ah5, bh3) | 0;
    lo = lo + Math.imul(al4, bl4) | 0;
    mid = mid + Math.imul(al4, bh4) | 0;
    mid = mid + Math.imul(ah4, bl4) | 0;
    hi = hi + Math.imul(ah4, bh4) | 0;
    lo = lo + Math.imul(al3, bl5) | 0;
    mid = mid + Math.imul(al3, bh5) | 0;
    mid = mid + Math.imul(ah3, bl5) | 0;
    hi = hi + Math.imul(ah3, bh5) | 0;
    lo = lo + Math.imul(al2, bl6) | 0;
    mid = mid + Math.imul(al2, bh6) | 0;
    mid = mid + Math.imul(ah2, bl6) | 0;
    hi = hi + Math.imul(ah2, bh6) | 0;
    lo = lo + Math.imul(al1, bl7) | 0;
    mid = mid + Math.imul(al1, bh7) | 0;
    mid = mid + Math.imul(ah1, bl7) | 0;
    hi = hi + Math.imul(ah1, bh7) | 0;
    lo = lo + Math.imul(al0, bl8) | 0;
    mid = mid + Math.imul(al0, bh8) | 0;
    mid = mid + Math.imul(ah0, bl8) | 0;
    hi = hi + Math.imul(ah0, bh8) | 0;
    var w8 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */

    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = mid + Math.imul(ah9, bl0) | 0;
    hi = Math.imul(ah9, bh0);
    lo = lo + Math.imul(al8, bl1) | 0;
    mid = mid + Math.imul(al8, bh1) | 0;
    mid = mid + Math.imul(ah8, bl1) | 0;
    hi = hi + Math.imul(ah8, bh1) | 0;
    lo = lo + Math.imul(al7, bl2) | 0;
    mid = mid + Math.imul(al7, bh2) | 0;
    mid = mid + Math.imul(ah7, bl2) | 0;
    hi = hi + Math.imul(ah7, bh2) | 0;
    lo = lo + Math.imul(al6, bl3) | 0;
    mid = mid + Math.imul(al6, bh3) | 0;
    mid = mid + Math.imul(ah6, bl3) | 0;
    hi = hi + Math.imul(ah6, bh3) | 0;
    lo = lo + Math.imul(al5, bl4) | 0;
    mid = mid + Math.imul(al5, bh4) | 0;
    mid = mid + Math.imul(ah5, bl4) | 0;
    hi = hi + Math.imul(ah5, bh4) | 0;
    lo = lo + Math.imul(al4, bl5) | 0;
    mid = mid + Math.imul(al4, bh5) | 0;
    mid = mid + Math.imul(ah4, bl5) | 0;
    hi = hi + Math.imul(ah4, bh5) | 0;
    lo = lo + Math.imul(al3, bl6) | 0;
    mid = mid + Math.imul(al3, bh6) | 0;
    mid = mid + Math.imul(ah3, bl6) | 0;
    hi = hi + Math.imul(ah3, bh6) | 0;
    lo = lo + Math.imul(al2, bl7) | 0;
    mid = mid + Math.imul(al2, bh7) | 0;
    mid = mid + Math.imul(ah2, bl7) | 0;
    hi = hi + Math.imul(ah2, bh7) | 0;
    lo = lo + Math.imul(al1, bl8) | 0;
    mid = mid + Math.imul(al1, bh8) | 0;
    mid = mid + Math.imul(ah1, bl8) | 0;
    hi = hi + Math.imul(ah1, bh8) | 0;
    lo = lo + Math.imul(al0, bl9) | 0;
    mid = mid + Math.imul(al0, bh9) | 0;
    mid = mid + Math.imul(ah0, bl9) | 0;
    hi = hi + Math.imul(ah0, bh9) | 0;
    var w9 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */

    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = mid + Math.imul(ah9, bl1) | 0;
    hi = Math.imul(ah9, bh1);
    lo = lo + Math.imul(al8, bl2) | 0;
    mid = mid + Math.imul(al8, bh2) | 0;
    mid = mid + Math.imul(ah8, bl2) | 0;
    hi = hi + Math.imul(ah8, bh2) | 0;
    lo = lo + Math.imul(al7, bl3) | 0;
    mid = mid + Math.imul(al7, bh3) | 0;
    mid = mid + Math.imul(ah7, bl3) | 0;
    hi = hi + Math.imul(ah7, bh3) | 0;
    lo = lo + Math.imul(al6, bl4) | 0;
    mid = mid + Math.imul(al6, bh4) | 0;
    mid = mid + Math.imul(ah6, bl4) | 0;
    hi = hi + Math.imul(ah6, bh4) | 0;
    lo = lo + Math.imul(al5, bl5) | 0;
    mid = mid + Math.imul(al5, bh5) | 0;
    mid = mid + Math.imul(ah5, bl5) | 0;
    hi = hi + Math.imul(ah5, bh5) | 0;
    lo = lo + Math.imul(al4, bl6) | 0;
    mid = mid + Math.imul(al4, bh6) | 0;
    mid = mid + Math.imul(ah4, bl6) | 0;
    hi = hi + Math.imul(ah4, bh6) | 0;
    lo = lo + Math.imul(al3, bl7) | 0;
    mid = mid + Math.imul(al3, bh7) | 0;
    mid = mid + Math.imul(ah3, bl7) | 0;
    hi = hi + Math.imul(ah3, bh7) | 0;
    lo = lo + Math.imul(al2, bl8) | 0;
    mid = mid + Math.imul(al2, bh8) | 0;
    mid = mid + Math.imul(ah2, bl8) | 0;
    hi = hi + Math.imul(ah2, bh8) | 0;
    lo = lo + Math.imul(al1, bl9) | 0;
    mid = mid + Math.imul(al1, bh9) | 0;
    mid = mid + Math.imul(ah1, bl9) | 0;
    hi = hi + Math.imul(ah1, bh9) | 0;
    var w10 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */

    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = mid + Math.imul(ah9, bl2) | 0;
    hi = Math.imul(ah9, bh2);
    lo = lo + Math.imul(al8, bl3) | 0;
    mid = mid + Math.imul(al8, bh3) | 0;
    mid = mid + Math.imul(ah8, bl3) | 0;
    hi = hi + Math.imul(ah8, bh3) | 0;
    lo = lo + Math.imul(al7, bl4) | 0;
    mid = mid + Math.imul(al7, bh4) | 0;
    mid = mid + Math.imul(ah7, bl4) | 0;
    hi = hi + Math.imul(ah7, bh4) | 0;
    lo = lo + Math.imul(al6, bl5) | 0;
    mid = mid + Math.imul(al6, bh5) | 0;
    mid = mid + Math.imul(ah6, bl5) | 0;
    hi = hi + Math.imul(ah6, bh5) | 0;
    lo = lo + Math.imul(al5, bl6) | 0;
    mid = mid + Math.imul(al5, bh6) | 0;
    mid = mid + Math.imul(ah5, bl6) | 0;
    hi = hi + Math.imul(ah5, bh6) | 0;
    lo = lo + Math.imul(al4, bl7) | 0;
    mid = mid + Math.imul(al4, bh7) | 0;
    mid = mid + Math.imul(ah4, bl7) | 0;
    hi = hi + Math.imul(ah4, bh7) | 0;
    lo = lo + Math.imul(al3, bl8) | 0;
    mid = mid + Math.imul(al3, bh8) | 0;
    mid = mid + Math.imul(ah3, bl8) | 0;
    hi = hi + Math.imul(ah3, bh8) | 0;
    lo = lo + Math.imul(al2, bl9) | 0;
    mid = mid + Math.imul(al2, bh9) | 0;
    mid = mid + Math.imul(ah2, bl9) | 0;
    hi = hi + Math.imul(ah2, bh9) | 0;
    var w11 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */

    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = mid + Math.imul(ah9, bl3) | 0;
    hi = Math.imul(ah9, bh3);
    lo = lo + Math.imul(al8, bl4) | 0;
    mid = mid + Math.imul(al8, bh4) | 0;
    mid = mid + Math.imul(ah8, bl4) | 0;
    hi = hi + Math.imul(ah8, bh4) | 0;
    lo = lo + Math.imul(al7, bl5) | 0;
    mid = mid + Math.imul(al7, bh5) | 0;
    mid = mid + Math.imul(ah7, bl5) | 0;
    hi = hi + Math.imul(ah7, bh5) | 0;
    lo = lo + Math.imul(al6, bl6) | 0;
    mid = mid + Math.imul(al6, bh6) | 0;
    mid = mid + Math.imul(ah6, bl6) | 0;
    hi = hi + Math.imul(ah6, bh6) | 0;
    lo = lo + Math.imul(al5, bl7) | 0;
    mid = mid + Math.imul(al5, bh7) | 0;
    mid = mid + Math.imul(ah5, bl7) | 0;
    hi = hi + Math.imul(ah5, bh7) | 0;
    lo = lo + Math.imul(al4, bl8) | 0;
    mid = mid + Math.imul(al4, bh8) | 0;
    mid = mid + Math.imul(ah4, bl8) | 0;
    hi = hi + Math.imul(ah4, bh8) | 0;
    lo = lo + Math.imul(al3, bl9) | 0;
    mid = mid + Math.imul(al3, bh9) | 0;
    mid = mid + Math.imul(ah3, bl9) | 0;
    hi = hi + Math.imul(ah3, bh9) | 0;
    var w12 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */

    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = mid + Math.imul(ah9, bl4) | 0;
    hi = Math.imul(ah9, bh4);
    lo = lo + Math.imul(al8, bl5) | 0;
    mid = mid + Math.imul(al8, bh5) | 0;
    mid = mid + Math.imul(ah8, bl5) | 0;
    hi = hi + Math.imul(ah8, bh5) | 0;
    lo = lo + Math.imul(al7, bl6) | 0;
    mid = mid + Math.imul(al7, bh6) | 0;
    mid = mid + Math.imul(ah7, bl6) | 0;
    hi = hi + Math.imul(ah7, bh6) | 0;
    lo = lo + Math.imul(al6, bl7) | 0;
    mid = mid + Math.imul(al6, bh7) | 0;
    mid = mid + Math.imul(ah6, bl7) | 0;
    hi = hi + Math.imul(ah6, bh7) | 0;
    lo = lo + Math.imul(al5, bl8) | 0;
    mid = mid + Math.imul(al5, bh8) | 0;
    mid = mid + Math.imul(ah5, bl8) | 0;
    hi = hi + Math.imul(ah5, bh8) | 0;
    lo = lo + Math.imul(al4, bl9) | 0;
    mid = mid + Math.imul(al4, bh9) | 0;
    mid = mid + Math.imul(ah4, bl9) | 0;
    hi = hi + Math.imul(ah4, bh9) | 0;
    var w13 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */

    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = mid + Math.imul(ah9, bl5) | 0;
    hi = Math.imul(ah9, bh5);
    lo = lo + Math.imul(al8, bl6) | 0;
    mid = mid + Math.imul(al8, bh6) | 0;
    mid = mid + Math.imul(ah8, bl6) | 0;
    hi = hi + Math.imul(ah8, bh6) | 0;
    lo = lo + Math.imul(al7, bl7) | 0;
    mid = mid + Math.imul(al7, bh7) | 0;
    mid = mid + Math.imul(ah7, bl7) | 0;
    hi = hi + Math.imul(ah7, bh7) | 0;
    lo = lo + Math.imul(al6, bl8) | 0;
    mid = mid + Math.imul(al6, bh8) | 0;
    mid = mid + Math.imul(ah6, bl8) | 0;
    hi = hi + Math.imul(ah6, bh8) | 0;
    lo = lo + Math.imul(al5, bl9) | 0;
    mid = mid + Math.imul(al5, bh9) | 0;
    mid = mid + Math.imul(ah5, bl9) | 0;
    hi = hi + Math.imul(ah5, bh9) | 0;
    var w14 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */

    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = mid + Math.imul(ah9, bl6) | 0;
    hi = Math.imul(ah9, bh6);
    lo = lo + Math.imul(al8, bl7) | 0;
    mid = mid + Math.imul(al8, bh7) | 0;
    mid = mid + Math.imul(ah8, bl7) | 0;
    hi = hi + Math.imul(ah8, bh7) | 0;
    lo = lo + Math.imul(al7, bl8) | 0;
    mid = mid + Math.imul(al7, bh8) | 0;
    mid = mid + Math.imul(ah7, bl8) | 0;
    hi = hi + Math.imul(ah7, bh8) | 0;
    lo = lo + Math.imul(al6, bl9) | 0;
    mid = mid + Math.imul(al6, bh9) | 0;
    mid = mid + Math.imul(ah6, bl9) | 0;
    hi = hi + Math.imul(ah6, bh9) | 0;
    var w15 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */

    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = mid + Math.imul(ah9, bl7) | 0;
    hi = Math.imul(ah9, bh7);
    lo = lo + Math.imul(al8, bl8) | 0;
    mid = mid + Math.imul(al8, bh8) | 0;
    mid = mid + Math.imul(ah8, bl8) | 0;
    hi = hi + Math.imul(ah8, bh8) | 0;
    lo = lo + Math.imul(al7, bl9) | 0;
    mid = mid + Math.imul(al7, bh9) | 0;
    mid = mid + Math.imul(ah7, bl9) | 0;
    hi = hi + Math.imul(ah7, bh9) | 0;
    var w16 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */

    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = mid + Math.imul(ah9, bl8) | 0;
    hi = Math.imul(ah9, bh8);
    lo = lo + Math.imul(al8, bl9) | 0;
    mid = mid + Math.imul(al8, bh9) | 0;
    mid = mid + Math.imul(ah8, bl9) | 0;
    hi = hi + Math.imul(ah8, bh9) | 0;
    var w17 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */

    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = mid + Math.imul(ah9, bl9) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (c + lo | 0) + ((mid & 0x1fff) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;

    if (c !== 0) {
      o[19] = c;
      out.length++;
    }

    return out;
  }; // Polyfill comb


  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo(self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;
    var carry = 0;
    var hncarry = 0;

    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);

      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;
        var lo = r & 0x3ffffff;
        ncarry = ncarry + (r / 0x4000000 | 0) | 0;
        lo = lo + rword | 0;
        rword = lo & 0x3ffffff;
        ncarry = ncarry + (lo >>> 26) | 0;
        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }

      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }

    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo(self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo(num, out) {
    var res;
    var len = this.length + num.length;

    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  }; // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion


  function FFTM(x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT(N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;

    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  }; // Returns binary-reversed representation of `x`


  FFTM.prototype.revBin = function revBin(x, l, N) {
    if (x === 0 || x === N - 1) return x;
    var rb = 0;

    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << l - i - 1;
      x >>= 1;
    }

    return rb;
  }; // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm


  FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;
      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];
          var ro = rtws[p + j + s];
          var io = itws[p + j + s];
          var rx = rtwdf_ * ro - itwdf_ * io;
          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;
          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;
          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;
          /* jshint maxdepth : false */

          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;
            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;

    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];
      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;
      t = iws[i];
      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b(ws, N) {
    var carry = 0;

    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 + Math.round(ws[2 * i] / N) + carry;
      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
    var carry = 0;

    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);
      rws[2 * i] = carry & 0x1fff;
      carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff;
      carry = carry >>> 13;
    } // Pad with zeroes


    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub(N) {
    var ph = new Array(N);

    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp(x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);
    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);
    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);
    var rmws = out.words;
    rmws.length = N;
    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);
    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);
    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  }; // Multiply `this` by `num`


  BN.prototype.mul = function mul(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  }; // Multiply employing FFT


  BN.prototype.mulf = function mulf(num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  }; // In-place Multiplication


  BN.prototype.imul = function imul(num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln(num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000); // Carry

    var carry = 0;

    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += w / 0x4000000 | 0; // NOTE: lo is 27bit maximum

      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln(num) {
    return this.clone().imuln(num);
  }; // `this` * `this`


  BN.prototype.sqr = function sqr() {
    return this.mul(this);
  }; // `this` * `this` in-place


  BN.prototype.isqr = function isqr() {
    return this.imul(this.clone());
  }; // Math.pow(`this`, `num`)


  BN.prototype.pow = function pow(num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1); // Skip leading zeroes

    var res = this;

    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;
        res = res.mul(q);
      }
    }

    return res;
  }; // Shift-left in-place


  BN.prototype.iushln = function iushln(bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = 0x3ffffff >>> 26 - r << 26 - r;
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = (this.words[i] | 0) - newCarry << r;
        this.words[i] = c | carry;
        carry = newCarry >>> 26 - r;
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln(bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  }; // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits


  BN.prototype.iushrn = function iushrn(bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;

    if (hint) {
      h = (hint - hint % 26) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
    var maskedWords = extended;
    h -= s;
    h = Math.max(0, h); // Extended mode, copy masked part

    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }

      maskedWords.length = s;
    }

    if (s === 0) {// No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;

      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;

    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = carry << 26 - r | word >>> r;
      carry = word & mask;
    } // Push carried bits as a mask


    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn(bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  }; // Shift-left


  BN.prototype.shln = function shln(bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln(bits) {
    return this.clone().iushln(bits);
  }; // Shift-right


  BN.prototype.shrn = function shrn(bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn(bits) {
    return this.clone().iushrn(bits);
  }; // Test if n bit is set


  BN.prototype.testn = function testn(bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r; // Fast case: bit is much higher than all existing words

    if (this.length <= s) return false; // Check bit and return

    var w = this.words[s];
    return !!(w & q);
  }; // Return only lowers bits of number (in-place)


  BN.prototype.imaskn = function imaskn(bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }

    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ 0x3ffffff >>> r << r;
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  }; // Return only lowers bits of number


  BN.prototype.maskn = function maskn(bits) {
    return this.clone().imaskn(bits);
  }; // Add plain number `num` to `this`


  BN.prototype.iaddn = function iaddn(num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num); // Possible sign change

    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    } // Add without checks


    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn(num) {
    this.words[0] += num; // Carry

    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;

      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }

    this.length = Math.max(this.length, i + 1);
    return this;
  }; // Subtract plain number `num` from `this`


  BN.prototype.isubn = function isubn(num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn(num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn(num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs() {
    this.negative = 0;
    return this;
  };

  BN.prototype.abs = function abs() {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;

    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - (right / 0x4000000 | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }

    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip(); // Subtraction overflow

    assert(carry === -1);
    carry = 0;

    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }

    this.negative = 1;
    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv(num, mode) {
    var shift = this.length - num.length;
    var a = this.clone();
    var b = num; // Normalize

    var bhi = b.words[b.length - 1] | 0;

    var bhiBits = this._countBits(bhi);

    shift = 26 - bhiBits;

    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    } // Initialize quotient


    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);

      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);

    if (diff.negative === 0) {
      a = diff;

      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 + (a.words[b.length + j - 1] | 0); // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)

      qj = Math.min(qj / bhi | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);

      while (a.negative !== 0) {
        qj--;
        a.negative = 0;

        a._ishlnsubmul(b, 1, j);

        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }

      if (q) {
        q.words[j] = qj;
      }
    }

    if (q) {
      q.strip();
    }

    a.strip(); // Denormalize

    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  }; // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested


  BN.prototype.divmod = function divmod(num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;

    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();

        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();

        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    } // Both numbers are positive at this point
    // Strip both numbers to approximate shift value


    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    } // Very short reduction


    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  }; // Find `this` / `num`


  BN.prototype.div = function div(num) {
    return this.divmod(num, 'div', false).div;
  }; // Find `this` % `num`


  BN.prototype.mod = function mod(num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod(num) {
    return this.divmod(num, 'mod', true).mod;
  }; // Find Round(`this` / `num`)


  BN.prototype.divRound = function divRound(num) {
    var dm = this.divmod(num); // Fast case - exact division

    if (dm.mod.isZero()) return dm.div;
    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half); // Round down

    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div; // Round up

    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn(num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;
    var acc = 0;

    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  }; // In-place division by number


  BN.prototype.idivn = function idivn(num) {
    assert(num <= 0x3ffffff);
    var carry = 0;

    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = w / num | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn(num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd(p) {
    assert(p.negative === 0);
    assert(!p.isZero());
    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    } // A * x + B * y = x


    var A = new BN(1);
    var B = new BN(0); // C * x + D * y = y

    var C = new BN(0);
    var D = new BN(1);
    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);

      if (i > 0) {
        x.iushrn(i);

        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);

      if (j > 0) {
        y.iushrn(j);

        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  }; // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed


  BN.prototype._invmp = function _invmp(p) {
    assert(p.negative === 0);
    assert(!p.isZero());
    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);
    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);

      if (i > 0) {
        a.iushrn(i);

        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);

      if (j > 0) {
        b.iushrn(j);

        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;

    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd(num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();
    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0; // Remove common factor of two

    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }

      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);

      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  }; // Invert number in the field F(num)


  BN.prototype.invm = function invm(num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven() {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd() {
    return (this.words[0] & 1) === 1;
  }; // And first word and num


  BN.prototype.andln = function andln(num) {
    return this.words[0] & num;
  }; // Increment at the bit position in-line


  BN.prototype.bincn = function bincn(bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r; // Fast case: bit is much higher than all existing words

    if (this.length <= s) {
      this._expand(s + 1);

      this.words[s] |= q;
      return this;
    } // Add bit and propagate, if needed


    var carry = q;

    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.isZero = function isZero() {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn(num) {
    var negative = num < 0;
    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;
    this.strip();
    var res;

    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');
      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }

    if (this.negative !== 0) return -res | 0;
    return res;
  }; // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`


  BN.prototype.cmp = function cmp(num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;
    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  }; // Unsigned comparison


  BN.prototype.ucmp = function ucmp(num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;
    var res = 0;

    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;
      if (a === b) continue;

      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }

      break;
    }

    return res;
  };

  BN.prototype.gtn = function gtn(num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt(num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten(num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte(num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn(num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt(num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten(num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte(num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn(num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq(num) {
    return this.cmp(num) === 0;
  }; //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //


  BN.red = function red(num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed(ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed() {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed(ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed(ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd(num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd(num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub(num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub(num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl(num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul(num) {
    assert(this.red, 'redMul works only with red numbers');

    this.red._verify2(this, num);

    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul(num) {
    assert(this.red, 'redMul works only with red numbers');

    this.red._verify2(this, num);

    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr() {
    assert(this.red, 'redSqr works only with red numbers');

    this.red._verify1(this);

    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr() {
    assert(this.red, 'redISqr works only with red numbers');

    this.red._verify1(this);

    return this.red.isqr(this);
  }; // Square root over p


  BN.prototype.redSqrt = function redSqrt() {
    assert(this.red, 'redSqrt works only with red numbers');

    this.red._verify1(this);

    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm() {
    assert(this.red, 'redInvm works only with red numbers');

    this.red._verify1(this);

    return this.red.invm(this);
  }; // Return negative clone of `this` % `red modulo`


  BN.prototype.redNeg = function redNeg() {
    assert(this.red, 'redNeg works only with red numbers');

    this.red._verify1(this);

    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow(num) {
    assert(this.red && !num.red, 'redPow(normalNum)');

    this.red._verify1(this);

    return this.red.pow(this, num);
  }; // Prime numbers with efficient reduction


  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  }; // Pseudo-Mersenne prime

  function MPrime(name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);
    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp() {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce(num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);

    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split(input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK(num) {
    return num.imul(this.k);
  };

  function K256() {
    MPrime.call(this, 'k256', 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }

  inherits(K256, MPrime);

  K256.prototype.split = function split(input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;
    var outLen = Math.min(input.length, 9);

    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }

    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    } // Shift by 9 limbs


    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
      prev = next;
    }

    prev >>>= 22;
    input.words[i - 10] = prev;

    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK(num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2; // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390

    var lo = 0;

    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + (lo / 0x4000000 | 0);
    } // Fast length reduction


    if (num.words[num.length - 1] === 0) {
      num.length--;

      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }

    return num;
  };

  function P224() {
    MPrime.call(this, 'p224', 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }

  inherits(P224, MPrime);

  function P192() {
    MPrime.call(this, 'p192', 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }

  inherits(P192, MPrime);

  function P25519() {
    // 2 ^ 255 - 19
    MPrime.call(this, '25519', '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }

  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK(num) {
    // K = 0x13
    var carry = 0;

    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;
      num.words[i] = lo;
      carry = hi;
    }

    if (carry !== 0) {
      num.words[num.length++] = carry;
    }

    return num;
  }; // Exported mostly for testing purposes, use plain name instead


  BN._prime = function prime(name) {
    // Cached version of prime
    if (primes[name]) return primes[name];
    var prime;

    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }

    primes[name] = prime;
    return prime;
  }; //
  // Base reduction engine
  //


  function Red(m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);

      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1(a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2(a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red, 'red works only with red numbers');
  };

  Red.prototype.imod = function imod(a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg(a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add(a, b) {
    this._verify2(a, b);

    var res = a.add(b);

    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }

    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd(a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);

    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }

    return res;
  };

  Red.prototype.sub = function sub(a, b) {
    this._verify2(a, b);

    var res = a.sub(b);

    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Red.prototype.isub = function isub(a, b) {
    this._verify2(a, b);

    var res = a.isub(b);

    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }

    return res;
  };

  Red.prototype.shl = function shl(a, num) {
    this._verify1(a);

    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul(a, b) {
    this._verify2(a, b);

    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul(a, b) {
    this._verify2(a, b);

    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr(a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr(a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt(a) {
    if (a.isZero()) return a.clone();
    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1); // Fast case

    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    } // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)


    var q = this.m.subn(1);
    var s = 0;

    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }

    assert(!q.isZero());
    var one = new BN(1).toRed(this);
    var nOne = one.redNeg(); // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.

    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;

    while (t.cmp(one) !== 0) {
      var tmp = t;

      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }

      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));
      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm(a) {
    var inv = a._invmp(this.m);

    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow(a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();
    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;

    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;

    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];

      for (var j = start - 1; j >= 0; j--) {
        var bit = word >> j & 1;

        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;
        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }

      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo(num) {
    var r = num.umod(this.m);
    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom(num) {
    var res = num.clone();
    res.red = null;
    return res;
  }; //
  // Montgomery method engine
  //


  BN.mont = function mont(num) {
    return new Mont(num);
  };

  function Mont(m) {
    Red.call(this, m);
    this.shift = this.m.bitLength();

    if (this.shift % 26 !== 0) {
      this.shift += 26 - this.shift % 26;
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);
    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }

  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo(num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom(num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul(a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul(a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);
    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm(a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);

/***/ }),

/***/ "./node_modules/brorand/index.js":
/*!***************************************!*\
  !*** ./node_modules/brorand/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var r;

module.exports = function rand(len) {
  if (!r) r = new Rand(null);
  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}

module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
}; // Emulate crypto API using randy


Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes) return this.rand.getBytes(n);
  var res = new Uint8Array(n);

  for (var i = 0; i < res.length; i++) res[i] = this.rand.getByte();

  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    }; // Safari's WebWorkers do not have `crypto`

  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function () {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = __webpack_require__(/*! crypto */ "?3fc0");

    if (typeof crypto.randomBytes !== 'function') throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {}
}

/***/ }),

/***/ "./node_modules/cross-blob/browser.js":
/*!********************************************!*\
  !*** ./node_modules/cross-blob/browser.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = __webpack_require__(/*! blob-polyfill */ "./src/polyfills/Blob.js").Blob;

/***/ }),

/***/ "./node_modules/crypto-js/aes.js":
/*!***************************************!*\
  !*** ./node_modules/crypto-js/aes.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
  } else {}
})(this, function (CryptoJS) {
  (function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var BlockCipher = C_lib.BlockCipher;
    var C_algo = C.algo; // Lookup tables

    var SBOX = [];
    var INV_SBOX = [];
    var SUB_MIX_0 = [];
    var SUB_MIX_1 = [];
    var SUB_MIX_2 = [];
    var SUB_MIX_3 = [];
    var INV_SUB_MIX_0 = [];
    var INV_SUB_MIX_1 = [];
    var INV_SUB_MIX_2 = [];
    var INV_SUB_MIX_3 = []; // Compute lookup tables

    (function () {
      // Compute double table
      var d = [];

      for (var i = 0; i < 256; i++) {
        if (i < 128) {
          d[i] = i << 1;
        } else {
          d[i] = i << 1 ^ 0x11b;
        }
      } // Walk GF(2^8)


      var x = 0;
      var xi = 0;

      for (var i = 0; i < 256; i++) {
        // Compute sbox
        var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
        sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
        SBOX[x] = sx;
        INV_SBOX[sx] = x; // Compute multiplication

        var x2 = d[x];
        var x4 = d[x2];
        var x8 = d[x4]; // Compute sub bytes, mix columns tables

        var t = d[sx] * 0x101 ^ sx * 0x1010100;
        SUB_MIX_0[x] = t << 24 | t >>> 8;
        SUB_MIX_1[x] = t << 16 | t >>> 16;
        SUB_MIX_2[x] = t << 8 | t >>> 24;
        SUB_MIX_3[x] = t; // Compute inv sub bytes, inv mix columns tables

        var t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
        INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
        INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
        INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
        INV_SUB_MIX_3[sx] = t; // Compute next counter

        if (!x) {
          x = xi = 1;
        } else {
          x = x2 ^ d[d[d[x8 ^ x2]]];
          xi ^= d[d[xi]];
        }
      }
    })(); // Precomputed Rcon lookup


    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
    /**
     * AES block cipher algorithm.
     */

    var AES = C_algo.AES = BlockCipher.extend({
      _doReset: function () {
        var t; // Skip reset of nRounds has been set before and key did not change

        if (this._nRounds && this._keyPriorReset === this._key) {
          return;
        } // Shortcuts


        var key = this._keyPriorReset = this._key;
        var keyWords = key.words;
        var keySize = key.sigBytes / 4; // Compute number of rounds

        var nRounds = this._nRounds = keySize + 6; // Compute number of key schedule rows

        var ksRows = (nRounds + 1) * 4; // Compute key schedule

        var keySchedule = this._keySchedule = [];

        for (var ksRow = 0; ksRow < ksRows; ksRow++) {
          if (ksRow < keySize) {
            keySchedule[ksRow] = keyWords[ksRow];
          } else {
            t = keySchedule[ksRow - 1];

            if (!(ksRow % keySize)) {
              // Rot word
              t = t << 8 | t >>> 24; // Sub word

              t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 0xff] << 16 | SBOX[t >>> 8 & 0xff] << 8 | SBOX[t & 0xff]; // Mix Rcon

              t ^= RCON[ksRow / keySize | 0] << 24;
            } else if (keySize > 6 && ksRow % keySize == 4) {
              // Sub word
              t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 0xff] << 16 | SBOX[t >>> 8 & 0xff] << 8 | SBOX[t & 0xff];
            }

            keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
          }
        } // Compute inv key schedule


        var invKeySchedule = this._invKeySchedule = [];

        for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
          var ksRow = ksRows - invKsRow;

          if (invKsRow % 4) {
            var t = keySchedule[ksRow];
          } else {
            var t = keySchedule[ksRow - 4];
          }

          if (invKsRow < 4 || ksRow <= 4) {
            invKeySchedule[invKsRow] = t;
          } else {
            invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 0xff]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
          }
        }
      },
      encryptBlock: function (M, offset) {
        this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
      },
      decryptBlock: function (M, offset) {
        // Swap 2nd and 4th rows
        var t = M[offset + 1];
        M[offset + 1] = M[offset + 3];
        M[offset + 3] = t;

        this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX); // Inv swap 2nd and 4th rows


        var t = M[offset + 1];
        M[offset + 1] = M[offset + 3];
        M[offset + 3] = t;
      },
      _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
        // Shortcut
        var nRounds = this._nRounds; // Get input, add round key

        var s0 = M[offset] ^ keySchedule[0];
        var s1 = M[offset + 1] ^ keySchedule[1];
        var s2 = M[offset + 2] ^ keySchedule[2];
        var s3 = M[offset + 3] ^ keySchedule[3]; // Key schedule row counter

        var ksRow = 4; // Rounds

        for (var round = 1; round < nRounds; round++) {
          // Shift rows, sub bytes, mix columns, add round key
          var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[s1 >>> 16 & 0xff] ^ SUB_MIX_2[s2 >>> 8 & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
          var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[s2 >>> 16 & 0xff] ^ SUB_MIX_2[s3 >>> 8 & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
          var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[s3 >>> 16 & 0xff] ^ SUB_MIX_2[s0 >>> 8 & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
          var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[s0 >>> 16 & 0xff] ^ SUB_MIX_2[s1 >>> 8 & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++]; // Update state

          s0 = t0;
          s1 = t1;
          s2 = t2;
          s3 = t3;
        } // Shift rows, sub bytes, add round key


        var t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 0xff] << 16 | SBOX[s2 >>> 8 & 0xff] << 8 | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
        var t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 0xff] << 16 | SBOX[s3 >>> 8 & 0xff] << 8 | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
        var t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 0xff] << 16 | SBOX[s0 >>> 8 & 0xff] << 8 | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
        var t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 0xff] << 16 | SBOX[s1 >>> 8 & 0xff] << 8 | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]; // Set output

        M[offset] = t0;
        M[offset + 1] = t1;
        M[offset + 2] = t2;
        M[offset + 3] = t3;
      },
      keySize: 256 / 32
    });
    /**
     * Shortcut functions to the cipher's object interface.
     *
     * @example
     *
     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
     */

    C.AES = BlockCipher._createHelper(AES);
  })();

  return CryptoJS.AES;
});

/***/ }),

/***/ "./node_modules/crypto-js/cipher-core.js":
/*!***********************************************!*\
  !*** ./node_modules/crypto-js/cipher-core.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"));
  } else {}
})(this, function (CryptoJS) {
  /**
   * Cipher core components.
   */
  CryptoJS.lib.Cipher || function (undefined) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var WordArray = C_lib.WordArray;
    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
    var C_enc = C.enc;
    var Utf8 = C_enc.Utf8;
    var Base64 = C_enc.Base64;
    var C_algo = C.algo;
    var EvpKDF = C_algo.EvpKDF;
    /**
     * Abstract base cipher template.
     *
     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
     */

    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
      /**
       * Configuration options.
       *
       * @property {WordArray} iv The IV to use for this operation.
       */
      cfg: Base.extend(),

      /**
       * Creates this cipher in encryption mode.
       *
       * @param {WordArray} key The key.
       * @param {Object} cfg (Optional) The configuration options to use for this operation.
       *
       * @return {Cipher} A cipher instance.
       *
       * @static
       *
       * @example
       *
       *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
       */
      createEncryptor: function (key, cfg) {
        return this.create(this._ENC_XFORM_MODE, key, cfg);
      },

      /**
       * Creates this cipher in decryption mode.
       *
       * @param {WordArray} key The key.
       * @param {Object} cfg (Optional) The configuration options to use for this operation.
       *
       * @return {Cipher} A cipher instance.
       *
       * @static
       *
       * @example
       *
       *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
       */
      createDecryptor: function (key, cfg) {
        return this.create(this._DEC_XFORM_MODE, key, cfg);
      },

      /**
       * Initializes a newly created cipher.
       *
       * @param {number} xformMode Either the encryption or decryption transormation mode constant.
       * @param {WordArray} key The key.
       * @param {Object} cfg (Optional) The configuration options to use for this operation.
       *
       * @example
       *
       *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
       */
      init: function (xformMode, key, cfg) {
        // Apply config defaults
        this.cfg = this.cfg.extend(cfg); // Store transform mode and key

        this._xformMode = xformMode;
        this._key = key; // Set initial values

        this.reset();
      },

      /**
       * Resets this cipher to its initial state.
       *
       * @example
       *
       *     cipher.reset();
       */
      reset: function () {
        // Reset data buffer
        BufferedBlockAlgorithm.reset.call(this); // Perform concrete-cipher logic

        this._doReset();
      },

      /**
       * Adds data to be encrypted or decrypted.
       *
       * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
       *
       * @return {WordArray} The data after processing.
       *
       * @example
       *
       *     var encrypted = cipher.process('data');
       *     var encrypted = cipher.process(wordArray);
       */
      process: function (dataUpdate) {
        // Append
        this._append(dataUpdate); // Process available blocks


        return this._process();
      },

      /**
       * Finalizes the encryption or decryption process.
       * Note that the finalize operation is effectively a destructive, read-once operation.
       *
       * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
       *
       * @return {WordArray} The data after final processing.
       *
       * @example
       *
       *     var encrypted = cipher.finalize();
       *     var encrypted = cipher.finalize('data');
       *     var encrypted = cipher.finalize(wordArray);
       */
      finalize: function (dataUpdate) {
        // Final data update
        if (dataUpdate) {
          this._append(dataUpdate);
        } // Perform concrete-cipher logic


        var finalProcessedData = this._doFinalize();

        return finalProcessedData;
      },
      keySize: 128 / 32,
      ivSize: 128 / 32,
      _ENC_XFORM_MODE: 1,
      _DEC_XFORM_MODE: 2,

      /**
       * Creates shortcut functions to a cipher's object interface.
       *
       * @param {Cipher} cipher The cipher to create a helper for.
       *
       * @return {Object} An object with encrypt and decrypt shortcut functions.
       *
       * @static
       *
       * @example
       *
       *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
       */
      _createHelper: function () {
        function selectCipherStrategy(key) {
          if (typeof key == 'string') {
            return PasswordBasedCipher;
          } else {
            return SerializableCipher;
          }
        }

        return function (cipher) {
          return {
            encrypt: function (message, key, cfg) {
              return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
            },
            decrypt: function (ciphertext, key, cfg) {
              return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
            }
          };
        };
      }()
    });
    /**
     * Abstract base stream cipher template.
     *
     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
     */

    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
      _doFinalize: function () {
        // Process partial blocks
        var finalProcessedBlocks = this._process(!!'flush');

        return finalProcessedBlocks;
      },
      blockSize: 1
    });
    /**
     * Mode namespace.
     */

    var C_mode = C.mode = {};
    /**
     * Abstract base block cipher mode template.
     */

    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
      /**
       * Creates this mode for encryption.
       *
       * @param {Cipher} cipher A block cipher instance.
       * @param {Array} iv The IV words.
       *
       * @static
       *
       * @example
       *
       *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
       */
      createEncryptor: function (cipher, iv) {
        return this.Encryptor.create(cipher, iv);
      },

      /**
       * Creates this mode for decryption.
       *
       * @param {Cipher} cipher A block cipher instance.
       * @param {Array} iv The IV words.
       *
       * @static
       *
       * @example
       *
       *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
       */
      createDecryptor: function (cipher, iv) {
        return this.Decryptor.create(cipher, iv);
      },

      /**
       * Initializes a newly created mode.
       *
       * @param {Cipher} cipher A block cipher instance.
       * @param {Array} iv The IV words.
       *
       * @example
       *
       *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
       */
      init: function (cipher, iv) {
        this._cipher = cipher;
        this._iv = iv;
      }
    });
    /**
     * Cipher Block Chaining mode.
     */

    var CBC = C_mode.CBC = function () {
      /**
       * Abstract base CBC mode.
       */
      var CBC = BlockCipherMode.extend();
      /**
       * CBC encryptor.
       */

      CBC.Encryptor = CBC.extend({
        /**
         * Processes the data block at offset.
         *
         * @param {Array} words The data words to operate on.
         * @param {number} offset The offset where the block starts.
         *
         * @example
         *
         *     mode.processBlock(data.words, offset);
         */
        processBlock: function (words, offset) {
          // Shortcuts
          var cipher = this._cipher;
          var blockSize = cipher.blockSize; // XOR and encrypt

          xorBlock.call(this, words, offset, blockSize);
          cipher.encryptBlock(words, offset); // Remember this block to use with next block

          this._prevBlock = words.slice(offset, offset + blockSize);
        }
      });
      /**
       * CBC decryptor.
       */

      CBC.Decryptor = CBC.extend({
        /**
         * Processes the data block at offset.
         *
         * @param {Array} words The data words to operate on.
         * @param {number} offset The offset where the block starts.
         *
         * @example
         *
         *     mode.processBlock(data.words, offset);
         */
        processBlock: function (words, offset) {
          // Shortcuts
          var cipher = this._cipher;
          var blockSize = cipher.blockSize; // Remember this block to use with next block

          var thisBlock = words.slice(offset, offset + blockSize); // Decrypt and XOR

          cipher.decryptBlock(words, offset);
          xorBlock.call(this, words, offset, blockSize); // This block becomes the previous block

          this._prevBlock = thisBlock;
        }
      });

      function xorBlock(words, offset, blockSize) {
        var block; // Shortcut

        var iv = this._iv; // Choose mixing block

        if (iv) {
          block = iv; // Remove IV for subsequent blocks

          this._iv = undefined;
        } else {
          block = this._prevBlock;
        } // XOR blocks


        for (var i = 0; i < blockSize; i++) {
          words[offset + i] ^= block[i];
        }
      }

      return CBC;
    }();
    /**
     * Padding namespace.
     */


    var C_pad = C.pad = {};
    /**
     * PKCS #5/7 padding strategy.
     */

    var Pkcs7 = C_pad.Pkcs7 = {
      /**
       * Pads data using the algorithm defined in PKCS #5/7.
       *
       * @param {WordArray} data The data to pad.
       * @param {number} blockSize The multiple that the data should be padded to.
       *
       * @static
       *
       * @example
       *
       *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
       */
      pad: function (data, blockSize) {
        // Shortcut
        var blockSizeBytes = blockSize * 4; // Count padding bytes

        var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes; // Create padding word

        var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes; // Create padding

        var paddingWords = [];

        for (var i = 0; i < nPaddingBytes; i += 4) {
          paddingWords.push(paddingWord);
        }

        var padding = WordArray.create(paddingWords, nPaddingBytes); // Add padding

        data.concat(padding);
      },

      /**
       * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
       *
       * @param {WordArray} data The data to unpad.
       *
       * @static
       *
       * @example
       *
       *     CryptoJS.pad.Pkcs7.unpad(wordArray);
       */
      unpad: function (data) {
        // Get number of padding bytes from last byte
        var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 0xff; // Remove padding

        data.sigBytes -= nPaddingBytes;
      }
    };
    /**
     * Abstract base block cipher template.
     *
     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
     */

    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
      /**
       * Configuration options.
       *
       * @property {Mode} mode The block mode to use. Default: CBC
       * @property {Padding} padding The padding strategy to use. Default: Pkcs7
       */
      cfg: Cipher.cfg.extend({
        mode: CBC,
        padding: Pkcs7
      }),
      reset: function () {
        var modeCreator; // Reset cipher

        Cipher.reset.call(this); // Shortcuts

        var cfg = this.cfg;
        var iv = cfg.iv;
        var mode = cfg.mode; // Reset block mode

        if (this._xformMode == this._ENC_XFORM_MODE) {
          modeCreator = mode.createEncryptor;
        } else
          /* if (this._xformMode == this._DEC_XFORM_MODE) */
          {
            modeCreator = mode.createDecryptor; // Keep at least one block in the buffer for unpadding

            this._minBufferSize = 1;
          }

        if (this._mode && this._mode.__creator == modeCreator) {
          this._mode.init(this, iv && iv.words);
        } else {
          this._mode = modeCreator.call(mode, this, iv && iv.words);
          this._mode.__creator = modeCreator;
        }
      },
      _doProcessBlock: function (words, offset) {
        this._mode.processBlock(words, offset);
      },
      _doFinalize: function () {
        var finalProcessedBlocks; // Shortcut

        var padding = this.cfg.padding; // Finalize

        if (this._xformMode == this._ENC_XFORM_MODE) {
          // Pad data
          padding.pad(this._data, this.blockSize); // Process final blocks

          finalProcessedBlocks = this._process(!!'flush');
        } else
          /* if (this._xformMode == this._DEC_XFORM_MODE) */
          {
            // Process final blocks
            finalProcessedBlocks = this._process(!!'flush'); // Unpad data

            padding.unpad(finalProcessedBlocks);
          }

        return finalProcessedBlocks;
      },
      blockSize: 128 / 32
    });
    /**
     * A collection of cipher parameters.
     *
     * @property {WordArray} ciphertext The raw ciphertext.
     * @property {WordArray} key The key to this ciphertext.
     * @property {WordArray} iv The IV used in the ciphering operation.
     * @property {WordArray} salt The salt used with a key derivation function.
     * @property {Cipher} algorithm The cipher algorithm.
     * @property {Mode} mode The block mode used in the ciphering operation.
     * @property {Padding} padding The padding scheme used in the ciphering operation.
     * @property {number} blockSize The block size of the cipher.
     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
     */

    var CipherParams = C_lib.CipherParams = Base.extend({
      /**
       * Initializes a newly created cipher params object.
       *
       * @param {Object} cipherParams An object with any of the possible cipher parameters.
       *
       * @example
       *
       *     var cipherParams = CryptoJS.lib.CipherParams.create({
       *         ciphertext: ciphertextWordArray,
       *         key: keyWordArray,
       *         iv: ivWordArray,
       *         salt: saltWordArray,
       *         algorithm: CryptoJS.algo.AES,
       *         mode: CryptoJS.mode.CBC,
       *         padding: CryptoJS.pad.PKCS7,
       *         blockSize: 4,
       *         formatter: CryptoJS.format.OpenSSL
       *     });
       */
      init: function (cipherParams) {
        this.mixIn(cipherParams);
      },

      /**
       * Converts this cipher params object to a string.
       *
       * @param {Format} formatter (Optional) The formatting strategy to use.
       *
       * @return {string} The stringified cipher params.
       *
       * @throws Error If neither the formatter nor the default formatter is set.
       *
       * @example
       *
       *     var string = cipherParams + '';
       *     var string = cipherParams.toString();
       *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
       */
      toString: function (formatter) {
        return (formatter || this.formatter).stringify(this);
      }
    });
    /**
     * Format namespace.
     */

    var C_format = C.format = {};
    /**
     * OpenSSL formatting strategy.
     */

    var OpenSSLFormatter = C_format.OpenSSL = {
      /**
       * Converts a cipher params object to an OpenSSL-compatible string.
       *
       * @param {CipherParams} cipherParams The cipher params object.
       *
       * @return {string} The OpenSSL-compatible string.
       *
       * @static
       *
       * @example
       *
       *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
       */
      stringify: function (cipherParams) {
        var wordArray; // Shortcuts

        var ciphertext = cipherParams.ciphertext;
        var salt = cipherParams.salt; // Format

        if (salt) {
          wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
        } else {
          wordArray = ciphertext;
        }

        return wordArray.toString(Base64);
      },

      /**
       * Converts an OpenSSL-compatible string to a cipher params object.
       *
       * @param {string} openSSLStr The OpenSSL-compatible string.
       *
       * @return {CipherParams} The cipher params object.
       *
       * @static
       *
       * @example
       *
       *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
       */
      parse: function (openSSLStr) {
        var salt; // Parse base64

        var ciphertext = Base64.parse(openSSLStr); // Shortcut

        var ciphertextWords = ciphertext.words; // Test for salt

        if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
          // Extract salt
          salt = WordArray.create(ciphertextWords.slice(2, 4)); // Remove salt from ciphertext

          ciphertextWords.splice(0, 4);
          ciphertext.sigBytes -= 16;
        }

        return CipherParams.create({
          ciphertext: ciphertext,
          salt: salt
        });
      }
    };
    /**
     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
     */

    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
      /**
       * Configuration options.
       *
       * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
       */
      cfg: Base.extend({
        format: OpenSSLFormatter
      }),

      /**
       * Encrypts a message.
       *
       * @param {Cipher} cipher The cipher algorithm to use.
       * @param {WordArray|string} message The message to encrypt.
       * @param {WordArray} key The key.
       * @param {Object} cfg (Optional) The configuration options to use for this operation.
       *
       * @return {CipherParams} A cipher params object.
       *
       * @static
       *
       * @example
       *
       *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
       *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
       *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
       */
      encrypt: function (cipher, message, key, cfg) {
        // Apply config defaults
        cfg = this.cfg.extend(cfg); // Encrypt

        var encryptor = cipher.createEncryptor(key, cfg);
        var ciphertext = encryptor.finalize(message); // Shortcut

        var cipherCfg = encryptor.cfg; // Create and return serializable cipher params

        return CipherParams.create({
          ciphertext: ciphertext,
          key: key,
          iv: cipherCfg.iv,
          algorithm: cipher,
          mode: cipherCfg.mode,
          padding: cipherCfg.padding,
          blockSize: cipher.blockSize,
          formatter: cfg.format
        });
      },

      /**
       * Decrypts serialized ciphertext.
       *
       * @param {Cipher} cipher The cipher algorithm to use.
       * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
       * @param {WordArray} key The key.
       * @param {Object} cfg (Optional) The configuration options to use for this operation.
       *
       * @return {WordArray} The plaintext.
       *
       * @static
       *
       * @example
       *
       *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
       *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
       */
      decrypt: function (cipher, ciphertext, key, cfg) {
        // Apply config defaults
        cfg = this.cfg.extend(cfg); // Convert string to CipherParams

        ciphertext = this._parse(ciphertext, cfg.format); // Decrypt

        var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
        return plaintext;
      },

      /**
       * Converts serialized ciphertext to CipherParams,
       * else assumed CipherParams already and returns ciphertext unchanged.
       *
       * @param {CipherParams|string} ciphertext The ciphertext.
       * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
       *
       * @return {CipherParams} The unserialized ciphertext.
       *
       * @static
       *
       * @example
       *
       *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
       */
      _parse: function (ciphertext, format) {
        if (typeof ciphertext == 'string') {
          return format.parse(ciphertext, this);
        } else {
          return ciphertext;
        }
      }
    });
    /**
     * Key derivation function namespace.
     */

    var C_kdf = C.kdf = {};
    /**
     * OpenSSL key derivation function.
     */

    var OpenSSLKdf = C_kdf.OpenSSL = {
      /**
       * Derives a key and IV from a password.
       *
       * @param {string} password The password to derive from.
       * @param {number} keySize The size in words of the key to generate.
       * @param {number} ivSize The size in words of the IV to generate.
       * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
       *
       * @return {CipherParams} A cipher params object with the key, IV, and salt.
       *
       * @static
       *
       * @example
       *
       *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
       *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
       */
      execute: function (password, keySize, ivSize, salt) {
        // Generate random salt
        if (!salt) {
          salt = WordArray.random(64 / 8);
        } // Derive key and IV


        var key = EvpKDF.create({
          keySize: keySize + ivSize
        }).compute(password, salt); // Separate key and IV

        var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
        key.sigBytes = keySize * 4; // Return params

        return CipherParams.create({
          key: key,
          iv: iv,
          salt: salt
        });
      }
    };
    /**
     * A serializable cipher wrapper that derives the key from a password,
     * and returns ciphertext as a serializable cipher params object.
     */

    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
      /**
       * Configuration options.
       *
       * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
       */
      cfg: SerializableCipher.cfg.extend({
        kdf: OpenSSLKdf
      }),

      /**
       * Encrypts a message using a password.
       *
       * @param {Cipher} cipher The cipher algorithm to use.
       * @param {WordArray|string} message The message to encrypt.
       * @param {string} password The password.
       * @param {Object} cfg (Optional) The configuration options to use for this operation.
       *
       * @return {CipherParams} A cipher params object.
       *
       * @static
       *
       * @example
       *
       *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
       *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
       */
      encrypt: function (cipher, message, password, cfg) {
        // Apply config defaults
        cfg = this.cfg.extend(cfg); // Derive key and other params

        var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize); // Add IV to config

        cfg.iv = derivedParams.iv; // Encrypt

        var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg); // Mix in derived params

        ciphertext.mixIn(derivedParams);
        return ciphertext;
      },

      /**
       * Decrypts serialized ciphertext using a password.
       *
       * @param {Cipher} cipher The cipher algorithm to use.
       * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
       * @param {string} password The password.
       * @param {Object} cfg (Optional) The configuration options to use for this operation.
       *
       * @return {WordArray} The plaintext.
       *
       * @static
       *
       * @example
       *
       *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
       *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
       */
      decrypt: function (cipher, ciphertext, password, cfg) {
        // Apply config defaults
        cfg = this.cfg.extend(cfg); // Convert string to CipherParams

        ciphertext = this._parse(ciphertext, cfg.format); // Derive key and other params

        var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt); // Add IV to config

        cfg.iv = derivedParams.iv; // Decrypt

        var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
        return plaintext;
      }
    });
  }();
});

/***/ }),

/***/ "./node_modules/crypto-js/core.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/core.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory) {
  if (true) {
    // CommonJS
    module.exports = exports = factory();
  } else {}
})(this, function () {
  /*globals window, global, require*/

  /**
   * CryptoJS core components.
   */
  var CryptoJS = CryptoJS || function (Math, undefined) {
    var crypto; // Native crypto from window (Browser)

    if (typeof window !== 'undefined' && window.crypto) {
      crypto = window.crypto;
    } // Native crypto in web worker (Browser)


    if (typeof self !== 'undefined' && self.crypto) {
      crypto = self.crypto;
    } // Native crypto from worker


    if (typeof globalThis !== 'undefined' && globalThis.crypto) {
      crypto = globalThis.crypto;
    } // Native (experimental IE 11) crypto from window (Browser)


    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
      crypto = window.msCrypto;
    } // Native crypto from global (NodeJS)


    if (!crypto && typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.crypto) {
      crypto = __webpack_require__.g.crypto;
    } // Native crypto import via require (NodeJS)


    if (!crypto && "function" === 'function') {
      try {
        crypto = __webpack_require__(/*! crypto */ "?9157");
      } catch (err) {}
    }
    /*
     * Cryptographically secure pseudorandom number generator
     *
     * As Math.random() is cryptographically not safe to use
     */


    var cryptoSecureRandomInt = function () {
      if (crypto) {
        // Use getRandomValues method (Browser)
        if (typeof crypto.getRandomValues === 'function') {
          try {
            return crypto.getRandomValues(new Uint32Array(1))[0];
          } catch (err) {}
        } // Use randomBytes method (NodeJS)


        if (typeof crypto.randomBytes === 'function') {
          try {
            return crypto.randomBytes(4).readInt32LE();
          } catch (err) {}
        }
      }

      throw new Error('Native crypto module could not be used to get secure random number.');
    };
    /*
     * Local polyfill of Object.create
      */


    var create = Object.create || function () {
      function F() {}

      return function (obj) {
        var subtype;
        F.prototype = obj;
        subtype = new F();
        F.prototype = null;
        return subtype;
      };
    }();
    /**
     * CryptoJS namespace.
     */


    var C = {};
    /**
     * Library namespace.
     */

    var C_lib = C.lib = {};
    /**
     * Base object for prototypal inheritance.
     */

    var Base = C_lib.Base = function () {
      return {
        /**
         * Creates a new object that inherits from this object.
         *
         * @param {Object} overrides Properties to copy into the new object.
         *
         * @return {Object} The new object.
         *
         * @static
         *
         * @example
         *
         *     var MyType = CryptoJS.lib.Base.extend({
         *         field: 'value',
         *
         *         method: function () {
         *         }
         *     });
         */
        extend: function (overrides) {
          // Spawn
          var subtype = create(this); // Augment

          if (overrides) {
            subtype.mixIn(overrides);
          } // Create default initializer


          if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
            subtype.init = function () {
              subtype.$super.init.apply(this, arguments);
            };
          } // Initializer's prototype is the subtype object


          subtype.init.prototype = subtype; // Reference supertype

          subtype.$super = this;
          return subtype;
        },

        /**
         * Extends this object and runs the init method.
         * Arguments to create() will be passed to init().
         *
         * @return {Object} The new object.
         *
         * @static
         *
         * @example
         *
         *     var instance = MyType.create();
         */
        create: function () {
          var instance = this.extend();
          instance.init.apply(instance, arguments);
          return instance;
        },

        /**
         * Initializes a newly created object.
         * Override this method to add some logic when your objects are created.
         *
         * @example
         *
         *     var MyType = CryptoJS.lib.Base.extend({
         *         init: function () {
         *             // ...
         *         }
         *     });
         */
        init: function () {},

        /**
         * Copies properties into this object.
         *
         * @param {Object} properties The properties to mix in.
         *
         * @example
         *
         *     MyType.mixIn({
         *         field: 'value'
         *     });
         */
        mixIn: function (properties) {
          for (var propertyName in properties) {
            if (properties.hasOwnProperty(propertyName)) {
              this[propertyName] = properties[propertyName];
            }
          } // IE won't copy toString using the loop above


          if (properties.hasOwnProperty('toString')) {
            this.toString = properties.toString;
          }
        },

        /**
         * Creates a copy of this object.
         *
         * @return {Object} The clone.
         *
         * @example
         *
         *     var clone = instance.clone();
         */
        clone: function () {
          return this.init.prototype.extend(this);
        }
      };
    }();
    /**
     * An array of 32-bit words.
     *
     * @property {Array} words The array of 32-bit words.
     * @property {number} sigBytes The number of significant bytes in this word array.
     */


    var WordArray = C_lib.WordArray = Base.extend({
      /**
       * Initializes a newly created word array.
       *
       * @param {Array} words (Optional) An array of 32-bit words.
       * @param {number} sigBytes (Optional) The number of significant bytes in the words.
       *
       * @example
       *
       *     var wordArray = CryptoJS.lib.WordArray.create();
       *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
       *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
       */
      init: function (words, sigBytes) {
        words = this.words = words || [];

        if (sigBytes != undefined) {
          this.sigBytes = sigBytes;
        } else {
          this.sigBytes = words.length * 4;
        }
      },

      /**
       * Converts this word array to a string.
       *
       * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
       *
       * @return {string} The stringified word array.
       *
       * @example
       *
       *     var string = wordArray + '';
       *     var string = wordArray.toString();
       *     var string = wordArray.toString(CryptoJS.enc.Utf8);
       */
      toString: function (encoder) {
        return (encoder || Hex).stringify(this);
      },

      /**
       * Concatenates a word array to this word array.
       *
       * @param {WordArray} wordArray The word array to append.
       *
       * @return {WordArray} This word array.
       *
       * @example
       *
       *     wordArray1.concat(wordArray2);
       */
      concat: function (wordArray) {
        // Shortcuts
        var thisWords = this.words;
        var thatWords = wordArray.words;
        var thisSigBytes = this.sigBytes;
        var thatSigBytes = wordArray.sigBytes; // Clamp excess bits

        this.clamp(); // Concat

        if (thisSigBytes % 4) {
          // Copy one byte at a time
          for (var i = 0; i < thatSigBytes; i++) {
            var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
            thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
          }
        } else {
          // Copy one word at a time
          for (var j = 0; j < thatSigBytes; j += 4) {
            thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
          }
        }

        this.sigBytes += thatSigBytes; // Chainable

        return this;
      },

      /**
       * Removes insignificant bits.
       *
       * @example
       *
       *     wordArray.clamp();
       */
      clamp: function () {
        // Shortcuts
        var words = this.words;
        var sigBytes = this.sigBytes; // Clamp

        words[sigBytes >>> 2] &= 0xffffffff << 32 - sigBytes % 4 * 8;
        words.length = Math.ceil(sigBytes / 4);
      },

      /**
       * Creates a copy of this word array.
       *
       * @return {WordArray} The clone.
       *
       * @example
       *
       *     var clone = wordArray.clone();
       */
      clone: function () {
        var clone = Base.clone.call(this);
        clone.words = this.words.slice(0);
        return clone;
      },

      /**
       * Creates a word array filled with random bytes.
       *
       * @param {number} nBytes The number of random bytes to generate.
       *
       * @return {WordArray} The random word array.
       *
       * @static
       *
       * @example
       *
       *     var wordArray = CryptoJS.lib.WordArray.random(16);
       */
      random: function (nBytes) {
        var words = [];

        for (var i = 0; i < nBytes; i += 4) {
          words.push(cryptoSecureRandomInt());
        }

        return new WordArray.init(words, nBytes);
      }
    });
    /**
     * Encoder namespace.
     */

    var C_enc = C.enc = {};
    /**
     * Hex encoding strategy.
     */

    var Hex = C_enc.Hex = {
      /**
       * Converts a word array to a hex string.
       *
       * @param {WordArray} wordArray The word array.
       *
       * @return {string} The hex string.
       *
       * @static
       *
       * @example
       *
       *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
       */
      stringify: function (wordArray) {
        // Shortcuts
        var words = wordArray.words;
        var sigBytes = wordArray.sigBytes; // Convert

        var hexChars = [];

        for (var i = 0; i < sigBytes; i++) {
          var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
          hexChars.push((bite >>> 4).toString(16));
          hexChars.push((bite & 0x0f).toString(16));
        }

        return hexChars.join('');
      },

      /**
       * Converts a hex string to a word array.
       *
       * @param {string} hexStr The hex string.
       *
       * @return {WordArray} The word array.
       *
       * @static
       *
       * @example
       *
       *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
       */
      parse: function (hexStr) {
        // Shortcut
        var hexStrLength = hexStr.length; // Convert

        var words = [];

        for (var i = 0; i < hexStrLength; i += 2) {
          words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
        }

        return new WordArray.init(words, hexStrLength / 2);
      }
    };
    /**
     * Latin1 encoding strategy.
     */

    var Latin1 = C_enc.Latin1 = {
      /**
       * Converts a word array to a Latin1 string.
       *
       * @param {WordArray} wordArray The word array.
       *
       * @return {string} The Latin1 string.
       *
       * @static
       *
       * @example
       *
       *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
       */
      stringify: function (wordArray) {
        // Shortcuts
        var words = wordArray.words;
        var sigBytes = wordArray.sigBytes; // Convert

        var latin1Chars = [];

        for (var i = 0; i < sigBytes; i++) {
          var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
          latin1Chars.push(String.fromCharCode(bite));
        }

        return latin1Chars.join('');
      },

      /**
       * Converts a Latin1 string to a word array.
       *
       * @param {string} latin1Str The Latin1 string.
       *
       * @return {WordArray} The word array.
       *
       * @static
       *
       * @example
       *
       *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
       */
      parse: function (latin1Str) {
        // Shortcut
        var latin1StrLength = latin1Str.length; // Convert

        var words = [];

        for (var i = 0; i < latin1StrLength; i++) {
          words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << 24 - i % 4 * 8;
        }

        return new WordArray.init(words, latin1StrLength);
      }
    };
    /**
     * UTF-8 encoding strategy.
     */

    var Utf8 = C_enc.Utf8 = {
      /**
       * Converts a word array to a UTF-8 string.
       *
       * @param {WordArray} wordArray The word array.
       *
       * @return {string} The UTF-8 string.
       *
       * @static
       *
       * @example
       *
       *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
       */
      stringify: function (wordArray) {
        try {
          return decodeURIComponent(escape(Latin1.stringify(wordArray)));
        } catch (e) {
          throw new Error('Malformed UTF-8 data');
        }
      },

      /**
       * Converts a UTF-8 string to a word array.
       *
       * @param {string} utf8Str The UTF-8 string.
       *
       * @return {WordArray} The word array.
       *
       * @static
       *
       * @example
       *
       *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
       */
      parse: function (utf8Str) {
        return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
      }
    };
    /**
     * Abstract buffered block algorithm template.
     *
     * The property blockSize must be implemented in a concrete subtype.
     *
     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
     */

    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
      /**
       * Resets this block algorithm's data buffer to its initial state.
       *
       * @example
       *
       *     bufferedBlockAlgorithm.reset();
       */
      reset: function () {
        // Initial values
        this._data = new WordArray.init();
        this._nDataBytes = 0;
      },

      /**
       * Adds new data to this block algorithm's buffer.
       *
       * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
       *
       * @example
       *
       *     bufferedBlockAlgorithm._append('data');
       *     bufferedBlockAlgorithm._append(wordArray);
       */
      _append: function (data) {
        // Convert string to WordArray, else assume WordArray already
        if (typeof data == 'string') {
          data = Utf8.parse(data);
        } // Append


        this._data.concat(data);

        this._nDataBytes += data.sigBytes;
      },

      /**
       * Processes available data blocks.
       *
       * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
       *
       * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
       *
       * @return {WordArray} The processed data.
       *
       * @example
       *
       *     var processedData = bufferedBlockAlgorithm._process();
       *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
       */
      _process: function (doFlush) {
        var processedWords; // Shortcuts

        var data = this._data;
        var dataWords = data.words;
        var dataSigBytes = data.sigBytes;
        var blockSize = this.blockSize;
        var blockSizeBytes = blockSize * 4; // Count blocks ready

        var nBlocksReady = dataSigBytes / blockSizeBytes;

        if (doFlush) {
          // Round up to include partial blocks
          nBlocksReady = Math.ceil(nBlocksReady);
        } else {
          // Round down to include only full blocks,
          // less the number of blocks that must remain in the buffer
          nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
        } // Count words ready


        var nWordsReady = nBlocksReady * blockSize; // Count bytes ready

        var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes); // Process blocks

        if (nWordsReady) {
          for (var offset = 0; offset < nWordsReady; offset += blockSize) {
            // Perform concrete-algorithm logic
            this._doProcessBlock(dataWords, offset);
          } // Remove processed words


          processedWords = dataWords.splice(0, nWordsReady);
          data.sigBytes -= nBytesReady;
        } // Return processed words


        return new WordArray.init(processedWords, nBytesReady);
      },

      /**
       * Creates a copy of this object.
       *
       * @return {Object} The clone.
       *
       * @example
       *
       *     var clone = bufferedBlockAlgorithm.clone();
       */
      clone: function () {
        var clone = Base.clone.call(this);
        clone._data = this._data.clone();
        return clone;
      },
      _minBufferSize: 0
    });
    /**
     * Abstract hasher template.
     *
     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
     */

    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
      /**
       * Configuration options.
       */
      cfg: Base.extend(),

      /**
       * Initializes a newly created hasher.
       *
       * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
       *
       * @example
       *
       *     var hasher = CryptoJS.algo.SHA256.create();
       */
      init: function (cfg) {
        // Apply config defaults
        this.cfg = this.cfg.extend(cfg); // Set initial values

        this.reset();
      },

      /**
       * Resets this hasher to its initial state.
       *
       * @example
       *
       *     hasher.reset();
       */
      reset: function () {
        // Reset data buffer
        BufferedBlockAlgorithm.reset.call(this); // Perform concrete-hasher logic

        this._doReset();
      },

      /**
       * Updates this hasher with a message.
       *
       * @param {WordArray|string} messageUpdate The message to append.
       *
       * @return {Hasher} This hasher.
       *
       * @example
       *
       *     hasher.update('message');
       *     hasher.update(wordArray);
       */
      update: function (messageUpdate) {
        // Append
        this._append(messageUpdate); // Update the hash


        this._process(); // Chainable


        return this;
      },

      /**
       * Finalizes the hash computation.
       * Note that the finalize operation is effectively a destructive, read-once operation.
       *
       * @param {WordArray|string} messageUpdate (Optional) A final message update.
       *
       * @return {WordArray} The hash.
       *
       * @example
       *
       *     var hash = hasher.finalize();
       *     var hash = hasher.finalize('message');
       *     var hash = hasher.finalize(wordArray);
       */
      finalize: function (messageUpdate) {
        // Final message update
        if (messageUpdate) {
          this._append(messageUpdate);
        } // Perform concrete-hasher logic


        var hash = this._doFinalize();

        return hash;
      },
      blockSize: 512 / 32,

      /**
       * Creates a shortcut function to a hasher's object interface.
       *
       * @param {Hasher} hasher The hasher to create a helper for.
       *
       * @return {Function} The shortcut function.
       *
       * @static
       *
       * @example
       *
       *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
       */
      _createHelper: function (hasher) {
        return function (message, cfg) {
          return new hasher.init(cfg).finalize(message);
        };
      },

      /**
       * Creates a shortcut function to the HMAC's object interface.
       *
       * @param {Hasher} hasher The hasher to use in this HMAC helper.
       *
       * @return {Function} The shortcut function.
       *
       * @static
       *
       * @example
       *
       *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
       */
      _createHmacHelper: function (hasher) {
        return function (message, key) {
          return new C_algo.HMAC.init(hasher, key).finalize(message);
        };
      }
    });
    /**
     * Algorithm namespace.
     */

    var C_algo = C.algo = {};
    return C;
  }(Math);

  return CryptoJS;
});

/***/ }),

/***/ "./node_modules/crypto-js/enc-base64.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-js/enc-base64.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
  } else {}
})(this, function (CryptoJS) {
  (function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var C_enc = C.enc;
    /**
     * Base64 encoding strategy.
     */

    var Base64 = C_enc.Base64 = {
      /**
       * Converts a word array to a Base64 string.
       *
       * @param {WordArray} wordArray The word array.
       *
       * @return {string} The Base64 string.
       *
       * @static
       *
       * @example
       *
       *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
       */
      stringify: function (wordArray) {
        // Shortcuts
        var words = wordArray.words;
        var sigBytes = wordArray.sigBytes;
        var map = this._map; // Clamp excess bits

        wordArray.clamp(); // Convert

        var base64Chars = [];

        for (var i = 0; i < sigBytes; i += 3) {
          var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
          var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 0xff;
          var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 0xff;
          var triplet = byte1 << 16 | byte2 << 8 | byte3;

          for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
            base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 0x3f));
          }
        } // Add padding


        var paddingChar = map.charAt(64);

        if (paddingChar) {
          while (base64Chars.length % 4) {
            base64Chars.push(paddingChar);
          }
        }

        return base64Chars.join('');
      },

      /**
       * Converts a Base64 string to a word array.
       *
       * @param {string} base64Str The Base64 string.
       *
       * @return {WordArray} The word array.
       *
       * @static
       *
       * @example
       *
       *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
       */
      parse: function (base64Str) {
        // Shortcuts
        var base64StrLength = base64Str.length;
        var map = this._map;
        var reverseMap = this._reverseMap;

        if (!reverseMap) {
          reverseMap = this._reverseMap = [];

          for (var j = 0; j < map.length; j++) {
            reverseMap[map.charCodeAt(j)] = j;
          }
        } // Ignore padding


        var paddingChar = map.charAt(64);

        if (paddingChar) {
          var paddingIndex = base64Str.indexOf(paddingChar);

          if (paddingIndex !== -1) {
            base64StrLength = paddingIndex;
          }
        } // Convert


        return parseLoop(base64Str, base64StrLength, reverseMap);
      },
      _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
    };

    function parseLoop(base64Str, base64StrLength, reverseMap) {
      var words = [];
      var nBytes = 0;

      for (var i = 0; i < base64StrLength; i++) {
        if (i % 4) {
          var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
          var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
          var bitsCombined = bits1 | bits2;
          words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
          nBytes++;
        }
      }

      return WordArray.create(words, nBytes);
    }
  })();

  return CryptoJS.enc.Base64;
});

/***/ }),

/***/ "./node_modules/crypto-js/enc-base64url.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-js/enc-base64url.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
  } else {}
})(this, function (CryptoJS) {
  (function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var C_enc = C.enc;
    /**
     * Base64url encoding strategy.
     */

    var Base64url = C_enc.Base64url = {
      /**
       * Converts a word array to a Base64url string.
       *
       * @param {WordArray} wordArray The word array.
       *
       * @param {boolean} urlSafe Whether to use url safe
       *
       * @return {string} The Base64url string.
       *
       * @static
       *
       * @example
       *
       *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
       */
      stringify: function (wordArray, urlSafe = true) {
        // Shortcuts
        var words = wordArray.words;
        var sigBytes = wordArray.sigBytes;
        var map = urlSafe ? this._safe_map : this._map; // Clamp excess bits

        wordArray.clamp(); // Convert

        var base64Chars = [];

        for (var i = 0; i < sigBytes; i += 3) {
          var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
          var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 0xff;
          var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 0xff;
          var triplet = byte1 << 16 | byte2 << 8 | byte3;

          for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
            base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 0x3f));
          }
        } // Add padding


        var paddingChar = map.charAt(64);

        if (paddingChar) {
          while (base64Chars.length % 4) {
            base64Chars.push(paddingChar);
          }
        }

        return base64Chars.join('');
      },

      /**
       * Converts a Base64url string to a word array.
       *
       * @param {string} base64Str The Base64url string.
       *
       * @param {boolean} urlSafe Whether to use url safe
       *
       * @return {WordArray} The word array.
       *
       * @static
       *
       * @example
       *
       *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
       */
      parse: function (base64Str, urlSafe = true) {
        // Shortcuts
        var base64StrLength = base64Str.length;
        var map = urlSafe ? this._safe_map : this._map;
        var reverseMap = this._reverseMap;

        if (!reverseMap) {
          reverseMap = this._reverseMap = [];

          for (var j = 0; j < map.length; j++) {
            reverseMap[map.charCodeAt(j)] = j;
          }
        } // Ignore padding


        var paddingChar = map.charAt(64);

        if (paddingChar) {
          var paddingIndex = base64Str.indexOf(paddingChar);

          if (paddingIndex !== -1) {
            base64StrLength = paddingIndex;
          }
        } // Convert


        return parseLoop(base64Str, base64StrLength, reverseMap);
      },
      _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
      _safe_map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'
    };

    function parseLoop(base64Str, base64StrLength, reverseMap) {
      var words = [];
      var nBytes = 0;

      for (var i = 0; i < base64StrLength; i++) {
        if (i % 4) {
          var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
          var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
          var bitsCombined = bits1 | bits2;
          words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
          nBytes++;
        }
      }

      return WordArray.create(words, nBytes);
    }
  })();

  return CryptoJS.enc.Base64url;
});

/***/ }),

/***/ "./node_modules/crypto-js/enc-utf16.js":
/*!*********************************************!*\
  !*** ./node_modules/crypto-js/enc-utf16.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
  } else {}
})(this, function (CryptoJS) {
  (function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var C_enc = C.enc;
    /**
     * UTF-16 BE encoding strategy.
     */

    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
      /**
       * Converts a word array to a UTF-16 BE string.
       *
       * @param {WordArray} wordArray The word array.
       *
       * @return {string} The UTF-16 BE string.
       *
       * @static
       *
       * @example
       *
       *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
       */
      stringify: function (wordArray) {
        // Shortcuts
        var words = wordArray.words;
        var sigBytes = wordArray.sigBytes; // Convert

        var utf16Chars = [];

        for (var i = 0; i < sigBytes; i += 2) {
          var codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 0xffff;
          utf16Chars.push(String.fromCharCode(codePoint));
        }

        return utf16Chars.join('');
      },

      /**
       * Converts a UTF-16 BE string to a word array.
       *
       * @param {string} utf16Str The UTF-16 BE string.
       *
       * @return {WordArray} The word array.
       *
       * @static
       *
       * @example
       *
       *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
       */
      parse: function (utf16Str) {
        // Shortcut
        var utf16StrLength = utf16Str.length; // Convert

        var words = [];

        for (var i = 0; i < utf16StrLength; i++) {
          words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
        }

        return WordArray.create(words, utf16StrLength * 2);
      }
    };
    /**
     * UTF-16 LE encoding strategy.
     */

    C_enc.Utf16LE = {
      /**
       * Converts a word array to a UTF-16 LE string.
       *
       * @param {WordArray} wordArray The word array.
       *
       * @return {string} The UTF-16 LE string.
       *
       * @static
       *
       * @example
       *
       *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
       */
      stringify: function (wordArray) {
        // Shortcuts
        var words = wordArray.words;
        var sigBytes = wordArray.sigBytes; // Convert

        var utf16Chars = [];

        for (var i = 0; i < sigBytes; i += 2) {
          var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 0xffff);
          utf16Chars.push(String.fromCharCode(codePoint));
        }

        return utf16Chars.join('');
      },

      /**
       * Converts a UTF-16 LE string to a word array.
       *
       * @param {string} utf16Str The UTF-16 LE string.
       *
       * @return {WordArray} The word array.
       *
       * @static
       *
       * @example
       *
       *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
       */
      parse: function (utf16Str) {
        // Shortcut
        var utf16StrLength = utf16Str.length; // Convert

        var words = [];

        for (var i = 0; i < utf16StrLength; i++) {
          words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
        }

        return WordArray.create(words, utf16StrLength * 2);
      }
    };

    function swapEndian(word) {
      return word << 8 & 0xff00ff00 | word >>> 8 & 0x00ff00ff;
    }
  })();

  return CryptoJS.enc.Utf16;
});

/***/ }),

/***/ "./node_modules/crypto-js/evpkdf.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/evpkdf.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./sha1 */ "./node_modules/crypto-js/sha1.js"), __webpack_require__(/*! ./hmac */ "./node_modules/crypto-js/hmac.js"));
  } else {}
})(this, function (CryptoJS) {
  (function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var WordArray = C_lib.WordArray;
    var C_algo = C.algo;
    var MD5 = C_algo.MD5;
    /**
     * This key derivation function is meant to conform with EVP_BytesToKey.
     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
     */

    var EvpKDF = C_algo.EvpKDF = Base.extend({
      /**
       * Configuration options.
       *
       * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
       * @property {Hasher} hasher The hash algorithm to use. Default: MD5
       * @property {number} iterations The number of iterations to perform. Default: 1
       */
      cfg: Base.extend({
        keySize: 128 / 32,
        hasher: MD5,
        iterations: 1
      }),

      /**
       * Initializes a newly created key derivation function.
       *
       * @param {Object} cfg (Optional) The configuration options to use for the derivation.
       *
       * @example
       *
       *     var kdf = CryptoJS.algo.EvpKDF.create();
       *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
       *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
       */
      init: function (cfg) {
        this.cfg = this.cfg.extend(cfg);
      },

      /**
       * Derives a key from a password.
       *
       * @param {WordArray|string} password The password.
       * @param {WordArray|string} salt A salt.
       *
       * @return {WordArray} The derived key.
       *
       * @example
       *
       *     var key = kdf.compute(password, salt);
       */
      compute: function (password, salt) {
        var block; // Shortcut

        var cfg = this.cfg; // Init hasher

        var hasher = cfg.hasher.create(); // Initial values

        var derivedKey = WordArray.create(); // Shortcuts

        var derivedKeyWords = derivedKey.words;
        var keySize = cfg.keySize;
        var iterations = cfg.iterations; // Generate key

        while (derivedKeyWords.length < keySize) {
          if (block) {
            hasher.update(block);
          }

          block = hasher.update(password).finalize(salt);
          hasher.reset(); // Iterations

          for (var i = 1; i < iterations; i++) {
            block = hasher.finalize(block);
            hasher.reset();
          }

          derivedKey.concat(block);
        }

        derivedKey.sigBytes = keySize * 4;
        return derivedKey;
      }
    });
    /**
     * Derives a key from a password.
     *
     * @param {WordArray|string} password The password.
     * @param {WordArray|string} salt A salt.
     * @param {Object} cfg (Optional) The configuration options to use for this computation.
     *
     * @return {WordArray} The derived key.
     *
     * @static
     *
     * @example
     *
     *     var key = CryptoJS.EvpKDF(password, salt);
     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
     */

    C.EvpKDF = function (password, salt, cfg) {
      return EvpKDF.create(cfg).compute(password, salt);
    };
  })();

  return CryptoJS.EvpKDF;
});

/***/ }),

/***/ "./node_modules/crypto-js/format-hex.js":
/*!**********************************************!*\
  !*** ./node_modules/crypto-js/format-hex.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
  } else {}
})(this, function (CryptoJS) {
  (function (undefined) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var CipherParams = C_lib.CipherParams;
    var C_enc = C.enc;
    var Hex = C_enc.Hex;
    var C_format = C.format;
    var HexFormatter = C_format.Hex = {
      /**
       * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
       *
       * @param {CipherParams} cipherParams The cipher params object.
       *
       * @return {string} The hexadecimally encoded string.
       *
       * @static
       *
       * @example
       *
       *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
       */
      stringify: function (cipherParams) {
        return cipherParams.ciphertext.toString(Hex);
      },

      /**
       * Converts a hexadecimally encoded ciphertext string to a cipher params object.
       *
       * @param {string} input The hexadecimally encoded string.
       *
       * @return {CipherParams} The cipher params object.
       *
       * @static
       *
       * @example
       *
       *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
       */
      parse: function (input) {
        var ciphertext = Hex.parse(input);
        return CipherParams.create({
          ciphertext: ciphertext
        });
      }
    };
  })();

  return CryptoJS.format.Hex;
});

/***/ }),

/***/ "./node_modules/crypto-js/hmac.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/hmac.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
  } else {}
})(this, function (CryptoJS) {
  (function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var C_enc = C.enc;
    var Utf8 = C_enc.Utf8;
    var C_algo = C.algo;
    /**
     * HMAC algorithm.
     */

    var HMAC = C_algo.HMAC = Base.extend({
      /**
       * Initializes a newly created HMAC.
       *
       * @param {Hasher} hasher The hash algorithm to use.
       * @param {WordArray|string} key The secret key.
       *
       * @example
       *
       *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
       */
      init: function (hasher, key) {
        // Init hasher
        hasher = this._hasher = new hasher.init(); // Convert string to WordArray, else assume WordArray already

        if (typeof key == 'string') {
          key = Utf8.parse(key);
        } // Shortcuts


        var hasherBlockSize = hasher.blockSize;
        var hasherBlockSizeBytes = hasherBlockSize * 4; // Allow arbitrary length keys

        if (key.sigBytes > hasherBlockSizeBytes) {
          key = hasher.finalize(key);
        } // Clamp excess bits


        key.clamp(); // Clone key for inner and outer pads

        var oKey = this._oKey = key.clone();
        var iKey = this._iKey = key.clone(); // Shortcuts

        var oKeyWords = oKey.words;
        var iKeyWords = iKey.words; // XOR keys with pad constants

        for (var i = 0; i < hasherBlockSize; i++) {
          oKeyWords[i] ^= 0x5c5c5c5c;
          iKeyWords[i] ^= 0x36363636;
        }

        oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes; // Set initial values

        this.reset();
      },

      /**
       * Resets this HMAC to its initial state.
       *
       * @example
       *
       *     hmacHasher.reset();
       */
      reset: function () {
        // Shortcut
        var hasher = this._hasher; // Reset

        hasher.reset();
        hasher.update(this._iKey);
      },

      /**
       * Updates this HMAC with a message.
       *
       * @param {WordArray|string} messageUpdate The message to append.
       *
       * @return {HMAC} This HMAC instance.
       *
       * @example
       *
       *     hmacHasher.update('message');
       *     hmacHasher.update(wordArray);
       */
      update: function (messageUpdate) {
        this._hasher.update(messageUpdate); // Chainable


        return this;
      },

      /**
       * Finalizes the HMAC computation.
       * Note that the finalize operation is effectively a destructive, read-once operation.
       *
       * @param {WordArray|string} messageUpdate (Optional) A final message update.
       *
       * @return {WordArray} The HMAC.
       *
       * @example
       *
       *     var hmac = hmacHasher.finalize();
       *     var hmac = hmacHasher.finalize('message');
       *     var hmac = hmacHasher.finalize(wordArray);
       */
      finalize: function (messageUpdate) {
        // Shortcut
        var hasher = this._hasher; // Compute HMAC

        var innerHash = hasher.finalize(messageUpdate);
        hasher.reset();
        var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
        return hmac;
      }
    });
  })();
});

/***/ }),

/***/ "./node_modules/crypto-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/crypto-js/index.js ***!
  \*****************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./x64-core */ "./node_modules/crypto-js/x64-core.js"), __webpack_require__(/*! ./lib-typedarrays */ "./node_modules/crypto-js/lib-typedarrays.js"), __webpack_require__(/*! ./enc-utf16 */ "./node_modules/crypto-js/enc-utf16.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./enc-base64url */ "./node_modules/crypto-js/enc-base64url.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./sha1 */ "./node_modules/crypto-js/sha1.js"), __webpack_require__(/*! ./sha256 */ "./node_modules/crypto-js/sha256.js"), __webpack_require__(/*! ./sha224 */ "./node_modules/crypto-js/sha224.js"), __webpack_require__(/*! ./sha512 */ "./node_modules/crypto-js/sha512.js"), __webpack_require__(/*! ./sha384 */ "./node_modules/crypto-js/sha384.js"), __webpack_require__(/*! ./sha3 */ "./node_modules/crypto-js/sha3.js"), __webpack_require__(/*! ./ripemd160 */ "./node_modules/crypto-js/ripemd160.js"), __webpack_require__(/*! ./hmac */ "./node_modules/crypto-js/hmac.js"), __webpack_require__(/*! ./pbkdf2 */ "./node_modules/crypto-js/pbkdf2.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"), __webpack_require__(/*! ./mode-cfb */ "./node_modules/crypto-js/mode-cfb.js"), __webpack_require__(/*! ./mode-ctr */ "./node_modules/crypto-js/mode-ctr.js"), __webpack_require__(/*! ./mode-ctr-gladman */ "./node_modules/crypto-js/mode-ctr-gladman.js"), __webpack_require__(/*! ./mode-ofb */ "./node_modules/crypto-js/mode-ofb.js"), __webpack_require__(/*! ./mode-ecb */ "./node_modules/crypto-js/mode-ecb.js"), __webpack_require__(/*! ./pad-ansix923 */ "./node_modules/crypto-js/pad-ansix923.js"), __webpack_require__(/*! ./pad-iso10126 */ "./node_modules/crypto-js/pad-iso10126.js"), __webpack_require__(/*! ./pad-iso97971 */ "./node_modules/crypto-js/pad-iso97971.js"), __webpack_require__(/*! ./pad-zeropadding */ "./node_modules/crypto-js/pad-zeropadding.js"), __webpack_require__(/*! ./pad-nopadding */ "./node_modules/crypto-js/pad-nopadding.js"), __webpack_require__(/*! ./format-hex */ "./node_modules/crypto-js/format-hex.js"), __webpack_require__(/*! ./aes */ "./node_modules/crypto-js/aes.js"), __webpack_require__(/*! ./tripledes */ "./node_modules/crypto-js/tripledes.js"), __webpack_require__(/*! ./rc4 */ "./node_modules/crypto-js/rc4.js"), __webpack_require__(/*! ./rabbit */ "./node_modules/crypto-js/rabbit.js"), __webpack_require__(/*! ./rabbit-legacy */ "./node_modules/crypto-js/rabbit-legacy.js"));
  } else {}
})(this, function (CryptoJS) {
  return CryptoJS;
});

/***/ }),

/***/ "./node_modules/crypto-js/lib-typedarrays.js":
/*!***************************************************!*\
  !*** ./node_modules/crypto-js/lib-typedarrays.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
  } else {}
})(this, function (CryptoJS) {
  (function () {
    // Check if typed arrays are supported
    if (typeof ArrayBuffer != 'function') {
      return;
    } // Shortcuts


    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray; // Reference original init

    var superInit = WordArray.init; // Augment WordArray.init to handle typed arrays

    var subInit = WordArray.init = function (typedArray) {
      // Convert buffers to uint8
      if (typedArray instanceof ArrayBuffer) {
        typedArray = new Uint8Array(typedArray);
      } // Convert other array views to uint8


      if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
        typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
      } // Handle Uint8Array


      if (typedArray instanceof Uint8Array) {
        // Shortcut
        var typedArrayByteLength = typedArray.byteLength; // Extract bytes

        var words = [];

        for (var i = 0; i < typedArrayByteLength; i++) {
          words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
        } // Initialize this word array


        superInit.call(this, words, typedArrayByteLength);
      } else {
        // Else call normal init
        superInit.apply(this, arguments);
      }
    };

    subInit.prototype = WordArray;
  })();

  return CryptoJS.lib.WordArray;
});

/***/ }),

/***/ "./node_modules/crypto-js/md5.js":
/*!***************************************!*\
  !*** ./node_modules/crypto-js/md5.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
  } else {}
})(this, function (CryptoJS) {
  (function (Math) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo; // Constants table

    var T = []; // Compute constants

    (function () {
      for (var i = 0; i < 64; i++) {
        T[i] = Math.abs(Math.sin(i + 1)) * 0x100000000 | 0;
      }
    })();
    /**
     * MD5 hash algorithm.
     */


    var MD5 = C_algo.MD5 = Hasher.extend({
      _doReset: function () {
        this._hash = new WordArray.init([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]);
      },
      _doProcessBlock: function (M, offset) {
        // Swap endian
        for (var i = 0; i < 16; i++) {
          // Shortcuts
          var offset_i = offset + i;
          var M_offset_i = M[offset_i];
          M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 0x00ff00ff | (M_offset_i << 24 | M_offset_i >>> 8) & 0xff00ff00;
        } // Shortcuts


        var H = this._hash.words;
        var M_offset_0 = M[offset + 0];
        var M_offset_1 = M[offset + 1];
        var M_offset_2 = M[offset + 2];
        var M_offset_3 = M[offset + 3];
        var M_offset_4 = M[offset + 4];
        var M_offset_5 = M[offset + 5];
        var M_offset_6 = M[offset + 6];
        var M_offset_7 = M[offset + 7];
        var M_offset_8 = M[offset + 8];
        var M_offset_9 = M[offset + 9];
        var M_offset_10 = M[offset + 10];
        var M_offset_11 = M[offset + 11];
        var M_offset_12 = M[offset + 12];
        var M_offset_13 = M[offset + 13];
        var M_offset_14 = M[offset + 14];
        var M_offset_15 = M[offset + 15]; // Working varialbes

        var a = H[0];
        var b = H[1];
        var c = H[2];
        var d = H[3]; // Computation

        a = FF(a, b, c, d, M_offset_0, 7, T[0]);
        d = FF(d, a, b, c, M_offset_1, 12, T[1]);
        c = FF(c, d, a, b, M_offset_2, 17, T[2]);
        b = FF(b, c, d, a, M_offset_3, 22, T[3]);
        a = FF(a, b, c, d, M_offset_4, 7, T[4]);
        d = FF(d, a, b, c, M_offset_5, 12, T[5]);
        c = FF(c, d, a, b, M_offset_6, 17, T[6]);
        b = FF(b, c, d, a, M_offset_7, 22, T[7]);
        a = FF(a, b, c, d, M_offset_8, 7, T[8]);
        d = FF(d, a, b, c, M_offset_9, 12, T[9]);
        c = FF(c, d, a, b, M_offset_10, 17, T[10]);
        b = FF(b, c, d, a, M_offset_11, 22, T[11]);
        a = FF(a, b, c, d, M_offset_12, 7, T[12]);
        d = FF(d, a, b, c, M_offset_13, 12, T[13]);
        c = FF(c, d, a, b, M_offset_14, 17, T[14]);
        b = FF(b, c, d, a, M_offset_15, 22, T[15]);
        a = GG(a, b, c, d, M_offset_1, 5, T[16]);
        d = GG(d, a, b, c, M_offset_6, 9, T[17]);
        c = GG(c, d, a, b, M_offset_11, 14, T[18]);
        b = GG(b, c, d, a, M_offset_0, 20, T[19]);
        a = GG(a, b, c, d, M_offset_5, 5, T[20]);
        d = GG(d, a, b, c, M_offset_10, 9, T[21]);
        c = GG(c, d, a, b, M_offset_15, 14, T[22]);
        b = GG(b, c, d, a, M_offset_4, 20, T[23]);
        a = GG(a, b, c, d, M_offset_9, 5, T[24]);
        d = GG(d, a, b, c, M_offset_14, 9, T[25]);
        c = GG(c, d, a, b, M_offset_3, 14, T[26]);
        b = GG(b, c, d, a, M_offset_8, 20, T[27]);
        a = GG(a, b, c, d, M_offset_13, 5, T[28]);
        d = GG(d, a, b, c, M_offset_2, 9, T[29]);
        c = GG(c, d, a, b, M_offset_7, 14, T[30]);
        b = GG(b, c, d, a, M_offset_12, 20, T[31]);
        a = HH(a, b, c, d, M_offset_5, 4, T[32]);
        d = HH(d, a, b, c, M_offset_8, 11, T[33]);
        c = HH(c, d, a, b, M_offset_11, 16, T[34]);
        b = HH(b, c, d, a, M_offset_14, 23, T[35]);
        a = HH(a, b, c, d, M_offset_1, 4, T[36]);
        d = HH(d, a, b, c, M_offset_4, 11, T[37]);
        c = HH(c, d, a, b, M_offset_7, 16, T[38]);
        b = HH(b, c, d, a, M_offset_10, 23, T[39]);
        a = HH(a, b, c, d, M_offset_13, 4, T[40]);
        d = HH(d, a, b, c, M_offset_0, 11, T[41]);
        c = HH(c, d, a, b, M_offset_3, 16, T[42]);
        b = HH(b, c, d, a, M_offset_6, 23, T[43]);
        a = HH(a, b, c, d, M_offset_9, 4, T[44]);
        d = HH(d, a, b, c, M_offset_12, 11, T[45]);
        c = HH(c, d, a, b, M_offset_15, 16, T[46]);
        b = HH(b, c, d, a, M_offset_2, 23, T[47]);
        a = II(a, b, c, d, M_offset_0, 6, T[48]);
        d = II(d, a, b, c, M_offset_7, 10, T[49]);
        c = II(c, d, a, b, M_offset_14, 15, T[50]);
        b = II(b, c, d, a, M_offset_5, 21, T[51]);
        a = II(a, b, c, d, M_offset_12, 6, T[52]);
        d = II(d, a, b, c, M_offset_3, 10, T[53]);
        c = II(c, d, a, b, M_offset_10, 15, T[54]);
        b = II(b, c, d, a, M_offset_1, 21, T[55]);
        a = II(a, b, c, d, M_offset_8, 6, T[56]);
        d = II(d, a, b, c, M_offset_15, 10, T[57]);
        c = II(c, d, a, b, M_offset_6, 15, T[58]);
        b = II(b, c, d, a, M_offset_13, 21, T[59]);
        a = II(a, b, c, d, M_offset_4, 6, T[60]);
        d = II(d, a, b, c, M_offset_11, 10, T[61]);
        c = II(c, d, a, b, M_offset_2, 15, T[62]);
        b = II(b, c, d, a, M_offset_9, 21, T[63]); // Intermediate hash value

        H[0] = H[0] + a | 0;
        H[1] = H[1] + b | 0;
        H[2] = H[2] + c | 0;
        H[3] = H[3] + d | 0;
      },
      _doFinalize: function () {
        // Shortcuts
        var data = this._data;
        var dataWords = data.words;
        var nBitsTotal = this._nDataBytes * 8;
        var nBitsLeft = data.sigBytes * 8; // Add padding

        dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
        var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
        var nBitsTotalL = nBitsTotal;
        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 0x00ff00ff | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 0xff00ff00;
        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 0x00ff00ff | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 0xff00ff00;
        data.sigBytes = (dataWords.length + 1) * 4; // Hash final blocks

        this._process(); // Shortcuts


        var hash = this._hash;
        var H = hash.words; // Swap endian

        for (var i = 0; i < 4; i++) {
          // Shortcut
          var H_i = H[i];
          H[i] = (H_i << 8 | H_i >>> 24) & 0x00ff00ff | (H_i << 24 | H_i >>> 8) & 0xff00ff00;
        } // Return final computed hash


        return hash;
      },
      clone: function () {
        var clone = Hasher.clone.call(this);
        clone._hash = this._hash.clone();
        return clone;
      }
    });

    function FF(a, b, c, d, x, s, t) {
      var n = a + (b & c | ~b & d) + x + t;
      return (n << s | n >>> 32 - s) + b;
    }

    function GG(a, b, c, d, x, s, t) {
      var n = a + (b & d | c & ~d) + x + t;
      return (n << s | n >>> 32 - s) + b;
    }

    function HH(a, b, c, d, x, s, t) {
      var n = a + (b ^ c ^ d) + x + t;
      return (n << s | n >>> 32 - s) + b;
    }

    function II(a, b, c, d, x, s, t) {
      var n = a + (c ^ (b | ~d)) + x + t;
      return (n << s | n >>> 32 - s) + b;
    }
    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.MD5('message');
     *     var hash = CryptoJS.MD5(wordArray);
     */


    C.MD5 = Hasher._createHelper(MD5);
    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacMD5(message, key);
     */

    C.HmacMD5 = Hasher._createHmacHelper(MD5);
  })(Math);

  return CryptoJS.MD5;
});

/***/ }),

/***/ "./node_modules/crypto-js/mode-cfb.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/mode-cfb.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
  } else {}
})(this, function (CryptoJS) {
  /**
   * Cipher Feedback block mode.
   */
  CryptoJS.mode.CFB = function () {
    var CFB = CryptoJS.lib.BlockCipherMode.extend();
    CFB.Encryptor = CFB.extend({
      processBlock: function (words, offset) {
        // Shortcuts
        var cipher = this._cipher;
        var blockSize = cipher.blockSize;
        generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher); // Remember this block to use with next block

        this._prevBlock = words.slice(offset, offset + blockSize);
      }
    });
    CFB.Decryptor = CFB.extend({
      processBlock: function (words, offset) {
        // Shortcuts
        var cipher = this._cipher;
        var blockSize = cipher.blockSize; // Remember this block to use with next block

        var thisBlock = words.slice(offset, offset + blockSize);
        generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher); // This block becomes the previous block

        this._prevBlock = thisBlock;
      }
    });

    function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
      var keystream; // Shortcut

      var iv = this._iv; // Generate keystream

      if (iv) {
        keystream = iv.slice(0); // Remove IV for subsequent blocks

        this._iv = undefined;
      } else {
        keystream = this._prevBlock;
      }

      cipher.encryptBlock(keystream, 0); // Encrypt

      for (var i = 0; i < blockSize; i++) {
        words[offset + i] ^= keystream[i];
      }
    }

    return CFB;
  }();

  return CryptoJS.mode.CFB;
});

/***/ }),

/***/ "./node_modules/crypto-js/mode-ctr-gladman.js":
/*!****************************************************!*\
  !*** ./node_modules/crypto-js/mode-ctr-gladman.js ***!
  \****************************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
  } else {}
})(this, function (CryptoJS) {
  /** @preserve
   * Counter block mode compatible with  Dr Brian Gladman fileenc.c
   * derived from CryptoJS.mode.CTR
   * Jan Hruby jhruby.web@gmail.com
   */
  CryptoJS.mode.CTRGladman = function () {
    var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();

    function incWord(word) {
      if ((word >> 24 & 0xff) === 0xff) {
        //overflow
        var b1 = word >> 16 & 0xff;
        var b2 = word >> 8 & 0xff;
        var b3 = word & 0xff;

        if (b1 === 0xff) // overflow b1
          {
            b1 = 0;

            if (b2 === 0xff) {
              b2 = 0;

              if (b3 === 0xff) {
                b3 = 0;
              } else {
                ++b3;
              }
            } else {
              ++b2;
            }
          } else {
          ++b1;
        }

        word = 0;
        word += b1 << 16;
        word += b2 << 8;
        word += b3;
      } else {
        word += 0x01 << 24;
      }

      return word;
    }

    function incCounter(counter) {
      if ((counter[0] = incWord(counter[0])) === 0) {
        // encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
        counter[1] = incWord(counter[1]);
      }

      return counter;
    }

    var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
      processBlock: function (words, offset) {
        // Shortcuts
        var cipher = this._cipher;
        var blockSize = cipher.blockSize;
        var iv = this._iv;
        var counter = this._counter; // Generate keystream

        if (iv) {
          counter = this._counter = iv.slice(0); // Remove IV for subsequent blocks

          this._iv = undefined;
        }

        incCounter(counter);
        var keystream = counter.slice(0);
        cipher.encryptBlock(keystream, 0); // Encrypt

        for (var i = 0; i < blockSize; i++) {
          words[offset + i] ^= keystream[i];
        }
      }
    });
    CTRGladman.Decryptor = Encryptor;
    return CTRGladman;
  }();

  return CryptoJS.mode.CTRGladman;
});

/***/ }),

/***/ "./node_modules/crypto-js/mode-ctr.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/mode-ctr.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
  } else {}
})(this, function (CryptoJS) {
  /**
   * Counter block mode.
   */
  CryptoJS.mode.CTR = function () {
    var CTR = CryptoJS.lib.BlockCipherMode.extend();
    var Encryptor = CTR.Encryptor = CTR.extend({
      processBlock: function (words, offset) {
        // Shortcuts
        var cipher = this._cipher;
        var blockSize = cipher.blockSize;
        var iv = this._iv;
        var counter = this._counter; // Generate keystream

        if (iv) {
          counter = this._counter = iv.slice(0); // Remove IV for subsequent blocks

          this._iv = undefined;
        }

        var keystream = counter.slice(0);
        cipher.encryptBlock(keystream, 0); // Increment counter

        counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0; // Encrypt

        for (var i = 0; i < blockSize; i++) {
          words[offset + i] ^= keystream[i];
        }
      }
    });
    CTR.Decryptor = Encryptor;
    return CTR;
  }();

  return CryptoJS.mode.CTR;
});

/***/ }),

/***/ "./node_modules/crypto-js/mode-ecb.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/mode-ecb.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
  } else {}
})(this, function (CryptoJS) {
  /**
   * Electronic Codebook block mode.
   */
  CryptoJS.mode.ECB = function () {
    var ECB = CryptoJS.lib.BlockCipherMode.extend();
    ECB.Encryptor = ECB.extend({
      processBlock: function (words, offset) {
        this._cipher.encryptBlock(words, offset);
      }
    });
    ECB.Decryptor = ECB.extend({
      processBlock: function (words, offset) {
        this._cipher.decryptBlock(words, offset);
      }
    });
    return ECB;
  }();

  return CryptoJS.mode.ECB;
});

/***/ }),

/***/ "./node_modules/crypto-js/mode-ofb.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/mode-ofb.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
  } else {}
})(this, function (CryptoJS) {
  /**
   * Output Feedback block mode.
   */
  CryptoJS.mode.OFB = function () {
    var OFB = CryptoJS.lib.BlockCipherMode.extend();
    var Encryptor = OFB.Encryptor = OFB.extend({
      processBlock: function (words, offset) {
        // Shortcuts
        var cipher = this._cipher;
        var blockSize = cipher.blockSize;
        var iv = this._iv;
        var keystream = this._keystream; // Generate keystream

        if (iv) {
          keystream = this._keystream = iv.slice(0); // Remove IV for subsequent blocks

          this._iv = undefined;
        }

        cipher.encryptBlock(keystream, 0); // Encrypt

        for (var i = 0; i < blockSize; i++) {
          words[offset + i] ^= keystream[i];
        }
      }
    });
    OFB.Decryptor = Encryptor;
    return OFB;
  }();

  return CryptoJS.mode.OFB;
});

/***/ }),

/***/ "./node_modules/crypto-js/pad-ansix923.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-js/pad-ansix923.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
  } else {}
})(this, function (CryptoJS) {
  /**
   * ANSI X.923 padding strategy.
   */
  CryptoJS.pad.AnsiX923 = {
    pad: function (data, blockSize) {
      // Shortcuts
      var dataSigBytes = data.sigBytes;
      var blockSizeBytes = blockSize * 4; // Count padding bytes

      var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes; // Compute last byte position

      var lastBytePos = dataSigBytes + nPaddingBytes - 1; // Pad

      data.clamp();
      data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
      data.sigBytes += nPaddingBytes;
    },
    unpad: function (data) {
      // Get number of padding bytes from last byte
      var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 0xff; // Remove padding

      data.sigBytes -= nPaddingBytes;
    }
  };
  return CryptoJS.pad.Ansix923;
});

/***/ }),

/***/ "./node_modules/crypto-js/pad-iso10126.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-js/pad-iso10126.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
  } else {}
})(this, function (CryptoJS) {
  /**
   * ISO 10126 padding strategy.
   */
  CryptoJS.pad.Iso10126 = {
    pad: function (data, blockSize) {
      // Shortcut
      var blockSizeBytes = blockSize * 4; // Count padding bytes

      var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes; // Pad

      data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
    },
    unpad: function (data) {
      // Get number of padding bytes from last byte
      var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 0xff; // Remove padding

      data.sigBytes -= nPaddingBytes;
    }
  };
  return CryptoJS.pad.Iso10126;
});

/***/ }),

/***/ "./node_modules/crypto-js/pad-iso97971.js":
/*!************************************************!*\
  !*** ./node_modules/crypto-js/pad-iso97971.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
  } else {}
})(this, function (CryptoJS) {
  /**
   * ISO/IEC 9797-1 Padding Method 2.
   */
  CryptoJS.pad.Iso97971 = {
    pad: function (data, blockSize) {
      // Add 0x80 byte
      data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1)); // Zero pad the rest

      CryptoJS.pad.ZeroPadding.pad(data, blockSize);
    },
    unpad: function (data) {
      // Remove zero padding
      CryptoJS.pad.ZeroPadding.unpad(data); // Remove one more byte -- the 0x80 byte

      data.sigBytes--;
    }
  };
  return CryptoJS.pad.Iso97971;
});

/***/ }),

/***/ "./node_modules/crypto-js/pad-nopadding.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-js/pad-nopadding.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
  } else {}
})(this, function (CryptoJS) {
  /**
   * A noop padding strategy.
   */
  CryptoJS.pad.NoPadding = {
    pad: function () {},
    unpad: function () {}
  };
  return CryptoJS.pad.NoPadding;
});

/***/ }),

/***/ "./node_modules/crypto-js/pad-zeropadding.js":
/*!***************************************************!*\
  !*** ./node_modules/crypto-js/pad-zeropadding.js ***!
  \***************************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
  } else {}
})(this, function (CryptoJS) {
  /**
   * Zero padding strategy.
   */
  CryptoJS.pad.ZeroPadding = {
    pad: function (data, blockSize) {
      // Shortcut
      var blockSizeBytes = blockSize * 4; // Pad

      data.clamp();
      data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
    },
    unpad: function (data) {
      // Shortcut
      var dataWords = data.words; // Unpad

      var i = data.sigBytes - 1;

      for (var i = data.sigBytes - 1; i >= 0; i--) {
        if (dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 0xff) {
          data.sigBytes = i + 1;
          break;
        }
      }
    }
  };
  return CryptoJS.pad.ZeroPadding;
});

/***/ }),

/***/ "./node_modules/crypto-js/pbkdf2.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/pbkdf2.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./sha1 */ "./node_modules/crypto-js/sha1.js"), __webpack_require__(/*! ./hmac */ "./node_modules/crypto-js/hmac.js"));
  } else {}
})(this, function (CryptoJS) {
  (function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var WordArray = C_lib.WordArray;
    var C_algo = C.algo;
    var SHA1 = C_algo.SHA1;
    var HMAC = C_algo.HMAC;
    /**
     * Password-Based Key Derivation Function 2 algorithm.
     */

    var PBKDF2 = C_algo.PBKDF2 = Base.extend({
      /**
       * Configuration options.
       *
       * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
       * @property {Hasher} hasher The hasher to use. Default: SHA1
       * @property {number} iterations The number of iterations to perform. Default: 1
       */
      cfg: Base.extend({
        keySize: 128 / 32,
        hasher: SHA1,
        iterations: 1
      }),

      /**
       * Initializes a newly created key derivation function.
       *
       * @param {Object} cfg (Optional) The configuration options to use for the derivation.
       *
       * @example
       *
       *     var kdf = CryptoJS.algo.PBKDF2.create();
       *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
       *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
       */
      init: function (cfg) {
        this.cfg = this.cfg.extend(cfg);
      },

      /**
       * Computes the Password-Based Key Derivation Function 2.
       *
       * @param {WordArray|string} password The password.
       * @param {WordArray|string} salt A salt.
       *
       * @return {WordArray} The derived key.
       *
       * @example
       *
       *     var key = kdf.compute(password, salt);
       */
      compute: function (password, salt) {
        // Shortcut
        var cfg = this.cfg; // Init HMAC

        var hmac = HMAC.create(cfg.hasher, password); // Initial values

        var derivedKey = WordArray.create();
        var blockIndex = WordArray.create([0x00000001]); // Shortcuts

        var derivedKeyWords = derivedKey.words;
        var blockIndexWords = blockIndex.words;
        var keySize = cfg.keySize;
        var iterations = cfg.iterations; // Generate key

        while (derivedKeyWords.length < keySize) {
          var block = hmac.update(salt).finalize(blockIndex);
          hmac.reset(); // Shortcuts

          var blockWords = block.words;
          var blockWordsLength = blockWords.length; // Iterations

          var intermediate = block;

          for (var i = 1; i < iterations; i++) {
            intermediate = hmac.finalize(intermediate);
            hmac.reset(); // Shortcut

            var intermediateWords = intermediate.words; // XOR intermediate with block

            for (var j = 0; j < blockWordsLength; j++) {
              blockWords[j] ^= intermediateWords[j];
            }
          }

          derivedKey.concat(block);
          blockIndexWords[0]++;
        }

        derivedKey.sigBytes = keySize * 4;
        return derivedKey;
      }
    });
    /**
     * Computes the Password-Based Key Derivation Function 2.
     *
     * @param {WordArray|string} password The password.
     * @param {WordArray|string} salt A salt.
     * @param {Object} cfg (Optional) The configuration options to use for this computation.
     *
     * @return {WordArray} The derived key.
     *
     * @static
     *
     * @example
     *
     *     var key = CryptoJS.PBKDF2(password, salt);
     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
     *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
     */

    C.PBKDF2 = function (password, salt, cfg) {
      return PBKDF2.create(cfg).compute(password, salt);
    };
  })();

  return CryptoJS.PBKDF2;
});

/***/ }),

/***/ "./node_modules/crypto-js/rabbit-legacy.js":
/*!*************************************************!*\
  !*** ./node_modules/crypto-js/rabbit-legacy.js ***!
  \*************************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
  } else {}
})(this, function (CryptoJS) {
  (function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var StreamCipher = C_lib.StreamCipher;
    var C_algo = C.algo; // Reusable objects

    var S = [];
    var C_ = [];
    var G = [];
    /**
     * Rabbit stream cipher algorithm.
     *
     * This is a legacy version that neglected to convert the key to little-endian.
     * This error doesn't affect the cipher's security,
     * but it does affect its compatibility with other implementations.
     */

    var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
      _doReset: function () {
        // Shortcuts
        var K = this._key.words;
        var iv = this.cfg.iv; // Generate initial state values

        var X = this._X = [K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16]; // Generate initial counter values

        var C = this._C = [K[2] << 16 | K[2] >>> 16, K[0] & 0xffff0000 | K[1] & 0x0000ffff, K[3] << 16 | K[3] >>> 16, K[1] & 0xffff0000 | K[2] & 0x0000ffff, K[0] << 16 | K[0] >>> 16, K[2] & 0xffff0000 | K[3] & 0x0000ffff, K[1] << 16 | K[1] >>> 16, K[3] & 0xffff0000 | K[0] & 0x0000ffff]; // Carry bit

        this._b = 0; // Iterate the system four times

        for (var i = 0; i < 4; i++) {
          nextState.call(this);
        } // Modify the counters


        for (var i = 0; i < 8; i++) {
          C[i] ^= X[i + 4 & 7];
        } // IV setup


        if (iv) {
          // Shortcuts
          var IV = iv.words;
          var IV_0 = IV[0];
          var IV_1 = IV[1]; // Generate four subvectors

          var i0 = (IV_0 << 8 | IV_0 >>> 24) & 0x00ff00ff | (IV_0 << 24 | IV_0 >>> 8) & 0xff00ff00;
          var i2 = (IV_1 << 8 | IV_1 >>> 24) & 0x00ff00ff | (IV_1 << 24 | IV_1 >>> 8) & 0xff00ff00;
          var i1 = i0 >>> 16 | i2 & 0xffff0000;
          var i3 = i2 << 16 | i0 & 0x0000ffff; // Modify counter values

          C[0] ^= i0;
          C[1] ^= i1;
          C[2] ^= i2;
          C[3] ^= i3;
          C[4] ^= i0;
          C[5] ^= i1;
          C[6] ^= i2;
          C[7] ^= i3; // Iterate the system four times

          for (var i = 0; i < 4; i++) {
            nextState.call(this);
          }
        }
      },
      _doProcessBlock: function (M, offset) {
        // Shortcut
        var X = this._X; // Iterate the system

        nextState.call(this); // Generate four keystream words

        S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
        S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
        S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
        S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;

        for (var i = 0; i < 4; i++) {
          // Swap endian
          S[i] = (S[i] << 8 | S[i] >>> 24) & 0x00ff00ff | (S[i] << 24 | S[i] >>> 8) & 0xff00ff00; // Encrypt

          M[offset + i] ^= S[i];
        }
      },
      blockSize: 128 / 32,
      ivSize: 64 / 32
    });

    function nextState() {
      // Shortcuts
      var X = this._X;
      var C = this._C; // Save old counter values

      for (var i = 0; i < 8; i++) {
        C_[i] = C[i];
      } // Calculate new counter values


      C[0] = C[0] + 0x4d34d34d + this._b | 0;
      C[1] = C[1] + 0xd34d34d3 + (C[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
      C[2] = C[2] + 0x34d34d34 + (C[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
      C[3] = C[3] + 0x4d34d34d + (C[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
      C[4] = C[4] + 0xd34d34d3 + (C[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
      C[5] = C[5] + 0x34d34d34 + (C[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
      C[6] = C[6] + 0x4d34d34d + (C[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
      C[7] = C[7] + 0xd34d34d3 + (C[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
      this._b = C[7] >>> 0 < C_[7] >>> 0 ? 1 : 0; // Calculate the g-values

      for (var i = 0; i < 8; i++) {
        var gx = X[i] + C[i]; // Construct high and low argument for squaring

        var ga = gx & 0xffff;
        var gb = gx >>> 16; // Calculate high and low result of squaring

        var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
        var gl = ((gx & 0xffff0000) * gx | 0) + ((gx & 0x0000ffff) * gx | 0); // High XOR low

        G[i] = gh ^ gl;
      } // Calculate new state values


      X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
      X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
      X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
      X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
      X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
      X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
      X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
      X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
    }
    /**
     * Shortcut functions to the cipher's object interface.
     *
     * @example
     *
     *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);
     *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);
     */


    C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
  })();

  return CryptoJS.RabbitLegacy;
});

/***/ }),

/***/ "./node_modules/crypto-js/rabbit.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/rabbit.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
  } else {}
})(this, function (CryptoJS) {
  (function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var StreamCipher = C_lib.StreamCipher;
    var C_algo = C.algo; // Reusable objects

    var S = [];
    var C_ = [];
    var G = [];
    /**
     * Rabbit stream cipher algorithm
     */

    var Rabbit = C_algo.Rabbit = StreamCipher.extend({
      _doReset: function () {
        // Shortcuts
        var K = this._key.words;
        var iv = this.cfg.iv; // Swap endian

        for (var i = 0; i < 4; i++) {
          K[i] = (K[i] << 8 | K[i] >>> 24) & 0x00ff00ff | (K[i] << 24 | K[i] >>> 8) & 0xff00ff00;
        } // Generate initial state values


        var X = this._X = [K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16]; // Generate initial counter values

        var C = this._C = [K[2] << 16 | K[2] >>> 16, K[0] & 0xffff0000 | K[1] & 0x0000ffff, K[3] << 16 | K[3] >>> 16, K[1] & 0xffff0000 | K[2] & 0x0000ffff, K[0] << 16 | K[0] >>> 16, K[2] & 0xffff0000 | K[3] & 0x0000ffff, K[1] << 16 | K[1] >>> 16, K[3] & 0xffff0000 | K[0] & 0x0000ffff]; // Carry bit

        this._b = 0; // Iterate the system four times

        for (var i = 0; i < 4; i++) {
          nextState.call(this);
        } // Modify the counters


        for (var i = 0; i < 8; i++) {
          C[i] ^= X[i + 4 & 7];
        } // IV setup


        if (iv) {
          // Shortcuts
          var IV = iv.words;
          var IV_0 = IV[0];
          var IV_1 = IV[1]; // Generate four subvectors

          var i0 = (IV_0 << 8 | IV_0 >>> 24) & 0x00ff00ff | (IV_0 << 24 | IV_0 >>> 8) & 0xff00ff00;
          var i2 = (IV_1 << 8 | IV_1 >>> 24) & 0x00ff00ff | (IV_1 << 24 | IV_1 >>> 8) & 0xff00ff00;
          var i1 = i0 >>> 16 | i2 & 0xffff0000;
          var i3 = i2 << 16 | i0 & 0x0000ffff; // Modify counter values

          C[0] ^= i0;
          C[1] ^= i1;
          C[2] ^= i2;
          C[3] ^= i3;
          C[4] ^= i0;
          C[5] ^= i1;
          C[6] ^= i2;
          C[7] ^= i3; // Iterate the system four times

          for (var i = 0; i < 4; i++) {
            nextState.call(this);
          }
        }
      },
      _doProcessBlock: function (M, offset) {
        // Shortcut
        var X = this._X; // Iterate the system

        nextState.call(this); // Generate four keystream words

        S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
        S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
        S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
        S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;

        for (var i = 0; i < 4; i++) {
          // Swap endian
          S[i] = (S[i] << 8 | S[i] >>> 24) & 0x00ff00ff | (S[i] << 24 | S[i] >>> 8) & 0xff00ff00; // Encrypt

          M[offset + i] ^= S[i];
        }
      },
      blockSize: 128 / 32,
      ivSize: 64 / 32
    });

    function nextState() {
      // Shortcuts
      var X = this._X;
      var C = this._C; // Save old counter values

      for (var i = 0; i < 8; i++) {
        C_[i] = C[i];
      } // Calculate new counter values


      C[0] = C[0] + 0x4d34d34d + this._b | 0;
      C[1] = C[1] + 0xd34d34d3 + (C[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
      C[2] = C[2] + 0x34d34d34 + (C[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
      C[3] = C[3] + 0x4d34d34d + (C[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
      C[4] = C[4] + 0xd34d34d3 + (C[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
      C[5] = C[5] + 0x34d34d34 + (C[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
      C[6] = C[6] + 0x4d34d34d + (C[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
      C[7] = C[7] + 0xd34d34d3 + (C[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
      this._b = C[7] >>> 0 < C_[7] >>> 0 ? 1 : 0; // Calculate the g-values

      for (var i = 0; i < 8; i++) {
        var gx = X[i] + C[i]; // Construct high and low argument for squaring

        var ga = gx & 0xffff;
        var gb = gx >>> 16; // Calculate high and low result of squaring

        var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
        var gl = ((gx & 0xffff0000) * gx | 0) + ((gx & 0x0000ffff) * gx | 0); // High XOR low

        G[i] = gh ^ gl;
      } // Calculate new state values


      X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
      X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
      X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
      X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
      X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
      X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
      X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
      X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
    }
    /**
     * Shortcut functions to the cipher's object interface.
     *
     * @example
     *
     *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);
     *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);
     */


    C.Rabbit = StreamCipher._createHelper(Rabbit);
  })();

  return CryptoJS.Rabbit;
});

/***/ }),

/***/ "./node_modules/crypto-js/rc4.js":
/*!***************************************!*\
  !*** ./node_modules/crypto-js/rc4.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
  } else {}
})(this, function (CryptoJS) {
  (function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var StreamCipher = C_lib.StreamCipher;
    var C_algo = C.algo;
    /**
     * RC4 stream cipher algorithm.
     */

    var RC4 = C_algo.RC4 = StreamCipher.extend({
      _doReset: function () {
        // Shortcuts
        var key = this._key;
        var keyWords = key.words;
        var keySigBytes = key.sigBytes; // Init sbox

        var S = this._S = [];

        for (var i = 0; i < 256; i++) {
          S[i] = i;
        } // Key setup


        for (var i = 0, j = 0; i < 256; i++) {
          var keyByteIndex = i % keySigBytes;
          var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 0xff;
          j = (j + S[i] + keyByte) % 256; // Swap

          var t = S[i];
          S[i] = S[j];
          S[j] = t;
        } // Counters


        this._i = this._j = 0;
      },
      _doProcessBlock: function (M, offset) {
        M[offset] ^= generateKeystreamWord.call(this);
      },
      keySize: 256 / 32,
      ivSize: 0
    });

    function generateKeystreamWord() {
      // Shortcuts
      var S = this._S;
      var i = this._i;
      var j = this._j; // Generate keystream word

      var keystreamWord = 0;

      for (var n = 0; n < 4; n++) {
        i = (i + 1) % 256;
        j = (j + S[i]) % 256; // Swap

        var t = S[i];
        S[i] = S[j];
        S[j] = t;
        keystreamWord |= S[(S[i] + S[j]) % 256] << 24 - n * 8;
      } // Update counters


      this._i = i;
      this._j = j;
      return keystreamWord;
    }
    /**
     * Shortcut functions to the cipher's object interface.
     *
     * @example
     *
     *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);
     *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);
     */


    C.RC4 = StreamCipher._createHelper(RC4);
    /**
     * Modified RC4 stream cipher algorithm.
     */

    var RC4Drop = C_algo.RC4Drop = RC4.extend({
      /**
       * Configuration options.
       *
       * @property {number} drop The number of keystream words to drop. Default 192
       */
      cfg: RC4.cfg.extend({
        drop: 192
      }),
      _doReset: function () {
        RC4._doReset.call(this); // Drop


        for (var i = this.cfg.drop; i > 0; i--) {
          generateKeystreamWord.call(this);
        }
      }
    });
    /**
     * Shortcut functions to the cipher's object interface.
     *
     * @example
     *
     *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);
     *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);
     */

    C.RC4Drop = StreamCipher._createHelper(RC4Drop);
  })();

  return CryptoJS.RC4;
});

/***/ }),

/***/ "./node_modules/crypto-js/ripemd160.js":
/*!*********************************************!*\
  !*** ./node_modules/crypto-js/ripemd160.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
  } else {}
})(this, function (CryptoJS) {
  /** @preserve
  (c) 2012 by Cdric Mesnil. All rights reserved.
  	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
  	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
      - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
  	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
  (function (Math) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo; // Constants table

    var _zl = WordArray.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]);

    var _zr = WordArray.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]);

    var _sl = WordArray.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]);

    var _sr = WordArray.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]);

    var _hl = WordArray.create([0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);

    var _hr = WordArray.create([0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);
    /**
     * RIPEMD160 hash algorithm.
     */


    var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
      _doReset: function () {
        this._hash = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
      },
      _doProcessBlock: function (M, offset) {
        // Swap endian
        for (var i = 0; i < 16; i++) {
          // Shortcuts
          var offset_i = offset + i;
          var M_offset_i = M[offset_i]; // Swap

          M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 0x00ff00ff | (M_offset_i << 24 | M_offset_i >>> 8) & 0xff00ff00;
        } // Shortcut


        var H = this._hash.words;
        var hl = _hl.words;
        var hr = _hr.words;
        var zl = _zl.words;
        var zr = _zr.words;
        var sl = _sl.words;
        var sr = _sr.words; // Working variables

        var al, bl, cl, dl, el;
        var ar, br, cr, dr, er;
        ar = al = H[0];
        br = bl = H[1];
        cr = cl = H[2];
        dr = dl = H[3];
        er = el = H[4]; // Computation

        var t;

        for (var i = 0; i < 80; i += 1) {
          t = al + M[offset + zl[i]] | 0;

          if (i < 16) {
            t += f1(bl, cl, dl) + hl[0];
          } else if (i < 32) {
            t += f2(bl, cl, dl) + hl[1];
          } else if (i < 48) {
            t += f3(bl, cl, dl) + hl[2];
          } else if (i < 64) {
            t += f4(bl, cl, dl) + hl[3];
          } else {
            // if (i<80) {
            t += f5(bl, cl, dl) + hl[4];
          }

          t = t | 0;
          t = rotl(t, sl[i]);
          t = t + el | 0;
          al = el;
          el = dl;
          dl = rotl(cl, 10);
          cl = bl;
          bl = t;
          t = ar + M[offset + zr[i]] | 0;

          if (i < 16) {
            t += f5(br, cr, dr) + hr[0];
          } else if (i < 32) {
            t += f4(br, cr, dr) + hr[1];
          } else if (i < 48) {
            t += f3(br, cr, dr) + hr[2];
          } else if (i < 64) {
            t += f2(br, cr, dr) + hr[3];
          } else {
            // if (i<80) {
            t += f1(br, cr, dr) + hr[4];
          }

          t = t | 0;
          t = rotl(t, sr[i]);
          t = t + er | 0;
          ar = er;
          er = dr;
          dr = rotl(cr, 10);
          cr = br;
          br = t;
        } // Intermediate hash value


        t = H[1] + cl + dr | 0;
        H[1] = H[2] + dl + er | 0;
        H[2] = H[3] + el + ar | 0;
        H[3] = H[4] + al + br | 0;
        H[4] = H[0] + bl + cr | 0;
        H[0] = t;
      },
      _doFinalize: function () {
        // Shortcuts
        var data = this._data;
        var dataWords = data.words;
        var nBitsTotal = this._nDataBytes * 8;
        var nBitsLeft = data.sigBytes * 8; // Add padding

        dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 0x00ff00ff | (nBitsTotal << 24 | nBitsTotal >>> 8) & 0xff00ff00;
        data.sigBytes = (dataWords.length + 1) * 4; // Hash final blocks

        this._process(); // Shortcuts


        var hash = this._hash;
        var H = hash.words; // Swap endian

        for (var i = 0; i < 5; i++) {
          // Shortcut
          var H_i = H[i]; // Swap

          H[i] = (H_i << 8 | H_i >>> 24) & 0x00ff00ff | (H_i << 24 | H_i >>> 8) & 0xff00ff00;
        } // Return final computed hash


        return hash;
      },
      clone: function () {
        var clone = Hasher.clone.call(this);
        clone._hash = this._hash.clone();
        return clone;
      }
    });

    function f1(x, y, z) {
      return x ^ y ^ z;
    }

    function f2(x, y, z) {
      return x & y | ~x & z;
    }

    function f3(x, y, z) {
      return (x | ~y) ^ z;
    }

    function f4(x, y, z) {
      return x & z | y & ~z;
    }

    function f5(x, y, z) {
      return x ^ (y | ~z);
    }

    function rotl(x, n) {
      return x << n | x >>> 32 - n;
    }
    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.RIPEMD160('message');
     *     var hash = CryptoJS.RIPEMD160(wordArray);
     */


    C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
     */

    C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
  })(Math);

  return CryptoJS.RIPEMD160;
});

/***/ }),

/***/ "./node_modules/crypto-js/sha1.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/sha1.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
  } else {}
})(this, function (CryptoJS) {
  (function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo; // Reusable object

    var W = [];
    /**
     * SHA-1 hash algorithm.
     */

    var SHA1 = C_algo.SHA1 = Hasher.extend({
      _doReset: function () {
        this._hash = new WordArray.init([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]);
      },
      _doProcessBlock: function (M, offset) {
        // Shortcut
        var H = this._hash.words; // Working variables

        var a = H[0];
        var b = H[1];
        var c = H[2];
        var d = H[3];
        var e = H[4]; // Computation

        for (var i = 0; i < 80; i++) {
          if (i < 16) {
            W[i] = M[offset + i] | 0;
          } else {
            var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
            W[i] = n << 1 | n >>> 31;
          }

          var t = (a << 5 | a >>> 27) + e + W[i];

          if (i < 20) {
            t += (b & c | ~b & d) + 0x5a827999;
          } else if (i < 40) {
            t += (b ^ c ^ d) + 0x6ed9eba1;
          } else if (i < 60) {
            t += (b & c | b & d | c & d) - 0x70e44324;
          } else
            /* if (i < 80) */
            {
              t += (b ^ c ^ d) - 0x359d3e2a;
            }

          e = d;
          d = c;
          c = b << 30 | b >>> 2;
          b = a;
          a = t;
        } // Intermediate hash value


        H[0] = H[0] + a | 0;
        H[1] = H[1] + b | 0;
        H[2] = H[2] + c | 0;
        H[3] = H[3] + d | 0;
        H[4] = H[4] + e | 0;
      },
      _doFinalize: function () {
        // Shortcuts
        var data = this._data;
        var dataWords = data.words;
        var nBitsTotal = this._nDataBytes * 8;
        var nBitsLeft = data.sigBytes * 8; // Add padding

        dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
        data.sigBytes = dataWords.length * 4; // Hash final blocks

        this._process(); // Return final computed hash


        return this._hash;
      },
      clone: function () {
        var clone = Hasher.clone.call(this);
        clone._hash = this._hash.clone();
        return clone;
      }
    });
    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA1('message');
     *     var hash = CryptoJS.SHA1(wordArray);
     */

    C.SHA1 = Hasher._createHelper(SHA1);
    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA1(message, key);
     */

    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
  })();

  return CryptoJS.SHA1;
});

/***/ }),

/***/ "./node_modules/crypto-js/sha224.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/sha224.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./sha256 */ "./node_modules/crypto-js/sha256.js"));
  } else {}
})(this, function (CryptoJS) {
  (function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var C_algo = C.algo;
    var SHA256 = C_algo.SHA256;
    /**
     * SHA-224 hash algorithm.
     */

    var SHA224 = C_algo.SHA224 = SHA256.extend({
      _doReset: function () {
        this._hash = new WordArray.init([0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4]);
      },
      _doFinalize: function () {
        var hash = SHA256._doFinalize.call(this);

        hash.sigBytes -= 4;
        return hash;
      }
    });
    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA224('message');
     *     var hash = CryptoJS.SHA224(wordArray);
     */

    C.SHA224 = SHA256._createHelper(SHA224);
    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA224(message, key);
     */

    C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
  })();

  return CryptoJS.SHA224;
});

/***/ }),

/***/ "./node_modules/crypto-js/sha256.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/sha256.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
  } else {}
})(this, function (CryptoJS) {
  (function (Math) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_algo = C.algo; // Initialization and round constants tables

    var H = [];
    var K = []; // Compute constants

    (function () {
      function isPrime(n) {
        var sqrtN = Math.sqrt(n);

        for (var factor = 2; factor <= sqrtN; factor++) {
          if (!(n % factor)) {
            return false;
          }
        }

        return true;
      }

      function getFractionalBits(n) {
        return (n - (n | 0)) * 0x100000000 | 0;
      }

      var n = 2;
      var nPrime = 0;

      while (nPrime < 64) {
        if (isPrime(n)) {
          if (nPrime < 8) {
            H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
          }

          K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));
          nPrime++;
        }

        n++;
      }
    })(); // Reusable object


    var W = [];
    /**
     * SHA-256 hash algorithm.
     */

    var SHA256 = C_algo.SHA256 = Hasher.extend({
      _doReset: function () {
        this._hash = new WordArray.init(H.slice(0));
      },
      _doProcessBlock: function (M, offset) {
        // Shortcut
        var H = this._hash.words; // Working variables

        var a = H[0];
        var b = H[1];
        var c = H[2];
        var d = H[3];
        var e = H[4];
        var f = H[5];
        var g = H[6];
        var h = H[7]; // Computation

        for (var i = 0; i < 64; i++) {
          if (i < 16) {
            W[i] = M[offset + i] | 0;
          } else {
            var gamma0x = W[i - 15];
            var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
            var gamma1x = W[i - 2];
            var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
            W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
          }

          var ch = e & f ^ ~e & g;
          var maj = a & b ^ a & c ^ b & c;
          var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
          var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
          var t1 = h + sigma1 + ch + K[i] + W[i];
          var t2 = sigma0 + maj;
          h = g;
          g = f;
          f = e;
          e = d + t1 | 0;
          d = c;
          c = b;
          b = a;
          a = t1 + t2 | 0;
        } // Intermediate hash value


        H[0] = H[0] + a | 0;
        H[1] = H[1] + b | 0;
        H[2] = H[2] + c | 0;
        H[3] = H[3] + d | 0;
        H[4] = H[4] + e | 0;
        H[5] = H[5] + f | 0;
        H[6] = H[6] + g | 0;
        H[7] = H[7] + h | 0;
      },
      _doFinalize: function () {
        // Shortcuts
        var data = this._data;
        var dataWords = data.words;
        var nBitsTotal = this._nDataBytes * 8;
        var nBitsLeft = data.sigBytes * 8; // Add padding

        dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
        dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
        data.sigBytes = dataWords.length * 4; // Hash final blocks

        this._process(); // Return final computed hash


        return this._hash;
      },
      clone: function () {
        var clone = Hasher.clone.call(this);
        clone._hash = this._hash.clone();
        return clone;
      }
    });
    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA256('message');
     *     var hash = CryptoJS.SHA256(wordArray);
     */

    C.SHA256 = Hasher._createHelper(SHA256);
    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA256(message, key);
     */

    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
  })(Math);

  return CryptoJS.SHA256;
});

/***/ }),

/***/ "./node_modules/crypto-js/sha3.js":
/*!****************************************!*\
  !*** ./node_modules/crypto-js/sha3.js ***!
  \****************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./x64-core */ "./node_modules/crypto-js/x64-core.js"));
  } else {}
})(this, function (CryptoJS) {
  (function (Math) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var Hasher = C_lib.Hasher;
    var C_x64 = C.x64;
    var X64Word = C_x64.Word;
    var C_algo = C.algo; // Constants tables

    var RHO_OFFSETS = [];
    var PI_INDEXES = [];
    var ROUND_CONSTANTS = []; // Compute Constants

    (function () {
      // Compute rho offset constants
      var x = 1,
          y = 0;

      for (var t = 0; t < 24; t++) {
        RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
        var newX = y % 5;
        var newY = (2 * x + 3 * y) % 5;
        x = newX;
        y = newY;
      } // Compute pi index constants


      for (var x = 0; x < 5; x++) {
        for (var y = 0; y < 5; y++) {
          PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
        }
      } // Compute round constants


      var LFSR = 0x01;

      for (var i = 0; i < 24; i++) {
        var roundConstantMsw = 0;
        var roundConstantLsw = 0;

        for (var j = 0; j < 7; j++) {
          if (LFSR & 0x01) {
            var bitPosition = (1 << j) - 1;

            if (bitPosition < 32) {
              roundConstantLsw ^= 1 << bitPosition;
            } else
              /* if (bitPosition >= 32) */
              {
                roundConstantMsw ^= 1 << bitPosition - 32;
              }
          } // Compute next LFSR


          if (LFSR & 0x80) {
            // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
            LFSR = LFSR << 1 ^ 0x71;
          } else {
            LFSR <<= 1;
          }
        }

        ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
      }
    })(); // Reusable objects for temporary values


    var T = [];

    (function () {
      for (var i = 0; i < 25; i++) {
        T[i] = X64Word.create();
      }
    })();
    /**
     * SHA-3 hash algorithm.
     */


    var SHA3 = C_algo.SHA3 = Hasher.extend({
      /**
       * Configuration options.
       *
       * @property {number} outputLength
       *   The desired number of bits in the output hash.
       *   Only values permitted are: 224, 256, 384, 512.
       *   Default: 512
       */
      cfg: Hasher.cfg.extend({
        outputLength: 512
      }),
      _doReset: function () {
        var state = this._state = [];

        for (var i = 0; i < 25; i++) {
          state[i] = new X64Word.init();
        }

        this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
      },
      _doProcessBlock: function (M, offset) {
        // Shortcuts
        var state = this._state;
        var nBlockSizeLanes = this.blockSize / 2; // Absorb

        for (var i = 0; i < nBlockSizeLanes; i++) {
          // Shortcuts
          var M2i = M[offset + 2 * i];
          var M2i1 = M[offset + 2 * i + 1]; // Swap endian

          M2i = (M2i << 8 | M2i >>> 24) & 0x00ff00ff | (M2i << 24 | M2i >>> 8) & 0xff00ff00;
          M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 0x00ff00ff | (M2i1 << 24 | M2i1 >>> 8) & 0xff00ff00; // Absorb message into state

          var lane = state[i];
          lane.high ^= M2i1;
          lane.low ^= M2i;
        } // Rounds


        for (var round = 0; round < 24; round++) {
          // Theta
          for (var x = 0; x < 5; x++) {
            // Mix column lanes
            var tMsw = 0,
                tLsw = 0;

            for (var y = 0; y < 5; y++) {
              var lane = state[x + 5 * y];
              tMsw ^= lane.high;
              tLsw ^= lane.low;
            } // Temporary values


            var Tx = T[x];
            Tx.high = tMsw;
            Tx.low = tLsw;
          }

          for (var x = 0; x < 5; x++) {
            // Shortcuts
            var Tx4 = T[(x + 4) % 5];
            var Tx1 = T[(x + 1) % 5];
            var Tx1Msw = Tx1.high;
            var Tx1Lsw = Tx1.low; // Mix surrounding columns

            var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
            var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);

            for (var y = 0; y < 5; y++) {
              var lane = state[x + 5 * y];
              lane.high ^= tMsw;
              lane.low ^= tLsw;
            }
          } // Rho Pi


          for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
            var tMsw;
            var tLsw; // Shortcuts

            var lane = state[laneIndex];
            var laneMsw = lane.high;
            var laneLsw = lane.low;
            var rhoOffset = RHO_OFFSETS[laneIndex]; // Rotate lanes

            if (rhoOffset < 32) {
              tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
              tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
            } else
              /* if (rhoOffset >= 32) */
              {
                tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
              } // Transpose lanes


            var TPiLane = T[PI_INDEXES[laneIndex]];
            TPiLane.high = tMsw;
            TPiLane.low = tLsw;
          } // Rho pi at x = y = 0


          var T0 = T[0];
          var state0 = state[0];
          T0.high = state0.high;
          T0.low = state0.low; // Chi

          for (var x = 0; x < 5; x++) {
            for (var y = 0; y < 5; y++) {
              // Shortcuts
              var laneIndex = x + 5 * y;
              var lane = state[laneIndex];
              var TLane = T[laneIndex];
              var Tx1Lane = T[(x + 1) % 5 + 5 * y];
              var Tx2Lane = T[(x + 2) % 5 + 5 * y]; // Mix rows

              lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
              lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
            }
          } // Iota


          var lane = state[0];
          var roundConstant = ROUND_CONSTANTS[round];
          lane.high ^= roundConstant.high;
          lane.low ^= roundConstant.low;
        }
      },
      _doFinalize: function () {
        // Shortcuts
        var data = this._data;
        var dataWords = data.words;
        var nBitsTotal = this._nDataBytes * 8;
        var nBitsLeft = data.sigBytes * 8;
        var blockSizeBits = this.blockSize * 32; // Add padding

        dataWords[nBitsLeft >>> 5] |= 0x1 << 24 - nBitsLeft % 32;
        dataWords[(Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 0x80;
        data.sigBytes = dataWords.length * 4; // Hash final blocks

        this._process(); // Shortcuts


        var state = this._state;
        var outputLengthBytes = this.cfg.outputLength / 8;
        var outputLengthLanes = outputLengthBytes / 8; // Squeeze

        var hashWords = [];

        for (var i = 0; i < outputLengthLanes; i++) {
          // Shortcuts
          var lane = state[i];
          var laneMsw = lane.high;
          var laneLsw = lane.low; // Swap endian

          laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 0x00ff00ff | (laneMsw << 24 | laneMsw >>> 8) & 0xff00ff00;
          laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 0x00ff00ff | (laneLsw << 24 | laneLsw >>> 8) & 0xff00ff00; // Squeeze state to retrieve hash

          hashWords.push(laneLsw);
          hashWords.push(laneMsw);
        } // Return final computed hash


        return new WordArray.init(hashWords, outputLengthBytes);
      },
      clone: function () {
        var clone = Hasher.clone.call(this);

        var state = clone._state = this._state.slice(0);

        for (var i = 0; i < 25; i++) {
          state[i] = state[i].clone();
        }

        return clone;
      }
    });
    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA3('message');
     *     var hash = CryptoJS.SHA3(wordArray);
     */

    C.SHA3 = Hasher._createHelper(SHA3);
    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA3(message, key);
     */

    C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
  })(Math);

  return CryptoJS.SHA3;
});

/***/ }),

/***/ "./node_modules/crypto-js/sha384.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/sha384.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./x64-core */ "./node_modules/crypto-js/x64-core.js"), __webpack_require__(/*! ./sha512 */ "./node_modules/crypto-js/sha512.js"));
  } else {}
})(this, function (CryptoJS) {
  (function () {
    // Shortcuts
    var C = CryptoJS;
    var C_x64 = C.x64;
    var X64Word = C_x64.Word;
    var X64WordArray = C_x64.WordArray;
    var C_algo = C.algo;
    var SHA512 = C_algo.SHA512;
    /**
     * SHA-384 hash algorithm.
     */

    var SHA384 = C_algo.SHA384 = SHA512.extend({
      _doReset: function () {
        this._hash = new X64WordArray.init([new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507), new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939), new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511), new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)]);
      },
      _doFinalize: function () {
        var hash = SHA512._doFinalize.call(this);

        hash.sigBytes -= 16;
        return hash;
      }
    });
    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA384('message');
     *     var hash = CryptoJS.SHA384(wordArray);
     */

    C.SHA384 = SHA512._createHelper(SHA384);
    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA384(message, key);
     */

    C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
  })();

  return CryptoJS.SHA384;
});

/***/ }),

/***/ "./node_modules/crypto-js/sha512.js":
/*!******************************************!*\
  !*** ./node_modules/crypto-js/sha512.js ***!
  \******************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./x64-core */ "./node_modules/crypto-js/x64-core.js"));
  } else {}
})(this, function (CryptoJS) {
  (function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Hasher = C_lib.Hasher;
    var C_x64 = C.x64;
    var X64Word = C_x64.Word;
    var X64WordArray = C_x64.WordArray;
    var C_algo = C.algo;

    function X64Word_create() {
      return X64Word.create.apply(X64Word, arguments);
    } // Constants


    var K = [X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd), X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc), X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019), X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118), X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe), X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2), X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1), X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694), X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3), X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65), X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483), X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5), X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210), X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4), X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725), X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70), X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926), X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df), X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8), X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b), X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001), X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30), X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910), X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8), X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53), X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8), X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb), X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3), X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60), X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec), X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9), X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b), X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207), X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178), X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6), X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b), X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493), X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c), X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a), X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)]; // Reusable objects

    var W = [];

    (function () {
      for (var i = 0; i < 80; i++) {
        W[i] = X64Word_create();
      }
    })();
    /**
     * SHA-512 hash algorithm.
     */


    var SHA512 = C_algo.SHA512 = Hasher.extend({
      _doReset: function () {
        this._hash = new X64WordArray.init([new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b), new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1), new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f), new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)]);
      },
      _doProcessBlock: function (M, offset) {
        // Shortcuts
        var H = this._hash.words;
        var H0 = H[0];
        var H1 = H[1];
        var H2 = H[2];
        var H3 = H[3];
        var H4 = H[4];
        var H5 = H[5];
        var H6 = H[6];
        var H7 = H[7];
        var H0h = H0.high;
        var H0l = H0.low;
        var H1h = H1.high;
        var H1l = H1.low;
        var H2h = H2.high;
        var H2l = H2.low;
        var H3h = H3.high;
        var H3l = H3.low;
        var H4h = H4.high;
        var H4l = H4.low;
        var H5h = H5.high;
        var H5l = H5.low;
        var H6h = H6.high;
        var H6l = H6.low;
        var H7h = H7.high;
        var H7l = H7.low; // Working variables

        var ah = H0h;
        var al = H0l;
        var bh = H1h;
        var bl = H1l;
        var ch = H2h;
        var cl = H2l;
        var dh = H3h;
        var dl = H3l;
        var eh = H4h;
        var el = H4l;
        var fh = H5h;
        var fl = H5l;
        var gh = H6h;
        var gl = H6l;
        var hh = H7h;
        var hl = H7l; // Rounds

        for (var i = 0; i < 80; i++) {
          var Wil;
          var Wih; // Shortcut

          var Wi = W[i]; // Extend message

          if (i < 16) {
            Wih = Wi.high = M[offset + i * 2] | 0;
            Wil = Wi.low = M[offset + i * 2 + 1] | 0;
          } else {
            // Gamma0
            var gamma0x = W[i - 15];
            var gamma0xh = gamma0x.high;
            var gamma0xl = gamma0x.low;
            var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
            var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25); // Gamma1

            var gamma1x = W[i - 2];
            var gamma1xh = gamma1x.high;
            var gamma1xl = gamma1x.low;
            var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
            var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26); // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]

            var Wi7 = W[i - 7];
            var Wi7h = Wi7.high;
            var Wi7l = Wi7.low;
            var Wi16 = W[i - 16];
            var Wi16h = Wi16.high;
            var Wi16l = Wi16.low;
            Wil = gamma0l + Wi7l;
            Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
            Wil = Wil + gamma1l;
            Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
            Wil = Wil + Wi16l;
            Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
            Wi.high = Wih;
            Wi.low = Wil;
          }

          var chh = eh & fh ^ ~eh & gh;
          var chl = el & fl ^ ~el & gl;
          var majh = ah & bh ^ ah & ch ^ bh & ch;
          var majl = al & bl ^ al & cl ^ bl & cl;
          var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
          var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
          var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
          var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9); // t1 = h + sigma1 + ch + K[i] + W[i]

          var Ki = K[i];
          var Kih = Ki.high;
          var Kil = Ki.low;
          var t1l = hl + sigma1l;
          var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
          var t1l = t1l + chl;
          var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
          var t1l = t1l + Kil;
          var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
          var t1l = t1l + Wil;
          var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0); // t2 = sigma0 + maj

          var t2l = sigma0l + majl;
          var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0); // Update working variables

          hh = gh;
          hl = gl;
          gh = fh;
          gl = fl;
          fh = eh;
          fl = el;
          el = dl + t1l | 0;
          eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
          dh = ch;
          dl = cl;
          ch = bh;
          cl = bl;
          bh = ah;
          bl = al;
          al = t1l + t2l | 0;
          ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
        } // Intermediate hash value


        H0l = H0.low = H0l + al;
        H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
        H1l = H1.low = H1l + bl;
        H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
        H2l = H2.low = H2l + cl;
        H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
        H3l = H3.low = H3l + dl;
        H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
        H4l = H4.low = H4l + el;
        H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
        H5l = H5.low = H5l + fl;
        H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
        H6l = H6.low = H6l + gl;
        H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
        H7l = H7.low = H7l + hl;
        H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
      },
      _doFinalize: function () {
        // Shortcuts
        var data = this._data;
        var dataWords = data.words;
        var nBitsTotal = this._nDataBytes * 8;
        var nBitsLeft = data.sigBytes * 8; // Add padding

        dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
        dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
        dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
        data.sigBytes = dataWords.length * 4; // Hash final blocks

        this._process(); // Convert hash to 32-bit word array before returning


        var hash = this._hash.toX32(); // Return final computed hash


        return hash;
      },
      clone: function () {
        var clone = Hasher.clone.call(this);
        clone._hash = this._hash.clone();
        return clone;
      },
      blockSize: 1024 / 32
    });
    /**
     * Shortcut function to the hasher's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     *
     * @return {WordArray} The hash.
     *
     * @static
     *
     * @example
     *
     *     var hash = CryptoJS.SHA512('message');
     *     var hash = CryptoJS.SHA512(wordArray);
     */

    C.SHA512 = Hasher._createHelper(SHA512);
    /**
     * Shortcut function to the HMAC's object interface.
     *
     * @param {WordArray|string} message The message to hash.
     * @param {WordArray|string} key The secret key.
     *
     * @return {WordArray} The HMAC.
     *
     * @static
     *
     * @example
     *
     *     var hmac = CryptoJS.HmacSHA512(message, key);
     */

    C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
  })();

  return CryptoJS.SHA512;
});

/***/ }),

/***/ "./node_modules/crypto-js/tripledes.js":
/*!*********************************************!*\
  !*** ./node_modules/crypto-js/tripledes.js ***!
  \*********************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory, undef) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"), __webpack_require__(/*! ./enc-base64 */ "./node_modules/crypto-js/enc-base64.js"), __webpack_require__(/*! ./md5 */ "./node_modules/crypto-js/md5.js"), __webpack_require__(/*! ./evpkdf */ "./node_modules/crypto-js/evpkdf.js"), __webpack_require__(/*! ./cipher-core */ "./node_modules/crypto-js/cipher-core.js"));
  } else {}
})(this, function (CryptoJS) {
  (function () {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var WordArray = C_lib.WordArray;
    var BlockCipher = C_lib.BlockCipher;
    var C_algo = C.algo; // Permuted Choice 1 constants

    var PC1 = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4]; // Permuted Choice 2 constants

    var PC2 = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32]; // Cumulative bit shift constants

    var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28]; // SBOXes and round permutation constants

    var SBOX_P = [{
      0x0: 0x808200,
      0x10000000: 0x8000,
      0x20000000: 0x808002,
      0x30000000: 0x2,
      0x40000000: 0x200,
      0x50000000: 0x808202,
      0x60000000: 0x800202,
      0x70000000: 0x800000,
      0x80000000: 0x202,
      0x90000000: 0x800200,
      0xa0000000: 0x8200,
      0xb0000000: 0x808000,
      0xc0000000: 0x8002,
      0xd0000000: 0x800002,
      0xe0000000: 0x0,
      0xf0000000: 0x8202,
      0x8000000: 0x0,
      0x18000000: 0x808202,
      0x28000000: 0x8202,
      0x38000000: 0x8000,
      0x48000000: 0x808200,
      0x58000000: 0x200,
      0x68000000: 0x808002,
      0x78000000: 0x2,
      0x88000000: 0x800200,
      0x98000000: 0x8200,
      0xa8000000: 0x808000,
      0xb8000000: 0x800202,
      0xc8000000: 0x800002,
      0xd8000000: 0x8002,
      0xe8000000: 0x202,
      0xf8000000: 0x800000,
      0x1: 0x8000,
      0x10000001: 0x2,
      0x20000001: 0x808200,
      0x30000001: 0x800000,
      0x40000001: 0x808002,
      0x50000001: 0x8200,
      0x60000001: 0x200,
      0x70000001: 0x800202,
      0x80000001: 0x808202,
      0x90000001: 0x808000,
      0xa0000001: 0x800002,
      0xb0000001: 0x8202,
      0xc0000001: 0x202,
      0xd0000001: 0x800200,
      0xe0000001: 0x8002,
      0xf0000001: 0x0,
      0x8000001: 0x808202,
      0x18000001: 0x808000,
      0x28000001: 0x800000,
      0x38000001: 0x200,
      0x48000001: 0x8000,
      0x58000001: 0x800002,
      0x68000001: 0x2,
      0x78000001: 0x8202,
      0x88000001: 0x8002,
      0x98000001: 0x800202,
      0xa8000001: 0x202,
      0xb8000001: 0x808200,
      0xc8000001: 0x800200,
      0xd8000001: 0x0,
      0xe8000001: 0x8200,
      0xf8000001: 0x808002
    }, {
      0x0: 0x40084010,
      0x1000000: 0x4000,
      0x2000000: 0x80000,
      0x3000000: 0x40080010,
      0x4000000: 0x40000010,
      0x5000000: 0x40084000,
      0x6000000: 0x40004000,
      0x7000000: 0x10,
      0x8000000: 0x84000,
      0x9000000: 0x40004010,
      0xa000000: 0x40000000,
      0xb000000: 0x84010,
      0xc000000: 0x80010,
      0xd000000: 0x0,
      0xe000000: 0x4010,
      0xf000000: 0x40080000,
      0x800000: 0x40004000,
      0x1800000: 0x84010,
      0x2800000: 0x10,
      0x3800000: 0x40004010,
      0x4800000: 0x40084010,
      0x5800000: 0x40000000,
      0x6800000: 0x80000,
      0x7800000: 0x40080010,
      0x8800000: 0x80010,
      0x9800000: 0x0,
      0xa800000: 0x4000,
      0xb800000: 0x40080000,
      0xc800000: 0x40000010,
      0xd800000: 0x84000,
      0xe800000: 0x40084000,
      0xf800000: 0x4010,
      0x10000000: 0x0,
      0x11000000: 0x40080010,
      0x12000000: 0x40004010,
      0x13000000: 0x40084000,
      0x14000000: 0x40080000,
      0x15000000: 0x10,
      0x16000000: 0x84010,
      0x17000000: 0x4000,
      0x18000000: 0x4010,
      0x19000000: 0x80000,
      0x1a000000: 0x80010,
      0x1b000000: 0x40000010,
      0x1c000000: 0x84000,
      0x1d000000: 0x40004000,
      0x1e000000: 0x40000000,
      0x1f000000: 0x40084010,
      0x10800000: 0x84010,
      0x11800000: 0x80000,
      0x12800000: 0x40080000,
      0x13800000: 0x4000,
      0x14800000: 0x40004000,
      0x15800000: 0x40084010,
      0x16800000: 0x10,
      0x17800000: 0x40000000,
      0x18800000: 0x40084000,
      0x19800000: 0x40000010,
      0x1a800000: 0x40004010,
      0x1b800000: 0x80010,
      0x1c800000: 0x0,
      0x1d800000: 0x4010,
      0x1e800000: 0x40080010,
      0x1f800000: 0x84000
    }, {
      0x0: 0x104,
      0x100000: 0x0,
      0x200000: 0x4000100,
      0x300000: 0x10104,
      0x400000: 0x10004,
      0x500000: 0x4000004,
      0x600000: 0x4010104,
      0x700000: 0x4010000,
      0x800000: 0x4000000,
      0x900000: 0x4010100,
      0xa00000: 0x10100,
      0xb00000: 0x4010004,
      0xc00000: 0x4000104,
      0xd00000: 0x10000,
      0xe00000: 0x4,
      0xf00000: 0x100,
      0x80000: 0x4010100,
      0x180000: 0x4010004,
      0x280000: 0x0,
      0x380000: 0x4000100,
      0x480000: 0x4000004,
      0x580000: 0x10000,
      0x680000: 0x10004,
      0x780000: 0x104,
      0x880000: 0x4,
      0x980000: 0x100,
      0xa80000: 0x4010000,
      0xb80000: 0x10104,
      0xc80000: 0x10100,
      0xd80000: 0x4000104,
      0xe80000: 0x4010104,
      0xf80000: 0x4000000,
      0x1000000: 0x4010100,
      0x1100000: 0x10004,
      0x1200000: 0x10000,
      0x1300000: 0x4000100,
      0x1400000: 0x100,
      0x1500000: 0x4010104,
      0x1600000: 0x4000004,
      0x1700000: 0x0,
      0x1800000: 0x4000104,
      0x1900000: 0x4000000,
      0x1a00000: 0x4,
      0x1b00000: 0x10100,
      0x1c00000: 0x4010000,
      0x1d00000: 0x104,
      0x1e00000: 0x10104,
      0x1f00000: 0x4010004,
      0x1080000: 0x4000000,
      0x1180000: 0x104,
      0x1280000: 0x4010100,
      0x1380000: 0x0,
      0x1480000: 0x10004,
      0x1580000: 0x4000100,
      0x1680000: 0x100,
      0x1780000: 0x4010004,
      0x1880000: 0x10000,
      0x1980000: 0x4010104,
      0x1a80000: 0x10104,
      0x1b80000: 0x4000004,
      0x1c80000: 0x4000104,
      0x1d80000: 0x4010000,
      0x1e80000: 0x4,
      0x1f80000: 0x10100
    }, {
      0x0: 0x80401000,
      0x10000: 0x80001040,
      0x20000: 0x401040,
      0x30000: 0x80400000,
      0x40000: 0x0,
      0x50000: 0x401000,
      0x60000: 0x80000040,
      0x70000: 0x400040,
      0x80000: 0x80000000,
      0x90000: 0x400000,
      0xa0000: 0x40,
      0xb0000: 0x80001000,
      0xc0000: 0x80400040,
      0xd0000: 0x1040,
      0xe0000: 0x1000,
      0xf0000: 0x80401040,
      0x8000: 0x80001040,
      0x18000: 0x40,
      0x28000: 0x80400040,
      0x38000: 0x80001000,
      0x48000: 0x401000,
      0x58000: 0x80401040,
      0x68000: 0x0,
      0x78000: 0x80400000,
      0x88000: 0x1000,
      0x98000: 0x80401000,
      0xa8000: 0x400000,
      0xb8000: 0x1040,
      0xc8000: 0x80000000,
      0xd8000: 0x400040,
      0xe8000: 0x401040,
      0xf8000: 0x80000040,
      0x100000: 0x400040,
      0x110000: 0x401000,
      0x120000: 0x80000040,
      0x130000: 0x0,
      0x140000: 0x1040,
      0x150000: 0x80400040,
      0x160000: 0x80401000,
      0x170000: 0x80001040,
      0x180000: 0x80401040,
      0x190000: 0x80000000,
      0x1a0000: 0x80400000,
      0x1b0000: 0x401040,
      0x1c0000: 0x80001000,
      0x1d0000: 0x400000,
      0x1e0000: 0x40,
      0x1f0000: 0x1000,
      0x108000: 0x80400000,
      0x118000: 0x80401040,
      0x128000: 0x0,
      0x138000: 0x401000,
      0x148000: 0x400040,
      0x158000: 0x80000000,
      0x168000: 0x80001040,
      0x178000: 0x40,
      0x188000: 0x80000040,
      0x198000: 0x1000,
      0x1a8000: 0x80001000,
      0x1b8000: 0x80400040,
      0x1c8000: 0x1040,
      0x1d8000: 0x80401000,
      0x1e8000: 0x400000,
      0x1f8000: 0x401040
    }, {
      0x0: 0x80,
      0x1000: 0x1040000,
      0x2000: 0x40000,
      0x3000: 0x20000000,
      0x4000: 0x20040080,
      0x5000: 0x1000080,
      0x6000: 0x21000080,
      0x7000: 0x40080,
      0x8000: 0x1000000,
      0x9000: 0x20040000,
      0xa000: 0x20000080,
      0xb000: 0x21040080,
      0xc000: 0x21040000,
      0xd000: 0x0,
      0xe000: 0x1040080,
      0xf000: 0x21000000,
      0x800: 0x1040080,
      0x1800: 0x21000080,
      0x2800: 0x80,
      0x3800: 0x1040000,
      0x4800: 0x40000,
      0x5800: 0x20040080,
      0x6800: 0x21040000,
      0x7800: 0x20000000,
      0x8800: 0x20040000,
      0x9800: 0x0,
      0xa800: 0x21040080,
      0xb800: 0x1000080,
      0xc800: 0x20000080,
      0xd800: 0x21000000,
      0xe800: 0x1000000,
      0xf800: 0x40080,
      0x10000: 0x40000,
      0x11000: 0x80,
      0x12000: 0x20000000,
      0x13000: 0x21000080,
      0x14000: 0x1000080,
      0x15000: 0x21040000,
      0x16000: 0x20040080,
      0x17000: 0x1000000,
      0x18000: 0x21040080,
      0x19000: 0x21000000,
      0x1a000: 0x1040000,
      0x1b000: 0x20040000,
      0x1c000: 0x40080,
      0x1d000: 0x20000080,
      0x1e000: 0x0,
      0x1f000: 0x1040080,
      0x10800: 0x21000080,
      0x11800: 0x1000000,
      0x12800: 0x1040000,
      0x13800: 0x20040080,
      0x14800: 0x20000000,
      0x15800: 0x1040080,
      0x16800: 0x80,
      0x17800: 0x21040000,
      0x18800: 0x40080,
      0x19800: 0x21040080,
      0x1a800: 0x0,
      0x1b800: 0x21000000,
      0x1c800: 0x1000080,
      0x1d800: 0x40000,
      0x1e800: 0x20040000,
      0x1f800: 0x20000080
    }, {
      0x0: 0x10000008,
      0x100: 0x2000,
      0x200: 0x10200000,
      0x300: 0x10202008,
      0x400: 0x10002000,
      0x500: 0x200000,
      0x600: 0x200008,
      0x700: 0x10000000,
      0x800: 0x0,
      0x900: 0x10002008,
      0xa00: 0x202000,
      0xb00: 0x8,
      0xc00: 0x10200008,
      0xd00: 0x202008,
      0xe00: 0x2008,
      0xf00: 0x10202000,
      0x80: 0x10200000,
      0x180: 0x10202008,
      0x280: 0x8,
      0x380: 0x200000,
      0x480: 0x202008,
      0x580: 0x10000008,
      0x680: 0x10002000,
      0x780: 0x2008,
      0x880: 0x200008,
      0x980: 0x2000,
      0xa80: 0x10002008,
      0xb80: 0x10200008,
      0xc80: 0x0,
      0xd80: 0x10202000,
      0xe80: 0x202000,
      0xf80: 0x10000000,
      0x1000: 0x10002000,
      0x1100: 0x10200008,
      0x1200: 0x10202008,
      0x1300: 0x2008,
      0x1400: 0x200000,
      0x1500: 0x10000000,
      0x1600: 0x10000008,
      0x1700: 0x202000,
      0x1800: 0x202008,
      0x1900: 0x0,
      0x1a00: 0x8,
      0x1b00: 0x10200000,
      0x1c00: 0x2000,
      0x1d00: 0x10002008,
      0x1e00: 0x10202000,
      0x1f00: 0x200008,
      0x1080: 0x8,
      0x1180: 0x202000,
      0x1280: 0x200000,
      0x1380: 0x10000008,
      0x1480: 0x10002000,
      0x1580: 0x2008,
      0x1680: 0x10202008,
      0x1780: 0x10200000,
      0x1880: 0x10202000,
      0x1980: 0x10200008,
      0x1a80: 0x2000,
      0x1b80: 0x202008,
      0x1c80: 0x200008,
      0x1d80: 0x0,
      0x1e80: 0x10000000,
      0x1f80: 0x10002008
    }, {
      0x0: 0x100000,
      0x10: 0x2000401,
      0x20: 0x400,
      0x30: 0x100401,
      0x40: 0x2100401,
      0x50: 0x0,
      0x60: 0x1,
      0x70: 0x2100001,
      0x80: 0x2000400,
      0x90: 0x100001,
      0xa0: 0x2000001,
      0xb0: 0x2100400,
      0xc0: 0x2100000,
      0xd0: 0x401,
      0xe0: 0x100400,
      0xf0: 0x2000000,
      0x8: 0x2100001,
      0x18: 0x0,
      0x28: 0x2000401,
      0x38: 0x2100400,
      0x48: 0x100000,
      0x58: 0x2000001,
      0x68: 0x2000000,
      0x78: 0x401,
      0x88: 0x100401,
      0x98: 0x2000400,
      0xa8: 0x2100000,
      0xb8: 0x100001,
      0xc8: 0x400,
      0xd8: 0x2100401,
      0xe8: 0x1,
      0xf8: 0x100400,
      0x100: 0x2000000,
      0x110: 0x100000,
      0x120: 0x2000401,
      0x130: 0x2100001,
      0x140: 0x100001,
      0x150: 0x2000400,
      0x160: 0x2100400,
      0x170: 0x100401,
      0x180: 0x401,
      0x190: 0x2100401,
      0x1a0: 0x100400,
      0x1b0: 0x1,
      0x1c0: 0x0,
      0x1d0: 0x2100000,
      0x1e0: 0x2000001,
      0x1f0: 0x400,
      0x108: 0x100400,
      0x118: 0x2000401,
      0x128: 0x2100001,
      0x138: 0x1,
      0x148: 0x2000000,
      0x158: 0x100000,
      0x168: 0x401,
      0x178: 0x2100400,
      0x188: 0x2000001,
      0x198: 0x2100000,
      0x1a8: 0x0,
      0x1b8: 0x2100401,
      0x1c8: 0x100401,
      0x1d8: 0x400,
      0x1e8: 0x2000400,
      0x1f8: 0x100001
    }, {
      0x0: 0x8000820,
      0x1: 0x20000,
      0x2: 0x8000000,
      0x3: 0x20,
      0x4: 0x20020,
      0x5: 0x8020820,
      0x6: 0x8020800,
      0x7: 0x800,
      0x8: 0x8020000,
      0x9: 0x8000800,
      0xa: 0x20800,
      0xb: 0x8020020,
      0xc: 0x820,
      0xd: 0x0,
      0xe: 0x8000020,
      0xf: 0x20820,
      0x80000000: 0x800,
      0x80000001: 0x8020820,
      0x80000002: 0x8000820,
      0x80000003: 0x8000000,
      0x80000004: 0x8020000,
      0x80000005: 0x20800,
      0x80000006: 0x20820,
      0x80000007: 0x20,
      0x80000008: 0x8000020,
      0x80000009: 0x820,
      0x8000000a: 0x20020,
      0x8000000b: 0x8020800,
      0x8000000c: 0x0,
      0x8000000d: 0x8020020,
      0x8000000e: 0x8000800,
      0x8000000f: 0x20000,
      0x10: 0x20820,
      0x11: 0x8020800,
      0x12: 0x20,
      0x13: 0x800,
      0x14: 0x8000800,
      0x15: 0x8000020,
      0x16: 0x8020020,
      0x17: 0x20000,
      0x18: 0x0,
      0x19: 0x20020,
      0x1a: 0x8020000,
      0x1b: 0x8000820,
      0x1c: 0x8020820,
      0x1d: 0x20800,
      0x1e: 0x820,
      0x1f: 0x8000000,
      0x80000010: 0x20000,
      0x80000011: 0x800,
      0x80000012: 0x8020020,
      0x80000013: 0x20820,
      0x80000014: 0x20,
      0x80000015: 0x8020000,
      0x80000016: 0x8000000,
      0x80000017: 0x8000820,
      0x80000018: 0x8020820,
      0x80000019: 0x8000020,
      0x8000001a: 0x8000800,
      0x8000001b: 0x0,
      0x8000001c: 0x20800,
      0x8000001d: 0x820,
      0x8000001e: 0x20020,
      0x8000001f: 0x8020800
    }]; // Masks that select the SBOX input

    var SBOX_MASK = [0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000, 0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f];
    /**
     * DES block cipher algorithm.
     */

    var DES = C_algo.DES = BlockCipher.extend({
      _doReset: function () {
        // Shortcuts
        var key = this._key;
        var keyWords = key.words; // Select 56 bits according to PC1

        var keyBits = [];

        for (var i = 0; i < 56; i++) {
          var keyBitPos = PC1[i] - 1;
          keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
        } // Assemble 16 subkeys


        var subKeys = this._subKeys = [];

        for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
          // Create subkey
          var subKey = subKeys[nSubKey] = []; // Shortcut

          var bitShift = BIT_SHIFTS[nSubKey]; // Select 48 bits according to PC2

          for (var i = 0; i < 24; i++) {
            // Select from the left 28 key bits
            subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6; // Select from the right 28 key bits

            subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
          } // Since each subkey is applied to an expanded 32-bit input,
          // the subkey can be broken into 8 values scaled to 32-bits,
          // which allows the key to be used without expansion


          subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;

          for (var i = 1; i < 7; i++) {
            subKey[i] = subKey[i] >>> (i - 1) * 4 + 3;
          }

          subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
        } // Compute inverse subkeys


        var invSubKeys = this._invSubKeys = [];

        for (var i = 0; i < 16; i++) {
          invSubKeys[i] = subKeys[15 - i];
        }
      },
      encryptBlock: function (M, offset) {
        this._doCryptBlock(M, offset, this._subKeys);
      },
      decryptBlock: function (M, offset) {
        this._doCryptBlock(M, offset, this._invSubKeys);
      },
      _doCryptBlock: function (M, offset, subKeys) {
        // Get input
        this._lBlock = M[offset];
        this._rBlock = M[offset + 1]; // Initial permutation

        exchangeLR.call(this, 4, 0x0f0f0f0f);
        exchangeLR.call(this, 16, 0x0000ffff);
        exchangeRL.call(this, 2, 0x33333333);
        exchangeRL.call(this, 8, 0x00ff00ff);
        exchangeLR.call(this, 1, 0x55555555); // Rounds

        for (var round = 0; round < 16; round++) {
          // Shortcuts
          var subKey = subKeys[round];
          var lBlock = this._lBlock;
          var rBlock = this._rBlock; // Feistel function

          var f = 0;

          for (var i = 0; i < 8; i++) {
            f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
          }

          this._lBlock = rBlock;
          this._rBlock = lBlock ^ f;
        } // Undo swap from last round


        var t = this._lBlock;
        this._lBlock = this._rBlock;
        this._rBlock = t; // Final permutation

        exchangeLR.call(this, 1, 0x55555555);
        exchangeRL.call(this, 8, 0x00ff00ff);
        exchangeRL.call(this, 2, 0x33333333);
        exchangeLR.call(this, 16, 0x0000ffff);
        exchangeLR.call(this, 4, 0x0f0f0f0f); // Set output

        M[offset] = this._lBlock;
        M[offset + 1] = this._rBlock;
      },
      keySize: 64 / 32,
      ivSize: 64 / 32,
      blockSize: 64 / 32
    }); // Swap bits across the left and right words

    function exchangeLR(offset, mask) {
      var t = (this._lBlock >>> offset ^ this._rBlock) & mask;
      this._rBlock ^= t;
      this._lBlock ^= t << offset;
    }

    function exchangeRL(offset, mask) {
      var t = (this._rBlock >>> offset ^ this._lBlock) & mask;
      this._lBlock ^= t;
      this._rBlock ^= t << offset;
    }
    /**
     * Shortcut functions to the cipher's object interface.
     *
     * @example
     *
     *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
     *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
     */


    C.DES = BlockCipher._createHelper(DES);
    /**
     * Triple-DES block cipher algorithm.
     */

    var TripleDES = C_algo.TripleDES = BlockCipher.extend({
      _doReset: function () {
        // Shortcuts
        var key = this._key;
        var keyWords = key.words; // Make sure the key length is valid (64, 128 or >= 192 bit)

        if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
          throw new Error('Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.');
        } // Extend the key according to the keying options defined in 3DES standard


        var key1 = keyWords.slice(0, 2);
        var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
        var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6); // Create DES instances

        this._des1 = DES.createEncryptor(WordArray.create(key1));
        this._des2 = DES.createEncryptor(WordArray.create(key2));
        this._des3 = DES.createEncryptor(WordArray.create(key3));
      },
      encryptBlock: function (M, offset) {
        this._des1.encryptBlock(M, offset);

        this._des2.decryptBlock(M, offset);

        this._des3.encryptBlock(M, offset);
      },
      decryptBlock: function (M, offset) {
        this._des3.decryptBlock(M, offset);

        this._des2.encryptBlock(M, offset);

        this._des1.decryptBlock(M, offset);
      },
      keySize: 192 / 32,
      ivSize: 64 / 32,
      blockSize: 64 / 32
    });
    /**
     * Shortcut functions to the cipher's object interface.
     *
     * @example
     *
     *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
     *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
     */

    C.TripleDES = BlockCipher._createHelper(TripleDES);
  })();

  return CryptoJS.TripleDES;
});

/***/ }),

/***/ "./node_modules/crypto-js/x64-core.js":
/*!********************************************!*\
  !*** ./node_modules/crypto-js/x64-core.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

;

(function (root, factory) {
  if (true) {
    // CommonJS
    module.exports = exports = factory(__webpack_require__(/*! ./core */ "./node_modules/crypto-js/core.js"));
  } else {}
})(this, function (CryptoJS) {
  (function (undefined) {
    // Shortcuts
    var C = CryptoJS;
    var C_lib = C.lib;
    var Base = C_lib.Base;
    var X32WordArray = C_lib.WordArray;
    /**
     * x64 namespace.
     */

    var C_x64 = C.x64 = {};
    /**
     * A 64-bit word.
     */

    var X64Word = C_x64.Word = Base.extend({
      /**
       * Initializes a newly created 64-bit word.
       *
       * @param {number} high The high 32 bits.
       * @param {number} low The low 32 bits.
       *
       * @example
       *
       *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
       */
      init: function (high, low) {
        this.high = high;
        this.low = low;
      }
      /**
       * Bitwise NOTs this word.
       *
       * @return {X64Word} A new x64-Word object after negating.
       *
       * @example
       *
       *     var negated = x64Word.not();
       */
      // not: function () {
      // var high = ~this.high;
      // var low = ~this.low;
      // return X64Word.create(high, low);
      // },

      /**
       * Bitwise ANDs this word with the passed word.
       *
       * @param {X64Word} word The x64-Word to AND with this word.
       *
       * @return {X64Word} A new x64-Word object after ANDing.
       *
       * @example
       *
       *     var anded = x64Word.and(anotherX64Word);
       */
      // and: function (word) {
      // var high = this.high & word.high;
      // var low = this.low & word.low;
      // return X64Word.create(high, low);
      // },

      /**
       * Bitwise ORs this word with the passed word.
       *
       * @param {X64Word} word The x64-Word to OR with this word.
       *
       * @return {X64Word} A new x64-Word object after ORing.
       *
       * @example
       *
       *     var ored = x64Word.or(anotherX64Word);
       */
      // or: function (word) {
      // var high = this.high | word.high;
      // var low = this.low | word.low;
      // return X64Word.create(high, low);
      // },

      /**
       * Bitwise XORs this word with the passed word.
       *
       * @param {X64Word} word The x64-Word to XOR with this word.
       *
       * @return {X64Word} A new x64-Word object after XORing.
       *
       * @example
       *
       *     var xored = x64Word.xor(anotherX64Word);
       */
      // xor: function (word) {
      // var high = this.high ^ word.high;
      // var low = this.low ^ word.low;
      // return X64Word.create(high, low);
      // },

      /**
       * Shifts this word n bits to the left.
       *
       * @param {number} n The number of bits to shift.
       *
       * @return {X64Word} A new x64-Word object after shifting.
       *
       * @example
       *
       *     var shifted = x64Word.shiftL(25);
       */
      // shiftL: function (n) {
      // if (n < 32) {
      // var high = (this.high << n) | (this.low >>> (32 - n));
      // var low = this.low << n;
      // } else {
      // var high = this.low << (n - 32);
      // var low = 0;
      // }
      // return X64Word.create(high, low);
      // },

      /**
       * Shifts this word n bits to the right.
       *
       * @param {number} n The number of bits to shift.
       *
       * @return {X64Word} A new x64-Word object after shifting.
       *
       * @example
       *
       *     var shifted = x64Word.shiftR(7);
       */
      // shiftR: function (n) {
      // if (n < 32) {
      // var low = (this.low >>> n) | (this.high << (32 - n));
      // var high = this.high >>> n;
      // } else {
      // var low = this.high >>> (n - 32);
      // var high = 0;
      // }
      // return X64Word.create(high, low);
      // },

      /**
       * Rotates this word n bits to the left.
       *
       * @param {number} n The number of bits to rotate.
       *
       * @return {X64Word} A new x64-Word object after rotating.
       *
       * @example
       *
       *     var rotated = x64Word.rotL(25);
       */
      // rotL: function (n) {
      // return this.shiftL(n).or(this.shiftR(64 - n));
      // },

      /**
       * Rotates this word n bits to the right.
       *
       * @param {number} n The number of bits to rotate.
       *
       * @return {X64Word} A new x64-Word object after rotating.
       *
       * @example
       *
       *     var rotated = x64Word.rotR(7);
       */
      // rotR: function (n) {
      // return this.shiftR(n).or(this.shiftL(64 - n));
      // },

      /**
       * Adds this word with the passed word.
       *
       * @param {X64Word} word The x64-Word to add with this word.
       *
       * @return {X64Word} A new x64-Word object after adding.
       *
       * @example
       *
       *     var added = x64Word.add(anotherX64Word);
       */
      // add: function (word) {
      // var low = (this.low + word.low) | 0;
      // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
      // var high = (this.high + word.high + carry) | 0;
      // return X64Word.create(high, low);
      // }

    });
    /**
     * An array of 64-bit words.
     *
     * @property {Array} words The array of CryptoJS.x64.Word objects.
     * @property {number} sigBytes The number of significant bytes in this word array.
     */

    var X64WordArray = C_x64.WordArray = Base.extend({
      /**
       * Initializes a newly created word array.
       *
       * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
       * @param {number} sigBytes (Optional) The number of significant bytes in the words.
       *
       * @example
       *
       *     var wordArray = CryptoJS.x64.WordArray.create();
       *
       *     var wordArray = CryptoJS.x64.WordArray.create([
       *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
       *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
       *     ]);
       *
       *     var wordArray = CryptoJS.x64.WordArray.create([
       *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
       *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
       *     ], 10);
       */
      init: function (words, sigBytes) {
        words = this.words = words || [];

        if (sigBytes != undefined) {
          this.sigBytes = sigBytes;
        } else {
          this.sigBytes = words.length * 8;
        }
      },

      /**
       * Converts this 64-bit word array to a 32-bit word array.
       *
       * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
       *
       * @example
       *
       *     var x32WordArray = x64WordArray.toX32();
       */
      toX32: function () {
        // Shortcuts
        var x64Words = this.words;
        var x64WordsLength = x64Words.length; // Convert

        var x32Words = [];

        for (var i = 0; i < x64WordsLength; i++) {
          var x64Word = x64Words[i];
          x32Words.push(x64Word.high);
          x32Words.push(x64Word.low);
        }

        return X32WordArray.create(x32Words, this.sigBytes);
      },

      /**
       * Creates a copy of this word array.
       *
       * @return {X64WordArray} The clone.
       *
       * @example
       *
       *     var clone = x64WordArray.clone();
       */
      clone: function () {
        var clone = Base.clone.call(this); // Clone "words" array

        var words = clone.words = this.words.slice(0); // Clone each X64Word object

        var wordsLength = words.length;

        for (var i = 0; i < wordsLength; i++) {
          words[i] = words[i].clone();
        }

        return clone;
      }
    });
  })();

  return CryptoJS;
});

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic.js":
/*!***********************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var elliptic = exports;
elliptic.version = (__webpack_require__(/*! ../package.json */ "./node_modules/elliptic/package.json").version);
elliptic.utils = __webpack_require__(/*! ./elliptic/utils */ "./node_modules/elliptic/lib/elliptic/utils.js");
elliptic.rand = __webpack_require__(/*! brorand */ "./node_modules/brorand/index.js");
elliptic.curve = __webpack_require__(/*! ./elliptic/curve */ "./node_modules/elliptic/lib/elliptic/curve/index.js");
elliptic.curves = __webpack_require__(/*! ./elliptic/curves */ "./node_modules/elliptic/lib/elliptic/curves.js"); // Protocols

elliptic.ec = __webpack_require__(/*! ./elliptic/ec */ "./node_modules/elliptic/lib/elliptic/ec/index.js");
elliptic.eddsa = __webpack_require__(/*! ./elliptic/eddsa */ "./node_modules/elliptic/lib/elliptic/eddsa/index.js");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/base.js":
/*!**********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/base.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");

var utils = __webpack_require__(/*! ../utils */ "./node_modules/elliptic/lib/elliptic/utils.js");

var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16); // Use Montgomery, when there is no fast reduction for the prime

  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p); // Useful for many curves

  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red); // Curve configuration, optional

  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed); // Temporary arrays

  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);
  this._bitLength = this.n ? this.n.bitLength() : 0; // Generalized Greg Maxwell's trick

  var adjustCount = this.n && this.p.div(this.n);

  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}

module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);

  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3; // Translate into more windowed form

  var repr = [];
  var j;
  var nafW;

  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;

    for (var l = j + doubles.step - 1; l >= j; l--) nafW = (nafW << 1) + naf[l];

    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);

  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i) b = b.mixedAdd(doubles.points[j]);else if (nafW === -i) b = b.mixedAdd(doubles.points[j].neg());
    }

    a = a.add(b);
  }

  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4; // Precompute window

  var nafPoints = p._getNAFPoints(w);

  w = nafPoints.wnd;
  var wnd = nafPoints.points; // Get NAF form

  var naf = getNAF(k, w, this._bitLength); // Add `this`*(N+1) for every w-NAF index

  var acc = this.jpoint(null, null, null);

  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--) l++;

    if (i >= 0) l++;
    acc = acc.dblp(l);
    if (i < 0) break;
    var z = naf[i];
    assert(z !== 0);

    if (p.type === 'affine') {
      // J +- P
      if (z > 0) acc = acc.mixedAdd(wnd[z - 1 >> 1]);else acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
    } else {
      // J +- J
      if (z > 0) acc = acc.add(wnd[z - 1 >> 1]);else acc = acc.add(wnd[-z - 1 >> 1].neg());
    }
  }

  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3; // Fill all arrays

  var max = 0;
  var i;
  var j;
  var p;

  for (i = 0; i < len; i++) {
    p = points[i];

    var nafPoints = p._getNAFPoints(defW);

    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  } // Comb small window NAFs


  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;

    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [points[a],
    /* 1 */
    null,
    /* 3 */
    null,
    /* 5 */
    points[b]
    /* 7 */
    ]; // Try to avoid Projective points, if possible

    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [-3,
    /* -1 -1 */
    -1,
    /* -1 0 */
    -5,
    /* -1 1 */
    -7,
    /* 0 -1 */
    0,
    /* 0 0 */
    7,
    /* 0 1 */
    5,
    /* 1 -1 */
    1,
    /* 1 0 */
    3
    /* 1 1 */
    ];
    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);

    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;
      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;

  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;

      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0) zero = false;
      }

      if (!zero) break;
      k++;
      i--;
    }

    if (i >= 0) k++;
    acc = acc.dblp(k);
    if (i < 0) break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0) continue;else if (z > 0) p = wnd[j][z - 1 >> 1];else if (z < 0) p = wnd[j][-z - 1 >> 1].neg();
      if (p.type === 'affine') acc = acc.mixedAdd(p);else acc = acc.add(p);
    }
  } // Zeroify references


  for (i = 0; i < len; i++) wnd[i] = null;

  if (jacobianResult) return acc;else return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}

BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function
  /*other*/
eq() {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);
  var len = this.p.byteLength(); // uncompressed, hybrid-odd, hybrid-even

  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) && bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06) assert(bytes[bytes.length - 1] % 2 === 0);else if (bytes[0] === 0x07) assert(bytes[bytes.length - 1] % 2 === 1);
    var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) && bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }

  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);
  if (compact) return [this.getY().isEven() ? 0x02 : 0x03].concat(x);
  return [0x04].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed) return this;
  var precomputed = {
    doubles: null,
    naf: null,
    beta: null
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;
  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed) return false;
  var doubles = this.precomputed.doubles;
  if (!doubles) return false;
  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles) return this.precomputed.doubles;
  var doubles = [this];
  var acc = this;

  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++) acc = acc.dbl();

    doubles.push(acc);
  }

  return {
    step: step,
    points: doubles
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf) return this.precomputed.naf;
  var res = [this];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();

  for (var i = 1; i < max; i++) res[i] = res[i - 1].add(dbl);

  return {
    wnd: wnd,
    points: res
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;

  for (var i = 0; i < k; i++) r = r.dbl();

  return r;
};

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/edwards.js":
/*!*************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/edwards.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/elliptic/lib/elliptic/utils.js");

var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var Base = __webpack_require__(/*! ./base */ "./node_modules/elliptic/lib/elliptic/curve/base.js");

var assert = utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;
  Base.call(this, 'edwards', conf);
  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);
  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}

inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA) return num.redNeg();else return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC) return num;else return this.c.redMul(num);
}; // Just for compatibility with Short curve


EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red) x = x.toRed(this.red);
  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error('invalid point');
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red) y = y.toRed(this.red); // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)

  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd) throw new Error('invalid point');else return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0) throw new Error('invalid point');
  if (x.fromRed().isOdd() !== odd) x = x.redNeg();
  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity()) return true; // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)

  point.normalize();
  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');

  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
    if (!this.y.red) this.y = this.y.toRed(this.curve.red);
    if (!this.z.red) this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red) this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one; // Use extended coordinates

    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne) this.t = this.t.redMul(this.z.redInvm());
    }
  }
}

inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity()) return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S
  // A = X1^2
  var a = this.x.redSqr(); // B = Y1^2

  var b = this.y.redSqr(); // C = 2 * Z1^2

  var c = this.z.redSqr();
  c = c.redIAdd(c); // D = a * A

  var d = this.curve._mulA(a); // E = (X1 + Y1)^2 - A - B


  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b); // G = D + B

  var g = d.redAdd(b); // F = G - C

  var f = g.redSub(c); // H = D - B

  var h = d.redSub(b); // X3 = E * F

  var nx = e.redMul(f); // Y3 = G * H

  var ny = g.redMul(h); // T3 = E * H

  var nt = e.redMul(h); // Z3 = F * G

  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S
  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr(); // C = X1^2

  var c = this.x.redSqr(); // D = Y1^2

  var d = this.y.redSqr();
  var nx;
  var ny;
  var nz;
  var e;
  var h;
  var j;

  if (this.curve.twisted) {
    // E = a * C
    e = this.curve._mulA(c); // F = E + D

    var f = e.redAdd(d);

    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two)); // Y3 = F * (E - D)

      ny = f.redMul(e.redSub(d)); // Z3 = F^2 - 2 * F

      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      h = this.z.redSqr(); // J = F - 2 * H

      j = f.redSub(h).redISub(h); // X3 = (B-C-D)*J

      nx = b.redSub(c).redISub(d).redMul(j); // Y3 = F * (E - D)

      ny = f.redMul(e.redSub(d)); // Z3 = F * J

      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    e = c.redAdd(d); // H = (c * Z1)^2

    h = this.curve._mulC(this.z).redSqr(); // J = E - 2 * H

    j = e.redSub(h).redSub(h); // X3 = c * (B - E) * J

    nx = this.curve._mulC(b.redISub(e)).redMul(j); // Y3 = c * E * (C - D)

    ny = this.curve._mulC(e).redMul(c.redISub(d)); // Z3 = E * J

    nz = e.redMul(j);
  }

  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity()) return this; // Double in extended coordinates

  if (this.curve.extended) return this._extDbl();else return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M
  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x)); // B = (Y1 + X1) * (Y2 + X2)

  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x)); // C = T1 * k * T2

  var c = this.t.redMul(this.curve.dd).redMul(p.t); // D = Z1 * 2 * Z2

  var d = this.z.redMul(p.z.redAdd(p.z)); // E = B - A

  var e = b.redSub(a); // F = D - C

  var f = d.redSub(c); // G = D + C

  var g = d.redAdd(c); // H = B + A

  var h = b.redAdd(a); // X3 = E * F

  var nx = e.redMul(f); // Y3 = G * H

  var ny = g.redMul(h); // T3 = E * H

  var nt = e.redMul(h); // Z3 = F * G

  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S
  // A = Z1 * Z2
  var a = this.z.redMul(p.z); // B = A^2

  var b = a.redSqr(); // C = X1 * X2

  var c = this.x.redMul(p.x); // D = Y1 * Y2

  var d = this.y.redMul(p.y); // E = d * C * D

  var e = this.curve.d.redMul(c).redMul(d); // F = B - E

  var f = b.redSub(e); // G = B + E

  var g = b.redAdd(e); // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)

  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;

  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c))); // Z3 = F * G

    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c)); // Z3 = c * F * G

    nz = this.curve._mulC(f).redMul(g);
  }

  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity()) return p;
  if (p.isInfinity()) return this;
  if (this.curve.extended) return this._extAdd(p);else return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);else return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne) return this; // Normalize coordinates

  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t) this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0) return true;
  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);

  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0) return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0) return true;
  }
}; // Compatibility with BaseCurve


Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var curve = exports;
curve.base = __webpack_require__(/*! ./base */ "./node_modules/elliptic/lib/elliptic/curve/base.js");
curve.short = __webpack_require__(/*! ./short */ "./node_modules/elliptic/lib/elliptic/curve/short.js");
curve.mont = __webpack_require__(/*! ./mont */ "./node_modules/elliptic/lib/elliptic/curve/mont.js");
curve.edwards = __webpack_require__(/*! ./edwards */ "./node_modules/elliptic/lib/elliptic/curve/edwards.js");

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/mont.js":
/*!**********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/mont.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var Base = __webpack_require__(/*! ./base */ "./node_modules/elliptic/lib/elliptic/curve/base.js");

var utils = __webpack_require__(/*! ../utils */ "./node_modules/elliptic/lib/elliptic/utils.js");

function MontCurve(conf) {
  Base.call(this, 'mont', conf);
  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}

inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();
  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');

  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
    if (!this.z.red) this.z = this.z.toRed(this.curve.red);
  }
}

inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {// No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity()) return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A
  // A = X1 + Z1
  var a = this.x.redAdd(this.z); // AA = A^2

  var aa = a.redSqr(); // B = X1 - Z1

  var b = this.x.redSub(this.z); // BB = B^2

  var bb = b.redSqr(); // C = AA - BB

  var c = aa.redSub(bb); // X3 = AA * BB

  var nx = aa.redMul(bb); // Z3 = C * (BB + A24 * C)

  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A
  // A = X2 + Z2
  var a = this.x.redAdd(this.z); // B = X2 - Z2

  var b = this.x.redSub(this.z); // C = X3 + Z3

  var c = p.x.redAdd(p.z); // D = X3 - Z3

  var d = p.x.redSub(p.z); // DA = D * A

  var da = d.redMul(a); // CB = C * B

  var cb = c.redMul(b); // X5 = Z1 * (DA + CB)^2

  var nx = diff.z.redMul(da.redAdd(cb).redSqr()); // Z5 = X1 * (DA - CB)^2

  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q

  var b = this.curve.point(null, null); // (N / 2) * Q

  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1)) bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c); // N * Q = 2 * ((N / 2) * Q + Q))

      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c); // N * Q + Q = 2 * ((N / 2) * Q + Q)

      a = a.dbl();
    }
  }

  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();
  return this.x.fromRed();
};

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curve/short.js":
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curve/short.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/elliptic/lib/elliptic/utils.js");

var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var Base = __webpack_require__(/*! ./base */ "./node_modules/elliptic/lib/elliptic/curve/base.js");

var assert = utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);
  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();
  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0; // If the curve is endomorphic, precalculate beta and lambda

  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}

inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1) return; // Compute beta and lambda, that lambda * P = (beta * Px; Py)

  var beta;
  var lambda;

  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p); // Choose the smallest beta


    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }

  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);

    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  } // Get basis vectors, used for balanced length-two representation


  var basis;

  if (conf.basis) {
    basis = conf.basis.map(function (vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16)
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();
  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [l1, l2];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2)); // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt

  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1); // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)

  var a0;
  var b0; // First vector

  var a1;
  var b1; // Second vector

  var a2;
  var b2;
  var prevR;
  var i = 0;
  var r;
  var x;

  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }

    prevR = r;
    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }

  a2 = r.neg();
  b2 = x;
  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());

  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  } // Normalize signs


  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }

  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [{
    a: a1,
    b: b1
  }, {
    a: a2,
    b: b2
  }];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];
  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);
  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b); // Calculate answer

  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return {
    k1: k1,
    k2: k2
  };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red) x = x.toRed(this.red);
  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0) throw new Error('invalid point'); // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd) y = y.redNeg();
  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf) return true;
  var x = point.x;
  var y = point.y;
  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
  var npoints = this._endoWnafT1;
  var ncoeffs = this._endoWnafT2;

  for (var i = 0; i < points.length; i++) {
    var split = this._endoSplit(coeffs[i]);

    var p = points[i];

    var beta = p._getBeta();

    if (split.k1.negative) {
      split.k1.ineg();
      p = p.neg(true);
    }

    if (split.k2.negative) {
      split.k2.ineg();
      beta = beta.neg(true);
    }

    npoints[i * 2] = p;
    npoints[i * 2 + 1] = beta;
    ncoeffs[i * 2] = split.k1;
    ncoeffs[i * 2 + 1] = split.k2;
  }

  var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult); // Clean-up references to points and coefficients


  for (var j = 0; j < i * 2; j++) {
    npoints[j] = null;
    ncoeffs[j] = null;
  }

  return res;
};

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');

  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16); // Force redgomery representation when loading from JSON

    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }

    if (!this.x.red) this.x = this.x.toRed(this.curve.red);
    if (!this.y.red) this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}

inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo) return;
  var pre = this.precomputed;
  if (pre && pre.beta) return pre.beta;
  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);

  if (pre) {
    var curve = this.curve;

    var endoMul = function (p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };

    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul)
      }
    };
  }

  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed) return [this.x, this.y];
  return [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string') obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2]) return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [res].concat(pre.doubles.points.map(obj2point))
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [res].concat(pre.naf.points.map(obj2point))
    }
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity()) return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) + ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf) return p; // P + O = P

  if (p.inf) return this; // P + P = 2P

  if (this.eq(p)) return this.dbl(); // P + (-P) = O

  if (this.neg().eq(p)) return this.curve.point(null, null); // P + Q = O

  if (this.x.cmp(p.x) === 0) return this.curve.point(null, null);
  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0) c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf) return this; // 2P = O

  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0) return this.curve.point(null, null);
  var a = this.curve.a;
  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);
  if (this.isInfinity()) return this;else if (this._hasDoubles(k)) return this.curve._fixedNafMul(this, k);else if (this.curve.endo) return this.curve._endoWnafMulAdd([this], [k]);else return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs);else return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [this, p2];
  var coeffs = [k1, k2];
  if (this.curve.endo) return this.curve._endoWnafMulAdd(points, coeffs, true);else return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf) return this;
  var res = this.curve.point(this.x, this.y.redNeg());

  if (_precompute && this.precomputed) {
    var pre = this.precomputed;

    var negate = function (p) {
      return p.neg();
    };

    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate)
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate)
      }
    };
  }

  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf) return this.curve.jpoint(null, null, null);
  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');

  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }

  if (!this.x.red) this.x = this.x.toRed(this.curve.red);
  if (!this.y.red) this.y = this.y.toRed(this.curve.red);
  if (!this.z.red) this.z = this.z.toRed(this.curve.red);
  this.zOne = this.z === this.curve.one;
}

inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity()) return this.curve.point(null, null);
  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);
  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity()) return p; // P + O = P

  if (p.isInfinity()) return this; // 12M + 4S + 7A

  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);

  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);else return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity()) return p.toJ(); // P + O = P

  if (p.isInfinity()) return this; // 8M + 3S + 7A

  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);
  var h = u1.redSub(u2);
  var r = s1.redSub(s2);

  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0) return this.curve.jpoint(null, null, null);else return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);
  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);
  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0) return this;
  if (this.isInfinity()) return this;
  if (!pow) return this.dbl();
  var i;

  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;

    for (i = 0; i < pow; i++) r = r.dbl();

    return r;
  } // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A


  var a = this.curve.a;
  var tinv = this.curve.tinv;
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr(); // Reuse results

  var jyd = jy.redAdd(jy);

  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow) jz4 = jz4.redMul(jyd4);
    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity()) return this;
  if (this.curve.zeroA) return this._zeroDbl();else if (this.curve.threeA) return this._threeDbl();else return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz; // Z = 1

  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A
    // XX = X1^2
    var xx = this.x.redSqr(); // YY = Y1^2

    var yy = this.y.redSqr(); // YYYY = YY^2

    var yyyy = yy.redSqr(); // S = 2 * ((X1 + YY)^2 - XX - YYYY)

    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s); // M = 3 * XX + a; a = 0

    var m = xx.redAdd(xx).redIAdd(xx); // T = M ^ 2 - 2*S

    var t = m.redSqr().redISub(s).redISub(s); // 8 * YYYY

    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8); // X3 = T

    nx = t; // Y3 = M * (S - T) - 8 * YYYY

    ny = m.redMul(s.redISub(t)).redISub(yyyy8); // Z3 = 2*Y1

    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A
    // A = X1^2
    var a = this.x.redSqr(); // B = Y1^2

    var b = this.y.redSqr(); // C = B^2

    var c = b.redSqr(); // D = 2 * ((X1 + B)^2 - A - C)

    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d); // E = 3 * A

    var e = a.redAdd(a).redIAdd(a); // F = E^2

    var f = e.redSqr(); // 8 * C

    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8); // X3 = F - 2 * D

    nx = f.redISub(d).redISub(d); // Y3 = E * (D - X3) - 8 * C

    ny = e.redMul(d.redISub(nx)).redISub(c8); // Z3 = 2 * Y1 * Z1

    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz; // Z = 1

  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A
    // XX = X1^2
    var xx = this.x.redSqr(); // YY = Y1^2

    var yy = this.y.redSqr(); // YYYY = YY^2

    var yyyy = yy.redSqr(); // S = 2 * ((X1 + YY)^2 - XX - YYYY)

    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s); // M = 3 * XX + a

    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a); // T = M^2 - 2 * S

    var t = m.redSqr().redISub(s).redISub(s); // X3 = T

    nx = t; // Y3 = M * (S - T) - 8 * YYYY

    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8); // Z3 = 2 * Y1

    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S
    // delta = Z1^2
    var delta = this.z.redSqr(); // gamma = Y1^2

    var gamma = this.y.redSqr(); // beta = X1 * gamma

    var beta = this.x.redMul(gamma); // alpha = 3 * (X1 - delta) * (X1 + delta)

    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha); // X3 = alpha^2 - 8 * beta

    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8); // Z3 = (Y1 + Z1)^2 - gamma - delta

    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta); // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2

    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a; // 4M + 6S + 10A

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();
  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();
  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);
  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);
  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA) return this.dbl().add(this); // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...
  // XX = X1^2

  var xx = this.x.redSqr(); // YY = Y1^2

  var yy = this.y.redSqr(); // ZZ = Z1^2

  var zz = this.z.redSqr(); // YYYY = YY^2

  var yyyy = yy.redSqr(); // M = 3 * XX + a * ZZ2; a = 0

  var m = xx.redAdd(xx).redIAdd(xx); // MM = M^2

  var mm = m.redSqr(); // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM

  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm); // EE = E^2

  var ee = e.redSqr(); // T = 16*YYYY

  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t); // U = (M + E)^2 - MM - EE - T

  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t); // X3 = 4 * (X1 * EE - 4 * YY * U)

  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx); // Y3 = 8 * Y1 * (U * (T - U) - E * EE)

  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny); // Z3 = (Z1 + E)^2 - ZZ - EE

  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);
  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine') return this.eq(p.toJ());
  if (this === p) return true; // x1 * z2^2 == x2 * z1^2

  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0) return false; // y1 * z2^3 == y2 * z1^3

  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0) return true;
  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);

  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0) return false;
    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0) return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity()) return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) + ' y: ' + this.y.toString(16, 2) + ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/curves.js":
/*!******************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/curves.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var curves = exports;

var hash = __webpack_require__(/*! hash.js */ "./node_modules/hash.js/lib/hash.js");

var curve = __webpack_require__(/*! ./curve */ "./node_modules/elliptic/lib/elliptic/curve/index.js");

var utils = __webpack_require__(/*! ./utils */ "./node_modules/elliptic/lib/elliptic/utils.js");

var assert = utils.assert;

function PresetCurve(options) {
  if (options.type === 'short') this.curve = new curve.short(options);else if (options.type === 'edwards') this.curve = new curve.edwards(options);else this.curve = new curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;
  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}

curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function () {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve
      });
      return curve;
    }
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: ['188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012', '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811']
});
defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: ['b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21', 'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34']
});
defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: ['6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296', '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5']
});
defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' + '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' + 'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: ['aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' + '5502f25d bf55296c 3a545e38 72760ab7', '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' + '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f']
});
defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' + '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' + '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' + 'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' + 'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: ['000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' + '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' + 'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66', '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' + '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' + '3fad0761 353c7086 a272c240 88be9476 9fd16650']
});
defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: ['9']
});
defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: ['216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a', // 4/5
  '6666666666666666666666666666666666666666666666666666666666666658']
});
var pre;

try {
  pre = __webpack_require__(/*! ./precomputed/secp256k1 */ "./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js");
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,
  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [{
    a: '3086d221a7d46bcde86c90e49284eb15',
    b: '-e4437ed6010e88286f547fa90abfe4c3'
  }, {
    a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
    b: '3086d221a7d46bcde86c90e49284eb15'
  }],
  gRed: false,
  g: ['79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798', '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8', pre]
});

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/ec/index.js":
/*!********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/index.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");

var HmacDRBG = __webpack_require__(/*! hmac-drbg */ "./node_modules/hmac-drbg/lib/hmac-drbg.js");

var utils = __webpack_require__(/*! ../utils */ "./node_modules/elliptic/lib/elliptic/utils.js");

var curves = __webpack_require__(/*! ../curves */ "./node_modules/elliptic/lib/elliptic/curves.js");

var rand = __webpack_require__(/*! brorand */ "./node_modules/brorand/index.js");

var assert = utils.assert;

var KeyPair = __webpack_require__(/*! ./key */ "./node_modules/elliptic/lib/elliptic/ec/key.js");

var Signature = __webpack_require__(/*! ./signature */ "./node_modules/elliptic/lib/elliptic/ec/signature.js");

function EC(options) {
  if (!(this instanceof EC)) return new EC(options); // Shortcut `elliptic.ec(curve-name)`

  if (typeof options === 'string') {
    assert(Object.prototype.hasOwnProperty.call(curves, options), 'Unknown curve ' + options);
    options = curves[options];
  } // Shortcut for `elliptic.ec(elliptic.curves.curveName)`


  if (options instanceof curves.PresetCurve) options = {
    curve: options
  };
  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g; // Point on curve

  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1); // Hash for function for DRBG

  this.hash = options.hash || options.curve.hash;
}

module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options) options = {}; // Instantiate Hmac_DRBG

  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray()
  });
  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));

  for (;;) {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0) continue;
    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0) msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0) return msg.sub(this.n);else return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }

  if (!options) options = {};
  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16)); // Zero-extend key to provide enough entropy

  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes); // Zero-extend nonce to have the same byte size as N

  var nonce = msg.toArray('be', bytes); // Instantiate Hmac_DRBG

  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8'
  }); // Number of bytes to generate

  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0;; iter++) {
    var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0) continue;
    var kp = this.g.mul(k);
    if (kp.isInfinity()) continue;
    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0) continue;
    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0) continue;
    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0); // Use complement of `s`, if it is > `n / 2`

    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({
      r: r,
      s: s,
      recoveryParam: recoveryParam
    });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex'); // Perform primitive values validation

  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0) return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0) return false; // Validate signature

  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity()) return false;
    return p.getX().umod(this.n).cmp(r) === 0;
  } // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K


  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity()) return false; // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`

  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function (msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);
  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s; // A set LSB signifies that the y-coordinate is odd

  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey) throw new Error('Unable to find sencond key candinate'); // 1.1. Let x = r + jn.

  if (isSecondKey) r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);else r = this.curve.pointFromX(r, isYOdd);
  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n); // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)

  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function (e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null) return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;

    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q)) return i;
  }

  throw new Error('Unable to find valid recovery factor');
};

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/ec/key.js":
/*!******************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/key.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");

var utils = __webpack_require__(/*! ../utils */ "./node_modules/elliptic/lib/elliptic/utils.js");

var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null; // KeyPair(ec, { priv: ..., pub: ... })

  if (options.priv) this._importPrivate(options.priv, options.privEnc);
  if (options.pub) this._importPublic(options.pub, options.pubEnc);
}

module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair) return pub;
  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair) return priv;
  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();
  if (pub.isInfinity()) return {
    result: false,
    reason: 'Invalid public key'
  };
  if (!pub.validate()) return {
    result: false,
    reason: 'Public key is not a point'
  };
  if (!pub.mul(this.ec.curve.n).isInfinity()) return {
    result: false,
    reason: 'Public key * N != O'
  };
  return {
    result: true,
    reason: null
  };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub) this.pub = this.ec.g.mul(this.priv);
  if (!enc) return this.pub;
  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex') return this.priv.toString(16, 2);else return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16); // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method

  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' || this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }

    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }

  this.pub = this.ec.curve.decodePoint(key, enc);
}; // ECDH


KeyPair.prototype.derive = function derive(pub) {
  if (!pub.validate()) {
    assert(pub.validate(), 'public point not validated');
  }

  return pub.mul(this.priv).getX();
}; // ECDSA


KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) + ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/ec/signature.js":
/*!************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/ec/signature.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");

var utils = __webpack_require__(/*! ../utils */ "./node_modules/elliptic/lib/elliptic/utils.js");

var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature) return options;
  if (this._importDER(options, enc)) return;
  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined) this.recoveryParam = null;else this.recoveryParam = options.recoveryParam;
}

module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];

  if (!(initial & 0x80)) {
    return initial;
  }

  var octetLen = initial & 0xf; // Indefinite length or overflow

  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  var val = 0;

  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  } // Leading zeroes


  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;

  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }

  if (i === 0) {
    return buf;
  }

  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();

  if (data[p.place++] !== 0x30) {
    return false;
  }

  var len = getLength(data, p);

  if (len === false) {
    return false;
  }

  if (len + p.place !== data.length) {
    return false;
  }

  if (data[p.place++] !== 0x02) {
    return false;
  }

  var rlen = getLength(data, p);

  if (rlen === false) {
    return false;
  }

  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;

  if (data[p.place++] !== 0x02) {
    return false;
  }

  var slen = getLength(data, p);

  if (slen === false) {
    return false;
  }

  if (data.length !== slen + p.place) {
    return false;
  }

  var s = data.slice(p.place, slen + p.place);

  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;
  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }

  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);

  while (--octets) {
    arr.push(len >>> (octets << 3) & 0xff);
  }

  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray(); // Pad values

  if (r[0] & 0x80) r = [0].concat(r); // Pad values

  if (s[0] & 0x80) s = [0].concat(s);
  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }

  var arr = [0x02];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [0x30];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/eddsa/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/index.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hash = __webpack_require__(/*! hash.js */ "./node_modules/hash.js/lib/hash.js");

var curves = __webpack_require__(/*! ../curves */ "./node_modules/elliptic/lib/elliptic/curves.js");

var utils = __webpack_require__(/*! ../utils */ "./node_modules/elliptic/lib/elliptic/utils.js");

var assert = utils.assert;
var parseBytes = utils.parseBytes;

var KeyPair = __webpack_require__(/*! ./key */ "./node_modules/elliptic/lib/elliptic/eddsa/key.js");

var Signature = __webpack_require__(/*! ./signature */ "./node_modules/elliptic/lib/elliptic/eddsa/signature.js");

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');
  if (!(this instanceof EDDSA)) return new EDDSA(curve);
  curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);
  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;
/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/

EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({
    R: R,
    S: S,
    Rencoded: Rencoded
  });
};
/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/


EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();

  for (var i = 0; i < arguments.length; i++) hash.update(arguments[i]);

  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature) return sig;
  return new Signature(this, sig);
};
/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/


EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);
  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;
  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/eddsa/key.js":
/*!*********************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/key.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/elliptic/lib/elliptic/utils.js");

var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;
/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/

function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub)) this._pub = params.pub;else this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair) return pub;
  return new KeyPair(eddsa, {
    pub: pub
  });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair) return secret;
  return new KeyPair(eddsa, {
    secret: secret
  });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});
cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes) return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});
cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;
  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;
  return a;
});
cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});
cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});
cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/eddsa/signature.js":
/*!***************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/eddsa/signature.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");

var utils = __webpack_require__(/*! ../utils */ "./node_modules/elliptic/lib/elliptic/utils.js");

var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;
/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/

function Signature(eddsa, sig) {
  this.eddsa = eddsa;
  if (typeof sig !== 'object') sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength)
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');
  if (eddsa.isPoint(sig.R)) this._R = sig.R;
  if (sig.S instanceof BN) this._S = sig.S;
  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});
cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});
cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});
cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js":
/*!*********************************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js ***!
  \*********************************************************************/
/***/ ((module) => {

module.exports = {
  doubles: {
    step: 4,
    points: [['e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a', 'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821'], ['8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508', '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf'], ['175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739', 'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695'], ['363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640', '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9'], ['8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c', '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36'], ['723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda', '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f'], ['eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa', '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999'], ['100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0', 'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09'], ['e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d', '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d'], ['feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d', 'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088'], ['da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1', '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d'], ['53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0', '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8'], ['8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047', '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a'], ['385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862', '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453'], ['6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7', '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160'], ['3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd', '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0'], ['85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83', '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6'], ['948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a', '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589'], ['6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8', 'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17'], ['e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d', '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda'], ['e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725', '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd'], ['213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754', '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2'], ['4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c', '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6'], ['fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6', '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f'], ['76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39', 'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01'], ['c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891', '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3'], ['d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b', 'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f'], ['b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03', '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7'], ['e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d', 'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78'], ['a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070', '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1'], ['90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4', 'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150'], ['8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da', '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82'], ['e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11', '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc'], ['8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e', 'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b'], ['e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41', '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51'], ['b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef', '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45'], ['d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8', 'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120'], ['324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d', '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84'], ['4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96', '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d'], ['9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd', 'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d'], ['6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5', '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8'], ['a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266', '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8'], ['7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71', '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac'], ['928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac', 'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f'], ['85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751', '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962'], ['ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e', '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907'], ['827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241', 'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec'], ['eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3', 'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d'], ['e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f', '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414'], ['1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19', 'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd'], ['146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be', 'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0'], ['fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9', '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811'], ['da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2', '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1'], ['a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13', '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c'], ['174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c', 'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73'], ['959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba', '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd'], ['d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151', 'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405'], ['64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073', 'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589'], ['8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458', '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e'], ['13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b', '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27'], ['bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366', 'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1'], ['8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa', '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482'], ['8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0', '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945'], ['dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787', '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573'], ['f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e', 'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82']]
  },
  naf: {
    wnd: 7,
    points: [['f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9', '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672'], ['2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4', 'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6'], ['5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc', '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da'], ['acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe', 'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37'], ['774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb', 'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b'], ['f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8', 'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81'], ['d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e', '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58'], ['defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34', '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77'], ['2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c', '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a'], ['352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5', '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c'], ['2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f', '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67'], ['9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714', '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402'], ['daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729', 'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55'], ['c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db', '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482'], ['6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4', 'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82'], ['1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5', 'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396'], ['605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479', '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49'], ['62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d', '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf'], ['80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f', '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a'], ['7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb', 'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7'], ['d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9', 'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933'], ['49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963', '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a'], ['77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74', '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6'], ['f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530', 'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37'], ['463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b', '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e'], ['f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247', 'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6'], ['caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1', 'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476'], ['2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120', '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40'], ['7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435', '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61'], ['754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18', '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683'], ['e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8', '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5'], ['186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb', '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b'], ['df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f', '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417'], ['5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143', 'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868'], ['290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba', 'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a'], ['af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45', 'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6'], ['766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a', '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996'], ['59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e', 'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e'], ['f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8', 'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d'], ['7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c', '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2'], ['948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519', 'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e'], ['7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab', '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437'], ['3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca', 'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311'], ['d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf', '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4'], ['1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610', '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575'], ['733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4', 'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d'], ['15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c', 'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d'], ['a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940', 'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629'], ['e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980', 'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06'], ['311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3', '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374'], ['34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf', '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee'], ['f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63', '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1'], ['d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448', 'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b'], ['32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf', '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661'], ['7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5', '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6'], ['ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6', '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e'], ['16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5', '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d'], ['eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99', 'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc'], ['78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51', 'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4'], ['494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5', '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c'], ['a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5', '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b'], ['c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997', '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913'], ['841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881', '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154'], ['5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5', '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865'], ['36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66', 'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc'], ['336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726', 'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224'], ['8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede', '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e'], ['1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94', '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6'], ['85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31', '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511'], ['29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51', 'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b'], ['a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252', 'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2'], ['4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5', 'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c'], ['d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b', '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3'], ['ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4', '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d'], ['af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f', '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700'], ['e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889', '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4'], ['591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246', 'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196'], ['11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984', '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4'], ['3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a', 'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257'], ['cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030', 'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13'], ['c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197', '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096'], ['c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593', 'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38'], ['a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef', '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f'], ['347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38', '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448'], ['da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a', '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a'], ['c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111', '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4'], ['4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502', '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437'], ['3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea', 'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7'], ['cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26', '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d'], ['b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986', '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a'], ['d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e', '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54'], ['48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4', '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77'], ['dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda', 'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517'], ['6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859', 'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10'], ['e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f', 'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125'], ['eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c', '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e'], ['13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942', 'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1'], ['ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a', '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2'], ['b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80', '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423'], ['ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d', '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8'], ['8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1', 'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758'], ['52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63', 'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375'], ['e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352', '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d'], ['7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193', 'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec'], ['5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00', '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0'], ['32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58', 'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c'], ['e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7', 'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4'], ['8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8', 'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f'], ['4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e', '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649'], ['3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d', 'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826'], ['674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b', '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5'], ['d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f', 'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87'], ['30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6', '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b'], ['be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297', '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc'], ['93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a', '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c'], ['b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c', 'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f'], ['d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52', '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a'], ['d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb', 'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46'], ['463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065', 'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f'], ['7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917', '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03'], ['74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9', 'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08'], ['30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3', '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8'], ['9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57', '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373'], ['176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66', 'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3'], ['75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8', '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8'], ['809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721', '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1'], ['1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180', '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9']]
  }
};

/***/ }),

/***/ "./node_modules/elliptic/lib/elliptic/utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/elliptic/lib/elliptic/utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var utils = exports;

var BN = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");

var minAssert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

var minUtils = __webpack_require__(/*! minimalistic-crypto-utils */ "./node_modules/minimalistic-crypto-utils/lib/utils.js");

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode; // Represent num in a w-NAF form

function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  naf.fill(0);
  var ws = 1 << w + 1;
  var k = num.clone();

  for (var i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);

    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1) z = (ws >> 1) - mod;else z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf[i] = z;
    k.iushrn(1);
  }

  return naf;
}

utils.getNAF = getNAF; // Represent k1, k2 in a Joint Sparse Form

function getJSF(k1, k2) {
  var jsf = [[], []];
  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  var m8;

  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = k1.andln(3) + d1 & 3;
    var m24 = k2.andln(3) + d2 & 3;
    if (m14 === 3) m14 = -1;
    if (m24 === 3) m24 = -1;
    var u1;

    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      m8 = k1.andln(7) + d1 & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2) u1 = -m14;else u1 = m14;
    }

    jsf[0].push(u1);
    var u2;

    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      m8 = k2.andln(7) + d2 & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2) u2 = -m24;else u2 = m24;
    }

    jsf[1].push(u2); // Second phase

    if (2 * d1 === u1 + 1) d1 = 1 - d1;
    if (2 * d2 === u2 + 1) d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}

utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;

  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] : this[key] = computer.call(this);
  };
}

utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') : bytes;
}

utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}

utils.intFromLE = intFromLE;

/***/ }),

/***/ "./node_modules/ethers/lib.esm/_version.js":
/*!*************************************************!*\
  !*** ./node_modules/ethers/lib.esm/_version.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": () => (/* binding */ version)
/* harmony export */ });
const version = "ethers/5.6.5";

/***/ }),

/***/ "./node_modules/ethers/lib.esm/ethers.js":
/*!***********************************************!*\
  !*** ./node_modules/ethers/lib.esm/ethers.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseContract": () => (/* reexport safe */ _ethersproject_contracts__WEBPACK_IMPORTED_MODULE_5__.BaseContract),
/* harmony export */   "BigNumber": () => (/* reexport safe */ _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__.BigNumber),
/* harmony export */   "Contract": () => (/* reexport safe */ _ethersproject_contracts__WEBPACK_IMPORTED_MODULE_5__.Contract),
/* harmony export */   "ContractFactory": () => (/* reexport safe */ _ethersproject_contracts__WEBPACK_IMPORTED_MODULE_5__.ContractFactory),
/* harmony export */   "FixedNumber": () => (/* reexport safe */ _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_7__.FixedNumber),
/* harmony export */   "Signer": () => (/* reexport safe */ _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_2__.Signer),
/* harmony export */   "VoidSigner": () => (/* reexport safe */ _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_2__.VoidSigner),
/* harmony export */   "Wallet": () => (/* reexport safe */ _ethersproject_wallet__WEBPACK_IMPORTED_MODULE_3__.Wallet),
/* harmony export */   "Wordlist": () => (/* reexport safe */ _ethersproject_wordlists__WEBPACK_IMPORTED_MODULE_11__.Wordlist),
/* harmony export */   "constants": () => (/* reexport module object */ _ethersproject_constants__WEBPACK_IMPORTED_MODULE_8__),
/* harmony export */   "errors": () => (/* reexport safe */ _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.ErrorCode),
/* harmony export */   "getDefaultProvider": () => (/* reexport safe */ _ethersproject_providers__WEBPACK_IMPORTED_MODULE_4__.getDefaultProvider),
/* harmony export */   "logger": () => (/* binding */ logger),
/* harmony export */   "providers": () => (/* reexport module object */ _ethersproject_providers__WEBPACK_IMPORTED_MODULE_4__),
/* harmony export */   "utils": () => (/* reexport module object */ _utils__WEBPACK_IMPORTED_MODULE_9__),
/* harmony export */   "version": () => (/* reexport safe */ _version__WEBPACK_IMPORTED_MODULE_1__.version),
/* harmony export */   "wordlists": () => (/* reexport safe */ _ethersproject_wordlists__WEBPACK_IMPORTED_MODULE_10__.wordlists)
/* harmony export */ });
/* harmony import */ var _ethersproject_contracts__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/contracts */ "./node_modules/@ethersproject/contracts/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js");
/* harmony import */ var _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/abstract-signer */ "./node_modules/@ethersproject/abstract-signer/lib.esm/index.js");
/* harmony import */ var _ethersproject_wallet__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/wallet */ "./node_modules/@ethersproject/wallet/lib.esm/index.js");
/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/constants */ "./node_modules/@ethersproject/constants/lib.esm/index.js");
/* harmony import */ var _ethersproject_providers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/providers */ "./node_modules/@ethersproject/providers/lib.esm/index.js");
/* harmony import */ var _ethersproject_wordlists__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/wordlists */ "./node_modules/@ethersproject/wordlists/lib.esm/wordlists.js");
/* harmony import */ var _ethersproject_wordlists__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @ethersproject/wordlists */ "./node_modules/@ethersproject/wordlists/lib.esm/wordlist.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils */ "./node_modules/ethers/lib.esm/utils.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/ethers/lib.esm/_version.js");











 ////////////////////////
// Compile-Time Constants
// This is generated by "npm run dist"


const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__.Logger(_version__WEBPACK_IMPORTED_MODULE_1__.version); ////////////////////////
// Exports



/***/ }),

/***/ "./node_modules/ethers/lib.esm/index.js":
/*!**********************************************!*\
  !*** ./node_modules/ethers/lib.esm/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseContract": () => (/* reexport safe */ _ethers__WEBPACK_IMPORTED_MODULE_4__.BaseContract),
/* harmony export */   "BigNumber": () => (/* reexport safe */ _ethers__WEBPACK_IMPORTED_MODULE_5__.BigNumber),
/* harmony export */   "Contract": () => (/* reexport safe */ _ethers__WEBPACK_IMPORTED_MODULE_4__.Contract),
/* harmony export */   "ContractFactory": () => (/* reexport safe */ _ethers__WEBPACK_IMPORTED_MODULE_4__.ContractFactory),
/* harmony export */   "FixedNumber": () => (/* reexport safe */ _ethers__WEBPACK_IMPORTED_MODULE_6__.FixedNumber),
/* harmony export */   "Signer": () => (/* reexport safe */ _ethers__WEBPACK_IMPORTED_MODULE_1__.Signer),
/* harmony export */   "VoidSigner": () => (/* reexport safe */ _ethers__WEBPACK_IMPORTED_MODULE_1__.VoidSigner),
/* harmony export */   "Wallet": () => (/* reexport safe */ _ethers__WEBPACK_IMPORTED_MODULE_2__.Wallet),
/* harmony export */   "Wordlist": () => (/* reexport safe */ _ethers__WEBPACK_IMPORTED_MODULE_12__.Wordlist),
/* harmony export */   "constants": () => (/* reexport module object */ _ethers__WEBPACK_IMPORTED_MODULE_7__),
/* harmony export */   "errors": () => (/* reexport safe */ _ethers__WEBPACK_IMPORTED_MODULE_8__.ErrorCode),
/* harmony export */   "ethers": () => (/* reexport module object */ _ethers__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   "getDefaultProvider": () => (/* reexport safe */ _ethers__WEBPACK_IMPORTED_MODULE_3__.getDefaultProvider),
/* harmony export */   "logger": () => (/* reexport safe */ _ethers__WEBPACK_IMPORTED_MODULE_0__.logger),
/* harmony export */   "providers": () => (/* reexport module object */ _ethers__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   "utils": () => (/* reexport module object */ _ethers__WEBPACK_IMPORTED_MODULE_9__),
/* harmony export */   "version": () => (/* reexport safe */ _ethers__WEBPACK_IMPORTED_MODULE_11__.version),
/* harmony export */   "wordlists": () => (/* reexport safe */ _ethers__WEBPACK_IMPORTED_MODULE_10__.wordlists)
/* harmony export */ });
/* harmony import */ var _ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ethers */ "./node_modules/ethers/lib.esm/ethers.js");
/* harmony import */ var _ethers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ethers */ "./node_modules/@ethersproject/abstract-signer/lib.esm/index.js");
/* harmony import */ var _ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ethers */ "./node_modules/@ethersproject/wallet/lib.esm/index.js");
/* harmony import */ var _ethers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ethers */ "./node_modules/@ethersproject/providers/lib.esm/index.js");
/* harmony import */ var _ethers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ethers */ "./node_modules/@ethersproject/contracts/lib.esm/index.js");
/* harmony import */ var _ethers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ethers */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony import */ var _ethers__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ethers */ "./node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js");
/* harmony import */ var _ethers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ethers */ "./node_modules/@ethersproject/constants/lib.esm/index.js");
/* harmony import */ var _ethers__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./ethers */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _ethers__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./ethers */ "./node_modules/ethers/lib.esm/utils.js");
/* harmony import */ var _ethers__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ethers */ "./node_modules/@ethersproject/wordlists/lib.esm/wordlists.js");
/* harmony import */ var _ethers__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ethers */ "./node_modules/ethers/lib.esm/_version.js");
/* harmony import */ var _ethers__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./ethers */ "./node_modules/@ethersproject/wordlists/lib.esm/wordlist.js");
 // To modify this file, you must update ./misc/admin/lib/cmds/update-exports.js



try {
  const anyGlobal = window;

  if (anyGlobal._ethers == null) {
    anyGlobal._ethers = _ethers__WEBPACK_IMPORTED_MODULE_0__;
  }
} catch (error) {}




/***/ }),

/***/ "./node_modules/ethers/lib.esm/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AbiCoder": () => (/* reexport safe */ _ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__.AbiCoder),
/* harmony export */   "ConstructorFragment": () => (/* reexport safe */ _ethersproject_abi__WEBPACK_IMPORTED_MODULE_1__.ConstructorFragment),
/* harmony export */   "ErrorFragment": () => (/* reexport safe */ _ethersproject_abi__WEBPACK_IMPORTED_MODULE_1__.ErrorFragment),
/* harmony export */   "EventFragment": () => (/* reexport safe */ _ethersproject_abi__WEBPACK_IMPORTED_MODULE_1__.EventFragment),
/* harmony export */   "FormatTypes": () => (/* reexport safe */ _ethersproject_abi__WEBPACK_IMPORTED_MODULE_1__.FormatTypes),
/* harmony export */   "Fragment": () => (/* reexport safe */ _ethersproject_abi__WEBPACK_IMPORTED_MODULE_1__.Fragment),
/* harmony export */   "FunctionFragment": () => (/* reexport safe */ _ethersproject_abi__WEBPACK_IMPORTED_MODULE_1__.FunctionFragment),
/* harmony export */   "HDNode": () => (/* reexport safe */ _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_8__.HDNode),
/* harmony export */   "Indexed": () => (/* reexport safe */ _ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__.Indexed),
/* harmony export */   "Interface": () => (/* reexport safe */ _ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__.Interface),
/* harmony export */   "LogDescription": () => (/* reexport safe */ _ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__.LogDescription),
/* harmony export */   "Logger": () => (/* reexport safe */ _ethersproject_logger__WEBPACK_IMPORTED_MODULE_3__.Logger),
/* harmony export */   "ParamType": () => (/* reexport safe */ _ethersproject_abi__WEBPACK_IMPORTED_MODULE_1__.ParamType),
/* harmony export */   "RLP": () => (/* reexport module object */ _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_4__),
/* harmony export */   "SigningKey": () => (/* reexport safe */ _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_9__.SigningKey),
/* harmony export */   "SupportedAlgorithm": () => (/* reexport safe */ _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_30__.SupportedAlgorithm),
/* harmony export */   "TransactionDescription": () => (/* reexport safe */ _ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__.TransactionDescription),
/* harmony export */   "TransactionTypes": () => (/* reexport safe */ _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_27__.TransactionTypes),
/* harmony export */   "UnicodeNormalizationForm": () => (/* reexport safe */ _ethersproject_strings__WEBPACK_IMPORTED_MODULE_14__.UnicodeNormalizationForm),
/* harmony export */   "Utf8ErrorFuncs": () => (/* reexport safe */ _ethersproject_strings__WEBPACK_IMPORTED_MODULE_14__.Utf8ErrorFuncs),
/* harmony export */   "Utf8ErrorReason": () => (/* reexport safe */ _ethersproject_strings__WEBPACK_IMPORTED_MODULE_14__.Utf8ErrorReason),
/* harmony export */   "_TypedDataEncoder": () => (/* reexport safe */ _ethersproject_hash__WEBPACK_IMPORTED_MODULE_19__.TypedDataEncoder),
/* harmony export */   "_fetchData": () => (/* reexport safe */ _ethersproject_web__WEBPACK_IMPORTED_MODULE_5__._fetchData),
/* harmony export */   "_toEscapedUtf8String": () => (/* reexport safe */ _ethersproject_strings__WEBPACK_IMPORTED_MODULE_14__._toEscapedUtf8String),
/* harmony export */   "accessListify": () => (/* reexport safe */ _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_27__.accessListify),
/* harmony export */   "arrayify": () => (/* reexport safe */ _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.arrayify),
/* harmony export */   "base58": () => (/* reexport safe */ _ethersproject_basex__WEBPACK_IMPORTED_MODULE_11__.Base58),
/* harmony export */   "base64": () => (/* reexport module object */ _ethersproject_base64__WEBPACK_IMPORTED_MODULE_12__),
/* harmony export */   "checkProperties": () => (/* reexport safe */ _ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__.checkProperties),
/* harmony export */   "checkResultErrors": () => (/* reexport safe */ _ethersproject_abi__WEBPACK_IMPORTED_MODULE_2__.checkResultErrors),
/* harmony export */   "commify": () => (/* reexport safe */ _ethersproject_units__WEBPACK_IMPORTED_MODULE_21__.commify),
/* harmony export */   "computeAddress": () => (/* reexport safe */ _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_27__.computeAddress),
/* harmony export */   "computeHmac": () => (/* reexport safe */ _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_22__.computeHmac),
/* harmony export */   "computePublicKey": () => (/* reexport safe */ _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_9__.computePublicKey),
/* harmony export */   "concat": () => (/* reexport safe */ _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.concat),
/* harmony export */   "deepCopy": () => (/* reexport safe */ _ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__.deepCopy),
/* harmony export */   "defaultAbiCoder": () => (/* reexport safe */ _ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__.defaultAbiCoder),
/* harmony export */   "defaultPath": () => (/* reexport safe */ _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_8__.defaultPath),
/* harmony export */   "defineReadOnly": () => (/* reexport safe */ _ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__.defineReadOnly),
/* harmony export */   "dnsEncode": () => (/* reexport safe */ _ethersproject_hash__WEBPACK_IMPORTED_MODULE_16__.dnsEncode),
/* harmony export */   "entropyToMnemonic": () => (/* reexport safe */ _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_8__.entropyToMnemonic),
/* harmony export */   "fetchJson": () => (/* reexport safe */ _ethersproject_web__WEBPACK_IMPORTED_MODULE_5__.fetchJson),
/* harmony export */   "formatBytes32String": () => (/* reexport safe */ _ethersproject_strings__WEBPACK_IMPORTED_MODULE_15__.formatBytes32String),
/* harmony export */   "formatEther": () => (/* reexport safe */ _ethersproject_units__WEBPACK_IMPORTED_MODULE_21__.formatEther),
/* harmony export */   "formatUnits": () => (/* reexport safe */ _ethersproject_units__WEBPACK_IMPORTED_MODULE_21__.formatUnits),
/* harmony export */   "getAccountPath": () => (/* reexport safe */ _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_8__.getAccountPath),
/* harmony export */   "getAddress": () => (/* reexport safe */ _ethersproject_address__WEBPACK_IMPORTED_MODULE_20__.getAddress),
/* harmony export */   "getContractAddress": () => (/* reexport safe */ _ethersproject_address__WEBPACK_IMPORTED_MODULE_20__.getContractAddress),
/* harmony export */   "getCreate2Address": () => (/* reexport safe */ _ethersproject_address__WEBPACK_IMPORTED_MODULE_20__.getCreate2Address),
/* harmony export */   "getIcapAddress": () => (/* reexport safe */ _ethersproject_address__WEBPACK_IMPORTED_MODULE_20__.getIcapAddress),
/* harmony export */   "getJsonWalletAddress": () => (/* reexport safe */ _ethersproject_json_wallets__WEBPACK_IMPORTED_MODULE_28__.getJsonWalletAddress),
/* harmony export */   "getStatic": () => (/* reexport safe */ _ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__.getStatic),
/* harmony export */   "hashMessage": () => (/* reexport safe */ _ethersproject_hash__WEBPACK_IMPORTED_MODULE_17__.hashMessage),
/* harmony export */   "hexConcat": () => (/* reexport safe */ _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexConcat),
/* harmony export */   "hexDataLength": () => (/* reexport safe */ _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexDataLength),
/* harmony export */   "hexDataSlice": () => (/* reexport safe */ _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexDataSlice),
/* harmony export */   "hexStripZeros": () => (/* reexport safe */ _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexStripZeros),
/* harmony export */   "hexValue": () => (/* reexport safe */ _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexValue),
/* harmony export */   "hexZeroPad": () => (/* reexport safe */ _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexZeroPad),
/* harmony export */   "hexlify": () => (/* reexport safe */ _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.hexlify),
/* harmony export */   "id": () => (/* reexport safe */ _ethersproject_hash__WEBPACK_IMPORTED_MODULE_18__.id),
/* harmony export */   "isAddress": () => (/* reexport safe */ _ethersproject_address__WEBPACK_IMPORTED_MODULE_20__.isAddress),
/* harmony export */   "isBytes": () => (/* reexport safe */ _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.isBytes),
/* harmony export */   "isBytesLike": () => (/* reexport safe */ _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.isBytesLike),
/* harmony export */   "isHexString": () => (/* reexport safe */ _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.isHexString),
/* harmony export */   "isValidMnemonic": () => (/* reexport safe */ _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_8__.isValidMnemonic),
/* harmony export */   "isValidName": () => (/* reexport safe */ _ethersproject_hash__WEBPACK_IMPORTED_MODULE_16__.isValidName),
/* harmony export */   "joinSignature": () => (/* reexport safe */ _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.joinSignature),
/* harmony export */   "keccak256": () => (/* reexport safe */ _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_23__.keccak256),
/* harmony export */   "mnemonicToEntropy": () => (/* reexport safe */ _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_8__.mnemonicToEntropy),
/* harmony export */   "mnemonicToSeed": () => (/* reexport safe */ _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_8__.mnemonicToSeed),
/* harmony export */   "namehash": () => (/* reexport safe */ _ethersproject_hash__WEBPACK_IMPORTED_MODULE_16__.namehash),
/* harmony export */   "nameprep": () => (/* reexport safe */ _ethersproject_strings__WEBPACK_IMPORTED_MODULE_13__.nameprep),
/* harmony export */   "parseBytes32String": () => (/* reexport safe */ _ethersproject_strings__WEBPACK_IMPORTED_MODULE_15__.parseBytes32String),
/* harmony export */   "parseEther": () => (/* reexport safe */ _ethersproject_units__WEBPACK_IMPORTED_MODULE_21__.parseEther),
/* harmony export */   "parseTransaction": () => (/* reexport safe */ _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_27__.parse),
/* harmony export */   "parseUnits": () => (/* reexport safe */ _ethersproject_units__WEBPACK_IMPORTED_MODULE_21__.parseUnits),
/* harmony export */   "poll": () => (/* reexport safe */ _ethersproject_web__WEBPACK_IMPORTED_MODULE_5__.poll),
/* harmony export */   "randomBytes": () => (/* reexport safe */ _ethersproject_random__WEBPACK_IMPORTED_MODULE_24__.randomBytes),
/* harmony export */   "recoverAddress": () => (/* reexport safe */ _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_27__.recoverAddress),
/* harmony export */   "recoverPublicKey": () => (/* reexport safe */ _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_9__.recoverPublicKey),
/* harmony export */   "resolveProperties": () => (/* reexport safe */ _ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__.resolveProperties),
/* harmony export */   "ripemd160": () => (/* reexport safe */ _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_22__.ripemd160),
/* harmony export */   "serializeTransaction": () => (/* reexport safe */ _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_27__.serialize),
/* harmony export */   "sha256": () => (/* reexport safe */ _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_22__.sha256),
/* harmony export */   "sha512": () => (/* reexport safe */ _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_22__.sha512),
/* harmony export */   "shallowCopy": () => (/* reexport safe */ _ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__.shallowCopy),
/* harmony export */   "shuffled": () => (/* reexport safe */ _ethersproject_random__WEBPACK_IMPORTED_MODULE_25__.shuffled),
/* harmony export */   "solidityKeccak256": () => (/* reexport safe */ _ethersproject_solidity__WEBPACK_IMPORTED_MODULE_26__.keccak256),
/* harmony export */   "solidityPack": () => (/* reexport safe */ _ethersproject_solidity__WEBPACK_IMPORTED_MODULE_26__.pack),
/* harmony export */   "soliditySha256": () => (/* reexport safe */ _ethersproject_solidity__WEBPACK_IMPORTED_MODULE_26__.sha256),
/* harmony export */   "splitSignature": () => (/* reexport safe */ _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.splitSignature),
/* harmony export */   "stripZeros": () => (/* reexport safe */ _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.stripZeros),
/* harmony export */   "toUtf8Bytes": () => (/* reexport safe */ _ethersproject_strings__WEBPACK_IMPORTED_MODULE_14__.toUtf8Bytes),
/* harmony export */   "toUtf8CodePoints": () => (/* reexport safe */ _ethersproject_strings__WEBPACK_IMPORTED_MODULE_14__.toUtf8CodePoints),
/* harmony export */   "toUtf8String": () => (/* reexport safe */ _ethersproject_strings__WEBPACK_IMPORTED_MODULE_14__.toUtf8String),
/* harmony export */   "verifyMessage": () => (/* reexport safe */ _ethersproject_wallet__WEBPACK_IMPORTED_MODULE_29__.verifyMessage),
/* harmony export */   "verifyTypedData": () => (/* reexport safe */ _ethersproject_wallet__WEBPACK_IMPORTED_MODULE_29__.verifyTypedData),
/* harmony export */   "zeroPad": () => (/* reexport safe */ _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__.zeroPad)
/* harmony export */ });
/* harmony import */ var _ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/abi */ "./node_modules/@ethersproject/abi/lib.esm/abi-coder.js");
/* harmony import */ var _ethersproject_abi__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/abi */ "./node_modules/@ethersproject/abi/lib.esm/fragments.js");
/* harmony import */ var _ethersproject_abi__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/abi */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");
/* harmony import */ var _ethersproject_abi__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/abi */ "./node_modules/@ethersproject/abi/lib.esm/interface.js");
/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @ethersproject/address */ "./node_modules/@ethersproject/address/lib.esm/index.js");
/* harmony import */ var _ethersproject_base64__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @ethersproject/base64 */ "./node_modules/@ethersproject/base64/lib.esm/index.js");
/* harmony import */ var _ethersproject_basex__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @ethersproject/basex */ "./node_modules/@ethersproject/basex/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @ethersproject/hash */ "./node_modules/@ethersproject/hash/lib.esm/namehash.js");
/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @ethersproject/hash */ "./node_modules/@ethersproject/hash/lib.esm/message.js");
/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @ethersproject/hash */ "./node_modules/@ethersproject/hash/lib.esm/id.js");
/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @ethersproject/hash */ "./node_modules/@ethersproject/hash/lib.esm/typed-data.js");
/* harmony import */ var _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/hdnode */ "./node_modules/@ethersproject/hdnode/lib.esm/index.js");
/* harmony import */ var _ethersproject_json_wallets__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! @ethersproject/json-wallets */ "./node_modules/@ethersproject/json-wallets/lib.esm/inspect.js");
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! @ethersproject/sha2 */ "./node_modules/@ethersproject/sha2/lib.esm/sha2.js");
/* harmony import */ var _ethersproject_solidity__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! @ethersproject/solidity */ "./node_modules/@ethersproject/solidity/lib.esm/index.js");
/* harmony import */ var _ethersproject_random__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @ethersproject/random */ "./node_modules/@ethersproject/random/lib.esm/random.js");
/* harmony import */ var _ethersproject_random__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @ethersproject/random */ "./node_modules/@ethersproject/random/lib.esm/shuffle.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/rlp */ "./node_modules/@ethersproject/rlp/lib.esm/index.js");
/* harmony import */ var _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/signing-key */ "./node_modules/@ethersproject/signing-key/lib.esm/index.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/idna.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/utf8.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/bytes32.js");
/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! @ethersproject/transactions */ "./node_modules/@ethersproject/transactions/lib.esm/index.js");
/* harmony import */ var _ethersproject_units__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @ethersproject/units */ "./node_modules/@ethersproject/units/lib.esm/index.js");
/* harmony import */ var _ethersproject_wallet__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! @ethersproject/wallet */ "./node_modules/@ethersproject/wallet/lib.esm/index.js");
/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/web */ "./node_modules/@ethersproject/web/lib.esm/index.js");
/* harmony import */ var _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! @ethersproject/sha2 */ "./node_modules/@ethersproject/sha2/lib.esm/types.js");






















 ////////////////////////
// Enums


 ////////////////////////
// Exports



/***/ }),

/***/ "./node_modules/ethers/lib/utils.js":
/*!******************************************!*\
  !*** ./node_modules/ethers/lib/utils.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.formatBytes32String = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports._toEscapedUtf8String = exports.nameprep = exports.hexDataSlice = exports.hexDataLength = exports.hexZeroPad = exports.hexValue = exports.hexStripZeros = exports.hexConcat = exports.isHexString = exports.hexlify = exports.base64 = exports.base58 = exports.TransactionDescription = exports.LogDescription = exports.Interface = exports.SigningKey = exports.HDNode = exports.defaultPath = exports.isBytesLike = exports.isBytes = exports.zeroPad = exports.stripZeros = exports.concat = exports.arrayify = exports.shallowCopy = exports.resolveProperties = exports.getStatic = exports.defineReadOnly = exports.deepCopy = exports.checkProperties = exports.poll = exports.fetchJson = exports._fetchData = exports.RLP = exports.Logger = exports.checkResultErrors = exports.FormatTypes = exports.ParamType = exports.FunctionFragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.Fragment = exports.defaultAbiCoder = exports.AbiCoder = void 0;
exports.Indexed = exports.Utf8ErrorReason = exports.UnicodeNormalizationForm = exports.SupportedAlgorithm = exports.mnemonicToSeed = exports.isValidMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.getAccountPath = exports.verifyTypedData = exports.verifyMessage = exports.recoverPublicKey = exports.computePublicKey = exports.recoverAddress = exports.computeAddress = exports.getJsonWalletAddress = exports.TransactionTypes = exports.serializeTransaction = exports.parseTransaction = exports.accessListify = exports.joinSignature = exports.splitSignature = exports.soliditySha256 = exports.solidityKeccak256 = exports.solidityPack = exports.shuffled = exports.randomBytes = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.keccak256 = exports.computeHmac = exports.commify = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.isAddress = exports.getCreate2Address = exports.getContractAddress = exports.getIcapAddress = exports.getAddress = exports._TypedDataEncoder = exports.id = exports.isValidName = exports.namehash = exports.hashMessage = exports.dnsEncode = exports.parseBytes32String = void 0;

var abi_1 = __webpack_require__(/*! @ethersproject/abi */ "./node_modules/@ethersproject/abi/lib.esm/index.js");

Object.defineProperty(exports, "AbiCoder", ({
  enumerable: true,
  get: function () {
    return abi_1.AbiCoder;
  }
}));
Object.defineProperty(exports, "checkResultErrors", ({
  enumerable: true,
  get: function () {
    return abi_1.checkResultErrors;
  }
}));
Object.defineProperty(exports, "ConstructorFragment", ({
  enumerable: true,
  get: function () {
    return abi_1.ConstructorFragment;
  }
}));
Object.defineProperty(exports, "defaultAbiCoder", ({
  enumerable: true,
  get: function () {
    return abi_1.defaultAbiCoder;
  }
}));
Object.defineProperty(exports, "ErrorFragment", ({
  enumerable: true,
  get: function () {
    return abi_1.ErrorFragment;
  }
}));
Object.defineProperty(exports, "EventFragment", ({
  enumerable: true,
  get: function () {
    return abi_1.EventFragment;
  }
}));
Object.defineProperty(exports, "FormatTypes", ({
  enumerable: true,
  get: function () {
    return abi_1.FormatTypes;
  }
}));
Object.defineProperty(exports, "Fragment", ({
  enumerable: true,
  get: function () {
    return abi_1.Fragment;
  }
}));
Object.defineProperty(exports, "FunctionFragment", ({
  enumerable: true,
  get: function () {
    return abi_1.FunctionFragment;
  }
}));
Object.defineProperty(exports, "Indexed", ({
  enumerable: true,
  get: function () {
    return abi_1.Indexed;
  }
}));
Object.defineProperty(exports, "Interface", ({
  enumerable: true,
  get: function () {
    return abi_1.Interface;
  }
}));
Object.defineProperty(exports, "LogDescription", ({
  enumerable: true,
  get: function () {
    return abi_1.LogDescription;
  }
}));
Object.defineProperty(exports, "ParamType", ({
  enumerable: true,
  get: function () {
    return abi_1.ParamType;
  }
}));
Object.defineProperty(exports, "TransactionDescription", ({
  enumerable: true,
  get: function () {
    return abi_1.TransactionDescription;
  }
}));

var address_1 = __webpack_require__(/*! @ethersproject/address */ "./node_modules/@ethersproject/address/lib.esm/index.js");

Object.defineProperty(exports, "getAddress", ({
  enumerable: true,
  get: function () {
    return address_1.getAddress;
  }
}));
Object.defineProperty(exports, "getCreate2Address", ({
  enumerable: true,
  get: function () {
    return address_1.getCreate2Address;
  }
}));
Object.defineProperty(exports, "getContractAddress", ({
  enumerable: true,
  get: function () {
    return address_1.getContractAddress;
  }
}));
Object.defineProperty(exports, "getIcapAddress", ({
  enumerable: true,
  get: function () {
    return address_1.getIcapAddress;
  }
}));
Object.defineProperty(exports, "isAddress", ({
  enumerable: true,
  get: function () {
    return address_1.isAddress;
  }
}));

var base64 = __importStar(__webpack_require__(/*! @ethersproject/base64 */ "./node_modules/@ethersproject/base64/lib.esm/index.js"));

exports.base64 = base64;

var basex_1 = __webpack_require__(/*! @ethersproject/basex */ "./node_modules/@ethersproject/basex/lib.esm/index.js");

Object.defineProperty(exports, "base58", ({
  enumerable: true,
  get: function () {
    return basex_1.Base58;
  }
}));

var bytes_1 = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");

Object.defineProperty(exports, "arrayify", ({
  enumerable: true,
  get: function () {
    return bytes_1.arrayify;
  }
}));
Object.defineProperty(exports, "concat", ({
  enumerable: true,
  get: function () {
    return bytes_1.concat;
  }
}));
Object.defineProperty(exports, "hexConcat", ({
  enumerable: true,
  get: function () {
    return bytes_1.hexConcat;
  }
}));
Object.defineProperty(exports, "hexDataSlice", ({
  enumerable: true,
  get: function () {
    return bytes_1.hexDataSlice;
  }
}));
Object.defineProperty(exports, "hexDataLength", ({
  enumerable: true,
  get: function () {
    return bytes_1.hexDataLength;
  }
}));
Object.defineProperty(exports, "hexlify", ({
  enumerable: true,
  get: function () {
    return bytes_1.hexlify;
  }
}));
Object.defineProperty(exports, "hexStripZeros", ({
  enumerable: true,
  get: function () {
    return bytes_1.hexStripZeros;
  }
}));
Object.defineProperty(exports, "hexValue", ({
  enumerable: true,
  get: function () {
    return bytes_1.hexValue;
  }
}));
Object.defineProperty(exports, "hexZeroPad", ({
  enumerable: true,
  get: function () {
    return bytes_1.hexZeroPad;
  }
}));
Object.defineProperty(exports, "isBytes", ({
  enumerable: true,
  get: function () {
    return bytes_1.isBytes;
  }
}));
Object.defineProperty(exports, "isBytesLike", ({
  enumerable: true,
  get: function () {
    return bytes_1.isBytesLike;
  }
}));
Object.defineProperty(exports, "isHexString", ({
  enumerable: true,
  get: function () {
    return bytes_1.isHexString;
  }
}));
Object.defineProperty(exports, "joinSignature", ({
  enumerable: true,
  get: function () {
    return bytes_1.joinSignature;
  }
}));
Object.defineProperty(exports, "zeroPad", ({
  enumerable: true,
  get: function () {
    return bytes_1.zeroPad;
  }
}));
Object.defineProperty(exports, "splitSignature", ({
  enumerable: true,
  get: function () {
    return bytes_1.splitSignature;
  }
}));
Object.defineProperty(exports, "stripZeros", ({
  enumerable: true,
  get: function () {
    return bytes_1.stripZeros;
  }
}));

var hash_1 = __webpack_require__(/*! @ethersproject/hash */ "./node_modules/@ethersproject/hash/lib.esm/index.js");

Object.defineProperty(exports, "_TypedDataEncoder", ({
  enumerable: true,
  get: function () {
    return hash_1._TypedDataEncoder;
  }
}));
Object.defineProperty(exports, "dnsEncode", ({
  enumerable: true,
  get: function () {
    return hash_1.dnsEncode;
  }
}));
Object.defineProperty(exports, "hashMessage", ({
  enumerable: true,
  get: function () {
    return hash_1.hashMessage;
  }
}));
Object.defineProperty(exports, "id", ({
  enumerable: true,
  get: function () {
    return hash_1.id;
  }
}));
Object.defineProperty(exports, "isValidName", ({
  enumerable: true,
  get: function () {
    return hash_1.isValidName;
  }
}));
Object.defineProperty(exports, "namehash", ({
  enumerable: true,
  get: function () {
    return hash_1.namehash;
  }
}));

var hdnode_1 = __webpack_require__(/*! @ethersproject/hdnode */ "./node_modules/@ethersproject/hdnode/lib.esm/index.js");

Object.defineProperty(exports, "defaultPath", ({
  enumerable: true,
  get: function () {
    return hdnode_1.defaultPath;
  }
}));
Object.defineProperty(exports, "entropyToMnemonic", ({
  enumerable: true,
  get: function () {
    return hdnode_1.entropyToMnemonic;
  }
}));
Object.defineProperty(exports, "getAccountPath", ({
  enumerable: true,
  get: function () {
    return hdnode_1.getAccountPath;
  }
}));
Object.defineProperty(exports, "HDNode", ({
  enumerable: true,
  get: function () {
    return hdnode_1.HDNode;
  }
}));
Object.defineProperty(exports, "isValidMnemonic", ({
  enumerable: true,
  get: function () {
    return hdnode_1.isValidMnemonic;
  }
}));
Object.defineProperty(exports, "mnemonicToEntropy", ({
  enumerable: true,
  get: function () {
    return hdnode_1.mnemonicToEntropy;
  }
}));
Object.defineProperty(exports, "mnemonicToSeed", ({
  enumerable: true,
  get: function () {
    return hdnode_1.mnemonicToSeed;
  }
}));

var json_wallets_1 = __webpack_require__(/*! @ethersproject/json-wallets */ "./node_modules/@ethersproject/json-wallets/lib.esm/index.js");

Object.defineProperty(exports, "getJsonWalletAddress", ({
  enumerable: true,
  get: function () {
    return json_wallets_1.getJsonWalletAddress;
  }
}));

var keccak256_1 = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");

Object.defineProperty(exports, "keccak256", ({
  enumerable: true,
  get: function () {
    return keccak256_1.keccak256;
  }
}));

var logger_1 = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");

Object.defineProperty(exports, "Logger", ({
  enumerable: true,
  get: function () {
    return logger_1.Logger;
  }
}));

var sha2_1 = __webpack_require__(/*! @ethersproject/sha2 */ "./node_modules/@ethersproject/sha2/lib.esm/index.js");

Object.defineProperty(exports, "computeHmac", ({
  enumerable: true,
  get: function () {
    return sha2_1.computeHmac;
  }
}));
Object.defineProperty(exports, "ripemd160", ({
  enumerable: true,
  get: function () {
    return sha2_1.ripemd160;
  }
}));
Object.defineProperty(exports, "sha256", ({
  enumerable: true,
  get: function () {
    return sha2_1.sha256;
  }
}));
Object.defineProperty(exports, "sha512", ({
  enumerable: true,
  get: function () {
    return sha2_1.sha512;
  }
}));

var solidity_1 = __webpack_require__(/*! @ethersproject/solidity */ "./node_modules/@ethersproject/solidity/lib.esm/index.js");

Object.defineProperty(exports, "solidityKeccak256", ({
  enumerable: true,
  get: function () {
    return solidity_1.keccak256;
  }
}));
Object.defineProperty(exports, "solidityPack", ({
  enumerable: true,
  get: function () {
    return solidity_1.pack;
  }
}));
Object.defineProperty(exports, "soliditySha256", ({
  enumerable: true,
  get: function () {
    return solidity_1.sha256;
  }
}));

var random_1 = __webpack_require__(/*! @ethersproject/random */ "./node_modules/@ethersproject/random/lib.esm/index.js");

Object.defineProperty(exports, "randomBytes", ({
  enumerable: true,
  get: function () {
    return random_1.randomBytes;
  }
}));
Object.defineProperty(exports, "shuffled", ({
  enumerable: true,
  get: function () {
    return random_1.shuffled;
  }
}));

var properties_1 = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");

Object.defineProperty(exports, "checkProperties", ({
  enumerable: true,
  get: function () {
    return properties_1.checkProperties;
  }
}));
Object.defineProperty(exports, "deepCopy", ({
  enumerable: true,
  get: function () {
    return properties_1.deepCopy;
  }
}));
Object.defineProperty(exports, "defineReadOnly", ({
  enumerable: true,
  get: function () {
    return properties_1.defineReadOnly;
  }
}));
Object.defineProperty(exports, "getStatic", ({
  enumerable: true,
  get: function () {
    return properties_1.getStatic;
  }
}));
Object.defineProperty(exports, "resolveProperties", ({
  enumerable: true,
  get: function () {
    return properties_1.resolveProperties;
  }
}));
Object.defineProperty(exports, "shallowCopy", ({
  enumerable: true,
  get: function () {
    return properties_1.shallowCopy;
  }
}));

var RLP = __importStar(__webpack_require__(/*! @ethersproject/rlp */ "./node_modules/@ethersproject/rlp/lib.esm/index.js"));

exports.RLP = RLP;

var signing_key_1 = __webpack_require__(/*! @ethersproject/signing-key */ "./node_modules/@ethersproject/signing-key/lib.esm/index.js");

Object.defineProperty(exports, "computePublicKey", ({
  enumerable: true,
  get: function () {
    return signing_key_1.computePublicKey;
  }
}));
Object.defineProperty(exports, "recoverPublicKey", ({
  enumerable: true,
  get: function () {
    return signing_key_1.recoverPublicKey;
  }
}));
Object.defineProperty(exports, "SigningKey", ({
  enumerable: true,
  get: function () {
    return signing_key_1.SigningKey;
  }
}));

var strings_1 = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/index.js");

Object.defineProperty(exports, "formatBytes32String", ({
  enumerable: true,
  get: function () {
    return strings_1.formatBytes32String;
  }
}));
Object.defineProperty(exports, "nameprep", ({
  enumerable: true,
  get: function () {
    return strings_1.nameprep;
  }
}));
Object.defineProperty(exports, "parseBytes32String", ({
  enumerable: true,
  get: function () {
    return strings_1.parseBytes32String;
  }
}));
Object.defineProperty(exports, "_toEscapedUtf8String", ({
  enumerable: true,
  get: function () {
    return strings_1._toEscapedUtf8String;
  }
}));
Object.defineProperty(exports, "toUtf8Bytes", ({
  enumerable: true,
  get: function () {
    return strings_1.toUtf8Bytes;
  }
}));
Object.defineProperty(exports, "toUtf8CodePoints", ({
  enumerable: true,
  get: function () {
    return strings_1.toUtf8CodePoints;
  }
}));
Object.defineProperty(exports, "toUtf8String", ({
  enumerable: true,
  get: function () {
    return strings_1.toUtf8String;
  }
}));
Object.defineProperty(exports, "Utf8ErrorFuncs", ({
  enumerable: true,
  get: function () {
    return strings_1.Utf8ErrorFuncs;
  }
}));

var transactions_1 = __webpack_require__(/*! @ethersproject/transactions */ "./node_modules/@ethersproject/transactions/lib.esm/index.js");

Object.defineProperty(exports, "accessListify", ({
  enumerable: true,
  get: function () {
    return transactions_1.accessListify;
  }
}));
Object.defineProperty(exports, "computeAddress", ({
  enumerable: true,
  get: function () {
    return transactions_1.computeAddress;
  }
}));
Object.defineProperty(exports, "parseTransaction", ({
  enumerable: true,
  get: function () {
    return transactions_1.parse;
  }
}));
Object.defineProperty(exports, "recoverAddress", ({
  enumerable: true,
  get: function () {
    return transactions_1.recoverAddress;
  }
}));
Object.defineProperty(exports, "serializeTransaction", ({
  enumerable: true,
  get: function () {
    return transactions_1.serialize;
  }
}));
Object.defineProperty(exports, "TransactionTypes", ({
  enumerable: true,
  get: function () {
    return transactions_1.TransactionTypes;
  }
}));

var units_1 = __webpack_require__(/*! @ethersproject/units */ "./node_modules/@ethersproject/units/lib.esm/index.js");

Object.defineProperty(exports, "commify", ({
  enumerable: true,
  get: function () {
    return units_1.commify;
  }
}));
Object.defineProperty(exports, "formatEther", ({
  enumerable: true,
  get: function () {
    return units_1.formatEther;
  }
}));
Object.defineProperty(exports, "parseEther", ({
  enumerable: true,
  get: function () {
    return units_1.parseEther;
  }
}));
Object.defineProperty(exports, "formatUnits", ({
  enumerable: true,
  get: function () {
    return units_1.formatUnits;
  }
}));
Object.defineProperty(exports, "parseUnits", ({
  enumerable: true,
  get: function () {
    return units_1.parseUnits;
  }
}));

var wallet_1 = __webpack_require__(/*! @ethersproject/wallet */ "./node_modules/@ethersproject/wallet/lib.esm/index.js");

Object.defineProperty(exports, "verifyMessage", ({
  enumerable: true,
  get: function () {
    return wallet_1.verifyMessage;
  }
}));
Object.defineProperty(exports, "verifyTypedData", ({
  enumerable: true,
  get: function () {
    return wallet_1.verifyTypedData;
  }
}));

var web_1 = __webpack_require__(/*! @ethersproject/web */ "./node_modules/@ethersproject/web/lib.esm/index.js");

Object.defineProperty(exports, "_fetchData", ({
  enumerable: true,
  get: function () {
    return web_1._fetchData;
  }
}));
Object.defineProperty(exports, "fetchJson", ({
  enumerable: true,
  get: function () {
    return web_1.fetchJson;
  }
}));
Object.defineProperty(exports, "poll", ({
  enumerable: true,
  get: function () {
    return web_1.poll;
  }
})); ////////////////////////
// Enums

var sha2_2 = __webpack_require__(/*! @ethersproject/sha2 */ "./node_modules/@ethersproject/sha2/lib.esm/index.js");

Object.defineProperty(exports, "SupportedAlgorithm", ({
  enumerable: true,
  get: function () {
    return sha2_2.SupportedAlgorithm;
  }
}));

var strings_2 = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/index.js");

Object.defineProperty(exports, "UnicodeNormalizationForm", ({
  enumerable: true,
  get: function () {
    return strings_2.UnicodeNormalizationForm;
  }
}));
Object.defineProperty(exports, "Utf8ErrorReason", ({
  enumerable: true,
  get: function () {
    return strings_2.Utf8ErrorReason;
  }
}));

/***/ }),

/***/ "./node_modules/hash.js/lib/hash.js":
/*!******************************************!*\
  !*** ./node_modules/hash.js/lib/hash.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var hash = exports;
hash.utils = __webpack_require__(/*! ./hash/utils */ "./node_modules/hash.js/lib/hash/utils.js");
hash.common = __webpack_require__(/*! ./hash/common */ "./node_modules/hash.js/lib/hash/common.js");
hash.sha = __webpack_require__(/*! ./hash/sha */ "./node_modules/hash.js/lib/hash/sha.js");
hash.ripemd = __webpack_require__(/*! ./hash/ripemd */ "./node_modules/hash.js/lib/hash/ripemd.js");
hash.hmac = __webpack_require__(/*! ./hash/hmac */ "./node_modules/hash.js/lib/hash/hmac.js"); // Proxy hash functions to the main object

hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/common.js":
/*!*************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/common.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/hash.js/lib/hash/utils.js");

var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';
  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}

exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending) this.pending = msg;else this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length; // Enough data, try updating

  if (this.pending.length >= this._delta8) {
    msg = this.pending; // Process pending data in blocks

    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0) this.pending = null;
    msg = utils.join32(msg, 0, msg.length - r, this.endian);

    for (var i = 0; i < msg.length; i += this._delta32) this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);
  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - (len + this.padLength) % bytes;
  var res = new Array(k + this.padLength);
  res[0] = 0x80;

  for (var i = 1; i < k; i++) res[i] = 0; // Append length


  len <<= 3;

  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++) res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = len >>> 24 & 0xff;
    res[i++] = len >>> 16 & 0xff;
    res[i++] = len >>> 8 & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = len >>> 8 & 0xff;
    res[i++] = len >>> 16 & 0xff;
    res[i++] = len >>> 24 & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++) res[i++] = 0;
  }

  return res;
};

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/hmac.js":
/*!***********************************************!*\
  !*** ./node_modules/hash.js/lib/hash/hmac.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/hash.js/lib/hash/utils.js");

var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac)) return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}

module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize) key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize); // Add padding to key

  for (var i = key.length; i < this.blockSize; i++) key.push(0);

  for (i = 0; i < key.length; i++) key[i] ^= 0x36;

  this.inner = new this.Hash().update(key); // 0x36 ^ 0x5c = 0x6a

  for (i = 0; i < key.length; i++) key[i] ^= 0x6a;

  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/ripemd.js":
/*!*************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/ripemd.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/hash.js/lib/hash/utils.js");

var common = __webpack_require__(/*! ./common */ "./node_modules/hash.js/lib/hash/common.js");

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160)) return new RIPEMD160();
  BlockHash.call(this);
  this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
  this.endian = 'little';
}

utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;
RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;

  for (var j = 0; j < 80; j++) {
    var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }

  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils.toHex32(this.h, 'little');else return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15) return x ^ y ^ z;else if (j <= 31) return x & y | ~x & z;else if (j <= 47) return (x | ~y) ^ z;else if (j <= 63) return x & z | y & ~z;else return x ^ (y | ~z);
}

function K(j) {
  if (j <= 15) return 0x00000000;else if (j <= 31) return 0x5a827999;else if (j <= 47) return 0x6ed9eba1;else if (j <= 63) return 0x8f1bbcdc;else return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15) return 0x50a28be6;else if (j <= 31) return 0x5c4dd124;else if (j <= 47) return 0x6d703ef3;else if (j <= 63) return 0x7a6d76e9;else return 0x00000000;
}

var r = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
var rh = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
var s = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
var sh = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha.js":
/*!**********************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.sha1 = __webpack_require__(/*! ./sha/1 */ "./node_modules/hash.js/lib/hash/sha/1.js");
exports.sha224 = __webpack_require__(/*! ./sha/224 */ "./node_modules/hash.js/lib/hash/sha/224.js");
exports.sha256 = __webpack_require__(/*! ./sha/256 */ "./node_modules/hash.js/lib/hash/sha/256.js");
exports.sha384 = __webpack_require__(/*! ./sha/384 */ "./node_modules/hash.js/lib/hash/sha/384.js");
exports.sha512 = __webpack_require__(/*! ./sha/512 */ "./node_modules/hash.js/lib/hash/sha/512.js");

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/1.js":
/*!************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/1.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");

var common = __webpack_require__(/*! ../common */ "./node_modules/hash.js/lib/hash/common.js");

var shaCommon = __webpack_require__(/*! ./common */ "./node_modules/hash.js/lib/hash/sha/common.js");

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;
var sha1_K = [0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6];

function SHA1() {
  if (!(this instanceof SHA1)) return new SHA1();
  BlockHash.call(this);
  this.h = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;
SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++) W[i] = msg[start + i];

  for (; i < W.length; i++) W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils.toHex32(this.h, 'big');else return utils.split32(this.h, 'big');
};

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/224.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/224.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");

var SHA256 = __webpack_require__(/*! ./256 */ "./node_modules/hash.js/lib/hash/sha/256.js");

function SHA224() {
  if (!(this instanceof SHA224)) return new SHA224();
  SHA256.call(this);
  this.h = [0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4];
}

utils.inherits(SHA224, SHA256);
module.exports = SHA224;
SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex') return utils.toHex32(this.h.slice(0, 7), 'big');else return utils.split32(this.h.slice(0, 7), 'big');
};

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/256.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/256.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");

var common = __webpack_require__(/*! ../common */ "./node_modules/hash.js/lib/hash/common.js");

var shaCommon = __webpack_require__(/*! ./common */ "./node_modules/hash.js/lib/hash/sha/common.js");

var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;
var BlockHash = common.BlockHash;
var sha256_K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];

function SHA256() {
  if (!(this instanceof SHA256)) return new SHA256();
  BlockHash.call(this);
  this.h = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];
  this.k = sha256_K;
  this.W = new Array(64);
}

utils.inherits(SHA256, BlockHash);
module.exports = SHA256;
SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++) W[i] = msg[start + i];

  for (; i < W.length; i++) W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];
  assert(this.k.length === W.length);

  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils.toHex32(this.h, 'big');else return utils.split32(this.h, 'big');
};

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/384.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/384.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");

var SHA512 = __webpack_require__(/*! ./512 */ "./node_modules/hash.js/lib/hash/sha/512.js");

function SHA384() {
  if (!(this instanceof SHA384)) return new SHA384();
  SHA512.call(this);
  this.h = [0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939, 0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4];
}

utils.inherits(SHA384, SHA512);
module.exports = SHA384;
SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils.toHex32(this.h.slice(0, 12), 'big');else return utils.split32(this.h.slice(0, 12), 'big');
};

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/512.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/512.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");

var common = __webpack_require__(/*! ../common */ "./node_modules/hash.js/lib/hash/common.js");

var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;
var BlockHash = common.BlockHash;
var sha512_K = [0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd, 0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc, 0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019, 0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118, 0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe, 0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2, 0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1, 0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694, 0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3, 0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65, 0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483, 0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5, 0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210, 0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4, 0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725, 0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70, 0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926, 0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df, 0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8, 0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b, 0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001, 0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30, 0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910, 0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8, 0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53, 0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8, 0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb, 0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3, 0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60, 0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec, 0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9, 0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b, 0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207, 0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178, 0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6, 0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b, 0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493, 0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c, 0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a, 0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817];

function SHA512() {
  if (!(this instanceof SHA512)) return new SHA512();
  BlockHash.call(this);
  this.h = [0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1, 0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179];
  this.k = sha512_K;
  this.W = new Array(160);
}

utils.inherits(SHA512, BlockHash);
module.exports = SHA512;
SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W; // 32 x 32bit words

  for (var i = 0; i < 32; i++) W[i] = msg[start + i];

  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]); // i - 2

    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14]; // i - 7

    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]); // i - 15

    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32]; // i - 16

    var c3_lo = W[i - 31];
    W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;
  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];
  assert(this.k.length === W.length);

  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];
    var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
    hh = gh;
    hl = gl;
    gh = fh;
    gl = fl;
    fh = eh;
    fl = el;
    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);
    dh = ch;
    dl = cl;
    ch = bh;
    cl = bl;
    bh = ah;
    bl = al;
    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex') return utils.toHex32(this.h, 'big');else return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = xh & yh ^ ~xh & zh;
  if (r < 0) r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = xl & yl ^ ~xl & zl;
  if (r < 0) r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = xh & yh ^ xh & zh ^ yh & zh;
  if (r < 0) r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = xl & yl ^ xl & zl ^ yl & zl;
  if (r < 0) r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2); // 34

  var c2_hi = rotr64_hi(xl, xh, 7); // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0) r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2); // 34

  var c2_lo = rotr64_lo(xl, xh, 7); // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0) r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9); // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0) r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9); // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0) r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);
  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0) r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);
  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0) r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29); // 61

  var c2_hi = shr64_hi(xh, xl, 6);
  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0) r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29); // 61

  var c2_lo = shr64_lo(xh, xl, 6);
  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0) r += 0x100000000;
  return r;
}

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/common.js":
/*!*****************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/common.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");

var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0) return ch32(x, y, z);
  if (s === 1 || s === 3) return p32(x, y, z);
  if (s === 2) return maj32(x, y, z);
}

exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return x & y ^ ~x & z;
}

exports.ch32 = ch32;

function maj32(x, y, z) {
  return x & y ^ x & z ^ y & z;
}

exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}

exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}

exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}

exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
}

exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
}

exports.g1_256 = g1_256;

/***/ }),

/***/ "./node_modules/hash.js/lib/hash/utils.js":
/*!************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/utils.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }

  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }

  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg)) return msg.slice();
  if (!msg) return [];
  var res = [];

  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;

      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);

        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = c >> 6 | 192;
          res[p++] = c & 63 | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = c >> 18 | 240;
          res[p++] = c >> 12 & 63 | 128;
          res[p++] = c >> 6 & 63 | 128;
          res[p++] = c & 63 | 128;
        } else {
          res[p++] = c >> 12 | 224;
          res[p++] = c >> 6 & 63 | 128;
          res[p++] = c & 63 | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0) msg = '0' + msg;

      for (i = 0; i < msg.length; i += 2) res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++) res[i] = msg[i] | 0;
  }

  return res;
}

exports.toArray = toArray;

function toHex(msg) {
  var res = '';

  for (var i = 0; i < msg.length; i++) res += zero2(msg[i].toString(16));

  return res;
}

exports.toHex = toHex;

function htonl(w) {
  var res = w >>> 24 | w >>> 8 & 0xff00 | w << 8 & 0xff0000 | (w & 0xff) << 24;
  return res >>> 0;
}

exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';

  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little') w = htonl(w);
    res += zero8(w.toString(16));
  }

  return res;
}

exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1) return '0' + word;else return word;
}

exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7) return '0' + word;else if (word.length === 6) return '00' + word;else if (word.length === 5) return '000' + word;else if (word.length === 4) return '0000' + word;else if (word.length === 3) return '00000' + word;else if (word.length === 2) return '000000' + word;else if (word.length === 1) return '0000000' + word;else return word;
}

exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);

  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big') w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];else w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
    res[i] = w >>> 0;
  }

  return res;
}

exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);

  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];

    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = m >>> 16 & 0xff;
      res[k + 2] = m >>> 8 & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = m >>> 16 & 0xff;
      res[k + 1] = m >>> 8 & 0xff;
      res[k] = m & 0xff;
    }
  }

  return res;
}

exports.split32 = split32;

function rotr32(w, b) {
  return w >>> b | w << 32 - b;
}

exports.rotr32 = rotr32;

function rotl32(w, b) {
  return w << b | w >>> 32 - b;
}

exports.rotl32 = rotl32;

function sum32(a, b) {
  return a + b >>> 0;
}

exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return a + b + c >>> 0;
}

exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return a + b + c + d >>> 0;
}

exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return a + b + c + d + e >>> 0;
}

exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}

exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = al + bl >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}

exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}

exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}

exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}

exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = lo + bl >>> 0;
  carry += lo < al ? 1 : 0;
  lo = lo + cl >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = lo + dl >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = lo + el >>> 0;
  carry += lo < el ? 1 : 0;
  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}

exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;
  return lo >>> 0;
}

exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = al << 32 - num | ah >>> num;
  return r >>> 0;
}

exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = ah << 32 - num | al >>> num;
  return r >>> 0;
}

exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}

exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = ah << 32 - num | al >>> num;
  return r >>> 0;
}

exports.shr64_lo = shr64_lo;

/***/ }),

/***/ "./node_modules/hmac-drbg/lib/hmac-drbg.js":
/*!*************************************************!*\
  !*** ./node_modules/hmac-drbg/lib/hmac-drbg.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hash = __webpack_require__(/*! hash.js */ "./node_modules/hash.js/lib/hash.js");

var utils = __webpack_require__(/*! minimalistic-crypto-utils */ "./node_modules/minimalistic-crypto-utils/lib/utils.js");

var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG)) return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;
  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;
  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;
  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._init(entropy, nonce, pers);
}

module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);
  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);

  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);

  this._reseed = 1;
  this.reseedInterval = 0x1000000000000; // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac().update(this.V).update([0x00]);

  if (seed) kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed) return;
  this.K = this._hmac().update(this.V).update([0x01]).update(seed).digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);
  assert(entropy.length >= this.minEntropy / 8, 'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));

  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval) throw new Error('Reseed is required'); // Optional encoding

  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  } // Optional additional data


  if (add) {
    add = utils.toArray(add, addEnc || 'hex');

    this._update(add);
  }

  var temp = [];

  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);

  this._update(add);

  this._reseed++;
  return utils.encode(res, enc);
};

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;

      var TempCtor = function () {};

      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

/***/ }),

/***/ "./node_modules/isomorphic-ws/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/isomorphic-ws/browser.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// https://github.com/maxogden/websocket-stream/blob/48dc3ddf943e5ada668c31ccd94e9186f02fafbd/ws-fallback.js
var ws = null;

if (typeof WebSocket !== 'undefined') {
  ws = WebSocket;
} else if (typeof MozWebSocket !== 'undefined') {
  ws = MozWebSocket;
} else if (typeof __webpack_require__.g !== 'undefined') {
  ws = __webpack_require__.g.WebSocket || __webpack_require__.g.MozWebSocket;
} else if (typeof window !== 'undefined') {
  ws = window.WebSocket || window.MozWebSocket;
} else if (typeof self !== 'undefined') {
  ws = self.WebSocket || self.MozWebSocket;
}

module.exports = ws;

/***/ }),

/***/ "./node_modules/js-sha3/src/sha3.js":
/*!******************************************!*\
  !*** ./node_modules/js-sha3/src/sha3.js ***!
  \******************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */

/*jslint bitwise: true */
(function () {
  'use strict';

  var INPUT_ERROR = 'input is invalid type';
  var FINALIZE_ERROR = 'finalize already called';
  var WINDOW = typeof window === 'object';
  var root = WINDOW ? window : {};

  if (root.JS_SHA3_NO_WINDOW) {
    WINDOW = false;
  }

  var WEB_WORKER = !WINDOW && typeof self === 'object';
  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;

  if (NODE_JS) {
    root = __webpack_require__.g;
  } else if (WEB_WORKER) {
    root = self;
  }

  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && "object" === 'object' && module.exports;
  var AMD =  true && __webpack_require__.amdO;
  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
  var KECCAK_PADDING = [1, 256, 65536, 16777216];
  var PADDING = [6, 1536, 393216, 100663296];
  var SHIFT = [0, 8, 16, 24];
  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
  var BITS = [224, 256, 384, 512];
  var SHAKE_BITS = [128, 256];
  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
  var CSHAKE_BYTEPAD = {
    '128': 168,
    '256': 136
  };

  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }

  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  var createOutputMethod = function (bits, padding, outputType) {
    return function (message) {
      return new Keccak(bits, padding, bits).update(message)[outputType]();
    };
  };

  var createShakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits) {
      return new Keccak(bits, padding, outputBits).update(message)[outputType]();
    };
  };

  var createCshakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits, n, s) {
      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
    };
  };

  var createKmacOutputMethod = function (bits, padding, outputType) {
    return function (key, message, outputBits, s) {
      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
    };
  };

  var createOutputMethods = function (method, createMethod, bits, padding) {
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createMethod(bits, padding, type);
    }

    return method;
  };

  var createMethod = function (bits, padding) {
    var method = createOutputMethod(bits, padding, 'hex');

    method.create = function () {
      return new Keccak(bits, padding, bits);
    };

    method.update = function (message) {
      return method.create().update(message);
    };

    return createOutputMethods(method, createOutputMethod, bits, padding);
  };

  var createShakeMethod = function (bits, padding) {
    var method = createShakeOutputMethod(bits, padding, 'hex');

    method.create = function (outputBits) {
      return new Keccak(bits, padding, outputBits);
    };

    method.update = function (message, outputBits) {
      return method.create(outputBits).update(message);
    };

    return createOutputMethods(method, createShakeOutputMethod, bits, padding);
  };

  var createCshakeMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createCshakeOutputMethod(bits, padding, 'hex');

    method.create = function (outputBits, n, s) {
      if (!n && !s) {
        return methods['shake' + bits].create(outputBits);
      } else {
        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
      }
    };

    method.update = function (message, outputBits, n, s) {
      return method.create(outputBits, n, s).update(message);
    };

    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
  };

  var createKmacMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createKmacOutputMethod(bits, padding, 'hex');

    method.create = function (key, outputBits, s) {
      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
    };

    method.update = function (key, message, outputBits, s) {
      return method.create(key, outputBits, s).update(message);
    };

    return createOutputMethods(method, createKmacOutputMethod, bits, padding);
  };

  var algorithms = [{
    name: 'keccak',
    padding: KECCAK_PADDING,
    bits: BITS,
    createMethod: createMethod
  }, {
    name: 'sha3',
    padding: PADDING,
    bits: BITS,
    createMethod: createMethod
  }, {
    name: 'shake',
    padding: SHAKE_PADDING,
    bits: SHAKE_BITS,
    createMethod: createShakeMethod
  }, {
    name: 'cshake',
    padding: CSHAKE_PADDING,
    bits: SHAKE_BITS,
    createMethod: createCshakeMethod
  }, {
    name: 'kmac',
    padding: CSHAKE_PADDING,
    bits: SHAKE_BITS,
    createMethod: createKmacMethod
  }];
  var methods = {},
      methodNames = [];

  for (var i = 0; i < algorithms.length; ++i) {
    var algorithm = algorithms[i];
    var bits = algorithm.bits;

    for (var j = 0; j < bits.length; ++j) {
      var methodName = algorithm.name + '_' + bits[j];
      methodNames.push(methodName);
      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);

      if (algorithm.name !== 'sha3') {
        var newMethodName = algorithm.name + bits[j];
        methodNames.push(newMethodName);
        methods[newMethodName] = methods[methodName];
      }
    }
  }

  function Keccak(bits, padding, outputBits) {
    this.blocks = [];
    this.s = [];
    this.padding = padding;
    this.outputBits = outputBits;
    this.reset = true;
    this.finalized = false;
    this.block = 0;
    this.start = 0;
    this.blockCount = 1600 - (bits << 1) >> 5;
    this.byteCount = this.blockCount << 2;
    this.outputBlocks = outputBits >> 5;
    this.extraBytes = (outputBits & 31) >> 3;

    for (var i = 0; i < 50; ++i) {
      this.s[i] = 0;
    }
  }

  Keccak.prototype.update = function (message) {
    if (this.finalized) {
      throw new Error(FINALIZE_ERROR);
    }

    var notString,
        type = typeof message;

    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }

      notString = true;
    }

    var blocks = this.blocks,
        byteCount = this.byteCount,
        length = message.length,
        blockCount = this.blockCount,
        index = 0,
        s = this.s,
        i,
        code;

    while (index < length) {
      if (this.reset) {
        this.reset = false;
        blocks[0] = this.block;

        for (i = 1; i < blockCount + 1; ++i) {
          blocks[i] = 0;
        }
      }

      if (notString) {
        for (i = this.start; index < length && i < byteCount; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < byteCount; ++index) {
          code = message.charCodeAt(index);

          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
            blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
          }
        }
      }

      this.lastByteIndex = i;

      if (i >= byteCount) {
        this.start = i - byteCount;
        this.block = blocks[blockCount];

        for (i = 0; i < blockCount; ++i) {
          s[i] ^= blocks[i];
        }

        f(s);
        this.reset = true;
      } else {
        this.start = i;
      }
    }

    return this;
  };

  Keccak.prototype.encode = function (x, right) {
    var o = x & 255,
        n = 1;
    var bytes = [o];
    x = x >> 8;
    o = x & 255;

    while (o > 0) {
      bytes.unshift(o);
      x = x >> 8;
      o = x & 255;
      ++n;
    }

    if (right) {
      bytes.push(n);
    } else {
      bytes.unshift(n);
    }

    this.update(bytes);
    return bytes.length;
  };

  Keccak.prototype.encodeString = function (str) {
    var notString,
        type = typeof str;

    if (type !== 'string') {
      if (type === 'object') {
        if (str === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
          str = new Uint8Array(str);
        } else if (!Array.isArray(str)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }

      notString = true;
    }

    var bytes = 0,
        length = str.length;

    if (notString) {
      bytes = length;
    } else {
      for (var i = 0; i < str.length; ++i) {
        var code = str.charCodeAt(i);

        if (code < 0x80) {
          bytes += 1;
        } else if (code < 0x800) {
          bytes += 2;
        } else if (code < 0xd800 || code >= 0xe000) {
          bytes += 3;
        } else {
          code = 0x10000 + ((code & 0x3ff) << 10 | str.charCodeAt(++i) & 0x3ff);
          bytes += 4;
        }
      }
    }

    bytes += this.encode(bytes * 8);
    this.update(str);
    return bytes;
  };

  Keccak.prototype.bytepad = function (strs, w) {
    var bytes = this.encode(w);

    for (var i = 0; i < strs.length; ++i) {
      bytes += this.encodeString(strs[i]);
    }

    var paddingBytes = w - bytes % w;
    var zeros = [];
    zeros.length = paddingBytes;
    this.update(zeros);
    return this;
  };

  Keccak.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }

    this.finalized = true;
    var blocks = this.blocks,
        i = this.lastByteIndex,
        blockCount = this.blockCount,
        s = this.s;
    blocks[i >> 2] |= this.padding[i & 3];

    if (this.lastByteIndex === this.byteCount) {
      blocks[0] = blocks[blockCount];

      for (i = 1; i < blockCount + 1; ++i) {
        blocks[i] = 0;
      }
    }

    blocks[blockCount - 1] |= 0x80000000;

    for (i = 0; i < blockCount; ++i) {
      s[i] ^= blocks[i];
    }

    f(s);
  };

  Keccak.prototype.toString = Keccak.prototype.hex = function () {
    this.finalize();
    var blockCount = this.blockCount,
        s = this.s,
        outputBlocks = this.outputBlocks,
        extraBytes = this.extraBytes,
        i = 0,
        j = 0;
    var hex = '',
        block;

    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        block = s[i];
        hex += HEX_CHARS[block >> 4 & 0x0F] + HEX_CHARS[block & 0x0F] + HEX_CHARS[block >> 12 & 0x0F] + HEX_CHARS[block >> 8 & 0x0F] + HEX_CHARS[block >> 20 & 0x0F] + HEX_CHARS[block >> 16 & 0x0F] + HEX_CHARS[block >> 28 & 0x0F] + HEX_CHARS[block >> 24 & 0x0F];
      }

      if (j % blockCount === 0) {
        f(s);
        i = 0;
      }
    }

    if (extraBytes) {
      block = s[i];
      hex += HEX_CHARS[block >> 4 & 0x0F] + HEX_CHARS[block & 0x0F];

      if (extraBytes > 1) {
        hex += HEX_CHARS[block >> 12 & 0x0F] + HEX_CHARS[block >> 8 & 0x0F];
      }

      if (extraBytes > 2) {
        hex += HEX_CHARS[block >> 20 & 0x0F] + HEX_CHARS[block >> 16 & 0x0F];
      }
    }

    return hex;
  };

  Keccak.prototype.arrayBuffer = function () {
    this.finalize();
    var blockCount = this.blockCount,
        s = this.s,
        outputBlocks = this.outputBlocks,
        extraBytes = this.extraBytes,
        i = 0,
        j = 0;
    var bytes = this.outputBits >> 3;
    var buffer;

    if (extraBytes) {
      buffer = new ArrayBuffer(outputBlocks + 1 << 2);
    } else {
      buffer = new ArrayBuffer(bytes);
    }

    var array = new Uint32Array(buffer);

    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        array[j] = s[i];
      }

      if (j % blockCount === 0) {
        f(s);
      }
    }

    if (extraBytes) {
      array[i] = s[i];
      buffer = buffer.slice(0, bytes);
    }

    return buffer;
  };

  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;

  Keccak.prototype.digest = Keccak.prototype.array = function () {
    this.finalize();
    var blockCount = this.blockCount,
        s = this.s,
        outputBlocks = this.outputBlocks,
        extraBytes = this.extraBytes,
        i = 0,
        j = 0;
    var array = [],
        offset,
        block;

    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        offset = j << 2;
        block = s[i];
        array[offset] = block & 0xFF;
        array[offset + 1] = block >> 8 & 0xFF;
        array[offset + 2] = block >> 16 & 0xFF;
        array[offset + 3] = block >> 24 & 0xFF;
      }

      if (j % blockCount === 0) {
        f(s);
      }
    }

    if (extraBytes) {
      offset = j << 2;
      block = s[i];
      array[offset] = block & 0xFF;

      if (extraBytes > 1) {
        array[offset + 1] = block >> 8 & 0xFF;
      }

      if (extraBytes > 2) {
        array[offset + 2] = block >> 16 & 0xFF;
      }
    }

    return array;
  };

  function Kmac(bits, padding, outputBits) {
    Keccak.call(this, bits, padding, outputBits);
  }

  Kmac.prototype = new Keccak();

  Kmac.prototype.finalize = function () {
    this.encode(this.outputBits, true);
    return Keccak.prototype.finalize.call(this);
  };

  var f = function (s) {
    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;

    for (n = 0; n < 48; n += 2) {
      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
      h = c8 ^ (c2 << 1 | c3 >>> 31);
      l = c9 ^ (c3 << 1 | c2 >>> 31);
      s[0] ^= h;
      s[1] ^= l;
      s[10] ^= h;
      s[11] ^= l;
      s[20] ^= h;
      s[21] ^= l;
      s[30] ^= h;
      s[31] ^= l;
      s[40] ^= h;
      s[41] ^= l;
      h = c0 ^ (c4 << 1 | c5 >>> 31);
      l = c1 ^ (c5 << 1 | c4 >>> 31);
      s[2] ^= h;
      s[3] ^= l;
      s[12] ^= h;
      s[13] ^= l;
      s[22] ^= h;
      s[23] ^= l;
      s[32] ^= h;
      s[33] ^= l;
      s[42] ^= h;
      s[43] ^= l;
      h = c2 ^ (c6 << 1 | c7 >>> 31);
      l = c3 ^ (c7 << 1 | c6 >>> 31);
      s[4] ^= h;
      s[5] ^= l;
      s[14] ^= h;
      s[15] ^= l;
      s[24] ^= h;
      s[25] ^= l;
      s[34] ^= h;
      s[35] ^= l;
      s[44] ^= h;
      s[45] ^= l;
      h = c4 ^ (c8 << 1 | c9 >>> 31);
      l = c5 ^ (c9 << 1 | c8 >>> 31);
      s[6] ^= h;
      s[7] ^= l;
      s[16] ^= h;
      s[17] ^= l;
      s[26] ^= h;
      s[27] ^= l;
      s[36] ^= h;
      s[37] ^= l;
      s[46] ^= h;
      s[47] ^= l;
      h = c6 ^ (c0 << 1 | c1 >>> 31);
      l = c7 ^ (c1 << 1 | c0 >>> 31);
      s[8] ^= h;
      s[9] ^= l;
      s[18] ^= h;
      s[19] ^= l;
      s[28] ^= h;
      s[29] ^= l;
      s[38] ^= h;
      s[39] ^= l;
      s[48] ^= h;
      s[49] ^= l;
      b0 = s[0];
      b1 = s[1];
      b32 = s[11] << 4 | s[10] >>> 28;
      b33 = s[10] << 4 | s[11] >>> 28;
      b14 = s[20] << 3 | s[21] >>> 29;
      b15 = s[21] << 3 | s[20] >>> 29;
      b46 = s[31] << 9 | s[30] >>> 23;
      b47 = s[30] << 9 | s[31] >>> 23;
      b28 = s[40] << 18 | s[41] >>> 14;
      b29 = s[41] << 18 | s[40] >>> 14;
      b20 = s[2] << 1 | s[3] >>> 31;
      b21 = s[3] << 1 | s[2] >>> 31;
      b2 = s[13] << 12 | s[12] >>> 20;
      b3 = s[12] << 12 | s[13] >>> 20;
      b34 = s[22] << 10 | s[23] >>> 22;
      b35 = s[23] << 10 | s[22] >>> 22;
      b16 = s[33] << 13 | s[32] >>> 19;
      b17 = s[32] << 13 | s[33] >>> 19;
      b48 = s[42] << 2 | s[43] >>> 30;
      b49 = s[43] << 2 | s[42] >>> 30;
      b40 = s[5] << 30 | s[4] >>> 2;
      b41 = s[4] << 30 | s[5] >>> 2;
      b22 = s[14] << 6 | s[15] >>> 26;
      b23 = s[15] << 6 | s[14] >>> 26;
      b4 = s[25] << 11 | s[24] >>> 21;
      b5 = s[24] << 11 | s[25] >>> 21;
      b36 = s[34] << 15 | s[35] >>> 17;
      b37 = s[35] << 15 | s[34] >>> 17;
      b18 = s[45] << 29 | s[44] >>> 3;
      b19 = s[44] << 29 | s[45] >>> 3;
      b10 = s[6] << 28 | s[7] >>> 4;
      b11 = s[7] << 28 | s[6] >>> 4;
      b42 = s[17] << 23 | s[16] >>> 9;
      b43 = s[16] << 23 | s[17] >>> 9;
      b24 = s[26] << 25 | s[27] >>> 7;
      b25 = s[27] << 25 | s[26] >>> 7;
      b6 = s[36] << 21 | s[37] >>> 11;
      b7 = s[37] << 21 | s[36] >>> 11;
      b38 = s[47] << 24 | s[46] >>> 8;
      b39 = s[46] << 24 | s[47] >>> 8;
      b30 = s[8] << 27 | s[9] >>> 5;
      b31 = s[9] << 27 | s[8] >>> 5;
      b12 = s[18] << 20 | s[19] >>> 12;
      b13 = s[19] << 20 | s[18] >>> 12;
      b44 = s[29] << 7 | s[28] >>> 25;
      b45 = s[28] << 7 | s[29] >>> 25;
      b26 = s[38] << 8 | s[39] >>> 24;
      b27 = s[39] << 8 | s[38] >>> 24;
      b8 = s[48] << 14 | s[49] >>> 18;
      b9 = s[49] << 14 | s[48] >>> 18;
      s[0] = b0 ^ ~b2 & b4;
      s[1] = b1 ^ ~b3 & b5;
      s[10] = b10 ^ ~b12 & b14;
      s[11] = b11 ^ ~b13 & b15;
      s[20] = b20 ^ ~b22 & b24;
      s[21] = b21 ^ ~b23 & b25;
      s[30] = b30 ^ ~b32 & b34;
      s[31] = b31 ^ ~b33 & b35;
      s[40] = b40 ^ ~b42 & b44;
      s[41] = b41 ^ ~b43 & b45;
      s[2] = b2 ^ ~b4 & b6;
      s[3] = b3 ^ ~b5 & b7;
      s[12] = b12 ^ ~b14 & b16;
      s[13] = b13 ^ ~b15 & b17;
      s[22] = b22 ^ ~b24 & b26;
      s[23] = b23 ^ ~b25 & b27;
      s[32] = b32 ^ ~b34 & b36;
      s[33] = b33 ^ ~b35 & b37;
      s[42] = b42 ^ ~b44 & b46;
      s[43] = b43 ^ ~b45 & b47;
      s[4] = b4 ^ ~b6 & b8;
      s[5] = b5 ^ ~b7 & b9;
      s[14] = b14 ^ ~b16 & b18;
      s[15] = b15 ^ ~b17 & b19;
      s[24] = b24 ^ ~b26 & b28;
      s[25] = b25 ^ ~b27 & b29;
      s[34] = b34 ^ ~b36 & b38;
      s[35] = b35 ^ ~b37 & b39;
      s[44] = b44 ^ ~b46 & b48;
      s[45] = b45 ^ ~b47 & b49;
      s[6] = b6 ^ ~b8 & b0;
      s[7] = b7 ^ ~b9 & b1;
      s[16] = b16 ^ ~b18 & b10;
      s[17] = b17 ^ ~b19 & b11;
      s[26] = b26 ^ ~b28 & b20;
      s[27] = b27 ^ ~b29 & b21;
      s[36] = b36 ^ ~b38 & b30;
      s[37] = b37 ^ ~b39 & b31;
      s[46] = b46 ^ ~b48 & b40;
      s[47] = b47 ^ ~b49 & b41;
      s[8] = b8 ^ ~b0 & b2;
      s[9] = b9 ^ ~b1 & b3;
      s[18] = b18 ^ ~b10 & b12;
      s[19] = b19 ^ ~b11 & b13;
      s[28] = b28 ^ ~b20 & b22;
      s[29] = b29 ^ ~b21 & b23;
      s[38] = b38 ^ ~b30 & b32;
      s[39] = b39 ^ ~b31 & b33;
      s[48] = b48 ^ ~b40 & b42;
      s[49] = b49 ^ ~b41 & b43;
      s[0] ^= RC[n];
      s[1] ^= RC[n + 1];
    }
  };

  if (COMMON_JS) {
    module.exports = methods;
  } else {
    for (i = 0; i < methodNames.length; ++i) {
      root[methodNames[i]] = methods[methodNames[i]];
    }

    if (AMD) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return methods;
      }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
  }
})();

/***/ }),

/***/ "./node_modules/ky-universal/browser.js":
/*!**********************************************!*\
  !*** ./node_modules/ky-universal/browser.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* reexport safe */ ky__WEBPACK_IMPORTED_MODULE_0__["default"])
/* harmony export */ });
/* harmony import */ var ky__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ky */ "./node_modules/ky/index.js");


/***/ }),

/***/ "./node_modules/ky/index.js":
/*!**********************************!*\
  !*** ./node_modules/ky/index.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*! MIT License  Sindre Sorhus */
const globals = {};

const getGlobal = property => {
  /* istanbul ignore next */
  if (typeof self !== 'undefined' && self && property in self) {
    return self;
  }
  /* istanbul ignore next */


  if (typeof window !== 'undefined' && window && property in window) {
    return window;
  }

  if (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g && property in __webpack_require__.g) {
    return __webpack_require__.g;
  }
  /* istanbul ignore next */


  if (typeof globalThis !== 'undefined' && globalThis) {
    return globalThis;
  }
};

const globalProperties = ['Headers', 'Request', 'Response', 'ReadableStream', 'fetch', 'AbortController', 'FormData'];

for (const property of globalProperties) {
  Object.defineProperty(globals, property, {
    get() {
      const globalObject = getGlobal(property);
      const value = globalObject && globalObject[property];
      return typeof value === 'function' ? value.bind(globalObject) : value;
    }

  });
}

const isObject = value => value !== null && typeof value === 'object';

const supportsAbortController = typeof globals.AbortController === 'function';
const supportsStreams = typeof globals.ReadableStream === 'function';
const supportsFormData = typeof globals.FormData === 'function';

const mergeHeaders = (source1, source2) => {
  const result = new globals.Headers(source1 || {});
  const isHeadersInstance = source2 instanceof globals.Headers;
  const source = new globals.Headers(source2 || {});

  for (const [key, value] of source) {
    if (isHeadersInstance && value === 'undefined' || value === undefined) {
      result.delete(key);
    } else {
      result.set(key, value);
    }
  }

  return result;
};

const deepMerge = (...sources) => {
  let returnValue = {};
  let headers = {};

  for (const source of sources) {
    if (Array.isArray(source)) {
      if (!Array.isArray(returnValue)) {
        returnValue = [];
      }

      returnValue = [...returnValue, ...source];
    } else if (isObject(source)) {
      for (let [key, value] of Object.entries(source)) {
        if (isObject(value) && key in returnValue) {
          value = deepMerge(returnValue[key], value);
        }

        returnValue = { ...returnValue,
          [key]: value
        };
      }

      if (isObject(source.headers)) {
        headers = mergeHeaders(headers, source.headers);
      }
    }

    returnValue.headers = headers;
  }

  return returnValue;
};

const requestMethods = ['get', 'post', 'put', 'patch', 'head', 'delete'];
const responseTypes = {
  json: 'application/json',
  text: 'text/*',
  formData: 'multipart/form-data',
  arrayBuffer: '*/*',
  blob: '*/*'
};
const retryMethods = ['get', 'put', 'head', 'delete', 'options', 'trace'];
const retryStatusCodes = [408, 413, 429, 500, 502, 503, 504];
const retryAfterStatusCodes = [413, 429, 503];
const stop = Symbol('stop');

class HTTPError extends Error {
  constructor(response) {
    // Set the message to the status text, such as Unauthorized,
    // with some fallbacks. This message should never be undefined.
    super(response.statusText || String(response.status === 0 || response.status ? response.status : 'Unknown response error'));
    this.name = 'HTTPError';
    this.response = response;
  }

}

class TimeoutError extends Error {
  constructor(request) {
    super('Request timed out');
    this.name = 'TimeoutError';
    this.request = request;
  }

}

const delay = ms => new Promise(resolve => setTimeout(resolve, ms)); // `Promise.race()` workaround (#91)


const timeout = (request, abortController, options) => new Promise((resolve, reject) => {
  const timeoutID = setTimeout(() => {
    if (abortController) {
      abortController.abort();
    }

    reject(new TimeoutError(request));
  }, options.timeout);
  /* eslint-disable promise/prefer-await-to-then */

  options.fetch(request).then(resolve).catch(reject).then(() => {
    clearTimeout(timeoutID);
  });
  /* eslint-enable promise/prefer-await-to-then */
});

const normalizeRequestMethod = input => requestMethods.includes(input) ? input.toUpperCase() : input;

const defaultRetryOptions = {
  limit: 2,
  methods: retryMethods,
  statusCodes: retryStatusCodes,
  afterStatusCodes: retryAfterStatusCodes
};

const normalizeRetryOptions = (retry = {}) => {
  if (typeof retry === 'number') {
    return { ...defaultRetryOptions,
      limit: retry
    };
  }

  if (retry.methods && !Array.isArray(retry.methods)) {
    throw new Error('retry.methods must be an array');
  }

  if (retry.statusCodes && !Array.isArray(retry.statusCodes)) {
    throw new Error('retry.statusCodes must be an array');
  }

  return { ...defaultRetryOptions,
    ...retry,
    afterStatusCodes: retryAfterStatusCodes
  };
}; // The maximum value of a 32bit int (see issue #117)


const maxSafeTimeout = 2147483647;

class Ky {
  constructor(input, options = {}) {
    this._retryCount = 0;
    this._input = input;
    this._options = {
      // TODO: credentials can be removed when the spec change is implemented in all browsers. Context: https://www.chromestatus.com/feature/4539473312350208
      credentials: this._input.credentials || 'same-origin',
      ...options,
      headers: mergeHeaders(this._input.headers, options.headers),
      hooks: deepMerge({
        beforeRequest: [],
        beforeRetry: [],
        afterResponse: []
      }, options.hooks),
      method: normalizeRequestMethod(options.method || this._input.method),
      prefixUrl: String(options.prefixUrl || ''),
      retry: normalizeRetryOptions(options.retry),
      throwHttpErrors: options.throwHttpErrors !== false,
      timeout: typeof options.timeout === 'undefined' ? 10000 : options.timeout,
      fetch: options.fetch || globals.fetch
    };

    if (typeof this._input !== 'string' && !(this._input instanceof URL || this._input instanceof globals.Request)) {
      throw new TypeError('`input` must be a string, URL, or Request');
    }

    if (this._options.prefixUrl && typeof this._input === 'string') {
      if (this._input.startsWith('/')) {
        throw new Error('`input` must not begin with a slash when using `prefixUrl`');
      }

      if (!this._options.prefixUrl.endsWith('/')) {
        this._options.prefixUrl += '/';
      }

      this._input = this._options.prefixUrl + this._input;
    }

    if (supportsAbortController) {
      this.abortController = new globals.AbortController();

      if (this._options.signal) {
        this._options.signal.addEventListener('abort', () => {
          this.abortController.abort();
        });
      }

      this._options.signal = this.abortController.signal;
    }

    this.request = new globals.Request(this._input, this._options);

    if (this._options.searchParams) {
      const searchParams = '?' + new URLSearchParams(this._options.searchParams).toString();
      const url = this.request.url.replace(/(?:\?.*?)?(?=#|$)/, searchParams); // To provide correct form boundary, Content-Type header should be deleted each time when new Request instantiated from another one

      if ((supportsFormData && this._options.body instanceof globals.FormData || this._options.body instanceof URLSearchParams) && !(this._options.headers && this._options.headers['content-type'])) {
        this.request.headers.delete('content-type');
      }

      this.request = new globals.Request(new globals.Request(url, this.request), this._options);
    }

    if (this._options.json !== undefined) {
      this._options.body = JSON.stringify(this._options.json);
      this.request.headers.set('content-type', 'application/json');
      this.request = new globals.Request(this.request, {
        body: this._options.body
      });
    }

    const fn = async () => {
      if (this._options.timeout > maxSafeTimeout) {
        throw new RangeError(`The \`timeout\` option cannot be greater than ${maxSafeTimeout}`);
      }

      await delay(1);
      let response = await this._fetch();

      for (const hook of this._options.hooks.afterResponse) {
        // eslint-disable-next-line no-await-in-loop
        const modifiedResponse = await hook(this.request, this._options, this._decorateResponse(response.clone()));

        if (modifiedResponse instanceof globals.Response) {
          response = modifiedResponse;
        }
      }

      this._decorateResponse(response);

      if (!response.ok && this._options.throwHttpErrors) {
        throw new HTTPError(response);
      } // If `onDownloadProgress` is passed, it uses the stream API internally

      /* istanbul ignore next */


      if (this._options.onDownloadProgress) {
        if (typeof this._options.onDownloadProgress !== 'function') {
          throw new TypeError('The `onDownloadProgress` option must be a function');
        }

        if (!supportsStreams) {
          throw new Error('Streams are not supported in your environment. `ReadableStream` is missing.');
        }

        return this._stream(response.clone(), this._options.onDownloadProgress);
      }

      return response;
    };

    const isRetriableMethod = this._options.retry.methods.includes(this.request.method.toLowerCase());

    const result = isRetriableMethod ? this._retry(fn) : fn();

    for (const [type, mimeType] of Object.entries(responseTypes)) {
      result[type] = async () => {
        this.request.headers.set('accept', this.request.headers.get('accept') || mimeType);
        const response = (await result).clone();

        if (type === 'json') {
          if (response.status === 204) {
            return '';
          }

          if (options.parseJson) {
            return options.parseJson(await response.text());
          }
        }

        return response[type]();
      };
    }

    return result;
  }

  _calculateRetryDelay(error) {
    this._retryCount++;

    if (this._retryCount < this._options.retry.limit && !(error instanceof TimeoutError)) {
      if (error instanceof HTTPError) {
        if (!this._options.retry.statusCodes.includes(error.response.status)) {
          return 0;
        }

        const retryAfter = error.response.headers.get('Retry-After');

        if (retryAfter && this._options.retry.afterStatusCodes.includes(error.response.status)) {
          let after = Number(retryAfter);

          if (Number.isNaN(after)) {
            after = Date.parse(retryAfter) - Date.now();
          } else {
            after *= 1000;
          }

          if (typeof this._options.retry.maxRetryAfter !== 'undefined' && after > this._options.retry.maxRetryAfter) {
            return 0;
          }

          return after;
        }

        if (error.response.status === 413) {
          return 0;
        }
      }

      const BACKOFF_FACTOR = 0.3;
      return BACKOFF_FACTOR * 2 ** (this._retryCount - 1) * 1000;
    }

    return 0;
  }

  _decorateResponse(response) {
    if (this._options.parseJson) {
      response.json = async () => {
        return this._options.parseJson(await response.text());
      };
    }

    return response;
  }

  async _retry(fn) {
    try {
      return await fn();
    } catch (error) {
      const ms = Math.min(this._calculateRetryDelay(error), maxSafeTimeout);

      if (ms !== 0 && this._retryCount > 0) {
        await delay(ms);

        for (const hook of this._options.hooks.beforeRetry) {
          // eslint-disable-next-line no-await-in-loop
          const hookResult = await hook({
            request: this.request,
            options: this._options,
            error,
            retryCount: this._retryCount
          }); // If `stop` is returned from the hook, the retry process is stopped

          if (hookResult === stop) {
            return;
          }
        }

        return this._retry(fn);
      }

      if (this._options.throwHttpErrors) {
        throw error;
      }
    }
  }

  async _fetch() {
    for (const hook of this._options.hooks.beforeRequest) {
      // eslint-disable-next-line no-await-in-loop
      const result = await hook(this.request, this._options);

      if (result instanceof Request) {
        this.request = result;
        break;
      }

      if (result instanceof Response) {
        return result;
      }
    }

    if (this._options.timeout === false) {
      return this._options.fetch(this.request.clone());
    }

    return timeout(this.request.clone(), this.abortController, this._options);
  }
  /* istanbul ignore next */


  _stream(response, onDownloadProgress) {
    const totalBytes = Number(response.headers.get('content-length')) || 0;
    let transferredBytes = 0;
    return new globals.Response(new globals.ReadableStream({
      start(controller) {
        const reader = response.body.getReader();

        if (onDownloadProgress) {
          onDownloadProgress({
            percent: 0,
            transferredBytes: 0,
            totalBytes
          }, new Uint8Array());
        }

        async function read() {
          const {
            done,
            value
          } = await reader.read();

          if (done) {
            controller.close();
            return;
          }

          if (onDownloadProgress) {
            transferredBytes += value.byteLength;
            const percent = totalBytes === 0 ? 0 : transferredBytes / totalBytes;
            onDownloadProgress({
              percent,
              transferredBytes,
              totalBytes
            }, value);
          }

          controller.enqueue(value);
          read();
        }

        read();
      }

    }));
  }

}

const validateAndMerge = (...sources) => {
  for (const source of sources) {
    if ((!isObject(source) || Array.isArray(source)) && typeof source !== 'undefined') {
      throw new TypeError('The `options` argument must be an object');
    }
  }

  return deepMerge({}, ...sources);
};

const createInstance = defaults => {
  const ky = (input, options) => new Ky(input, validateAndMerge(defaults, options));

  for (const method of requestMethods) {
    ky[method] = (input, options) => new Ky(input, validateAndMerge(defaults, options, {
      method
    }));
  }

  ky.HTTPError = HTTPError;
  ky.TimeoutError = TimeoutError;

  ky.create = newDefaults => createInstance(validateAndMerge(newDefaults));

  ky.extend = newDefaults => createInstance(validateAndMerge(defaults, newDefaults));

  ky.stop = stop;
  return ky;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createInstance());

/***/ }),

/***/ "./node_modules/minimalistic-assert/index.js":
/*!***************************************************!*\
  !*** ./node_modules/minimalistic-assert/index.js ***!
  \***************************************************/
/***/ ((module) => {

module.exports = assert;

function assert(val, msg) {
  if (!val) throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r) throw new Error(msg || 'Assertion failed: ' + l + ' != ' + r);
};

/***/ }),

/***/ "./node_modules/minimalistic-crypto-utils/lib/utils.js":
/*!*************************************************************!*\
  !*** ./node_modules/minimalistic-crypto-utils/lib/utils.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg)) return msg.slice();
  if (!msg) return [];
  var res = [];

  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++) res[i] = msg[i] | 0;

    return res;
  }

  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0) msg = '0' + msg;

    for (var i = 0; i < msg.length; i += 2) res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi) res.push(hi, lo);else res.push(lo);
    }
  }

  return res;
}

utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1) return '0' + word;else return word;
}

utils.zero2 = zero2;

function toHex(msg) {
  var res = '';

  for (var i = 0; i < msg.length; i++) res += zero2(msg[i].toString(16));

  return res;
}

utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex') return toHex(arr);else return arr;
};

/***/ }),

/***/ "./node_modules/scrypt-js/scrypt.js":
/*!******************************************!*\
  !*** ./node_modules/scrypt-js/scrypt.js ***!
  \******************************************/
/***/ (function(module) {

"use strict";


(function (root) {
  const MAX_VALUE = 0x7fffffff; // The SHA256 and PBKDF2 implementation are from scrypt-async-js:
  // See: https://github.com/dchest/scrypt-async-js

  function SHA256(m) {
    const K = new Uint32Array([0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2]);
    let h0 = 0x6a09e667,
        h1 = 0xbb67ae85,
        h2 = 0x3c6ef372,
        h3 = 0xa54ff53a;
    let h4 = 0x510e527f,
        h5 = 0x9b05688c,
        h6 = 0x1f83d9ab,
        h7 = 0x5be0cd19;
    const w = new Uint32Array(64);

    function blocks(p) {
      let off = 0,
          len = p.length;

      while (len >= 64) {
        let a = h0,
            b = h1,
            c = h2,
            d = h3,
            e = h4,
            f = h5,
            g = h6,
            h = h7,
            u,
            i,
            j,
            t1,
            t2;

        for (i = 0; i < 16; i++) {
          j = off + i * 4;
          w[i] = (p[j] & 0xff) << 24 | (p[j + 1] & 0xff) << 16 | (p[j + 2] & 0xff) << 8 | p[j + 3] & 0xff;
        }

        for (i = 16; i < 64; i++) {
          u = w[i - 2];
          t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
          u = w[i - 15];
          t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
          w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0) | 0;
        }

        for (i = 0; i < 64; i++) {
          t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h + (K[i] + w[i] | 0) | 0) | 0;
          t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
          h = g;
          g = f;
          f = e;
          e = d + t1 | 0;
          d = c;
          c = b;
          b = a;
          a = t1 + t2 | 0;
        }

        h0 = h0 + a | 0;
        h1 = h1 + b | 0;
        h2 = h2 + c | 0;
        h3 = h3 + d | 0;
        h4 = h4 + e | 0;
        h5 = h5 + f | 0;
        h6 = h6 + g | 0;
        h7 = h7 + h | 0;
        off += 64;
        len -= 64;
      }
    }

    blocks(m);
    let i,
        bytesLeft = m.length % 64,
        bitLenHi = m.length / 0x20000000 | 0,
        bitLenLo = m.length << 3,
        numZeros = bytesLeft < 56 ? 56 : 120,
        p = m.slice(m.length - bytesLeft, m.length);
    p.push(0x80);

    for (i = bytesLeft + 1; i < numZeros; i++) {
      p.push(0);
    }

    p.push(bitLenHi >>> 24 & 0xff);
    p.push(bitLenHi >>> 16 & 0xff);
    p.push(bitLenHi >>> 8 & 0xff);
    p.push(bitLenHi >>> 0 & 0xff);
    p.push(bitLenLo >>> 24 & 0xff);
    p.push(bitLenLo >>> 16 & 0xff);
    p.push(bitLenLo >>> 8 & 0xff);
    p.push(bitLenLo >>> 0 & 0xff);
    blocks(p);
    return [h0 >>> 24 & 0xff, h0 >>> 16 & 0xff, h0 >>> 8 & 0xff, h0 >>> 0 & 0xff, h1 >>> 24 & 0xff, h1 >>> 16 & 0xff, h1 >>> 8 & 0xff, h1 >>> 0 & 0xff, h2 >>> 24 & 0xff, h2 >>> 16 & 0xff, h2 >>> 8 & 0xff, h2 >>> 0 & 0xff, h3 >>> 24 & 0xff, h3 >>> 16 & 0xff, h3 >>> 8 & 0xff, h3 >>> 0 & 0xff, h4 >>> 24 & 0xff, h4 >>> 16 & 0xff, h4 >>> 8 & 0xff, h4 >>> 0 & 0xff, h5 >>> 24 & 0xff, h5 >>> 16 & 0xff, h5 >>> 8 & 0xff, h5 >>> 0 & 0xff, h6 >>> 24 & 0xff, h6 >>> 16 & 0xff, h6 >>> 8 & 0xff, h6 >>> 0 & 0xff, h7 >>> 24 & 0xff, h7 >>> 16 & 0xff, h7 >>> 8 & 0xff, h7 >>> 0 & 0xff];
  }

  function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
    // compress password if it's longer than hash block length
    password = password.length <= 64 ? password : SHA256(password);
    const innerLen = 64 + salt.length + 4;
    const inner = new Array(innerLen);
    const outerKey = new Array(64);
    let i;
    let dk = []; // inner = (password ^ ipad) || salt || counter

    for (i = 0; i < 64; i++) {
      inner[i] = 0x36;
    }

    for (i = 0; i < password.length; i++) {
      inner[i] ^= password[i];
    }

    for (i = 0; i < salt.length; i++) {
      inner[64 + i] = salt[i];
    }

    for (i = innerLen - 4; i < innerLen; i++) {
      inner[i] = 0;
    } // outerKey = password ^ opad


    for (i = 0; i < 64; i++) outerKey[i] = 0x5c;

    for (i = 0; i < password.length; i++) outerKey[i] ^= password[i]; // increments counter inside inner


    function incrementCounter() {
      for (let i = innerLen - 1; i >= innerLen - 4; i--) {
        inner[i]++;
        if (inner[i] <= 0xff) return;
        inner[i] = 0;
      }
    } // output blocks = SHA256(outerKey || SHA256(inner)) ...


    while (dkLen >= 32) {
      incrementCounter();
      dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));
      dkLen -= 32;
    }

    if (dkLen > 0) {
      incrementCounter();
      dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));
    }

    return dk;
  } // The following is an adaptation of scryptsy
  // See: https://www.npmjs.com/package/scryptsy


  function blockmix_salsa8(BY, Yi, r, x, _X) {
    let i;
    arraycopy(BY, (2 * r - 1) * 16, _X, 0, 16);

    for (i = 0; i < 2 * r; i++) {
      blockxor(BY, i * 16, _X, 16);
      salsa20_8(_X, x);
      arraycopy(_X, 0, BY, Yi + i * 16, 16);
    }

    for (i = 0; i < r; i++) {
      arraycopy(BY, Yi + i * 2 * 16, BY, i * 16, 16);
    }

    for (i = 0; i < r; i++) {
      arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r) * 16, 16);
    }
  }

  function R(a, b) {
    return a << b | a >>> 32 - b;
  }

  function salsa20_8(B, x) {
    arraycopy(B, 0, x, 0, 16);

    for (let i = 8; i > 0; i -= 2) {
      x[4] ^= R(x[0] + x[12], 7);
      x[8] ^= R(x[4] + x[0], 9);
      x[12] ^= R(x[8] + x[4], 13);
      x[0] ^= R(x[12] + x[8], 18);
      x[9] ^= R(x[5] + x[1], 7);
      x[13] ^= R(x[9] + x[5], 9);
      x[1] ^= R(x[13] + x[9], 13);
      x[5] ^= R(x[1] + x[13], 18);
      x[14] ^= R(x[10] + x[6], 7);
      x[2] ^= R(x[14] + x[10], 9);
      x[6] ^= R(x[2] + x[14], 13);
      x[10] ^= R(x[6] + x[2], 18);
      x[3] ^= R(x[15] + x[11], 7);
      x[7] ^= R(x[3] + x[15], 9);
      x[11] ^= R(x[7] + x[3], 13);
      x[15] ^= R(x[11] + x[7], 18);
      x[1] ^= R(x[0] + x[3], 7);
      x[2] ^= R(x[1] + x[0], 9);
      x[3] ^= R(x[2] + x[1], 13);
      x[0] ^= R(x[3] + x[2], 18);
      x[6] ^= R(x[5] + x[4], 7);
      x[7] ^= R(x[6] + x[5], 9);
      x[4] ^= R(x[7] + x[6], 13);
      x[5] ^= R(x[4] + x[7], 18);
      x[11] ^= R(x[10] + x[9], 7);
      x[8] ^= R(x[11] + x[10], 9);
      x[9] ^= R(x[8] + x[11], 13);
      x[10] ^= R(x[9] + x[8], 18);
      x[12] ^= R(x[15] + x[14], 7);
      x[13] ^= R(x[12] + x[15], 9);
      x[14] ^= R(x[13] + x[12], 13);
      x[15] ^= R(x[14] + x[13], 18);
    }

    for (let i = 0; i < 16; ++i) {
      B[i] += x[i];
    }
  } // naive approach... going back to loop unrolling may yield additional performance


  function blockxor(S, Si, D, len) {
    for (let i = 0; i < len; i++) {
      D[i] ^= S[Si + i];
    }
  }

  function arraycopy(src, srcPos, dest, destPos, length) {
    while (length--) {
      dest[destPos++] = src[srcPos++];
    }
  }

  function checkBufferish(o) {
    if (!o || typeof o.length !== 'number') {
      return false;
    }

    for (let i = 0; i < o.length; i++) {
      const v = o[i];

      if (typeof v !== 'number' || v % 1 || v < 0 || v >= 256) {
        return false;
      }
    }

    return true;
  }

  function ensureInteger(value, name) {
    if (typeof value !== "number" || value % 1) {
      throw new Error('invalid ' + name);
    }

    return value;
  } // N = Cpu cost, r = Memory cost, p = parallelization cost
  // callback(error, progress, key)


  function _scrypt(password, salt, N, r, p, dkLen, callback) {
    N = ensureInteger(N, 'N');
    r = ensureInteger(r, 'r');
    p = ensureInteger(p, 'p');
    dkLen = ensureInteger(dkLen, 'dkLen');

    if (N === 0 || (N & N - 1) !== 0) {
      throw new Error('N must be power of 2');
    }

    if (N > MAX_VALUE / 128 / r) {
      throw new Error('N too large');
    }

    if (r > MAX_VALUE / 128 / p) {
      throw new Error('r too large');
    }

    if (!checkBufferish(password)) {
      throw new Error('password must be an array or buffer');
    }

    password = Array.prototype.slice.call(password);

    if (!checkBufferish(salt)) {
      throw new Error('salt must be an array or buffer');
    }

    salt = Array.prototype.slice.call(salt);
    let b = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r);
    const B = new Uint32Array(p * 32 * r);

    for (let i = 0; i < B.length; i++) {
      const j = i * 4;
      B[i] = (b[j + 3] & 0xff) << 24 | (b[j + 2] & 0xff) << 16 | (b[j + 1] & 0xff) << 8 | (b[j + 0] & 0xff) << 0;
    }

    const XY = new Uint32Array(64 * r);
    const V = new Uint32Array(32 * r * N);
    const Yi = 32 * r; // scratch space

    const x = new Uint32Array(16); // salsa20_8

    const _X = new Uint32Array(16); // blockmix_salsa8


    const totalOps = p * N * 2;
    let currentOp = 0;
    let lastPercent10 = null; // Set this to true to abandon the scrypt on the next step

    let stop = false; // State information

    let state = 0;
    let i0 = 0,
        i1;
    let Bi; // How many blockmix_salsa8 can we do per step?

    const limit = callback ? parseInt(1000 / r) : 0xffffffff; // Trick from scrypt-async; if there is a setImmediate shim in place, use it

    const nextTick = typeof setImmediate !== 'undefined' ? setImmediate : setTimeout; // This is really all I changed; making scryptsy a state machine so we occasionally
    // stop and give other evnts on the evnt loop a chance to run. ~RicMoo

    const incrementalSMix = function () {
      if (stop) {
        return callback(new Error('cancelled'), currentOp / totalOps);
      }

      let steps;

      switch (state) {
        case 0:
          // for (var i = 0; i < p; i++)...
          Bi = i0 * 32 * r;
          arraycopy(B, Bi, XY, 0, Yi); // ROMix - 1

          state = 1; // Move to ROMix 2

          i1 = 0;
        // Fall through

        case 1:
          // Run up to 1000 steps of the first inner smix loop
          steps = N - i1;

          if (steps > limit) {
            steps = limit;
          }

          for (let i = 0; i < steps; i++) {
            // ROMix - 2
            arraycopy(XY, 0, V, (i1 + i) * Yi, Yi); // ROMix - 3

            blockmix_salsa8(XY, Yi, r, x, _X); // ROMix - 4
          } // for (var i = 0; i < N; i++)


          i1 += steps;
          currentOp += steps;

          if (callback) {
            // Call the callback with the progress (optionally stopping us)
            const percent10 = parseInt(1000 * currentOp / totalOps);

            if (percent10 !== lastPercent10) {
              stop = callback(null, currentOp / totalOps);

              if (stop) {
                break;
              }

              lastPercent10 = percent10;
            }
          }

          if (i1 < N) {
            break;
          }

          i1 = 0; // Move to ROMix 6

          state = 2;
        // Fall through

        case 2:
          // Run up to 1000 steps of the second inner smix loop
          steps = N - i1;

          if (steps > limit) {
            steps = limit;
          }

          for (let i = 0; i < steps; i++) {
            // ROMix - 6
            const offset = (2 * r - 1) * 16; // ROMix - 7

            const j = XY[offset] & N - 1;
            blockxor(V, j * Yi, XY, Yi); // ROMix - 8 (inner)

            blockmix_salsa8(XY, Yi, r, x, _X); // ROMix - 9 (outer)
          } // for (var i = 0; i < N; i++)...


          i1 += steps;
          currentOp += steps; // Call the callback with the progress (optionally stopping us)

          if (callback) {
            const percent10 = parseInt(1000 * currentOp / totalOps);

            if (percent10 !== lastPercent10) {
              stop = callback(null, currentOp / totalOps);

              if (stop) {
                break;
              }

              lastPercent10 = percent10;
            }
          }

          if (i1 < N) {
            break;
          }

          arraycopy(XY, 0, B, Bi, Yi); // ROMix - 10
          // for (var i = 0; i < p; i++)...

          i0++;

          if (i0 < p) {
            state = 0;
            break;
          }

          b = [];

          for (let i = 0; i < B.length; i++) {
            b.push(B[i] >> 0 & 0xff);
            b.push(B[i] >> 8 & 0xff);
            b.push(B[i] >> 16 & 0xff);
            b.push(B[i] >> 24 & 0xff);
          }

          const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b, dkLen); // Send the result to the callback

          if (callback) {
            callback(null, 1.0, derivedKey);
          } // Done; don't break (which would reschedule)


          return derivedKey;
      } // Schedule the next steps


      if (callback) {
        nextTick(incrementalSMix);
      }
    }; // Run the smix state machine until completion


    if (!callback) {
      while (true) {
        const derivedKey = incrementalSMix();

        if (derivedKey != undefined) {
          return derivedKey;
        }
      }
    } // Bootstrap the async incremental smix


    incrementalSMix();
  }

  const lib = {
    scrypt: function (password, salt, N, r, p, dkLen, progressCallback) {
      return new Promise(function (resolve, reject) {
        let lastProgress = 0;

        if (progressCallback) {
          progressCallback(0);
        }

        _scrypt(password, salt, N, r, p, dkLen, function (error, progress, key) {
          if (error) {
            reject(error);
          } else if (key) {
            if (progressCallback && lastProgress !== 1) {
              progressCallback(1);
            }

            resolve(new Uint8Array(key));
          } else if (progressCallback && progress !== lastProgress) {
            lastProgress = progress;
            return progressCallback(progress);
          }
        });
      });
    },
    syncScrypt: function (password, salt, N, r, p, dkLen) {
      return new Uint8Array(_scrypt(password, salt, N, r, p, dkLen));
    }
  }; // node.js

  if (true) {
    module.exports = lib; // RequireJS/AMD
    // http://www.requirejs.org/docs/api.html
    // https://github.com/amdjs/amdjs-api/wiki/AMD
  } else {}
})(this);

/***/ }),

/***/ "./node_modules/tar-js/lib/header.js":
/*!*******************************************!*\
  !*** ./node_modules/tar-js/lib/header.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * tar-js
 * MIT (c) 2011 T. Jameson Little
 */
(function () {
  "use strict";
  /*
  struct posix_header {             // byte offset
  	char name[100];               //   0
  	char mode[8];                 // 100
  	char uid[8];                  // 108
  	char gid[8];                  // 116
  	char size[12];                // 124
  	char mtime[12];               // 136
  	char chksum[8];               // 148
  	char typeflag;                // 156
  	char linkname[100];           // 157
  	char magic[6];                // 257
  	char version[2];              // 263
  	char uname[32];               // 265
  	char gname[32];               // 297
  	char devmajor[8];             // 329
  	char devminor[8];             // 337
  	char prefix[155];             // 345
                                    // 500
  };
  */

  var utils = __webpack_require__(/*! ./utils */ "./node_modules/tar-js/lib/utils.js"),
      headerFormat;

  headerFormat = [{
    'field': 'fileName',
    'length': 100
  }, {
    'field': 'fileMode',
    'length': 8
  }, {
    'field': 'uid',
    'length': 8
  }, {
    'field': 'gid',
    'length': 8
  }, {
    'field': 'fileSize',
    'length': 12
  }, {
    'field': 'mtime',
    'length': 12
  }, {
    'field': 'checksum',
    'length': 8
  }, {
    'field': 'type',
    'length': 1
  }, {
    'field': 'linkName',
    'length': 100
  }, {
    'field': 'ustar',
    'length': 8
  }, {
    'field': 'owner',
    'length': 32
  }, {
    'field': 'group',
    'length': 32
  }, {
    'field': 'majorNumber',
    'length': 8
  }, {
    'field': 'minorNumber',
    'length': 8
  }, {
    'field': 'filenamePrefix',
    'length': 155
  }, {
    'field': 'padding',
    'length': 12
  }];

  function formatHeader(data, cb) {
    var buffer = utils.clean(512),
        offset = 0;
    headerFormat.forEach(function (value) {
      var str = data[value.field] || "",
          i,
          length;

      for (i = 0, length = str.length; i < length; i += 1) {
        buffer[offset] = str.charCodeAt(i);
        offset += 1;
      }

      offset += value.length - i; // space it out with nulls
    });

    if (typeof cb === 'function') {
      return cb(buffer, offset);
    }

    return buffer;
  }

  module.exports.structure = headerFormat;
  module.exports.format = formatHeader;
})();

/***/ }),

/***/ "./node_modules/tar-js/lib/tar.js":
/*!****************************************!*\
  !*** ./node_modules/tar-js/lib/tar.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*
 * tar-js
 * MIT (c) 2011 T. Jameson Little
 */
(function () {
  "use strict";

  var header = __webpack_require__(/*! ./header */ "./node_modules/tar-js/lib/header.js"),
      utils = __webpack_require__(/*! ./utils */ "./node_modules/tar-js/lib/utils.js"),
      recordSize = 512,
      blockSize;

  function Tar(recordsPerBlock) {
    this.written = 0;
    blockSize = (recordsPerBlock || 20) * recordSize;
    this.out = utils.clean(blockSize);
  }

  Tar.prototype.append = function (filepath, input, opts, callback) {
    var data, checksum, mode, mtime, uid, gid, headerArr;

    if (typeof input === 'string') {
      input = utils.stringToUint8(input);
    } else if (input.constructor !== Uint8Array.prototype.constructor) {
      throw 'Invalid input type. You gave me: ' + input.constructor.toString().match(/function\s*([$A-Za-z_][0-9A-Za-z_]*)\s*\(/)[1];
    }

    if (typeof opts === 'function') {
      callback = opts;
      opts = {};
    }

    opts = opts || {};
    mode = opts.mode || parseInt('777', 8) & 0xfff;
    mtime = opts.mtime || Math.floor(+new Date() / 1000);
    uid = opts.uid || 0;
    gid = opts.gid || 0;
    data = {
      fileName: filepath,
      fileMode: utils.pad(mode, 7),
      uid: utils.pad(uid, 7),
      gid: utils.pad(gid, 7),
      fileSize: utils.pad(input.length, 11),
      mtime: utils.pad(mtime, 11),
      checksum: '        ',
      type: '0',
      // just a file
      ustar: 'ustar  ',
      owner: opts.owner || '',
      group: opts.group || ''
    }; // calculate the checksum

    checksum = 0;
    Object.keys(data).forEach(function (key) {
      var i,
          value = data[key],
          length;

      for (i = 0, length = value.length; i < length; i += 1) {
        checksum += value.charCodeAt(i);
      }
    });
    data.checksum = utils.pad(checksum, 6) + "\u0000 ";
    headerArr = header.format(data);
    var i, offset, length;
    this.out.set(headerArr, this.written);
    this.written += headerArr.length; // If there is not enough space in this.out, we need to expand it to
    // fit the new input.

    if (this.written + input.length > this.out.length) {
      this.out = utils.extend(this.out, this.written, input.length, blockSize);
    }

    this.out.set(input, this.written); // to the nearest multiple of recordSize

    this.written += input.length + (recordSize - (input.length % recordSize || recordSize)); // make sure there's at least 2 empty records worth of extra space

    if (this.out.length - this.written < recordSize * 2) {
      this.out = utils.extend(this.out, this.written, recordSize * 2, blockSize);
    }

    if (typeof callback === 'function') {
      callback(this.out);
    }

    return this.out;
  };

  Tar.prototype.clear = function () {
    this.written = 0;
    this.out = utils.clean(blockSize);
  };

  Tar.utils = utils;
  Tar.stringToUint8 = utils.stringToUint8;
  Tar.uint8ToBase64 = utils.uint8ToBase64;
  Tar.base64ToUint8 = utils.base64ToUint8;
  module.exports = Tar;
})();

/***/ }),

/***/ "./node_modules/tar-js/lib/utils.js":
/*!******************************************!*\
  !*** ./node_modules/tar-js/lib/utils.js ***!
  \******************************************/
/***/ ((module) => {

/*
 * tar-js
 * MIT (c) 2011 T. Jameson Little
 */
(function () {
  "use strict";

  var lookup = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'];

  function clean(length) {
    var i,
        buffer = new Uint8Array(length);

    for (i = 0; i < length; i += 1) {
      buffer[i] = 0;
    }

    return buffer;
  }

  function extend(orig, length, addLength, multipleOf) {
    var newSize = length + addLength,
        buffer = clean((parseInt(newSize / multipleOf) + 1) * multipleOf);
    buffer.set(orig);
    return buffer;
  }

  function pad(num, bytes, base) {
    num = num.toString(base || 8);
    return "000000000000".substr(num.length + 12 - bytes) + num;
  }

  function stringToUint8(input, out, offset) {
    var i, length;
    out = out || clean(input.length);
    offset = offset || 0;

    for (i = 0, length = input.length; i < length; i += 1) {
      out[offset] = input.charCodeAt(i);
      offset += 1;
    }

    return out;
  }

  function uint8ToBase64(uint8) {
    var i,
        extraBytes = uint8.length % 3,
        // if we have 1 byte left, pad 2 bytes
    output = "",
        temp,
        length;

    function tripletToBase64(num) {
      return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
    }

    ; // go through the array every three bytes, we'll deal with trailing stuff later

    for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
      temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
      output += tripletToBase64(temp);
    } // this prevents an ERR_INVALID_URL in Chrome (Firefox okay)


    switch (output.length % 4) {
      case 1:
        output += '=';
        break;

      case 2:
        output += '==';
        break;

      default:
        break;
    }

    return output;
  }

  function base64ToUint8(input) {
    var base64 = input.match(/^([^=]+)/)[1],
        extraBytes = input.match(/(=*)$/)[1].length,
        i = 0,
        length = base64.length,
        temp,
        offset = 0,
        ret = clean(base64.length * .75 + extraBytes);

    while (i < length) {
      temp = 0;
      temp |= lookup.indexOf(base64.charAt(i) || 'A') << 18;
      i += 1;
      temp |= lookup.indexOf(base64.charAt(i) || 'A') << 12;
      i += 1;
      temp |= lookup.indexOf(base64.charAt(i) || 'A') << 6;
      i += 1;
      temp |= lookup.indexOf(base64.charAt(i) || 'A');
      i += 1;
      ret[offset] = temp >> 16 & 0xFF;
      offset += 1;
      ret[offset] = temp >> 8 & 0xFF;
      offset += 1;
      ret[offset] = temp & 0xFF;
      offset += 1;
    }

    return ret;
  }

  module.exports.clean = clean;
  module.exports.pad = pad;
  module.exports.extend = extend;
  module.exports.stringToUint8 = stringToUint8;
  module.exports.uint8ToBase64 = uint8ToBase64;
  module.exports.base64ToUint8 = base64ToUint8;
})();

/***/ }),

/***/ "./node_modules/web-streams-polyfill/dist/ponyfill.js":
/*!************************************************************!*\
  !*** ./node_modules/web-streams-polyfill/dist/ponyfill.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/**
 * web-streams-polyfill v3.2.0
 */
(function (global, factory) {
   true ? factory(exports) : 0;
})(this, function (exports) {
  'use strict'; /// <reference lib="es2015.symbol" />

  var SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol : function (description) {
    return "Symbol(" + description + ")";
  }; /// <reference lib="dom" />

  function noop() {
    return undefined;
  }

  function getGlobals() {
    if (typeof self !== 'undefined') {
      return self;
    } else if (typeof window !== 'undefined') {
      return window;
    } else if (typeof __webpack_require__.g !== 'undefined') {
      return __webpack_require__.g;
    }

    return undefined;
  }

  var globals = getGlobals();

  function typeIsObject(x) {
    return typeof x === 'object' && x !== null || typeof x === 'function';
  }

  var rethrowAssertionErrorRejection = noop;
  var originalPromise = Promise;
  var originalPromiseThen = Promise.prototype.then;
  var originalPromiseResolve = Promise.resolve.bind(originalPromise);
  var originalPromiseReject = Promise.reject.bind(originalPromise);

  function newPromise(executor) {
    return new originalPromise(executor);
  }

  function promiseResolvedWith(value) {
    return originalPromiseResolve(value);
  }

  function promiseRejectedWith(reason) {
    return originalPromiseReject(reason);
  }

  function PerformPromiseThen(promise, onFulfilled, onRejected) {
    // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an
    // approximation.
    return originalPromiseThen.call(promise, onFulfilled, onRejected);
  }

  function uponPromise(promise, onFulfilled, onRejected) {
    PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);
  }

  function uponFulfillment(promise, onFulfilled) {
    uponPromise(promise, onFulfilled);
  }

  function uponRejection(promise, onRejected) {
    uponPromise(promise, undefined, onRejected);
  }

  function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
    return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
  }

  function setPromiseIsHandledToTrue(promise) {
    PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);
  }

  var queueMicrotask = function () {
    var globalQueueMicrotask = globals && globals.queueMicrotask;

    if (typeof globalQueueMicrotask === 'function') {
      return globalQueueMicrotask;
    }

    var resolvedPromise = promiseResolvedWith(undefined);
    return function (fn) {
      return PerformPromiseThen(resolvedPromise, fn);
    };
  }();

  function reflectCall(F, V, args) {
    if (typeof F !== 'function') {
      throw new TypeError('Argument is not a function');
    }

    return Function.prototype.apply.call(F, V, args);
  }

  function promiseCall(F, V, args) {
    try {
      return promiseResolvedWith(reflectCall(F, V, args));
    } catch (value) {
      return promiseRejectedWith(value);
    }
  } // Original from Chromium
  // https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js


  var QUEUE_MAX_ARRAY_SIZE = 16384;
  /**
   * Simple queue structure.
   *
   * Avoids scalability issues with using a packed array directly by using
   * multiple arrays in a linked list and keeping the array size bounded.
   */

  var SimpleQueue =
  /** @class */
  function () {
    function SimpleQueue() {
      this._cursor = 0;
      this._size = 0; // _front and _back are always defined.

      this._front = {
        _elements: [],
        _next: undefined
      };
      this._back = this._front; // The cursor is used to avoid calling Array.shift().
      // It contains the index of the front element of the array inside the
      // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).

      this._cursor = 0; // When there is only one node, size === elements.length - cursor.

      this._size = 0;
    }

    Object.defineProperty(SimpleQueue.prototype, "length", {
      get: function () {
        return this._size;
      },
      enumerable: false,
      configurable: true
    }); // For exception safety, this method is structured in order:
    // 1. Read state
    // 2. Calculate required state mutations
    // 3. Perform state mutations

    SimpleQueue.prototype.push = function (element) {
      var oldBack = this._back;
      var newBack = oldBack;

      if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
        newBack = {
          _elements: [],
          _next: undefined
        };
      } // push() is the mutation most likely to throw an exception, so it
      // goes first.


      oldBack._elements.push(element);

      if (newBack !== oldBack) {
        this._back = newBack;
        oldBack._next = newBack;
      }

      ++this._size;
    }; // Like push(), shift() follows the read -> calculate -> mutate pattern for
    // exception safety.


    SimpleQueue.prototype.shift = function () {
      // must not be called on an empty queue
      var oldFront = this._front;
      var newFront = oldFront;
      var oldCursor = this._cursor;
      var newCursor = oldCursor + 1;
      var elements = oldFront._elements;
      var element = elements[oldCursor];

      if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
        newFront = oldFront._next;
        newCursor = 0;
      } // No mutations before this point.


      --this._size;
      this._cursor = newCursor;

      if (oldFront !== newFront) {
        this._front = newFront;
      } // Permit shifted element to be garbage collected.


      elements[oldCursor] = undefined;
      return element;
    }; // The tricky thing about forEach() is that it can be called
    // re-entrantly. The queue may be mutated inside the callback. It is easy to
    // see that push() within the callback has no negative effects since the end
    // of the queue is checked for on every iteration. If shift() is called
    // repeatedly within the callback then the next iteration may return an
    // element that has been removed. In this case the callback will be called
    // with undefined values until we either "catch up" with elements that still
    // exist or reach the back of the queue.


    SimpleQueue.prototype.forEach = function (callback) {
      var i = this._cursor;
      var node = this._front;
      var elements = node._elements;

      while (i !== elements.length || node._next !== undefined) {
        if (i === elements.length) {
          node = node._next;
          elements = node._elements;
          i = 0;

          if (elements.length === 0) {
            break;
          }
        }

        callback(elements[i]);
        ++i;
      }
    }; // Return the element that would be returned if shift() was called now,
    // without modifying the queue.


    SimpleQueue.prototype.peek = function () {
      // must not be called on an empty queue
      var front = this._front;
      var cursor = this._cursor;
      return front._elements[cursor];
    };

    return SimpleQueue;
  }();

  function ReadableStreamReaderGenericInitialize(reader, stream) {
    reader._ownerReadableStream = stream;
    stream._reader = reader;

    if (stream._state === 'readable') {
      defaultReaderClosedPromiseInitialize(reader);
    } else if (stream._state === 'closed') {
      defaultReaderClosedPromiseInitializeAsResolved(reader);
    } else {
      defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
    }
  } // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state
  // check.


  function ReadableStreamReaderGenericCancel(reader, reason) {
    var stream = reader._ownerReadableStream;
    return ReadableStreamCancel(stream, reason);
  }

  function ReadableStreamReaderGenericRelease(reader) {
    if (reader._ownerReadableStream._state === 'readable') {
      defaultReaderClosedPromiseReject(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
    } else {
      defaultReaderClosedPromiseResetToRejected(reader, new TypeError("Reader was released and can no longer be used to monitor the stream's closedness"));
    }

    reader._ownerReadableStream._reader = undefined;
    reader._ownerReadableStream = undefined;
  } // Helper functions for the readers.


  function readerLockException(name) {
    return new TypeError('Cannot ' + name + ' a stream using a released reader');
  } // Helper functions for the ReadableStreamDefaultReader.


  function defaultReaderClosedPromiseInitialize(reader) {
    reader._closedPromise = newPromise(function (resolve, reject) {
      reader._closedPromise_resolve = resolve;
      reader._closedPromise_reject = reject;
    });
  }

  function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
    defaultReaderClosedPromiseInitialize(reader);
    defaultReaderClosedPromiseReject(reader, reason);
  }

  function defaultReaderClosedPromiseInitializeAsResolved(reader) {
    defaultReaderClosedPromiseInitialize(reader);
    defaultReaderClosedPromiseResolve(reader);
  }

  function defaultReaderClosedPromiseReject(reader, reason) {
    if (reader._closedPromise_reject === undefined) {
      return;
    }

    setPromiseIsHandledToTrue(reader._closedPromise);

    reader._closedPromise_reject(reason);

    reader._closedPromise_resolve = undefined;
    reader._closedPromise_reject = undefined;
  }

  function defaultReaderClosedPromiseResetToRejected(reader, reason) {
    defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
  }

  function defaultReaderClosedPromiseResolve(reader) {
    if (reader._closedPromise_resolve === undefined) {
      return;
    }

    reader._closedPromise_resolve(undefined);

    reader._closedPromise_resolve = undefined;
    reader._closedPromise_reject = undefined;
  }

  var AbortSteps = SymbolPolyfill('[[AbortSteps]]');
  var ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');
  var CancelSteps = SymbolPolyfill('[[CancelSteps]]');
  var PullSteps = SymbolPolyfill('[[PullSteps]]'); /// <reference lib="es2015.core" />
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill

  var NumberIsFinite = Number.isFinite || function (x) {
    return typeof x === 'number' && isFinite(x);
  }; /// <reference lib="es2015.core" />
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill


  var MathTrunc = Math.trunc || function (v) {
    return v < 0 ? Math.ceil(v) : Math.floor(v);
  }; // https://heycam.github.io/webidl/#idl-dictionaries


  function isDictionary(x) {
    return typeof x === 'object' || typeof x === 'function';
  }

  function assertDictionary(obj, context) {
    if (obj !== undefined && !isDictionary(obj)) {
      throw new TypeError(context + " is not an object.");
    }
  } // https://heycam.github.io/webidl/#idl-callback-functions


  function assertFunction(x, context) {
    if (typeof x !== 'function') {
      throw new TypeError(context + " is not a function.");
    }
  } // https://heycam.github.io/webidl/#idl-object


  function isObject(x) {
    return typeof x === 'object' && x !== null || typeof x === 'function';
  }

  function assertObject(x, context) {
    if (!isObject(x)) {
      throw new TypeError(context + " is not an object.");
    }
  }

  function assertRequiredArgument(x, position, context) {
    if (x === undefined) {
      throw new TypeError("Parameter " + position + " is required in '" + context + "'.");
    }
  }

  function assertRequiredField(x, field, context) {
    if (x === undefined) {
      throw new TypeError(field + " is required in '" + context + "'.");
    }
  } // https://heycam.github.io/webidl/#idl-unrestricted-double


  function convertUnrestrictedDouble(value) {
    return Number(value);
  }

  function censorNegativeZero(x) {
    return x === 0 ? 0 : x;
  }

  function integerPart(x) {
    return censorNegativeZero(MathTrunc(x));
  } // https://heycam.github.io/webidl/#idl-unsigned-long-long


  function convertUnsignedLongLongWithEnforceRange(value, context) {
    var lowerBound = 0;
    var upperBound = Number.MAX_SAFE_INTEGER;
    var x = Number(value);
    x = censorNegativeZero(x);

    if (!NumberIsFinite(x)) {
      throw new TypeError(context + " is not a finite number");
    }

    x = integerPart(x);

    if (x < lowerBound || x > upperBound) {
      throw new TypeError(context + " is outside the accepted range of " + lowerBound + " to " + upperBound + ", inclusive");
    }

    if (!NumberIsFinite(x) || x === 0) {
      return 0;
    } // TODO Use BigInt if supported?
    // let xBigInt = BigInt(integerPart(x));
    // xBigInt = BigInt.asUintN(64, xBigInt);
    // return Number(xBigInt);


    return x;
  }

  function assertReadableStream(x, context) {
    if (!IsReadableStream(x)) {
      throw new TypeError(context + " is not a ReadableStream.");
    }
  } // Abstract operations for the ReadableStream.


  function AcquireReadableStreamDefaultReader(stream) {
    return new ReadableStreamDefaultReader(stream);
  } // ReadableStream API exposed for controllers.


  function ReadableStreamAddReadRequest(stream, readRequest) {
    stream._reader._readRequests.push(readRequest);
  }

  function ReadableStreamFulfillReadRequest(stream, chunk, done) {
    var reader = stream._reader;

    var readRequest = reader._readRequests.shift();

    if (done) {
      readRequest._closeSteps();
    } else {
      readRequest._chunkSteps(chunk);
    }
  }

  function ReadableStreamGetNumReadRequests(stream) {
    return stream._reader._readRequests.length;
  }

  function ReadableStreamHasDefaultReader(stream) {
    var reader = stream._reader;

    if (reader === undefined) {
      return false;
    }

    if (!IsReadableStreamDefaultReader(reader)) {
      return false;
    }

    return true;
  }
  /**
   * A default reader vended by a {@link ReadableStream}.
   *
   * @public
   */


  var ReadableStreamDefaultReader =
  /** @class */
  function () {
    function ReadableStreamDefaultReader(stream) {
      assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');
      assertReadableStream(stream, 'First parameter');

      if (IsReadableStreamLocked(stream)) {
        throw new TypeError('This stream has already been locked for exclusive reading by another reader');
      }

      ReadableStreamReaderGenericInitialize(this, stream);
      this._readRequests = new SimpleQueue();
    }

    Object.defineProperty(ReadableStreamDefaultReader.prototype, "closed", {
      /**
       * Returns a promise that will be fulfilled when the stream becomes closed,
       * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
       */
      get: function () {
        if (!IsReadableStreamDefaultReader(this)) {
          return promiseRejectedWith(defaultReaderBrandCheckException('closed'));
        }

        return this._closedPromise;
      },
      enumerable: false,
      configurable: true
    });
    /**
     * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
     */

    ReadableStreamDefaultReader.prototype.cancel = function (reason) {
      if (reason === void 0) {
        reason = undefined;
      }

      if (!IsReadableStreamDefaultReader(this)) {
        return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));
      }

      if (this._ownerReadableStream === undefined) {
        return promiseRejectedWith(readerLockException('cancel'));
      }

      return ReadableStreamReaderGenericCancel(this, reason);
    };
    /**
     * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.
     *
     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
     */


    ReadableStreamDefaultReader.prototype.read = function () {
      if (!IsReadableStreamDefaultReader(this)) {
        return promiseRejectedWith(defaultReaderBrandCheckException('read'));
      }

      if (this._ownerReadableStream === undefined) {
        return promiseRejectedWith(readerLockException('read from'));
      }

      var resolvePromise;
      var rejectPromise;
      var promise = newPromise(function (resolve, reject) {
        resolvePromise = resolve;
        rejectPromise = reject;
      });
      var readRequest = {
        _chunkSteps: function (chunk) {
          return resolvePromise({
            value: chunk,
            done: false
          });
        },
        _closeSteps: function () {
          return resolvePromise({
            value: undefined,
            done: true
          });
        },
        _errorSteps: function (e) {
          return rejectPromise(e);
        }
      };
      ReadableStreamDefaultReaderRead(this, readRequest);
      return promise;
    };
    /**
     * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
     * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
     * from now on; otherwise, the reader will appear closed.
     *
     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
     * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to
     * do so will throw a `TypeError` and leave the reader locked to the stream.
     */


    ReadableStreamDefaultReader.prototype.releaseLock = function () {
      if (!IsReadableStreamDefaultReader(this)) {
        throw defaultReaderBrandCheckException('releaseLock');
      }

      if (this._ownerReadableStream === undefined) {
        return;
      }

      if (this._readRequests.length > 0) {
        throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
      }

      ReadableStreamReaderGenericRelease(this);
    };

    return ReadableStreamDefaultReader;
  }();

  Object.defineProperties(ReadableStreamDefaultReader.prototype, {
    cancel: {
      enumerable: true
    },
    read: {
      enumerable: true
    },
    releaseLock: {
      enumerable: true
    },
    closed: {
      enumerable: true
    }
  });

  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
      value: 'ReadableStreamDefaultReader',
      configurable: true
    });
  } // Abstract operations for the readers.


  function IsReadableStreamDefaultReader(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {
      return false;
    }

    return x instanceof ReadableStreamDefaultReader;
  }

  function ReadableStreamDefaultReaderRead(reader, readRequest) {
    var stream = reader._ownerReadableStream;
    stream._disturbed = true;

    if (stream._state === 'closed') {
      readRequest._closeSteps();
    } else if (stream._state === 'errored') {
      readRequest._errorSteps(stream._storedError);
    } else {
      stream._readableStreamController[PullSteps](readRequest);
    }
  } // Helper functions for the ReadableStreamDefaultReader.


  function defaultReaderBrandCheckException(name) {
    return new TypeError("ReadableStreamDefaultReader.prototype." + name + " can only be used on a ReadableStreamDefaultReader");
  } /// <reference lib="es2018.asynciterable" />


  var _a;

  var AsyncIteratorPrototype;

  if (typeof SymbolPolyfill.asyncIterator === 'symbol') {
    // We're running inside a ES2018+ environment, but we're compiling to an older syntax.
    // We cannot access %AsyncIteratorPrototype% without non-ES2018 syntax, but we can re-create it.
    AsyncIteratorPrototype = (_a = {}, // 25.1.3.1 %AsyncIteratorPrototype% [ @@asyncIterator ] ( )
    // https://tc39.github.io/ecma262/#sec-asynciteratorprototype-asynciterator
    _a[SymbolPolyfill.asyncIterator] = function () {
      return this;
    }, _a);
    Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, {
      enumerable: false
    });
  } /// <reference lib="es2018.asynciterable" />


  var ReadableStreamAsyncIteratorImpl =
  /** @class */
  function () {
    function ReadableStreamAsyncIteratorImpl(reader, preventCancel) {
      this._ongoingPromise = undefined;
      this._isFinished = false;
      this._reader = reader;
      this._preventCancel = preventCancel;
    }

    ReadableStreamAsyncIteratorImpl.prototype.next = function () {
      var _this = this;

      var nextSteps = function () {
        return _this._nextSteps();
      };

      this._ongoingPromise = this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) : nextSteps();
      return this._ongoingPromise;
    };

    ReadableStreamAsyncIteratorImpl.prototype.return = function (value) {
      var _this = this;

      var returnSteps = function () {
        return _this._returnSteps(value);
      };

      return this._ongoingPromise ? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) : returnSteps();
    };

    ReadableStreamAsyncIteratorImpl.prototype._nextSteps = function () {
      var _this = this;

      if (this._isFinished) {
        return Promise.resolve({
          value: undefined,
          done: true
        });
      }

      var reader = this._reader;

      if (reader._ownerReadableStream === undefined) {
        return promiseRejectedWith(readerLockException('iterate'));
      }

      var resolvePromise;
      var rejectPromise;
      var promise = newPromise(function (resolve, reject) {
        resolvePromise = resolve;
        rejectPromise = reject;
      });
      var readRequest = {
        _chunkSteps: function (chunk) {
          _this._ongoingPromise = undefined; // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.
          // FIXME Is this a bug in the specification, or in the test?

          queueMicrotask(function () {
            return resolvePromise({
              value: chunk,
              done: false
            });
          });
        },
        _closeSteps: function () {
          _this._ongoingPromise = undefined;
          _this._isFinished = true;
          ReadableStreamReaderGenericRelease(reader);
          resolvePromise({
            value: undefined,
            done: true
          });
        },
        _errorSteps: function (reason) {
          _this._ongoingPromise = undefined;
          _this._isFinished = true;
          ReadableStreamReaderGenericRelease(reader);
          rejectPromise(reason);
        }
      };
      ReadableStreamDefaultReaderRead(reader, readRequest);
      return promise;
    };

    ReadableStreamAsyncIteratorImpl.prototype._returnSteps = function (value) {
      if (this._isFinished) {
        return Promise.resolve({
          value: value,
          done: true
        });
      }

      this._isFinished = true;
      var reader = this._reader;

      if (reader._ownerReadableStream === undefined) {
        return promiseRejectedWith(readerLockException('finish iterating'));
      }

      if (!this._preventCancel) {
        var result = ReadableStreamReaderGenericCancel(reader, value);
        ReadableStreamReaderGenericRelease(reader);
        return transformPromiseWith(result, function () {
          return {
            value: value,
            done: true
          };
        });
      }

      ReadableStreamReaderGenericRelease(reader);
      return promiseResolvedWith({
        value: value,
        done: true
      });
    };

    return ReadableStreamAsyncIteratorImpl;
  }();

  var ReadableStreamAsyncIteratorPrototype = {
    next: function () {
      if (!IsReadableStreamAsyncIterator(this)) {
        return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));
      }

      return this._asyncIteratorImpl.next();
    },
    return: function (value) {
      if (!IsReadableStreamAsyncIterator(this)) {
        return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));
      }

      return this._asyncIteratorImpl.return(value);
    }
  };

  if (AsyncIteratorPrototype !== undefined) {
    Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
  } // Abstract operations for the ReadableStream.


  function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
    var reader = AcquireReadableStreamDefaultReader(stream);
    var impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
    iterator._asyncIteratorImpl = impl;
    return iterator;
  }

  function IsReadableStreamAsyncIterator(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {
      return false;
    }

    try {
      // noinspection SuspiciousTypeOfGuard
      return x._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
    } catch (_a) {
      return false;
    }
  } // Helper functions for the ReadableStream.


  function streamAsyncIteratorBrandCheckException(name) {
    return new TypeError("ReadableStreamAsyncIterator." + name + " can only be used on a ReadableSteamAsyncIterator");
  } /// <reference lib="es2015.core" />
  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill


  var NumberIsNaN = Number.isNaN || function (x) {
    // eslint-disable-next-line no-self-compare
    return x !== x;
  };

  function CreateArrayFromList(elements) {
    // We use arrays to represent lists, so this is basically a no-op.
    // Do a slice though just in case we happen to depend on the unique-ness.
    return elements.slice();
  }

  function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
    new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
  } // Not implemented correctly


  function TransferArrayBuffer(O) {
    return O;
  } // Not implemented correctly
  // eslint-disable-next-line @typescript-eslint/no-unused-vars


  function IsDetachedBuffer(O) {
    return false;
  }

  function ArrayBufferSlice(buffer, begin, end) {
    // ArrayBuffer.prototype.slice is not available on IE10
    // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice
    if (buffer.slice) {
      return buffer.slice(begin, end);
    }

    var length = end - begin;
    var slice = new ArrayBuffer(length);
    CopyDataBlockBytes(slice, 0, buffer, begin, length);
    return slice;
  }

  function IsNonNegativeNumber(v) {
    if (typeof v !== 'number') {
      return false;
    }

    if (NumberIsNaN(v)) {
      return false;
    }

    if (v < 0) {
      return false;
    }

    return true;
  }

  function CloneAsUint8Array(O) {
    var buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
    return new Uint8Array(buffer);
  }

  function DequeueValue(container) {
    var pair = container._queue.shift();

    container._queueTotalSize -= pair.size;

    if (container._queueTotalSize < 0) {
      container._queueTotalSize = 0;
    }

    return pair.value;
  }

  function EnqueueValueWithSize(container, value, size) {
    if (!IsNonNegativeNumber(size) || size === Infinity) {
      throw new RangeError('Size must be a finite, non-NaN, non-negative number.');
    }

    container._queue.push({
      value: value,
      size: size
    });

    container._queueTotalSize += size;
  }

  function PeekQueueValue(container) {
    var pair = container._queue.peek();

    return pair.value;
  }

  function ResetQueue(container) {
    container._queue = new SimpleQueue();
    container._queueTotalSize = 0;
  }
  /**
   * A pull-into request in a {@link ReadableByteStreamController}.
   *
   * @public
   */


  var ReadableStreamBYOBRequest =
  /** @class */
  function () {
    function ReadableStreamBYOBRequest() {
      throw new TypeError('Illegal constructor');
    }

    Object.defineProperty(ReadableStreamBYOBRequest.prototype, "view", {
      /**
       * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
       */
      get: function () {
        if (!IsReadableStreamBYOBRequest(this)) {
          throw byobRequestBrandCheckException('view');
        }

        return this._view;
      },
      enumerable: false,
      configurable: true
    });

    ReadableStreamBYOBRequest.prototype.respond = function (bytesWritten) {
      if (!IsReadableStreamBYOBRequest(this)) {
        throw byobRequestBrandCheckException('respond');
      }

      assertRequiredArgument(bytesWritten, 1, 'respond');
      bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');

      if (this._associatedReadableByteStreamController === undefined) {
        throw new TypeError('This BYOB request has been invalidated');
      }

      if (IsDetachedBuffer(this._view.buffer)) ;
      ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
    };

    ReadableStreamBYOBRequest.prototype.respondWithNewView = function (view) {
      if (!IsReadableStreamBYOBRequest(this)) {
        throw byobRequestBrandCheckException('respondWithNewView');
      }

      assertRequiredArgument(view, 1, 'respondWithNewView');

      if (!ArrayBuffer.isView(view)) {
        throw new TypeError('You can only respond with array buffer views');
      }

      if (this._associatedReadableByteStreamController === undefined) {
        throw new TypeError('This BYOB request has been invalidated');
      }

      if (IsDetachedBuffer(view.buffer)) ;
      ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
    };

    return ReadableStreamBYOBRequest;
  }();

  Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
    respond: {
      enumerable: true
    },
    respondWithNewView: {
      enumerable: true
    },
    view: {
      enumerable: true
    }
  });

  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
      value: 'ReadableStreamBYOBRequest',
      configurable: true
    });
  }
  /**
   * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.
   *
   * @public
   */


  var ReadableByteStreamController =
  /** @class */
  function () {
    function ReadableByteStreamController() {
      throw new TypeError('Illegal constructor');
    }

    Object.defineProperty(ReadableByteStreamController.prototype, "byobRequest", {
      /**
       * Returns the current BYOB pull request, or `null` if there isn't one.
       */
      get: function () {
        if (!IsReadableByteStreamController(this)) {
          throw byteStreamControllerBrandCheckException('byobRequest');
        }

        return ReadableByteStreamControllerGetBYOBRequest(this);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ReadableByteStreamController.prototype, "desiredSize", {
      /**
       * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
       * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
       */
      get: function () {
        if (!IsReadableByteStreamController(this)) {
          throw byteStreamControllerBrandCheckException('desiredSize');
        }

        return ReadableByteStreamControllerGetDesiredSize(this);
      },
      enumerable: false,
      configurable: true
    });
    /**
     * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
     * the stream, but once those are read, the stream will become closed.
     */

    ReadableByteStreamController.prototype.close = function () {
      if (!IsReadableByteStreamController(this)) {
        throw byteStreamControllerBrandCheckException('close');
      }

      if (this._closeRequested) {
        throw new TypeError('The stream has already been closed; do not close it again!');
      }

      var state = this._controlledReadableByteStream._state;

      if (state !== 'readable') {
        throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be closed");
      }

      ReadableByteStreamControllerClose(this);
    };

    ReadableByteStreamController.prototype.enqueue = function (chunk) {
      if (!IsReadableByteStreamController(this)) {
        throw byteStreamControllerBrandCheckException('enqueue');
      }

      assertRequiredArgument(chunk, 1, 'enqueue');

      if (!ArrayBuffer.isView(chunk)) {
        throw new TypeError('chunk must be an array buffer view');
      }

      if (chunk.byteLength === 0) {
        throw new TypeError('chunk must have non-zero byteLength');
      }

      if (chunk.buffer.byteLength === 0) {
        throw new TypeError("chunk's buffer must have non-zero byteLength");
      }

      if (this._closeRequested) {
        throw new TypeError('stream is closed or draining');
      }

      var state = this._controlledReadableByteStream._state;

      if (state !== 'readable') {
        throw new TypeError("The stream (in " + state + " state) is not in the readable state and cannot be enqueued to");
      }

      ReadableByteStreamControllerEnqueue(this, chunk);
    };
    /**
     * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
     */


    ReadableByteStreamController.prototype.error = function (e) {
      if (e === void 0) {
        e = undefined;
      }

      if (!IsReadableByteStreamController(this)) {
        throw byteStreamControllerBrandCheckException('error');
      }

      ReadableByteStreamControllerError(this, e);
    };
    /** @internal */


    ReadableByteStreamController.prototype[CancelSteps] = function (reason) {
      ReadableByteStreamControllerClearPendingPullIntos(this);
      ResetQueue(this);

      var result = this._cancelAlgorithm(reason);

      ReadableByteStreamControllerClearAlgorithms(this);
      return result;
    };
    /** @internal */


    ReadableByteStreamController.prototype[PullSteps] = function (readRequest) {
      var stream = this._controlledReadableByteStream;

      if (this._queueTotalSize > 0) {
        var entry = this._queue.shift();

        this._queueTotalSize -= entry.byteLength;
        ReadableByteStreamControllerHandleQueueDrain(this);
        var view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);

        readRequest._chunkSteps(view);

        return;
      }

      var autoAllocateChunkSize = this._autoAllocateChunkSize;

      if (autoAllocateChunkSize !== undefined) {
        var buffer = void 0;

        try {
          buffer = new ArrayBuffer(autoAllocateChunkSize);
        } catch (bufferE) {
          readRequest._errorSteps(bufferE);

          return;
        }

        var pullIntoDescriptor = {
          buffer: buffer,
          bufferByteLength: autoAllocateChunkSize,
          byteOffset: 0,
          byteLength: autoAllocateChunkSize,
          bytesFilled: 0,
          elementSize: 1,
          viewConstructor: Uint8Array,
          readerType: 'default'
        };

        this._pendingPullIntos.push(pullIntoDescriptor);
      }

      ReadableStreamAddReadRequest(stream, readRequest);
      ReadableByteStreamControllerCallPullIfNeeded(this);
    };

    return ReadableByteStreamController;
  }();

  Object.defineProperties(ReadableByteStreamController.prototype, {
    close: {
      enumerable: true
    },
    enqueue: {
      enumerable: true
    },
    error: {
      enumerable: true
    },
    byobRequest: {
      enumerable: true
    },
    desiredSize: {
      enumerable: true
    }
  });

  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
      value: 'ReadableByteStreamController',
      configurable: true
    });
  } // Abstract operations for the ReadableByteStreamController.


  function IsReadableByteStreamController(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {
      return false;
    }

    return x instanceof ReadableByteStreamController;
  }

  function IsReadableStreamBYOBRequest(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {
      return false;
    }

    return x instanceof ReadableStreamBYOBRequest;
  }

  function ReadableByteStreamControllerCallPullIfNeeded(controller) {
    var shouldPull = ReadableByteStreamControllerShouldCallPull(controller);

    if (!shouldPull) {
      return;
    }

    if (controller._pulling) {
      controller._pullAgain = true;
      return;
    }

    controller._pulling = true; // TODO: Test controller argument

    var pullPromise = controller._pullAlgorithm();

    uponPromise(pullPromise, function () {
      controller._pulling = false;

      if (controller._pullAgain) {
        controller._pullAgain = false;
        ReadableByteStreamControllerCallPullIfNeeded(controller);
      }
    }, function (e) {
      ReadableByteStreamControllerError(controller, e);
    });
  }

  function ReadableByteStreamControllerClearPendingPullIntos(controller) {
    ReadableByteStreamControllerInvalidateBYOBRequest(controller);
    controller._pendingPullIntos = new SimpleQueue();
  }

  function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
    var done = false;

    if (stream._state === 'closed') {
      done = true;
    }

    var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);

    if (pullIntoDescriptor.readerType === 'default') {
      ReadableStreamFulfillReadRequest(stream, filledView, done);
    } else {
      ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
    }
  }

  function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
    var bytesFilled = pullIntoDescriptor.bytesFilled;
    var elementSize = pullIntoDescriptor.elementSize;
    return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
  }

  function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
    controller._queue.push({
      buffer: buffer,
      byteOffset: byteOffset,
      byteLength: byteLength
    });

    controller._queueTotalSize += byteLength;
  }

  function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
    var elementSize = pullIntoDescriptor.elementSize;
    var currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
    var maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
    var maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
    var maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
    var totalBytesToCopyRemaining = maxBytesToCopy;
    var ready = false;

    if (maxAlignedBytes > currentAlignedBytes) {
      totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
      ready = true;
    }

    var queue = controller._queue;

    while (totalBytesToCopyRemaining > 0) {
      var headOfQueue = queue.peek();
      var bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
      var destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
      CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);

      if (headOfQueue.byteLength === bytesToCopy) {
        queue.shift();
      } else {
        headOfQueue.byteOffset += bytesToCopy;
        headOfQueue.byteLength -= bytesToCopy;
      }

      controller._queueTotalSize -= bytesToCopy;
      ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
      totalBytesToCopyRemaining -= bytesToCopy;
    }

    return ready;
  }

  function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
    pullIntoDescriptor.bytesFilled += size;
  }

  function ReadableByteStreamControllerHandleQueueDrain(controller) {
    if (controller._queueTotalSize === 0 && controller._closeRequested) {
      ReadableByteStreamControllerClearAlgorithms(controller);
      ReadableStreamClose(controller._controlledReadableByteStream);
    } else {
      ReadableByteStreamControllerCallPullIfNeeded(controller);
    }
  }

  function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
    if (controller._byobRequest === null) {
      return;
    }

    controller._byobRequest._associatedReadableByteStreamController = undefined;
    controller._byobRequest._view = null;
    controller._byobRequest = null;
  }

  function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
    while (controller._pendingPullIntos.length > 0) {
      if (controller._queueTotalSize === 0) {
        return;
      }

      var pullIntoDescriptor = controller._pendingPullIntos.peek();

      if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
        ReadableByteStreamControllerShiftPendingPullInto(controller);
        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
      }
    }
  }

  function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
    var stream = controller._controlledReadableByteStream;
    var elementSize = 1;

    if (view.constructor !== DataView) {
      elementSize = view.constructor.BYTES_PER_ELEMENT;
    }

    var ctor = view.constructor; // try {

    var buffer = TransferArrayBuffer(view.buffer); // } catch (e) {
    //   readIntoRequest._errorSteps(e);
    //   return;
    // }

    var pullIntoDescriptor = {
      buffer: buffer,
      bufferByteLength: buffer.byteLength,
      byteOffset: view.byteOffset,
      byteLength: view.byteLength,
      bytesFilled: 0,
      elementSize: elementSize,
      viewConstructor: ctor,
      readerType: 'byob'
    };

    if (controller._pendingPullIntos.length > 0) {
      controller._pendingPullIntos.push(pullIntoDescriptor); // No ReadableByteStreamControllerCallPullIfNeeded() call since:
      // - No change happens on desiredSize
      // - The source has already been notified of that there's at least 1 pending read(view)


      ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
      return;
    }

    if (stream._state === 'closed') {
      var emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);

      readIntoRequest._closeSteps(emptyView);

      return;
    }

    if (controller._queueTotalSize > 0) {
      if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
        var filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
        ReadableByteStreamControllerHandleQueueDrain(controller);

        readIntoRequest._chunkSteps(filledView);

        return;
      }

      if (controller._closeRequested) {
        var e = new TypeError('Insufficient bytes to fill elements in the given buffer');
        ReadableByteStreamControllerError(controller, e);

        readIntoRequest._errorSteps(e);

        return;
      }
    }

    controller._pendingPullIntos.push(pullIntoDescriptor);

    ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
    ReadableByteStreamControllerCallPullIfNeeded(controller);
  }

  function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
    var stream = controller._controlledReadableByteStream;

    if (ReadableStreamHasBYOBReader(stream)) {
      while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
        var pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
        ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
      }
    }
  }

  function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);

    if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
      return;
    }

    ReadableByteStreamControllerShiftPendingPullInto(controller);
    var remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;

    if (remainderSize > 0) {
      var end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
      var remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
      ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
    }

    pullIntoDescriptor.bytesFilled -= remainderSize;
    ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
  }

  function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
    var firstDescriptor = controller._pendingPullIntos.peek();

    ReadableByteStreamControllerInvalidateBYOBRequest(controller);
    var state = controller._controlledReadableByteStream._state;

    if (state === 'closed') {
      ReadableByteStreamControllerRespondInClosedState(controller);
    } else {
      ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
    }

    ReadableByteStreamControllerCallPullIfNeeded(controller);
  }

  function ReadableByteStreamControllerShiftPendingPullInto(controller) {
    var descriptor = controller._pendingPullIntos.shift();

    return descriptor;
  }

  function ReadableByteStreamControllerShouldCallPull(controller) {
    var stream = controller._controlledReadableByteStream;

    if (stream._state !== 'readable') {
      return false;
    }

    if (controller._closeRequested) {
      return false;
    }

    if (!controller._started) {
      return false;
    }

    if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
      return true;
    }

    if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
      return true;
    }

    var desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);

    if (desiredSize > 0) {
      return true;
    }

    return false;
  }

  function ReadableByteStreamControllerClearAlgorithms(controller) {
    controller._pullAlgorithm = undefined;
    controller._cancelAlgorithm = undefined;
  } // A client of ReadableByteStreamController may use these functions directly to bypass state check.


  function ReadableByteStreamControllerClose(controller) {
    var stream = controller._controlledReadableByteStream;

    if (controller._closeRequested || stream._state !== 'readable') {
      return;
    }

    if (controller._queueTotalSize > 0) {
      controller._closeRequested = true;
      return;
    }

    if (controller._pendingPullIntos.length > 0) {
      var firstPendingPullInto = controller._pendingPullIntos.peek();

      if (firstPendingPullInto.bytesFilled > 0) {
        var e = new TypeError('Insufficient bytes to fill elements in the given buffer');
        ReadableByteStreamControllerError(controller, e);
        throw e;
      }
    }

    ReadableByteStreamControllerClearAlgorithms(controller);
    ReadableStreamClose(stream);
  }

  function ReadableByteStreamControllerEnqueue(controller, chunk) {
    var stream = controller._controlledReadableByteStream;

    if (controller._closeRequested || stream._state !== 'readable') {
      return;
    }

    var buffer = chunk.buffer;
    var byteOffset = chunk.byteOffset;
    var byteLength = chunk.byteLength;
    var transferredBuffer = TransferArrayBuffer(buffer);

    if (controller._pendingPullIntos.length > 0) {
      var firstPendingPullInto = controller._pendingPullIntos.peek();

      if (IsDetachedBuffer(firstPendingPullInto.buffer)) ;
      firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
    }

    ReadableByteStreamControllerInvalidateBYOBRequest(controller);

    if (ReadableStreamHasDefaultReader(stream)) {
      if (ReadableStreamGetNumReadRequests(stream) === 0) {
        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
      } else {
        if (controller._pendingPullIntos.length > 0) {
          ReadableByteStreamControllerShiftPendingPullInto(controller);
        }

        var transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
        ReadableStreamFulfillReadRequest(stream, transferredView, false);
      }
    } else if (ReadableStreamHasBYOBReader(stream)) {
      // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.
      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
      ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
    } else {
      ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
    }

    ReadableByteStreamControllerCallPullIfNeeded(controller);
  }

  function ReadableByteStreamControllerError(controller, e) {
    var stream = controller._controlledReadableByteStream;

    if (stream._state !== 'readable') {
      return;
    }

    ReadableByteStreamControllerClearPendingPullIntos(controller);
    ResetQueue(controller);
    ReadableByteStreamControllerClearAlgorithms(controller);
    ReadableStreamError(stream, e);
  }

  function ReadableByteStreamControllerGetBYOBRequest(controller) {
    if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
      var firstDescriptor = controller._pendingPullIntos.peek();

      var view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
      var byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
      SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
      controller._byobRequest = byobRequest;
    }

    return controller._byobRequest;
  }

  function ReadableByteStreamControllerGetDesiredSize(controller) {
    var state = controller._controlledReadableByteStream._state;

    if (state === 'errored') {
      return null;
    }

    if (state === 'closed') {
      return 0;
    }

    return controller._strategyHWM - controller._queueTotalSize;
  }

  function ReadableByteStreamControllerRespond(controller, bytesWritten) {
    var firstDescriptor = controller._pendingPullIntos.peek();

    var state = controller._controlledReadableByteStream._state;

    if (state === 'closed') {
      if (bytesWritten !== 0) {
        throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');
      }
    } else {
      if (bytesWritten === 0) {
        throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');
      }

      if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
        throw new RangeError('bytesWritten out of range');
      }
    }

    firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
    ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
  }

  function ReadableByteStreamControllerRespondWithNewView(controller, view) {
    var firstDescriptor = controller._pendingPullIntos.peek();

    var state = controller._controlledReadableByteStream._state;

    if (state === 'closed') {
      if (view.byteLength !== 0) {
        throw new TypeError('The view\'s length must be 0 when calling respondWithNewView() on a closed stream');
      }
    } else {
      if (view.byteLength === 0) {
        throw new TypeError('The view\'s length must be greater than 0 when calling respondWithNewView() on a readable stream');
      }
    }

    if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
      throw new RangeError('The region specified by view does not match byobRequest');
    }

    if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
      throw new RangeError('The buffer of view has different capacity than byobRequest');
    }

    if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
      throw new RangeError('The region specified by view is larger than byobRequest');
    }

    var viewByteLength = view.byteLength;
    firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
    ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
  }

  function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
    controller._controlledReadableByteStream = stream;
    controller._pullAgain = false;
    controller._pulling = false;
    controller._byobRequest = null; // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.

    controller._queue = controller._queueTotalSize = undefined;
    ResetQueue(controller);
    controller._closeRequested = false;
    controller._started = false;
    controller._strategyHWM = highWaterMark;
    controller._pullAlgorithm = pullAlgorithm;
    controller._cancelAlgorithm = cancelAlgorithm;
    controller._autoAllocateChunkSize = autoAllocateChunkSize;
    controller._pendingPullIntos = new SimpleQueue();
    stream._readableStreamController = controller;
    var startResult = startAlgorithm();
    uponPromise(promiseResolvedWith(startResult), function () {
      controller._started = true;
      ReadableByteStreamControllerCallPullIfNeeded(controller);
    }, function (r) {
      ReadableByteStreamControllerError(controller, r);
    });
  }

  function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
    var controller = Object.create(ReadableByteStreamController.prototype);

    var startAlgorithm = function () {
      return undefined;
    };

    var pullAlgorithm = function () {
      return promiseResolvedWith(undefined);
    };

    var cancelAlgorithm = function () {
      return promiseResolvedWith(undefined);
    };

    if (underlyingByteSource.start !== undefined) {
      startAlgorithm = function () {
        return underlyingByteSource.start(controller);
      };
    }

    if (underlyingByteSource.pull !== undefined) {
      pullAlgorithm = function () {
        return underlyingByteSource.pull(controller);
      };
    }

    if (underlyingByteSource.cancel !== undefined) {
      cancelAlgorithm = function (reason) {
        return underlyingByteSource.cancel(reason);
      };
    }

    var autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;

    if (autoAllocateChunkSize === 0) {
      throw new TypeError('autoAllocateChunkSize must be greater than 0');
    }

    SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
  }

  function SetUpReadableStreamBYOBRequest(request, controller, view) {
    request._associatedReadableByteStreamController = controller;
    request._view = view;
  } // Helper functions for the ReadableStreamBYOBRequest.


  function byobRequestBrandCheckException(name) {
    return new TypeError("ReadableStreamBYOBRequest.prototype." + name + " can only be used on a ReadableStreamBYOBRequest");
  } // Helper functions for the ReadableByteStreamController.


  function byteStreamControllerBrandCheckException(name) {
    return new TypeError("ReadableByteStreamController.prototype." + name + " can only be used on a ReadableByteStreamController");
  } // Abstract operations for the ReadableStream.


  function AcquireReadableStreamBYOBReader(stream) {
    return new ReadableStreamBYOBReader(stream);
  } // ReadableStream API exposed for controllers.


  function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
    stream._reader._readIntoRequests.push(readIntoRequest);
  }

  function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
    var reader = stream._reader;

    var readIntoRequest = reader._readIntoRequests.shift();

    if (done) {
      readIntoRequest._closeSteps(chunk);
    } else {
      readIntoRequest._chunkSteps(chunk);
    }
  }

  function ReadableStreamGetNumReadIntoRequests(stream) {
    return stream._reader._readIntoRequests.length;
  }

  function ReadableStreamHasBYOBReader(stream) {
    var reader = stream._reader;

    if (reader === undefined) {
      return false;
    }

    if (!IsReadableStreamBYOBReader(reader)) {
      return false;
    }

    return true;
  }
  /**
   * A BYOB reader vended by a {@link ReadableStream}.
   *
   * @public
   */


  var ReadableStreamBYOBReader =
  /** @class */
  function () {
    function ReadableStreamBYOBReader(stream) {
      assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');
      assertReadableStream(stream, 'First parameter');

      if (IsReadableStreamLocked(stream)) {
        throw new TypeError('This stream has already been locked for exclusive reading by another reader');
      }

      if (!IsReadableByteStreamController(stream._readableStreamController)) {
        throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' + 'source');
      }

      ReadableStreamReaderGenericInitialize(this, stream);
      this._readIntoRequests = new SimpleQueue();
    }

    Object.defineProperty(ReadableStreamBYOBReader.prototype, "closed", {
      /**
       * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
       * the reader's lock is released before the stream finishes closing.
       */
      get: function () {
        if (!IsReadableStreamBYOBReader(this)) {
          return promiseRejectedWith(byobReaderBrandCheckException('closed'));
        }

        return this._closedPromise;
      },
      enumerable: false,
      configurable: true
    });
    /**
     * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
     */

    ReadableStreamBYOBReader.prototype.cancel = function (reason) {
      if (reason === void 0) {
        reason = undefined;
      }

      if (!IsReadableStreamBYOBReader(this)) {
        return promiseRejectedWith(byobReaderBrandCheckException('cancel'));
      }

      if (this._ownerReadableStream === undefined) {
        return promiseRejectedWith(readerLockException('cancel'));
      }

      return ReadableStreamReaderGenericCancel(this, reason);
    };
    /**
     * Attempts to reads bytes into view, and returns a promise resolved with the result.
     *
     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
     */


    ReadableStreamBYOBReader.prototype.read = function (view) {
      if (!IsReadableStreamBYOBReader(this)) {
        return promiseRejectedWith(byobReaderBrandCheckException('read'));
      }

      if (!ArrayBuffer.isView(view)) {
        return promiseRejectedWith(new TypeError('view must be an array buffer view'));
      }

      if (view.byteLength === 0) {
        return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));
      }

      if (view.buffer.byteLength === 0) {
        return promiseRejectedWith(new TypeError("view's buffer must have non-zero byteLength"));
      }

      if (IsDetachedBuffer(view.buffer)) ;

      if (this._ownerReadableStream === undefined) {
        return promiseRejectedWith(readerLockException('read from'));
      }

      var resolvePromise;
      var rejectPromise;
      var promise = newPromise(function (resolve, reject) {
        resolvePromise = resolve;
        rejectPromise = reject;
      });
      var readIntoRequest = {
        _chunkSteps: function (chunk) {
          return resolvePromise({
            value: chunk,
            done: false
          });
        },
        _closeSteps: function (chunk) {
          return resolvePromise({
            value: chunk,
            done: true
          });
        },
        _errorSteps: function (e) {
          return rejectPromise(e);
        }
      };
      ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
      return promise;
    };
    /**
     * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
     * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
     * from now on; otherwise, the reader will appear closed.
     *
     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
     * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to
     * do so will throw a `TypeError` and leave the reader locked to the stream.
     */


    ReadableStreamBYOBReader.prototype.releaseLock = function () {
      if (!IsReadableStreamBYOBReader(this)) {
        throw byobReaderBrandCheckException('releaseLock');
      }

      if (this._ownerReadableStream === undefined) {
        return;
      }

      if (this._readIntoRequests.length > 0) {
        throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
      }

      ReadableStreamReaderGenericRelease(this);
    };

    return ReadableStreamBYOBReader;
  }();

  Object.defineProperties(ReadableStreamBYOBReader.prototype, {
    cancel: {
      enumerable: true
    },
    read: {
      enumerable: true
    },
    releaseLock: {
      enumerable: true
    },
    closed: {
      enumerable: true
    }
  });

  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
      value: 'ReadableStreamBYOBReader',
      configurable: true
    });
  } // Abstract operations for the readers.


  function IsReadableStreamBYOBReader(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {
      return false;
    }

    return x instanceof ReadableStreamBYOBReader;
  }

  function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
    var stream = reader._ownerReadableStream;
    stream._disturbed = true;

    if (stream._state === 'errored') {
      readIntoRequest._errorSteps(stream._storedError);
    } else {
      ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
    }
  } // Helper functions for the ReadableStreamBYOBReader.


  function byobReaderBrandCheckException(name) {
    return new TypeError("ReadableStreamBYOBReader.prototype." + name + " can only be used on a ReadableStreamBYOBReader");
  }

  function ExtractHighWaterMark(strategy, defaultHWM) {
    var highWaterMark = strategy.highWaterMark;

    if (highWaterMark === undefined) {
      return defaultHWM;
    }

    if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
      throw new RangeError('Invalid highWaterMark');
    }

    return highWaterMark;
  }

  function ExtractSizeAlgorithm(strategy) {
    var size = strategy.size;

    if (!size) {
      return function () {
        return 1;
      };
    }

    return size;
  }

  function convertQueuingStrategy(init, context) {
    assertDictionary(init, context);
    var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
    var size = init === null || init === void 0 ? void 0 : init.size;
    return {
      highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),
      size: size === undefined ? undefined : convertQueuingStrategySize(size, context + " has member 'size' that")
    };
  }

  function convertQueuingStrategySize(fn, context) {
    assertFunction(fn, context);
    return function (chunk) {
      return convertUnrestrictedDouble(fn(chunk));
    };
  }

  function convertUnderlyingSink(original, context) {
    assertDictionary(original, context);
    var abort = original === null || original === void 0 ? void 0 : original.abort;
    var close = original === null || original === void 0 ? void 0 : original.close;
    var start = original === null || original === void 0 ? void 0 : original.start;
    var type = original === null || original === void 0 ? void 0 : original.type;
    var write = original === null || original === void 0 ? void 0 : original.write;
    return {
      abort: abort === undefined ? undefined : convertUnderlyingSinkAbortCallback(abort, original, context + " has member 'abort' that"),
      close: close === undefined ? undefined : convertUnderlyingSinkCloseCallback(close, original, context + " has member 'close' that"),
      start: start === undefined ? undefined : convertUnderlyingSinkStartCallback(start, original, context + " has member 'start' that"),
      write: write === undefined ? undefined : convertUnderlyingSinkWriteCallback(write, original, context + " has member 'write' that"),
      type: type
    };
  }

  function convertUnderlyingSinkAbortCallback(fn, original, context) {
    assertFunction(fn, context);
    return function (reason) {
      return promiseCall(fn, original, [reason]);
    };
  }

  function convertUnderlyingSinkCloseCallback(fn, original, context) {
    assertFunction(fn, context);
    return function () {
      return promiseCall(fn, original, []);
    };
  }

  function convertUnderlyingSinkStartCallback(fn, original, context) {
    assertFunction(fn, context);
    return function (controller) {
      return reflectCall(fn, original, [controller]);
    };
  }

  function convertUnderlyingSinkWriteCallback(fn, original, context) {
    assertFunction(fn, context);
    return function (chunk, controller) {
      return promiseCall(fn, original, [chunk, controller]);
    };
  }

  function assertWritableStream(x, context) {
    if (!IsWritableStream(x)) {
      throw new TypeError(context + " is not a WritableStream.");
    }
  }

  function isAbortSignal(value) {
    if (typeof value !== 'object' || value === null) {
      return false;
    }

    try {
      return typeof value.aborted === 'boolean';
    } catch (_a) {
      // AbortSignal.prototype.aborted throws if its brand check fails
      return false;
    }
  }

  var supportsAbortController = typeof AbortController === 'function';
  /**
   * Construct a new AbortController, if supported by the platform.
   *
   * @internal
   */

  function createAbortController() {
    if (supportsAbortController) {
      return new AbortController();
    }

    return undefined;
  }
  /**
   * A writable stream represents a destination for data, into which you can write.
   *
   * @public
   */


  var WritableStream =
  /** @class */
  function () {
    function WritableStream(rawUnderlyingSink, rawStrategy) {
      if (rawUnderlyingSink === void 0) {
        rawUnderlyingSink = {};
      }

      if (rawStrategy === void 0) {
        rawStrategy = {};
      }

      if (rawUnderlyingSink === undefined) {
        rawUnderlyingSink = null;
      } else {
        assertObject(rawUnderlyingSink, 'First parameter');
      }

      var strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');
      var underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');
      InitializeWritableStream(this);
      var type = underlyingSink.type;

      if (type !== undefined) {
        throw new RangeError('Invalid type is specified');
      }

      var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
      var highWaterMark = ExtractHighWaterMark(strategy, 1);
      SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
    }

    Object.defineProperty(WritableStream.prototype, "locked", {
      /**
       * Returns whether or not the writable stream is locked to a writer.
       */
      get: function () {
        if (!IsWritableStream(this)) {
          throw streamBrandCheckException$2('locked');
        }

        return IsWritableStreamLocked(this);
      },
      enumerable: false,
      configurable: true
    });
    /**
     * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be
     * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort
     * mechanism of the underlying sink.
     *
     * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled
     * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel
     * the stream) if the stream is currently locked.
     */

    WritableStream.prototype.abort = function (reason) {
      if (reason === void 0) {
        reason = undefined;
      }

      if (!IsWritableStream(this)) {
        return promiseRejectedWith(streamBrandCheckException$2('abort'));
      }

      if (IsWritableStreamLocked(this)) {
        return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));
      }

      return WritableStreamAbort(this, reason);
    };
    /**
     * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its
     * close behavior. During this time any further attempts to write will fail (without erroring the stream).
     *
     * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream
     * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with
     * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.
     */


    WritableStream.prototype.close = function () {
      if (!IsWritableStream(this)) {
        return promiseRejectedWith(streamBrandCheckException$2('close'));
      }

      if (IsWritableStreamLocked(this)) {
        return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));
      }

      if (WritableStreamCloseQueuedOrInFlight(this)) {
        return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));
      }

      return WritableStreamClose(this);
    };
    /**
     * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream
     * is locked, no other writer can be acquired until this one is released.
     *
     * This functionality is especially useful for creating abstractions that desire the ability to write to a stream
     * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at
     * the same time, which would cause the resulting written data to be unpredictable and probably useless.
     */


    WritableStream.prototype.getWriter = function () {
      if (!IsWritableStream(this)) {
        throw streamBrandCheckException$2('getWriter');
      }

      return AcquireWritableStreamDefaultWriter(this);
    };

    return WritableStream;
  }();

  Object.defineProperties(WritableStream.prototype, {
    abort: {
      enumerable: true
    },
    close: {
      enumerable: true
    },
    getWriter: {
      enumerable: true
    },
    locked: {
      enumerable: true
    }
  });

  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
      value: 'WritableStream',
      configurable: true
    });
  } // Abstract operations for the WritableStream.


  function AcquireWritableStreamDefaultWriter(stream) {
    return new WritableStreamDefaultWriter(stream);
  } // Throws if and only if startAlgorithm throws.


  function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
    if (highWaterMark === void 0) {
      highWaterMark = 1;
    }

    if (sizeAlgorithm === void 0) {
      sizeAlgorithm = function () {
        return 1;
      };
    }

    var stream = Object.create(WritableStream.prototype);
    InitializeWritableStream(stream);
    var controller = Object.create(WritableStreamDefaultController.prototype);
    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
    return stream;
  }

  function InitializeWritableStream(stream) {
    stream._state = 'writable'; // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is
    // 'erroring' or 'errored'. May be set to an undefined value.

    stream._storedError = undefined;
    stream._writer = undefined; // Initialize to undefined first because the constructor of the controller checks this
    // variable to validate the caller.

    stream._writableStreamController = undefined; // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data
    // producer without waiting for the queued writes to finish.

    stream._writeRequests = new SimpleQueue(); // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents
    // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.

    stream._inFlightWriteRequest = undefined; // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer
    // has been detached.

    stream._closeRequest = undefined; // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it
    // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.

    stream._inFlightCloseRequest = undefined; // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.

    stream._pendingAbortRequest = undefined; // The backpressure signal set by the controller.

    stream._backpressure = false;
  }

  function IsWritableStream(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {
      return false;
    }

    return x instanceof WritableStream;
  }

  function IsWritableStreamLocked(stream) {
    if (stream._writer === undefined) {
      return false;
    }

    return true;
  }

  function WritableStreamAbort(stream, reason) {
    var _a;

    if (stream._state === 'closed' || stream._state === 'errored') {
      return promiseResolvedWith(undefined);
    }

    stream._writableStreamController._abortReason = reason;
    (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort(); // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',
    // but it doesn't know that signaling abort runs author code that might have changed the state.
    // Widen the type again by casting to WritableStreamState.

    var state = stream._state;

    if (state === 'closed' || state === 'errored') {
      return promiseResolvedWith(undefined);
    }

    if (stream._pendingAbortRequest !== undefined) {
      return stream._pendingAbortRequest._promise;
    }

    var wasAlreadyErroring = false;

    if (state === 'erroring') {
      wasAlreadyErroring = true; // reason will not be used, so don't keep a reference to it.

      reason = undefined;
    }

    var promise = newPromise(function (resolve, reject) {
      stream._pendingAbortRequest = {
        _promise: undefined,
        _resolve: resolve,
        _reject: reject,
        _reason: reason,
        _wasAlreadyErroring: wasAlreadyErroring
      };
    });
    stream._pendingAbortRequest._promise = promise;

    if (!wasAlreadyErroring) {
      WritableStreamStartErroring(stream, reason);
    }

    return promise;
  }

  function WritableStreamClose(stream) {
    var state = stream._state;

    if (state === 'closed' || state === 'errored') {
      return promiseRejectedWith(new TypeError("The stream (in " + state + " state) is not in the writable state and cannot be closed"));
    }

    var promise = newPromise(function (resolve, reject) {
      var closeRequest = {
        _resolve: resolve,
        _reject: reject
      };
      stream._closeRequest = closeRequest;
    });
    var writer = stream._writer;

    if (writer !== undefined && stream._backpressure && state === 'writable') {
      defaultWriterReadyPromiseResolve(writer);
    }

    WritableStreamDefaultControllerClose(stream._writableStreamController);
    return promise;
  } // WritableStream API exposed for controllers.


  function WritableStreamAddWriteRequest(stream) {
    var promise = newPromise(function (resolve, reject) {
      var writeRequest = {
        _resolve: resolve,
        _reject: reject
      };

      stream._writeRequests.push(writeRequest);
    });
    return promise;
  }

  function WritableStreamDealWithRejection(stream, error) {
    var state = stream._state;

    if (state === 'writable') {
      WritableStreamStartErroring(stream, error);
      return;
    }

    WritableStreamFinishErroring(stream);
  }

  function WritableStreamStartErroring(stream, reason) {
    var controller = stream._writableStreamController;
    stream._state = 'erroring';
    stream._storedError = reason;
    var writer = stream._writer;

    if (writer !== undefined) {
      WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
    }

    if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
      WritableStreamFinishErroring(stream);
    }
  }

  function WritableStreamFinishErroring(stream) {
    stream._state = 'errored';

    stream._writableStreamController[ErrorSteps]();

    var storedError = stream._storedError;

    stream._writeRequests.forEach(function (writeRequest) {
      writeRequest._reject(storedError);
    });

    stream._writeRequests = new SimpleQueue();

    if (stream._pendingAbortRequest === undefined) {
      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
      return;
    }

    var abortRequest = stream._pendingAbortRequest;
    stream._pendingAbortRequest = undefined;

    if (abortRequest._wasAlreadyErroring) {
      abortRequest._reject(storedError);

      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
      return;
    }

    var promise = stream._writableStreamController[AbortSteps](abortRequest._reason);

    uponPromise(promise, function () {
      abortRequest._resolve();

      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
    }, function (reason) {
      abortRequest._reject(reason);

      WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
    });
  }

  function WritableStreamFinishInFlightWrite(stream) {
    stream._inFlightWriteRequest._resolve(undefined);

    stream._inFlightWriteRequest = undefined;
  }

  function WritableStreamFinishInFlightWriteWithError(stream, error) {
    stream._inFlightWriteRequest._reject(error);

    stream._inFlightWriteRequest = undefined;
    WritableStreamDealWithRejection(stream, error);
  }

  function WritableStreamFinishInFlightClose(stream) {
    stream._inFlightCloseRequest._resolve(undefined);

    stream._inFlightCloseRequest = undefined;
    var state = stream._state;

    if (state === 'erroring') {
      // The error was too late to do anything, so it is ignored.
      stream._storedError = undefined;

      if (stream._pendingAbortRequest !== undefined) {
        stream._pendingAbortRequest._resolve();

        stream._pendingAbortRequest = undefined;
      }
    }

    stream._state = 'closed';
    var writer = stream._writer;

    if (writer !== undefined) {
      defaultWriterClosedPromiseResolve(writer);
    }
  }

  function WritableStreamFinishInFlightCloseWithError(stream, error) {
    stream._inFlightCloseRequest._reject(error);

    stream._inFlightCloseRequest = undefined; // Never execute sink abort() after sink close().

    if (stream._pendingAbortRequest !== undefined) {
      stream._pendingAbortRequest._reject(error);

      stream._pendingAbortRequest = undefined;
    }

    WritableStreamDealWithRejection(stream, error);
  } // TODO(ricea): Fix alphabetical order.


  function WritableStreamCloseQueuedOrInFlight(stream) {
    if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {
      return false;
    }

    return true;
  }

  function WritableStreamHasOperationMarkedInFlight(stream) {
    if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {
      return false;
    }

    return true;
  }

  function WritableStreamMarkCloseRequestInFlight(stream) {
    stream._inFlightCloseRequest = stream._closeRequest;
    stream._closeRequest = undefined;
  }

  function WritableStreamMarkFirstWriteRequestInFlight(stream) {
    stream._inFlightWriteRequest = stream._writeRequests.shift();
  }

  function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
    if (stream._closeRequest !== undefined) {
      stream._closeRequest._reject(stream._storedError);

      stream._closeRequest = undefined;
    }

    var writer = stream._writer;

    if (writer !== undefined) {
      defaultWriterClosedPromiseReject(writer, stream._storedError);
    }
  }

  function WritableStreamUpdateBackpressure(stream, backpressure) {
    var writer = stream._writer;

    if (writer !== undefined && backpressure !== stream._backpressure) {
      if (backpressure) {
        defaultWriterReadyPromiseReset(writer);
      } else {
        defaultWriterReadyPromiseResolve(writer);
      }
    }

    stream._backpressure = backpressure;
  }
  /**
   * A default writer vended by a {@link WritableStream}.
   *
   * @public
   */


  var WritableStreamDefaultWriter =
  /** @class */
  function () {
    function WritableStreamDefaultWriter(stream) {
      assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');
      assertWritableStream(stream, 'First parameter');

      if (IsWritableStreamLocked(stream)) {
        throw new TypeError('This stream has already been locked for exclusive writing by another writer');
      }

      this._ownerWritableStream = stream;
      stream._writer = this;
      var state = stream._state;

      if (state === 'writable') {
        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
          defaultWriterReadyPromiseInitialize(this);
        } else {
          defaultWriterReadyPromiseInitializeAsResolved(this);
        }

        defaultWriterClosedPromiseInitialize(this);
      } else if (state === 'erroring') {
        defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
        defaultWriterClosedPromiseInitialize(this);
      } else if (state === 'closed') {
        defaultWriterReadyPromiseInitializeAsResolved(this);
        defaultWriterClosedPromiseInitializeAsResolved(this);
      } else {
        var storedError = stream._storedError;
        defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
        defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
      }
    }

    Object.defineProperty(WritableStreamDefaultWriter.prototype, "closed", {
      /**
       * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
       * the writers lock is released before the stream finishes closing.
       */
      get: function () {
        if (!IsWritableStreamDefaultWriter(this)) {
          return promiseRejectedWith(defaultWriterBrandCheckException('closed'));
        }

        return this._closedPromise;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(WritableStreamDefaultWriter.prototype, "desiredSize", {
      /**
       * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.
       * A producer can use this information to determine the right amount of data to write.
       *
       * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
       * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
       * the writers lock is released.
       */
      get: function () {
        if (!IsWritableStreamDefaultWriter(this)) {
          throw defaultWriterBrandCheckException('desiredSize');
        }

        if (this._ownerWritableStream === undefined) {
          throw defaultWriterLockException('desiredSize');
        }

        return WritableStreamDefaultWriterGetDesiredSize(this);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(WritableStreamDefaultWriter.prototype, "ready", {
      /**
       * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions
       * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
       * back to zero or below, the getter will return a new promise that stays pending until the next transition.
       *
       * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become
       * rejected.
       */
      get: function () {
        if (!IsWritableStreamDefaultWriter(this)) {
          return promiseRejectedWith(defaultWriterBrandCheckException('ready'));
        }

        return this._readyPromise;
      },
      enumerable: false,
      configurable: true
    });
    /**
     * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.
     */

    WritableStreamDefaultWriter.prototype.abort = function (reason) {
      if (reason === void 0) {
        reason = undefined;
      }

      if (!IsWritableStreamDefaultWriter(this)) {
        return promiseRejectedWith(defaultWriterBrandCheckException('abort'));
      }

      if (this._ownerWritableStream === undefined) {
        return promiseRejectedWith(defaultWriterLockException('abort'));
      }

      return WritableStreamDefaultWriterAbort(this, reason);
    };
    /**
     * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.
     */


    WritableStreamDefaultWriter.prototype.close = function () {
      if (!IsWritableStreamDefaultWriter(this)) {
        return promiseRejectedWith(defaultWriterBrandCheckException('close'));
      }

      var stream = this._ownerWritableStream;

      if (stream === undefined) {
        return promiseRejectedWith(defaultWriterLockException('close'));
      }

      if (WritableStreamCloseQueuedOrInFlight(stream)) {
        return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));
      }

      return WritableStreamDefaultWriterClose(this);
    };
    /**
     * Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.
     * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from
     * now on; otherwise, the writer will appear closed.
     *
     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the
     * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).
     * Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents
     * other producers from writing in an interleaved manner.
     */


    WritableStreamDefaultWriter.prototype.releaseLock = function () {
      if (!IsWritableStreamDefaultWriter(this)) {
        throw defaultWriterBrandCheckException('releaseLock');
      }

      var stream = this._ownerWritableStream;

      if (stream === undefined) {
        return;
      }

      WritableStreamDefaultWriterRelease(this);
    };

    WritableStreamDefaultWriter.prototype.write = function (chunk) {
      if (chunk === void 0) {
        chunk = undefined;
      }

      if (!IsWritableStreamDefaultWriter(this)) {
        return promiseRejectedWith(defaultWriterBrandCheckException('write'));
      }

      if (this._ownerWritableStream === undefined) {
        return promiseRejectedWith(defaultWriterLockException('write to'));
      }

      return WritableStreamDefaultWriterWrite(this, chunk);
    };

    return WritableStreamDefaultWriter;
  }();

  Object.defineProperties(WritableStreamDefaultWriter.prototype, {
    abort: {
      enumerable: true
    },
    close: {
      enumerable: true
    },
    releaseLock: {
      enumerable: true
    },
    write: {
      enumerable: true
    },
    closed: {
      enumerable: true
    },
    desiredSize: {
      enumerable: true
    },
    ready: {
      enumerable: true
    }
  });

  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
      value: 'WritableStreamDefaultWriter',
      configurable: true
    });
  } // Abstract operations for the WritableStreamDefaultWriter.


  function IsWritableStreamDefaultWriter(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {
      return false;
    }

    return x instanceof WritableStreamDefaultWriter;
  } // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.


  function WritableStreamDefaultWriterAbort(writer, reason) {
    var stream = writer._ownerWritableStream;
    return WritableStreamAbort(stream, reason);
  }

  function WritableStreamDefaultWriterClose(writer) {
    var stream = writer._ownerWritableStream;
    return WritableStreamClose(stream);
  }

  function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
    var stream = writer._ownerWritableStream;
    var state = stream._state;

    if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {
      return promiseResolvedWith(undefined);
    }

    if (state === 'errored') {
      return promiseRejectedWith(stream._storedError);
    }

    return WritableStreamDefaultWriterClose(writer);
  }

  function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
    if (writer._closedPromiseState === 'pending') {
      defaultWriterClosedPromiseReject(writer, error);
    } else {
      defaultWriterClosedPromiseResetToRejected(writer, error);
    }
  }

  function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
    if (writer._readyPromiseState === 'pending') {
      defaultWriterReadyPromiseReject(writer, error);
    } else {
      defaultWriterReadyPromiseResetToRejected(writer, error);
    }
  }

  function WritableStreamDefaultWriterGetDesiredSize(writer) {
    var stream = writer._ownerWritableStream;
    var state = stream._state;

    if (state === 'errored' || state === 'erroring') {
      return null;
    }

    if (state === 'closed') {
      return 0;
    }

    return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
  }

  function WritableStreamDefaultWriterRelease(writer) {
    var stream = writer._ownerWritableStream;
    var releasedError = new TypeError("Writer was released and can no longer be used to monitor the stream's closedness");
    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError); // The state transitions to "errored" before the sink abort() method runs, but the writer.closed promise is not
    // rejected until afterwards. This means that simply testing state will not work.

    WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
    stream._writer = undefined;
    writer._ownerWritableStream = undefined;
  }

  function WritableStreamDefaultWriterWrite(writer, chunk) {
    var stream = writer._ownerWritableStream;
    var controller = stream._writableStreamController;
    var chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);

    if (stream !== writer._ownerWritableStream) {
      return promiseRejectedWith(defaultWriterLockException('write to'));
    }

    var state = stream._state;

    if (state === 'errored') {
      return promiseRejectedWith(stream._storedError);
    }

    if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {
      return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));
    }

    if (state === 'erroring') {
      return promiseRejectedWith(stream._storedError);
    }

    var promise = WritableStreamAddWriteRequest(stream);
    WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
    return promise;
  }

  var closeSentinel = {};
  /**
   * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.
   *
   * @public
   */

  var WritableStreamDefaultController =
  /** @class */
  function () {
    function WritableStreamDefaultController() {
      throw new TypeError('Illegal constructor');
    }

    Object.defineProperty(WritableStreamDefaultController.prototype, "abortReason", {
      /**
       * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
       *
       * @deprecated
       *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
       *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
       */
      get: function () {
        if (!IsWritableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$2('abortReason');
        }

        return this._abortReason;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(WritableStreamDefaultController.prototype, "signal", {
      /**
       * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
       */
      get: function () {
        if (!IsWritableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$2('signal');
        }

        if (this._abortController === undefined) {
          // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.
          // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,
          // so instead we only implement support for `signal` if we find a global `AbortController` constructor.
          throw new TypeError('WritableStreamDefaultController.prototype.signal is not supported');
        }

        return this._abortController.signal;
      },
      enumerable: false,
      configurable: true
    });
    /**
     * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.
     *
     * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying
     * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the
     * normal lifecycle of interactions with the underlying sink.
     */

    WritableStreamDefaultController.prototype.error = function (e) {
      if (e === void 0) {
        e = undefined;
      }

      if (!IsWritableStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException$2('error');
      }

      var state = this._controlledWritableStream._state;

      if (state !== 'writable') {
        // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so
        // just treat it as a no-op.
        return;
      }

      WritableStreamDefaultControllerError(this, e);
    };
    /** @internal */


    WritableStreamDefaultController.prototype[AbortSteps] = function (reason) {
      var result = this._abortAlgorithm(reason);

      WritableStreamDefaultControllerClearAlgorithms(this);
      return result;
    };
    /** @internal */


    WritableStreamDefaultController.prototype[ErrorSteps] = function () {
      ResetQueue(this);
    };

    return WritableStreamDefaultController;
  }();

  Object.defineProperties(WritableStreamDefaultController.prototype, {
    abortReason: {
      enumerable: true
    },
    signal: {
      enumerable: true
    },
    error: {
      enumerable: true
    }
  });

  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
      value: 'WritableStreamDefaultController',
      configurable: true
    });
  } // Abstract operations implementing interface required by the WritableStream.


  function IsWritableStreamDefaultController(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {
      return false;
    }

    return x instanceof WritableStreamDefaultController;
  }

  function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
    controller._controlledWritableStream = stream;
    stream._writableStreamController = controller; // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.

    controller._queue = undefined;
    controller._queueTotalSize = undefined;
    ResetQueue(controller);
    controller._abortReason = undefined;
    controller._abortController = createAbortController();
    controller._started = false;
    controller._strategySizeAlgorithm = sizeAlgorithm;
    controller._strategyHWM = highWaterMark;
    controller._writeAlgorithm = writeAlgorithm;
    controller._closeAlgorithm = closeAlgorithm;
    controller._abortAlgorithm = abortAlgorithm;
    var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
    WritableStreamUpdateBackpressure(stream, backpressure);
    var startResult = startAlgorithm();
    var startPromise = promiseResolvedWith(startResult);
    uponPromise(startPromise, function () {
      controller._started = true;
      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
    }, function (r) {
      controller._started = true;
      WritableStreamDealWithRejection(stream, r);
    });
  }

  function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
    var controller = Object.create(WritableStreamDefaultController.prototype);

    var startAlgorithm = function () {
      return undefined;
    };

    var writeAlgorithm = function () {
      return promiseResolvedWith(undefined);
    };

    var closeAlgorithm = function () {
      return promiseResolvedWith(undefined);
    };

    var abortAlgorithm = function () {
      return promiseResolvedWith(undefined);
    };

    if (underlyingSink.start !== undefined) {
      startAlgorithm = function () {
        return underlyingSink.start(controller);
      };
    }

    if (underlyingSink.write !== undefined) {
      writeAlgorithm = function (chunk) {
        return underlyingSink.write(chunk, controller);
      };
    }

    if (underlyingSink.close !== undefined) {
      closeAlgorithm = function () {
        return underlyingSink.close();
      };
    }

    if (underlyingSink.abort !== undefined) {
      abortAlgorithm = function (reason) {
        return underlyingSink.abort(reason);
      };
    }

    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
  } // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.


  function WritableStreamDefaultControllerClearAlgorithms(controller) {
    controller._writeAlgorithm = undefined;
    controller._closeAlgorithm = undefined;
    controller._abortAlgorithm = undefined;
    controller._strategySizeAlgorithm = undefined;
  }

  function WritableStreamDefaultControllerClose(controller) {
    EnqueueValueWithSize(controller, closeSentinel, 0);
    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
  }

  function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
    try {
      return controller._strategySizeAlgorithm(chunk);
    } catch (chunkSizeE) {
      WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
      return 1;
    }
  }

  function WritableStreamDefaultControllerGetDesiredSize(controller) {
    return controller._strategyHWM - controller._queueTotalSize;
  }

  function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
    try {
      EnqueueValueWithSize(controller, chunk, chunkSize);
    } catch (enqueueE) {
      WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
      return;
    }

    var stream = controller._controlledWritableStream;

    if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {
      var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
      WritableStreamUpdateBackpressure(stream, backpressure);
    }

    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
  } // Abstract operations for the WritableStreamDefaultController.


  function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
    var stream = controller._controlledWritableStream;

    if (!controller._started) {
      return;
    }

    if (stream._inFlightWriteRequest !== undefined) {
      return;
    }

    var state = stream._state;

    if (state === 'erroring') {
      WritableStreamFinishErroring(stream);
      return;
    }

    if (controller._queue.length === 0) {
      return;
    }

    var value = PeekQueueValue(controller);

    if (value === closeSentinel) {
      WritableStreamDefaultControllerProcessClose(controller);
    } else {
      WritableStreamDefaultControllerProcessWrite(controller, value);
    }
  }

  function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
    if (controller._controlledWritableStream._state === 'writable') {
      WritableStreamDefaultControllerError(controller, error);
    }
  }

  function WritableStreamDefaultControllerProcessClose(controller) {
    var stream = controller._controlledWritableStream;
    WritableStreamMarkCloseRequestInFlight(stream);
    DequeueValue(controller);

    var sinkClosePromise = controller._closeAlgorithm();

    WritableStreamDefaultControllerClearAlgorithms(controller);
    uponPromise(sinkClosePromise, function () {
      WritableStreamFinishInFlightClose(stream);
    }, function (reason) {
      WritableStreamFinishInFlightCloseWithError(stream, reason);
    });
  }

  function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
    var stream = controller._controlledWritableStream;
    WritableStreamMarkFirstWriteRequestInFlight(stream);

    var sinkWritePromise = controller._writeAlgorithm(chunk);

    uponPromise(sinkWritePromise, function () {
      WritableStreamFinishInFlightWrite(stream);
      var state = stream._state;
      DequeueValue(controller);

      if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {
        var backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
        WritableStreamUpdateBackpressure(stream, backpressure);
      }

      WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
    }, function (reason) {
      if (stream._state === 'writable') {
        WritableStreamDefaultControllerClearAlgorithms(controller);
      }

      WritableStreamFinishInFlightWriteWithError(stream, reason);
    });
  }

  function WritableStreamDefaultControllerGetBackpressure(controller) {
    var desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
    return desiredSize <= 0;
  } // A client of WritableStreamDefaultController may use these functions directly to bypass state check.


  function WritableStreamDefaultControllerError(controller, error) {
    var stream = controller._controlledWritableStream;
    WritableStreamDefaultControllerClearAlgorithms(controller);
    WritableStreamStartErroring(stream, error);
  } // Helper functions for the WritableStream.


  function streamBrandCheckException$2(name) {
    return new TypeError("WritableStream.prototype." + name + " can only be used on a WritableStream");
  } // Helper functions for the WritableStreamDefaultController.


  function defaultControllerBrandCheckException$2(name) {
    return new TypeError("WritableStreamDefaultController.prototype." + name + " can only be used on a WritableStreamDefaultController");
  } // Helper functions for the WritableStreamDefaultWriter.


  function defaultWriterBrandCheckException(name) {
    return new TypeError("WritableStreamDefaultWriter.prototype." + name + " can only be used on a WritableStreamDefaultWriter");
  }

  function defaultWriterLockException(name) {
    return new TypeError('Cannot ' + name + ' a stream using a released writer');
  }

  function defaultWriterClosedPromiseInitialize(writer) {
    writer._closedPromise = newPromise(function (resolve, reject) {
      writer._closedPromise_resolve = resolve;
      writer._closedPromise_reject = reject;
      writer._closedPromiseState = 'pending';
    });
  }

  function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
    defaultWriterClosedPromiseInitialize(writer);
    defaultWriterClosedPromiseReject(writer, reason);
  }

  function defaultWriterClosedPromiseInitializeAsResolved(writer) {
    defaultWriterClosedPromiseInitialize(writer);
    defaultWriterClosedPromiseResolve(writer);
  }

  function defaultWriterClosedPromiseReject(writer, reason) {
    if (writer._closedPromise_reject === undefined) {
      return;
    }

    setPromiseIsHandledToTrue(writer._closedPromise);

    writer._closedPromise_reject(reason);

    writer._closedPromise_resolve = undefined;
    writer._closedPromise_reject = undefined;
    writer._closedPromiseState = 'rejected';
  }

  function defaultWriterClosedPromiseResetToRejected(writer, reason) {
    defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
  }

  function defaultWriterClosedPromiseResolve(writer) {
    if (writer._closedPromise_resolve === undefined) {
      return;
    }

    writer._closedPromise_resolve(undefined);

    writer._closedPromise_resolve = undefined;
    writer._closedPromise_reject = undefined;
    writer._closedPromiseState = 'resolved';
  }

  function defaultWriterReadyPromiseInitialize(writer) {
    writer._readyPromise = newPromise(function (resolve, reject) {
      writer._readyPromise_resolve = resolve;
      writer._readyPromise_reject = reject;
    });
    writer._readyPromiseState = 'pending';
  }

  function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
    defaultWriterReadyPromiseInitialize(writer);
    defaultWriterReadyPromiseReject(writer, reason);
  }

  function defaultWriterReadyPromiseInitializeAsResolved(writer) {
    defaultWriterReadyPromiseInitialize(writer);
    defaultWriterReadyPromiseResolve(writer);
  }

  function defaultWriterReadyPromiseReject(writer, reason) {
    if (writer._readyPromise_reject === undefined) {
      return;
    }

    setPromiseIsHandledToTrue(writer._readyPromise);

    writer._readyPromise_reject(reason);

    writer._readyPromise_resolve = undefined;
    writer._readyPromise_reject = undefined;
    writer._readyPromiseState = 'rejected';
  }

  function defaultWriterReadyPromiseReset(writer) {
    defaultWriterReadyPromiseInitialize(writer);
  }

  function defaultWriterReadyPromiseResetToRejected(writer, reason) {
    defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
  }

  function defaultWriterReadyPromiseResolve(writer) {
    if (writer._readyPromise_resolve === undefined) {
      return;
    }

    writer._readyPromise_resolve(undefined);

    writer._readyPromise_resolve = undefined;
    writer._readyPromise_reject = undefined;
    writer._readyPromiseState = 'fulfilled';
  } /// <reference lib="dom" />


  var NativeDOMException = typeof DOMException !== 'undefined' ? DOMException : undefined; /// <reference types="node" />

  function isDOMExceptionConstructor(ctor) {
    if (!(typeof ctor === 'function' || typeof ctor === 'object')) {
      return false;
    }

    try {
      new ctor();
      return true;
    } catch (_a) {
      return false;
    }
  }

  function createDOMExceptionPolyfill() {
    // eslint-disable-next-line no-shadow
    var ctor = function DOMException(message, name) {
      this.message = message || '';
      this.name = name || 'Error';

      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
    };

    ctor.prototype = Object.create(Error.prototype);
    Object.defineProperty(ctor.prototype, 'constructor', {
      value: ctor,
      writable: true,
      configurable: true
    });
    return ctor;
  } // eslint-disable-next-line no-redeclare


  var DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();

  function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
    var reader = AcquireReadableStreamDefaultReader(source);
    var writer = AcquireWritableStreamDefaultWriter(dest);
    source._disturbed = true;
    var shuttingDown = false; // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.

    var currentWrite = promiseResolvedWith(undefined);
    return newPromise(function (resolve, reject) {
      var abortAlgorithm;

      if (signal !== undefined) {
        abortAlgorithm = function () {
          var error = new DOMException$1('Aborted', 'AbortError');
          var actions = [];

          if (!preventAbort) {
            actions.push(function () {
              if (dest._state === 'writable') {
                return WritableStreamAbort(dest, error);
              }

              return promiseResolvedWith(undefined);
            });
          }

          if (!preventCancel) {
            actions.push(function () {
              if (source._state === 'readable') {
                return ReadableStreamCancel(source, error);
              }

              return promiseResolvedWith(undefined);
            });
          }

          shutdownWithAction(function () {
            return Promise.all(actions.map(function (action) {
              return action();
            }));
          }, true, error);
        };

        if (signal.aborted) {
          abortAlgorithm();
          return;
        }

        signal.addEventListener('abort', abortAlgorithm);
      } // Using reader and writer, read all chunks from this and write them to dest
      // - Backpressure must be enforced
      // - Shutdown must stop all activity


      function pipeLoop() {
        return newPromise(function (resolveLoop, rejectLoop) {
          function next(done) {
            if (done) {
              resolveLoop();
            } else {
              // Use `PerformPromiseThen` instead of `uponPromise` to avoid
              // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers
              PerformPromiseThen(pipeStep(), next, rejectLoop);
            }
          }

          next(false);
        });
      }

      function pipeStep() {
        if (shuttingDown) {
          return promiseResolvedWith(true);
        }

        return PerformPromiseThen(writer._readyPromise, function () {
          return newPromise(function (resolveRead, rejectRead) {
            ReadableStreamDefaultReaderRead(reader, {
              _chunkSteps: function (chunk) {
                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);
                resolveRead(false);
              },
              _closeSteps: function () {
                return resolveRead(true);
              },
              _errorSteps: rejectRead
            });
          });
        });
      } // Errors must be propagated forward


      isOrBecomesErrored(source, reader._closedPromise, function (storedError) {
        if (!preventAbort) {
          shutdownWithAction(function () {
            return WritableStreamAbort(dest, storedError);
          }, true, storedError);
        } else {
          shutdown(true, storedError);
        }
      }); // Errors must be propagated backward

      isOrBecomesErrored(dest, writer._closedPromise, function (storedError) {
        if (!preventCancel) {
          shutdownWithAction(function () {
            return ReadableStreamCancel(source, storedError);
          }, true, storedError);
        } else {
          shutdown(true, storedError);
        }
      }); // Closing must be propagated forward

      isOrBecomesClosed(source, reader._closedPromise, function () {
        if (!preventClose) {
          shutdownWithAction(function () {
            return WritableStreamDefaultWriterCloseWithErrorPropagation(writer);
          });
        } else {
          shutdown();
        }
      }); // Closing must be propagated backward

      if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {
        var destClosed_1 = new TypeError('the destination writable stream closed before all data could be piped to it');

        if (!preventCancel) {
          shutdownWithAction(function () {
            return ReadableStreamCancel(source, destClosed_1);
          }, true, destClosed_1);
        } else {
          shutdown(true, destClosed_1);
        }
      }

      setPromiseIsHandledToTrue(pipeLoop());

      function waitForWritesToFinish() {
        // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait
        // for that too.
        var oldCurrentWrite = currentWrite;
        return PerformPromiseThen(currentWrite, function () {
          return oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined;
        });
      }

      function isOrBecomesErrored(stream, promise, action) {
        if (stream._state === 'errored') {
          action(stream._storedError);
        } else {
          uponRejection(promise, action);
        }
      }

      function isOrBecomesClosed(stream, promise, action) {
        if (stream._state === 'closed') {
          action();
        } else {
          uponFulfillment(promise, action);
        }
      }

      function shutdownWithAction(action, originalIsError, originalError) {
        if (shuttingDown) {
          return;
        }

        shuttingDown = true;

        if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {
          uponFulfillment(waitForWritesToFinish(), doTheRest);
        } else {
          doTheRest();
        }

        function doTheRest() {
          uponPromise(action(), function () {
            return finalize(originalIsError, originalError);
          }, function (newError) {
            return finalize(true, newError);
          });
        }
      }

      function shutdown(isError, error) {
        if (shuttingDown) {
          return;
        }

        shuttingDown = true;

        if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {
          uponFulfillment(waitForWritesToFinish(), function () {
            return finalize(isError, error);
          });
        } else {
          finalize(isError, error);
        }
      }

      function finalize(isError, error) {
        WritableStreamDefaultWriterRelease(writer);
        ReadableStreamReaderGenericRelease(reader);

        if (signal !== undefined) {
          signal.removeEventListener('abort', abortAlgorithm);
        }

        if (isError) {
          reject(error);
        } else {
          resolve(undefined);
        }
      }
    });
  }
  /**
   * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.
   *
   * @public
   */


  var ReadableStreamDefaultController =
  /** @class */
  function () {
    function ReadableStreamDefaultController() {
      throw new TypeError('Illegal constructor');
    }

    Object.defineProperty(ReadableStreamDefaultController.prototype, "desiredSize", {
      /**
       * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
       * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
       */
      get: function () {
        if (!IsReadableStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException$1('desiredSize');
        }

        return ReadableStreamDefaultControllerGetDesiredSize(this);
      },
      enumerable: false,
      configurable: true
    });
    /**
     * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
     * the stream, but once those are read, the stream will become closed.
     */

    ReadableStreamDefaultController.prototype.close = function () {
      if (!IsReadableStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException$1('close');
      }

      if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
        throw new TypeError('The stream is not in a state that permits close');
      }

      ReadableStreamDefaultControllerClose(this);
    };

    ReadableStreamDefaultController.prototype.enqueue = function (chunk) {
      if (chunk === void 0) {
        chunk = undefined;
      }

      if (!IsReadableStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException$1('enqueue');
      }

      if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
        throw new TypeError('The stream is not in a state that permits enqueue');
      }

      return ReadableStreamDefaultControllerEnqueue(this, chunk);
    };
    /**
     * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
     */


    ReadableStreamDefaultController.prototype.error = function (e) {
      if (e === void 0) {
        e = undefined;
      }

      if (!IsReadableStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException$1('error');
      }

      ReadableStreamDefaultControllerError(this, e);
    };
    /** @internal */


    ReadableStreamDefaultController.prototype[CancelSteps] = function (reason) {
      ResetQueue(this);

      var result = this._cancelAlgorithm(reason);

      ReadableStreamDefaultControllerClearAlgorithms(this);
      return result;
    };
    /** @internal */


    ReadableStreamDefaultController.prototype[PullSteps] = function (readRequest) {
      var stream = this._controlledReadableStream;

      if (this._queue.length > 0) {
        var chunk = DequeueValue(this);

        if (this._closeRequested && this._queue.length === 0) {
          ReadableStreamDefaultControllerClearAlgorithms(this);
          ReadableStreamClose(stream);
        } else {
          ReadableStreamDefaultControllerCallPullIfNeeded(this);
        }

        readRequest._chunkSteps(chunk);
      } else {
        ReadableStreamAddReadRequest(stream, readRequest);
        ReadableStreamDefaultControllerCallPullIfNeeded(this);
      }
    };

    return ReadableStreamDefaultController;
  }();

  Object.defineProperties(ReadableStreamDefaultController.prototype, {
    close: {
      enumerable: true
    },
    enqueue: {
      enumerable: true
    },
    error: {
      enumerable: true
    },
    desiredSize: {
      enumerable: true
    }
  });

  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
      value: 'ReadableStreamDefaultController',
      configurable: true
    });
  } // Abstract operations for the ReadableStreamDefaultController.


  function IsReadableStreamDefaultController(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {
      return false;
    }

    return x instanceof ReadableStreamDefaultController;
  }

  function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
    var shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);

    if (!shouldPull) {
      return;
    }

    if (controller._pulling) {
      controller._pullAgain = true;
      return;
    }

    controller._pulling = true;

    var pullPromise = controller._pullAlgorithm();

    uponPromise(pullPromise, function () {
      controller._pulling = false;

      if (controller._pullAgain) {
        controller._pullAgain = false;
        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
      }
    }, function (e) {
      ReadableStreamDefaultControllerError(controller, e);
    });
  }

  function ReadableStreamDefaultControllerShouldCallPull(controller) {
    var stream = controller._controlledReadableStream;

    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
      return false;
    }

    if (!controller._started) {
      return false;
    }

    if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
      return true;
    }

    var desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);

    if (desiredSize > 0) {
      return true;
    }

    return false;
  }

  function ReadableStreamDefaultControllerClearAlgorithms(controller) {
    controller._pullAlgorithm = undefined;
    controller._cancelAlgorithm = undefined;
    controller._strategySizeAlgorithm = undefined;
  } // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.


  function ReadableStreamDefaultControllerClose(controller) {
    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
      return;
    }

    var stream = controller._controlledReadableStream;
    controller._closeRequested = true;

    if (controller._queue.length === 0) {
      ReadableStreamDefaultControllerClearAlgorithms(controller);
      ReadableStreamClose(stream);
    }
  }

  function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
      return;
    }

    var stream = controller._controlledReadableStream;

    if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
      ReadableStreamFulfillReadRequest(stream, chunk, false);
    } else {
      var chunkSize = void 0;

      try {
        chunkSize = controller._strategySizeAlgorithm(chunk);
      } catch (chunkSizeE) {
        ReadableStreamDefaultControllerError(controller, chunkSizeE);
        throw chunkSizeE;
      }

      try {
        EnqueueValueWithSize(controller, chunk, chunkSize);
      } catch (enqueueE) {
        ReadableStreamDefaultControllerError(controller, enqueueE);
        throw enqueueE;
      }
    }

    ReadableStreamDefaultControllerCallPullIfNeeded(controller);
  }

  function ReadableStreamDefaultControllerError(controller, e) {
    var stream = controller._controlledReadableStream;

    if (stream._state !== 'readable') {
      return;
    }

    ResetQueue(controller);
    ReadableStreamDefaultControllerClearAlgorithms(controller);
    ReadableStreamError(stream, e);
  }

  function ReadableStreamDefaultControllerGetDesiredSize(controller) {
    var state = controller._controlledReadableStream._state;

    if (state === 'errored') {
      return null;
    }

    if (state === 'closed') {
      return 0;
    }

    return controller._strategyHWM - controller._queueTotalSize;
  } // This is used in the implementation of TransformStream.


  function ReadableStreamDefaultControllerHasBackpressure(controller) {
    if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
      return false;
    }

    return true;
  }

  function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
    var state = controller._controlledReadableStream._state;

    if (!controller._closeRequested && state === 'readable') {
      return true;
    }

    return false;
  }

  function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
    controller._controlledReadableStream = stream;
    controller._queue = undefined;
    controller._queueTotalSize = undefined;
    ResetQueue(controller);
    controller._started = false;
    controller._closeRequested = false;
    controller._pullAgain = false;
    controller._pulling = false;
    controller._strategySizeAlgorithm = sizeAlgorithm;
    controller._strategyHWM = highWaterMark;
    controller._pullAlgorithm = pullAlgorithm;
    controller._cancelAlgorithm = cancelAlgorithm;
    stream._readableStreamController = controller;
    var startResult = startAlgorithm();
    uponPromise(promiseResolvedWith(startResult), function () {
      controller._started = true;
      ReadableStreamDefaultControllerCallPullIfNeeded(controller);
    }, function (r) {
      ReadableStreamDefaultControllerError(controller, r);
    });
  }

  function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
    var controller = Object.create(ReadableStreamDefaultController.prototype);

    var startAlgorithm = function () {
      return undefined;
    };

    var pullAlgorithm = function () {
      return promiseResolvedWith(undefined);
    };

    var cancelAlgorithm = function () {
      return promiseResolvedWith(undefined);
    };

    if (underlyingSource.start !== undefined) {
      startAlgorithm = function () {
        return underlyingSource.start(controller);
      };
    }

    if (underlyingSource.pull !== undefined) {
      pullAlgorithm = function () {
        return underlyingSource.pull(controller);
      };
    }

    if (underlyingSource.cancel !== undefined) {
      cancelAlgorithm = function (reason) {
        return underlyingSource.cancel(reason);
      };
    }

    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
  } // Helper functions for the ReadableStreamDefaultController.


  function defaultControllerBrandCheckException$1(name) {
    return new TypeError("ReadableStreamDefaultController.prototype." + name + " can only be used on a ReadableStreamDefaultController");
  }

  function ReadableStreamTee(stream, cloneForBranch2) {
    if (IsReadableByteStreamController(stream._readableStreamController)) {
      return ReadableByteStreamTee(stream);
    }

    return ReadableStreamDefaultTee(stream);
  }

  function ReadableStreamDefaultTee(stream, cloneForBranch2) {
    var reader = AcquireReadableStreamDefaultReader(stream);
    var reading = false;
    var readAgain = false;
    var canceled1 = false;
    var canceled2 = false;
    var reason1;
    var reason2;
    var branch1;
    var branch2;
    var resolveCancelPromise;
    var cancelPromise = newPromise(function (resolve) {
      resolveCancelPromise = resolve;
    });

    function pullAlgorithm() {
      if (reading) {
        readAgain = true;
        return promiseResolvedWith(undefined);
      }

      reading = true;
      var readRequest = {
        _chunkSteps: function (chunk) {
          // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
          // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
          // successful synchronously-available reads get ahead of asynchronously-available errors.
          queueMicrotask(function () {
            readAgain = false;
            var chunk1 = chunk;
            var chunk2 = chunk; // There is no way to access the cloning code right now in the reference implementation.
            // If we add one then we'll need an implementation for serializable objects.
            // if (!canceled2 && cloneForBranch2) {
            //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));
            // }

            if (!canceled1) {
              ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
            }

            if (!canceled2) {
              ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
            }

            reading = false;

            if (readAgain) {
              pullAlgorithm();
            }
          });
        },
        _closeSteps: function () {
          reading = false;

          if (!canceled1) {
            ReadableStreamDefaultControllerClose(branch1._readableStreamController);
          }

          if (!canceled2) {
            ReadableStreamDefaultControllerClose(branch2._readableStreamController);
          }

          if (!canceled1 || !canceled2) {
            resolveCancelPromise(undefined);
          }
        },
        _errorSteps: function () {
          reading = false;
        }
      };
      ReadableStreamDefaultReaderRead(reader, readRequest);
      return promiseResolvedWith(undefined);
    }

    function cancel1Algorithm(reason) {
      canceled1 = true;
      reason1 = reason;

      if (canceled2) {
        var compositeReason = CreateArrayFromList([reason1, reason2]);
        var cancelResult = ReadableStreamCancel(stream, compositeReason);
        resolveCancelPromise(cancelResult);
      }

      return cancelPromise;
    }

    function cancel2Algorithm(reason) {
      canceled2 = true;
      reason2 = reason;

      if (canceled1) {
        var compositeReason = CreateArrayFromList([reason1, reason2]);
        var cancelResult = ReadableStreamCancel(stream, compositeReason);
        resolveCancelPromise(cancelResult);
      }

      return cancelPromise;
    }

    function startAlgorithm() {// do nothing
    }

    branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
    branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
    uponRejection(reader._closedPromise, function (r) {
      ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
      ReadableStreamDefaultControllerError(branch2._readableStreamController, r);

      if (!canceled1 || !canceled2) {
        resolveCancelPromise(undefined);
      }
    });
    return [branch1, branch2];
  }

  function ReadableByteStreamTee(stream) {
    var reader = AcquireReadableStreamDefaultReader(stream);
    var reading = false;
    var readAgainForBranch1 = false;
    var readAgainForBranch2 = false;
    var canceled1 = false;
    var canceled2 = false;
    var reason1;
    var reason2;
    var branch1;
    var branch2;
    var resolveCancelPromise;
    var cancelPromise = newPromise(function (resolve) {
      resolveCancelPromise = resolve;
    });

    function forwardReaderError(thisReader) {
      uponRejection(thisReader._closedPromise, function (r) {
        if (thisReader !== reader) {
          return;
        }

        ReadableByteStreamControllerError(branch1._readableStreamController, r);
        ReadableByteStreamControllerError(branch2._readableStreamController, r);

        if (!canceled1 || !canceled2) {
          resolveCancelPromise(undefined);
        }
      });
    }

    function pullWithDefaultReader() {
      if (IsReadableStreamBYOBReader(reader)) {
        ReadableStreamReaderGenericRelease(reader);
        reader = AcquireReadableStreamDefaultReader(stream);
        forwardReaderError(reader);
      }

      var readRequest = {
        _chunkSteps: function (chunk) {
          // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
          // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
          // successful synchronously-available reads get ahead of asynchronously-available errors.
          queueMicrotask(function () {
            readAgainForBranch1 = false;
            readAgainForBranch2 = false;
            var chunk1 = chunk;
            var chunk2 = chunk;

            if (!canceled1 && !canceled2) {
              try {
                chunk2 = CloneAsUint8Array(chunk);
              } catch (cloneE) {
                ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
                ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                return;
              }
            }

            if (!canceled1) {
              ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
            }

            if (!canceled2) {
              ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
            }

            reading = false;

            if (readAgainForBranch1) {
              pull1Algorithm();
            } else if (readAgainForBranch2) {
              pull2Algorithm();
            }
          });
        },
        _closeSteps: function () {
          reading = false;

          if (!canceled1) {
            ReadableByteStreamControllerClose(branch1._readableStreamController);
          }

          if (!canceled2) {
            ReadableByteStreamControllerClose(branch2._readableStreamController);
          }

          if (branch1._readableStreamController._pendingPullIntos.length > 0) {
            ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
          }

          if (branch2._readableStreamController._pendingPullIntos.length > 0) {
            ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
          }

          if (!canceled1 || !canceled2) {
            resolveCancelPromise(undefined);
          }
        },
        _errorSteps: function () {
          reading = false;
        }
      };
      ReadableStreamDefaultReaderRead(reader, readRequest);
    }

    function pullWithBYOBReader(view, forBranch2) {
      if (IsReadableStreamDefaultReader(reader)) {
        ReadableStreamReaderGenericRelease(reader);
        reader = AcquireReadableStreamBYOBReader(stream);
        forwardReaderError(reader);
      }

      var byobBranch = forBranch2 ? branch2 : branch1;
      var otherBranch = forBranch2 ? branch1 : branch2;
      var readIntoRequest = {
        _chunkSteps: function (chunk) {
          // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
          // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
          // successful synchronously-available reads get ahead of asynchronously-available errors.
          queueMicrotask(function () {
            readAgainForBranch1 = false;
            readAgainForBranch2 = false;
            var byobCanceled = forBranch2 ? canceled2 : canceled1;
            var otherCanceled = forBranch2 ? canceled1 : canceled2;

            if (!otherCanceled) {
              var clonedChunk = void 0;

              try {
                clonedChunk = CloneAsUint8Array(chunk);
              } catch (cloneE) {
                ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
                ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
                return;
              }

              if (!byobCanceled) {
                ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
              }

              ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
            } else if (!byobCanceled) {
              ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
            }

            reading = false;

            if (readAgainForBranch1) {
              pull1Algorithm();
            } else if (readAgainForBranch2) {
              pull2Algorithm();
            }
          });
        },
        _closeSteps: function (chunk) {
          reading = false;
          var byobCanceled = forBranch2 ? canceled2 : canceled1;
          var otherCanceled = forBranch2 ? canceled1 : canceled2;

          if (!byobCanceled) {
            ReadableByteStreamControllerClose(byobBranch._readableStreamController);
          }

          if (!otherCanceled) {
            ReadableByteStreamControllerClose(otherBranch._readableStreamController);
          }

          if (chunk !== undefined) {
            if (!byobCanceled) {
              ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
            }

            if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
              ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
            }
          }

          if (!byobCanceled || !otherCanceled) {
            resolveCancelPromise(undefined);
          }
        },
        _errorSteps: function () {
          reading = false;
        }
      };
      ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
    }

    function pull1Algorithm() {
      if (reading) {
        readAgainForBranch1 = true;
        return promiseResolvedWith(undefined);
      }

      reading = true;
      var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);

      if (byobRequest === null) {
        pullWithDefaultReader();
      } else {
        pullWithBYOBReader(byobRequest._view, false);
      }

      return promiseResolvedWith(undefined);
    }

    function pull2Algorithm() {
      if (reading) {
        readAgainForBranch2 = true;
        return promiseResolvedWith(undefined);
      }

      reading = true;
      var byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);

      if (byobRequest === null) {
        pullWithDefaultReader();
      } else {
        pullWithBYOBReader(byobRequest._view, true);
      }

      return promiseResolvedWith(undefined);
    }

    function cancel1Algorithm(reason) {
      canceled1 = true;
      reason1 = reason;

      if (canceled2) {
        var compositeReason = CreateArrayFromList([reason1, reason2]);
        var cancelResult = ReadableStreamCancel(stream, compositeReason);
        resolveCancelPromise(cancelResult);
      }

      return cancelPromise;
    }

    function cancel2Algorithm(reason) {
      canceled2 = true;
      reason2 = reason;

      if (canceled1) {
        var compositeReason = CreateArrayFromList([reason1, reason2]);
        var cancelResult = ReadableStreamCancel(stream, compositeReason);
        resolveCancelPromise(cancelResult);
      }

      return cancelPromise;
    }

    function startAlgorithm() {
      return;
    }

    branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
    branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
    forwardReaderError(reader);
    return [branch1, branch2];
  }

  function convertUnderlyingDefaultOrByteSource(source, context) {
    assertDictionary(source, context);
    var original = source;
    var autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
    var cancel = original === null || original === void 0 ? void 0 : original.cancel;
    var pull = original === null || original === void 0 ? void 0 : original.pull;
    var start = original === null || original === void 0 ? void 0 : original.start;
    var type = original === null || original === void 0 ? void 0 : original.type;
    return {
      autoAllocateChunkSize: autoAllocateChunkSize === undefined ? undefined : convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, context + " has member 'autoAllocateChunkSize' that"),
      cancel: cancel === undefined ? undefined : convertUnderlyingSourceCancelCallback(cancel, original, context + " has member 'cancel' that"),
      pull: pull === undefined ? undefined : convertUnderlyingSourcePullCallback(pull, original, context + " has member 'pull' that"),
      start: start === undefined ? undefined : convertUnderlyingSourceStartCallback(start, original, context + " has member 'start' that"),
      type: type === undefined ? undefined : convertReadableStreamType(type, context + " has member 'type' that")
    };
  }

  function convertUnderlyingSourceCancelCallback(fn, original, context) {
    assertFunction(fn, context);
    return function (reason) {
      return promiseCall(fn, original, [reason]);
    };
  }

  function convertUnderlyingSourcePullCallback(fn, original, context) {
    assertFunction(fn, context);
    return function (controller) {
      return promiseCall(fn, original, [controller]);
    };
  }

  function convertUnderlyingSourceStartCallback(fn, original, context) {
    assertFunction(fn, context);
    return function (controller) {
      return reflectCall(fn, original, [controller]);
    };
  }

  function convertReadableStreamType(type, context) {
    type = "" + type;

    if (type !== 'bytes') {
      throw new TypeError(context + " '" + type + "' is not a valid enumeration value for ReadableStreamType");
    }

    return type;
  }

  function convertReaderOptions(options, context) {
    assertDictionary(options, context);
    var mode = options === null || options === void 0 ? void 0 : options.mode;
    return {
      mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, context + " has member 'mode' that")
    };
  }

  function convertReadableStreamReaderMode(mode, context) {
    mode = "" + mode;

    if (mode !== 'byob') {
      throw new TypeError(context + " '" + mode + "' is not a valid enumeration value for ReadableStreamReaderMode");
    }

    return mode;
  }

  function convertIteratorOptions(options, context) {
    assertDictionary(options, context);
    var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
    return {
      preventCancel: Boolean(preventCancel)
    };
  }

  function convertPipeOptions(options, context) {
    assertDictionary(options, context);
    var preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
    var preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
    var preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
    var signal = options === null || options === void 0 ? void 0 : options.signal;

    if (signal !== undefined) {
      assertAbortSignal(signal, context + " has member 'signal' that");
    }

    return {
      preventAbort: Boolean(preventAbort),
      preventCancel: Boolean(preventCancel),
      preventClose: Boolean(preventClose),
      signal: signal
    };
  }

  function assertAbortSignal(signal, context) {
    if (!isAbortSignal(signal)) {
      throw new TypeError(context + " is not an AbortSignal.");
    }
  }

  function convertReadableWritablePair(pair, context) {
    assertDictionary(pair, context);
    var readable = pair === null || pair === void 0 ? void 0 : pair.readable;
    assertRequiredField(readable, 'readable', 'ReadableWritablePair');
    assertReadableStream(readable, context + " has member 'readable' that");
    var writable = pair === null || pair === void 0 ? void 0 : pair.writable;
    assertRequiredField(writable, 'writable', 'ReadableWritablePair');
    assertWritableStream(writable, context + " has member 'writable' that");
    return {
      readable: readable,
      writable: writable
    };
  }
  /**
   * A readable stream represents a source of data, from which you can read.
   *
   * @public
   */


  var ReadableStream =
  /** @class */
  function () {
    function ReadableStream(rawUnderlyingSource, rawStrategy) {
      if (rawUnderlyingSource === void 0) {
        rawUnderlyingSource = {};
      }

      if (rawStrategy === void 0) {
        rawStrategy = {};
      }

      if (rawUnderlyingSource === undefined) {
        rawUnderlyingSource = null;
      } else {
        assertObject(rawUnderlyingSource, 'First parameter');
      }

      var strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');
      var underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');
      InitializeReadableStream(this);

      if (underlyingSource.type === 'bytes') {
        if (strategy.size !== undefined) {
          throw new RangeError('The strategy for a byte stream cannot have a size function');
        }

        var highWaterMark = ExtractHighWaterMark(strategy, 0);
        SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
      } else {
        var sizeAlgorithm = ExtractSizeAlgorithm(strategy);
        var highWaterMark = ExtractHighWaterMark(strategy, 1);
        SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
      }
    }

    Object.defineProperty(ReadableStream.prototype, "locked", {
      /**
       * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
       */
      get: function () {
        if (!IsReadableStream(this)) {
          throw streamBrandCheckException$1('locked');
        }

        return IsReadableStreamLocked(this);
      },
      enumerable: false,
      configurable: true
    });
    /**
     * Cancels the stream, signaling a loss of interest in the stream by a consumer.
     *
     * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}
     * method, which might or might not use it.
     */

    ReadableStream.prototype.cancel = function (reason) {
      if (reason === void 0) {
        reason = undefined;
      }

      if (!IsReadableStream(this)) {
        return promiseRejectedWith(streamBrandCheckException$1('cancel'));
      }

      if (IsReadableStreamLocked(this)) {
        return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));
      }

      return ReadableStreamCancel(this, reason);
    };

    ReadableStream.prototype.getReader = function (rawOptions) {
      if (rawOptions === void 0) {
        rawOptions = undefined;
      }

      if (!IsReadableStream(this)) {
        throw streamBrandCheckException$1('getReader');
      }

      var options = convertReaderOptions(rawOptions, 'First parameter');

      if (options.mode === undefined) {
        return AcquireReadableStreamDefaultReader(this);
      }

      return AcquireReadableStreamBYOBReader(this);
    };

    ReadableStream.prototype.pipeThrough = function (rawTransform, rawOptions) {
      if (rawOptions === void 0) {
        rawOptions = {};
      }

      if (!IsReadableStream(this)) {
        throw streamBrandCheckException$1('pipeThrough');
      }

      assertRequiredArgument(rawTransform, 1, 'pipeThrough');
      var transform = convertReadableWritablePair(rawTransform, 'First parameter');
      var options = convertPipeOptions(rawOptions, 'Second parameter');

      if (IsReadableStreamLocked(this)) {
        throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');
      }

      if (IsWritableStreamLocked(transform.writable)) {
        throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');
      }

      var promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
      setPromiseIsHandledToTrue(promise);
      return transform.readable;
    };

    ReadableStream.prototype.pipeTo = function (destination, rawOptions) {
      if (rawOptions === void 0) {
        rawOptions = {};
      }

      if (!IsReadableStream(this)) {
        return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));
      }

      if (destination === undefined) {
        return promiseRejectedWith("Parameter 1 is required in 'pipeTo'.");
      }

      if (!IsWritableStream(destination)) {
        return promiseRejectedWith(new TypeError("ReadableStream.prototype.pipeTo's first argument must be a WritableStream"));
      }

      var options;

      try {
        options = convertPipeOptions(rawOptions, 'Second parameter');
      } catch (e) {
        return promiseRejectedWith(e);
      }

      if (IsReadableStreamLocked(this)) {
        return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));
      }

      if (IsWritableStreamLocked(destination)) {
        return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));
      }

      return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
    };
    /**
     * Tees this readable stream, returning a two-element array containing the two resulting branches as
     * new {@link ReadableStream} instances.
     *
     * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.
     * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be
     * propagated to the stream's underlying source.
     *
     * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,
     * this could allow interference between the two branches.
     */


    ReadableStream.prototype.tee = function () {
      if (!IsReadableStream(this)) {
        throw streamBrandCheckException$1('tee');
      }

      var branches = ReadableStreamTee(this);
      return CreateArrayFromList(branches);
    };

    ReadableStream.prototype.values = function (rawOptions) {
      if (rawOptions === void 0) {
        rawOptions = undefined;
      }

      if (!IsReadableStream(this)) {
        throw streamBrandCheckException$1('values');
      }

      var options = convertIteratorOptions(rawOptions, 'First parameter');
      return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
    };

    return ReadableStream;
  }();

  Object.defineProperties(ReadableStream.prototype, {
    cancel: {
      enumerable: true
    },
    getReader: {
      enumerable: true
    },
    pipeThrough: {
      enumerable: true
    },
    pipeTo: {
      enumerable: true
    },
    tee: {
      enumerable: true
    },
    values: {
      enumerable: true
    },
    locked: {
      enumerable: true
    }
  });

  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {
      value: 'ReadableStream',
      configurable: true
    });
  }

  if (typeof SymbolPolyfill.asyncIterator === 'symbol') {
    Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {
      value: ReadableStream.prototype.values,
      writable: true,
      configurable: true
    });
  } // Abstract operations for the ReadableStream.
  // Throws if and only if startAlgorithm throws.


  function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
    if (highWaterMark === void 0) {
      highWaterMark = 1;
    }

    if (sizeAlgorithm === void 0) {
      sizeAlgorithm = function () {
        return 1;
      };
    }

    var stream = Object.create(ReadableStream.prototype);
    InitializeReadableStream(stream);
    var controller = Object.create(ReadableStreamDefaultController.prototype);
    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
    return stream;
  } // Throws if and only if startAlgorithm throws.


  function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
    var stream = Object.create(ReadableStream.prototype);
    InitializeReadableStream(stream);
    var controller = Object.create(ReadableByteStreamController.prototype);
    SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);
    return stream;
  }

  function InitializeReadableStream(stream) {
    stream._state = 'readable';
    stream._reader = undefined;
    stream._storedError = undefined;
    stream._disturbed = false;
  }

  function IsReadableStream(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {
      return false;
    }

    return x instanceof ReadableStream;
  }

  function IsReadableStreamLocked(stream) {
    if (stream._reader === undefined) {
      return false;
    }

    return true;
  } // ReadableStream API exposed for controllers.


  function ReadableStreamCancel(stream, reason) {
    stream._disturbed = true;

    if (stream._state === 'closed') {
      return promiseResolvedWith(undefined);
    }

    if (stream._state === 'errored') {
      return promiseRejectedWith(stream._storedError);
    }

    ReadableStreamClose(stream);
    var reader = stream._reader;

    if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {
      reader._readIntoRequests.forEach(function (readIntoRequest) {
        readIntoRequest._closeSteps(undefined);
      });

      reader._readIntoRequests = new SimpleQueue();
    }

    var sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);

    return transformPromiseWith(sourceCancelPromise, noop);
  }

  function ReadableStreamClose(stream) {
    stream._state = 'closed';
    var reader = stream._reader;

    if (reader === undefined) {
      return;
    }

    defaultReaderClosedPromiseResolve(reader);

    if (IsReadableStreamDefaultReader(reader)) {
      reader._readRequests.forEach(function (readRequest) {
        readRequest._closeSteps();
      });

      reader._readRequests = new SimpleQueue();
    }
  }

  function ReadableStreamError(stream, e) {
    stream._state = 'errored';
    stream._storedError = e;
    var reader = stream._reader;

    if (reader === undefined) {
      return;
    }

    defaultReaderClosedPromiseReject(reader, e);

    if (IsReadableStreamDefaultReader(reader)) {
      reader._readRequests.forEach(function (readRequest) {
        readRequest._errorSteps(e);
      });

      reader._readRequests = new SimpleQueue();
    } else {
      reader._readIntoRequests.forEach(function (readIntoRequest) {
        readIntoRequest._errorSteps(e);
      });

      reader._readIntoRequests = new SimpleQueue();
    }
  } // Helper functions for the ReadableStream.


  function streamBrandCheckException$1(name) {
    return new TypeError("ReadableStream.prototype." + name + " can only be used on a ReadableStream");
  }

  function convertQueuingStrategyInit(init, context) {
    assertDictionary(init, context);
    var highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
    assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');
    return {
      highWaterMark: convertUnrestrictedDouble(highWaterMark)
    };
  } // The size function must not have a prototype property nor be a constructor


  var byteLengthSizeFunction = function (chunk) {
    return chunk.byteLength;
  };

  Object.defineProperty(byteLengthSizeFunction, 'name', {
    value: 'size',
    configurable: true
  });
  /**
   * A queuing strategy that counts the number of bytes in each chunk.
   *
   * @public
   */

  var ByteLengthQueuingStrategy =
  /** @class */
  function () {
    function ByteLengthQueuingStrategy(options) {
      assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');
      options = convertQueuingStrategyInit(options, 'First parameter');
      this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
    }

    Object.defineProperty(ByteLengthQueuingStrategy.prototype, "highWaterMark", {
      /**
       * Returns the high water mark provided to the constructor.
       */
      get: function () {
        if (!IsByteLengthQueuingStrategy(this)) {
          throw byteLengthBrandCheckException('highWaterMark');
        }

        return this._byteLengthQueuingStrategyHighWaterMark;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ByteLengthQueuingStrategy.prototype, "size", {
      /**
       * Measures the size of `chunk` by returning the value of its `byteLength` property.
       */
      get: function () {
        if (!IsByteLengthQueuingStrategy(this)) {
          throw byteLengthBrandCheckException('size');
        }

        return byteLengthSizeFunction;
      },
      enumerable: false,
      configurable: true
    });
    return ByteLengthQueuingStrategy;
  }();

  Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
    highWaterMark: {
      enumerable: true
    },
    size: {
      enumerable: true
    }
  });

  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
      value: 'ByteLengthQueuingStrategy',
      configurable: true
    });
  } // Helper functions for the ByteLengthQueuingStrategy.


  function byteLengthBrandCheckException(name) {
    return new TypeError("ByteLengthQueuingStrategy.prototype." + name + " can only be used on a ByteLengthQueuingStrategy");
  }

  function IsByteLengthQueuingStrategy(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {
      return false;
    }

    return x instanceof ByteLengthQueuingStrategy;
  } // The size function must not have a prototype property nor be a constructor


  var countSizeFunction = function () {
    return 1;
  };

  Object.defineProperty(countSizeFunction, 'name', {
    value: 'size',
    configurable: true
  });
  /**
   * A queuing strategy that counts the number of chunks.
   *
   * @public
   */

  var CountQueuingStrategy =
  /** @class */
  function () {
    function CountQueuingStrategy(options) {
      assertRequiredArgument(options, 1, 'CountQueuingStrategy');
      options = convertQueuingStrategyInit(options, 'First parameter');
      this._countQueuingStrategyHighWaterMark = options.highWaterMark;
    }

    Object.defineProperty(CountQueuingStrategy.prototype, "highWaterMark", {
      /**
       * Returns the high water mark provided to the constructor.
       */
      get: function () {
        if (!IsCountQueuingStrategy(this)) {
          throw countBrandCheckException('highWaterMark');
        }

        return this._countQueuingStrategyHighWaterMark;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(CountQueuingStrategy.prototype, "size", {
      /**
       * Measures the size of `chunk` by always returning 1.
       * This ensures that the total queue size is a count of the number of chunks in the queue.
       */
      get: function () {
        if (!IsCountQueuingStrategy(this)) {
          throw countBrandCheckException('size');
        }

        return countSizeFunction;
      },
      enumerable: false,
      configurable: true
    });
    return CountQueuingStrategy;
  }();

  Object.defineProperties(CountQueuingStrategy.prototype, {
    highWaterMark: {
      enumerable: true
    },
    size: {
      enumerable: true
    }
  });

  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
      value: 'CountQueuingStrategy',
      configurable: true
    });
  } // Helper functions for the CountQueuingStrategy.


  function countBrandCheckException(name) {
    return new TypeError("CountQueuingStrategy.prototype." + name + " can only be used on a CountQueuingStrategy");
  }

  function IsCountQueuingStrategy(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {
      return false;
    }

    return x instanceof CountQueuingStrategy;
  }

  function convertTransformer(original, context) {
    assertDictionary(original, context);
    var flush = original === null || original === void 0 ? void 0 : original.flush;
    var readableType = original === null || original === void 0 ? void 0 : original.readableType;
    var start = original === null || original === void 0 ? void 0 : original.start;
    var transform = original === null || original === void 0 ? void 0 : original.transform;
    var writableType = original === null || original === void 0 ? void 0 : original.writableType;
    return {
      flush: flush === undefined ? undefined : convertTransformerFlushCallback(flush, original, context + " has member 'flush' that"),
      readableType: readableType,
      start: start === undefined ? undefined : convertTransformerStartCallback(start, original, context + " has member 'start' that"),
      transform: transform === undefined ? undefined : convertTransformerTransformCallback(transform, original, context + " has member 'transform' that"),
      writableType: writableType
    };
  }

  function convertTransformerFlushCallback(fn, original, context) {
    assertFunction(fn, context);
    return function (controller) {
      return promiseCall(fn, original, [controller]);
    };
  }

  function convertTransformerStartCallback(fn, original, context) {
    assertFunction(fn, context);
    return function (controller) {
      return reflectCall(fn, original, [controller]);
    };
  }

  function convertTransformerTransformCallback(fn, original, context) {
    assertFunction(fn, context);
    return function (chunk, controller) {
      return promiseCall(fn, original, [chunk, controller]);
    };
  } // Class TransformStream

  /**
   * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},
   * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.
   * In a manner specific to the transform stream in question, writes to the writable side result in new data being
   * made available for reading from the readable side.
   *
   * @public
   */


  var TransformStream =
  /** @class */
  function () {
    function TransformStream(rawTransformer, rawWritableStrategy, rawReadableStrategy) {
      if (rawTransformer === void 0) {
        rawTransformer = {};
      }

      if (rawWritableStrategy === void 0) {
        rawWritableStrategy = {};
      }

      if (rawReadableStrategy === void 0) {
        rawReadableStrategy = {};
      }

      if (rawTransformer === undefined) {
        rawTransformer = null;
      }

      var writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');
      var readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');
      var transformer = convertTransformer(rawTransformer, 'First parameter');

      if (transformer.readableType !== undefined) {
        throw new RangeError('Invalid readableType specified');
      }

      if (transformer.writableType !== undefined) {
        throw new RangeError('Invalid writableType specified');
      }

      var readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
      var readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
      var writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
      var writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
      var startPromise_resolve;
      var startPromise = newPromise(function (resolve) {
        startPromise_resolve = resolve;
      });
      InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
      SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);

      if (transformer.start !== undefined) {
        startPromise_resolve(transformer.start(this._transformStreamController));
      } else {
        startPromise_resolve(undefined);
      }
    }

    Object.defineProperty(TransformStream.prototype, "readable", {
      /**
       * The readable side of the transform stream.
       */
      get: function () {
        if (!IsTransformStream(this)) {
          throw streamBrandCheckException('readable');
        }

        return this._readable;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(TransformStream.prototype, "writable", {
      /**
       * The writable side of the transform stream.
       */
      get: function () {
        if (!IsTransformStream(this)) {
          throw streamBrandCheckException('writable');
        }

        return this._writable;
      },
      enumerable: false,
      configurable: true
    });
    return TransformStream;
  }();

  Object.defineProperties(TransformStream.prototype, {
    readable: {
      enumerable: true
    },
    writable: {
      enumerable: true
    }
  });

  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
      value: 'TransformStream',
      configurable: true
    });
  }

  function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
    function startAlgorithm() {
      return startPromise;
    }

    function writeAlgorithm(chunk) {
      return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
    }

    function abortAlgorithm(reason) {
      return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
    }

    function closeAlgorithm() {
      return TransformStreamDefaultSinkCloseAlgorithm(stream);
    }

    stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);

    function pullAlgorithm() {
      return TransformStreamDefaultSourcePullAlgorithm(stream);
    }

    function cancelAlgorithm(reason) {
      TransformStreamErrorWritableAndUnblockWrite(stream, reason);
      return promiseResolvedWith(undefined);
    }

    stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm); // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.

    stream._backpressure = undefined;
    stream._backpressureChangePromise = undefined;
    stream._backpressureChangePromise_resolve = undefined;
    TransformStreamSetBackpressure(stream, true);
    stream._transformStreamController = undefined;
  }

  function IsTransformStream(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {
      return false;
    }

    return x instanceof TransformStream;
  } // This is a no-op if both sides are already errored.


  function TransformStreamError(stream, e) {
    ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
    TransformStreamErrorWritableAndUnblockWrite(stream, e);
  }

  function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
    TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
    WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);

    if (stream._backpressure) {
      // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()
      // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time
      // _backpressure is set.
      TransformStreamSetBackpressure(stream, false);
    }
  }

  function TransformStreamSetBackpressure(stream, backpressure) {
    // Passes also when called during construction.
    if (stream._backpressureChangePromise !== undefined) {
      stream._backpressureChangePromise_resolve();
    }

    stream._backpressureChangePromise = newPromise(function (resolve) {
      stream._backpressureChangePromise_resolve = resolve;
    });
    stream._backpressure = backpressure;
  } // Class TransformStreamDefaultController

  /**
   * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.
   *
   * @public
   */


  var TransformStreamDefaultController =
  /** @class */
  function () {
    function TransformStreamDefaultController() {
      throw new TypeError('Illegal constructor');
    }

    Object.defineProperty(TransformStreamDefaultController.prototype, "desiredSize", {
      /**
       * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.
       */
      get: function () {
        if (!IsTransformStreamDefaultController(this)) {
          throw defaultControllerBrandCheckException('desiredSize');
        }

        var readableController = this._controlledTransformStream._readable._readableStreamController;
        return ReadableStreamDefaultControllerGetDesiredSize(readableController);
      },
      enumerable: false,
      configurable: true
    });

    TransformStreamDefaultController.prototype.enqueue = function (chunk) {
      if (chunk === void 0) {
        chunk = undefined;
      }

      if (!IsTransformStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException('enqueue');
      }

      TransformStreamDefaultControllerEnqueue(this, chunk);
    };
    /**
     * Errors both the readable side and the writable side of the controlled transform stream, making all future
     * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.
     */


    TransformStreamDefaultController.prototype.error = function (reason) {
      if (reason === void 0) {
        reason = undefined;
      }

      if (!IsTransformStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException('error');
      }

      TransformStreamDefaultControllerError(this, reason);
    };
    /**
     * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the
     * transformer only needs to consume a portion of the chunks written to the writable side.
     */


    TransformStreamDefaultController.prototype.terminate = function () {
      if (!IsTransformStreamDefaultController(this)) {
        throw defaultControllerBrandCheckException('terminate');
      }

      TransformStreamDefaultControllerTerminate(this);
    };

    return TransformStreamDefaultController;
  }();

  Object.defineProperties(TransformStreamDefaultController.prototype, {
    enqueue: {
      enumerable: true
    },
    error: {
      enumerable: true
    },
    terminate: {
      enumerable: true
    },
    desiredSize: {
      enumerable: true
    }
  });

  if (typeof SymbolPolyfill.toStringTag === 'symbol') {
    Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
      value: 'TransformStreamDefaultController',
      configurable: true
    });
  } // Transform Stream Default Controller Abstract Operations


  function IsTransformStreamDefaultController(x) {
    if (!typeIsObject(x)) {
      return false;
    }

    if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {
      return false;
    }

    return x instanceof TransformStreamDefaultController;
  }

  function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
    controller._controlledTransformStream = stream;
    stream._transformStreamController = controller;
    controller._transformAlgorithm = transformAlgorithm;
    controller._flushAlgorithm = flushAlgorithm;
  }

  function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
    var controller = Object.create(TransformStreamDefaultController.prototype);

    var transformAlgorithm = function (chunk) {
      try {
        TransformStreamDefaultControllerEnqueue(controller, chunk);
        return promiseResolvedWith(undefined);
      } catch (transformResultE) {
        return promiseRejectedWith(transformResultE);
      }
    };

    var flushAlgorithm = function () {
      return promiseResolvedWith(undefined);
    };

    if (transformer.transform !== undefined) {
      transformAlgorithm = function (chunk) {
        return transformer.transform(chunk, controller);
      };
    }

    if (transformer.flush !== undefined) {
      flushAlgorithm = function () {
        return transformer.flush(controller);
      };
    }

    SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
  }

  function TransformStreamDefaultControllerClearAlgorithms(controller) {
    controller._transformAlgorithm = undefined;
    controller._flushAlgorithm = undefined;
  }

  function TransformStreamDefaultControllerEnqueue(controller, chunk) {
    var stream = controller._controlledTransformStream;
    var readableController = stream._readable._readableStreamController;

    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
      throw new TypeError('Readable side is not in a state that permits enqueue');
    } // We throttle transform invocations based on the backpressure of the ReadableStream, but we still
    // accept TransformStreamDefaultControllerEnqueue() calls.


    try {
      ReadableStreamDefaultControllerEnqueue(readableController, chunk);
    } catch (e) {
      // This happens when readableStrategy.size() throws.
      TransformStreamErrorWritableAndUnblockWrite(stream, e);
      throw stream._readable._storedError;
    }

    var backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);

    if (backpressure !== stream._backpressure) {
      TransformStreamSetBackpressure(stream, true);
    }
  }

  function TransformStreamDefaultControllerError(controller, e) {
    TransformStreamError(controller._controlledTransformStream, e);
  }

  function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
    var transformPromise = controller._transformAlgorithm(chunk);

    return transformPromiseWith(transformPromise, undefined, function (r) {
      TransformStreamError(controller._controlledTransformStream, r);
      throw r;
    });
  }

  function TransformStreamDefaultControllerTerminate(controller) {
    var stream = controller._controlledTransformStream;
    var readableController = stream._readable._readableStreamController;
    ReadableStreamDefaultControllerClose(readableController);
    var error = new TypeError('TransformStream terminated');
    TransformStreamErrorWritableAndUnblockWrite(stream, error);
  } // TransformStreamDefaultSink Algorithms


  function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
    var controller = stream._transformStreamController;

    if (stream._backpressure) {
      var backpressureChangePromise = stream._backpressureChangePromise;
      return transformPromiseWith(backpressureChangePromise, function () {
        var writable = stream._writable;
        var state = writable._state;

        if (state === 'erroring') {
          throw writable._storedError;
        }

        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
      });
    }

    return TransformStreamDefaultControllerPerformTransform(controller, chunk);
  }

  function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
    // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already
    // errored.
    TransformStreamError(stream, reason);
    return promiseResolvedWith(undefined);
  }

  function TransformStreamDefaultSinkCloseAlgorithm(stream) {
    // stream._readable cannot change after construction, so caching it across a call to user code is safe.
    var readable = stream._readable;
    var controller = stream._transformStreamController;

    var flushPromise = controller._flushAlgorithm();

    TransformStreamDefaultControllerClearAlgorithms(controller); // Return a promise that is fulfilled with undefined on success.

    return transformPromiseWith(flushPromise, function () {
      if (readable._state === 'errored') {
        throw readable._storedError;
      }

      ReadableStreamDefaultControllerClose(readable._readableStreamController);
    }, function (r) {
      TransformStreamError(stream, r);
      throw readable._storedError;
    });
  } // TransformStreamDefaultSource Algorithms


  function TransformStreamDefaultSourcePullAlgorithm(stream) {
    // Invariant. Enforced by the promises returned by start() and pull().
    TransformStreamSetBackpressure(stream, false); // Prevent the next pull() call until there is backpressure.

    return stream._backpressureChangePromise;
  } // Helper functions for the TransformStreamDefaultController.


  function defaultControllerBrandCheckException(name) {
    return new TypeError("TransformStreamDefaultController.prototype." + name + " can only be used on a TransformStreamDefaultController");
  } // Helper functions for the TransformStream.


  function streamBrandCheckException(name) {
    return new TypeError("TransformStream.prototype." + name + " can only be used on a TransformStream");
  }

  exports.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
  exports.CountQueuingStrategy = CountQueuingStrategy;
  exports.ReadableByteStreamController = ReadableByteStreamController;
  exports.ReadableStream = ReadableStream;
  exports.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
  exports.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
  exports.ReadableStreamDefaultController = ReadableStreamDefaultController;
  exports.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
  exports.TransformStream = TransformStream;
  exports.TransformStreamDefaultController = TransformStreamDefaultController;
  exports.WritableStream = WritableStream;
  exports.WritableStreamDefaultController = WritableStreamDefaultController;
  exports.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
  Object.defineProperty(exports, '__esModule', {
    value: true
  });
});

/***/ }),

/***/ "./src/account/account-data.ts":
/*!*************************************!*\
  !*** ./src/account/account-data.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.AccountData = void 0;

var _ethers = __webpack_require__(/*! ethers */ "./node_modules/ethers/lib.esm/index.js");

var _utils = __webpack_require__(/*! ./utils */ "./src/account/utils.ts");

var _address = __webpack_require__(/*! ../utils/address */ "./src/utils/address.ts");

var _mnemonic = __webpack_require__(/*! ./mnemonic */ "./src/account/mnemonic.ts");

var _encryption = __webpack_require__(/*! ./encryption */ "./src/account/encryption.ts");

var _account = __webpack_require__(/*! ./account */ "./src/account/account.ts");

var _types = __webpack_require__(/*! ./types */ "./src/account/types.ts");

var _beeJs = __webpack_require__(/*! @ethersphere/bee-js */ "./node_modules/@ethersphere/bee-js/dist/cjs/index.js");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class AccountData {
  /**
   * Active FDP account wallet
   */
  constructor(connection, ens) {
    this.connection = connection;
    this.ens = ens;

    _defineProperty(this, "wallet", void 0);
  }
  /**
   * Sets the current account's wallet to interact with the data
   *
   * @param wallet BIP-039 + BIP-044 Wallet
   */


  setActiveAccount(wallet) {
    this.wallet = wallet.connect(this.ens.provider);
    this.ens.connect(this.wallet);
  }
  /**
   * Creates a new FDP account wallet
   */


  createWallet() {
    if (this.wallet) {
      throw new Error('Wallet already created');
    }

    const wallet = _ethers.Wallet.createRandom();

    this.setActiveAccount(wallet);
    return wallet;
  }
  /**
   * Exports wallet from version 1 account
   *
   * @deprecated the method will be removed after an accounts' migration process is completed
   *
   * @param username username from version 1 account
   * @param password password from version 1 account
   * @param options migration options with address or mnemonic from version 1 account
   */


  async exportWallet(username, password, options) {
    (0, _utils.assertUsername)(username);
    (0, _utils.assertPassword)(password);
    let mnemonic = (0, _types.isMnemonicOptions)(options) ? options.mnemonic : undefined;

    if ((0, _types.isAddressOptions)(options)) {
      const address = (0, _address.prepareEthAddress)(options.address);
      const encryptedMnemonic = await (0, _mnemonic.getEncryptedMnemonic)(this.connection.bee, username, address);
      mnemonic = (0, _encryption.decryptText)(password, encryptedMnemonic);
    }

    (0, _utils.assertMnemonic)(mnemonic);
    return _ethers.Wallet.fromMnemonic(mnemonic);
  }
  /**
   * Migrates from FDP account without ENS to account with ENS
   *
   * @deprecated the method will be removed after an accounts' migration process is completed
   *
   * @param username username from version 1 account
   * @param password password from version 1 account
   * @param options migration options with address or mnemonic from version 1 account
   */


  async migrate(username, password, options) {
    (0, _utils.assertUsername)(username);
    (0, _utils.assertPassword)(password);
    this.setActiveAccount(await this.exportWallet(username, password, options));
    return this.register(username, password);
  }
  /**
   * Logs in with the FDP credentials and gives back ethers wallet
   *
   * @param username FDP username
   * @param password password of the wallet
   *
   * @returns BIP-039 + BIP-044 Wallet
   */


  async login(username, password) {
    (0, _utils.assertUsername)(username);
    (0, _utils.assertPassword)(password);

    if (await this.ens.isUsernameAvailable(username)) {
      throw new Error(`Username "${username}" does not exists`);
    }

    const publicKey = await this.ens.getPublicKey(username);

    try {
      const address = (0, _address.prepareEthAddress)(_ethers.utils.computeAddress(publicKey));
      const wallet = await (0, _account.downloadPortableAccount)(this.connection.bee, address, username, password);
      this.setActiveAccount(wallet);
      return wallet;
    } catch (e) {
      throw new Error('Incorrect password');
    }
  }
  /**
   * Creates new FDP account and gives back user account with swarm reference
   *
   * @param username FDP username
   * @param password FDP password
   */


  async register(username, password) {
    (0, _utils.assertUsername)(username);
    (0, _utils.assertPassword)(password);
    const wallet = this.wallet;

    if (!wallet) {
      throw new Error('Before registration, an active account must be set');
    }

    try {
      await (0, _account.uploadPortableAccount)(this.connection, username, password, _beeJs.Utils.hexToBytes((0, _utils.removeZeroFromHex)(wallet.privateKey)));
      await this.ens.registerUsername(username, wallet.address, wallet.publicKey);
      return wallet;
    } catch (e) {
      const error = e;

      if (error.message.startsWith('Conflict: chunk already exists')) {
        throw new Error('User account already uploaded');
      } else {
        throw e;
      }
    }
  }

}

exports.AccountData = AccountData;

/***/ }),

/***/ "./src/account/account.ts":
/*!********************************!*\
  !*** ./src/account/account.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.createUserV1 = createUserV1;
exports.downloadPortableAccount = downloadPortableAccount;
exports.uploadPortableAccount = uploadPortableAccount;

var _beeJs = __webpack_require__(/*! @ethersphere/bee-js */ "./node_modules/@ethersphere/bee-js/dist/cjs/index.js");

var _ethers = __webpack_require__(/*! ethers */ "./node_modules/ethers/lib.esm/index.js");

var _encryption = __webpack_require__(/*! ./encryption */ "./src/account/encryption.ts");

var _mnemonic = __webpack_require__(/*! ./mnemonic */ "./src/account/mnemonic.ts");

var _utils = __webpack_require__(/*! ./utils */ "./src/account/utils.ts");

var _batch = __webpack_require__(/*! ../utils/batch */ "./src/utils/batch.ts");

var _cryptoJs = _interopRequireDefault(__webpack_require__(/*! crypto-js */ "./node_modules/crypto-js/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Creates a new user account based on the passed mnemonic phrase or without it, encrypted with a password
 *
 * @deprecated method for v1 accounts
 *
 * @param password FDP password
 * @param mnemonic mnemonic phrase
 */
async function createUserAccount(password, mnemonic) {
  (0, _utils.assertPassword)(password);

  if (mnemonic) {
    (0, _utils.assertMnemonic)(mnemonic);
  } else {
    mnemonic = _ethers.Wallet.createRandom().mnemonic.phrase;
  }

  const wallet = _ethers.Wallet.fromMnemonic(mnemonic);

  const encryptedMnemonic = (0, _encryption.encryptText)(password, mnemonic);
  return {
    wallet,
    mnemonic,
    encryptedMnemonic
  };
}
/**
 * Creates a new user (version 1) and uploads the encrypted account to the network
 *
 * @deprecated use `createUser` method instead to create the latest version of an account
 *
 * @param connection connection information for data uploading
 * @param username FDP username
 * @param password FDP password
 * @param mnemonic mnemonic phrase
 */


async function createUserV1(connection, username, password, mnemonic) {
  const account = await createUserAccount(password, mnemonic);
  const reference = await (0, _mnemonic.uploadEncryptedMnemonic)(connection, account.wallet, username, account.encryptedMnemonic);
  return { ...account,
    reference
  };
}
/**
 * Uploads portable account (version 2)
 *
 * @param connection connection information for data uploading
 * @param username FDP username
 * @param password FDP password
 * @param privateKey account's wallet private key
 *
 * @returns swarm reference to encrypted Ethereum wallet
 */


async function uploadPortableAccount(connection, username, password, privateKey) {
  const paddedData = _cryptoJs.default.lib.WordArray.random(_utils.CHUNK_SIZE - privateKey.length - _encryption.IV_LENGTH);

  const privateKeyWords = _cryptoJs.default.enc.Hex.parse(_beeJs.Utils.bytesToHex(privateKey));

  const chunkData = privateKeyWords.concat(paddedData);
  const encryptedBytes = (0, _encryption.encryptBytes)(password, chunkData);
  (0, _utils.assertChunkSizeLength)(encryptedBytes.length);
  const topic = (0, _utils.createCredentialsTopic)(username, password);
  const socWriter = connection.bee.makeSOCWriter(privateKey);
  return socWriter.upload(await (0, _batch.getBatchId)(connection.beeDebug), topic, encryptedBytes);
}
/**
 * Downloads portable account (version 2)
 *
 * @param bee Bee instance
 * @param address FDP account address
 * @param username FDP username
 * @param password FDP password
 *
 * @returns decrypted Ethereum wallet of the account
 */


async function downloadPortableAccount(bee, address, username, password) {
  const topic = (0, _utils.createCredentialsTopic)(username, password);
  const socReader = bee.makeSOCReader(address);
  const encryptedData = (await socReader.download(topic)).payload();
  const privateKey = (0, _encryption.decryptBytes)(password, encryptedData).slice(0, 32);
  return new _ethers.Wallet(privateKey);
}

/***/ }),

/***/ "./src/account/encryption.ts":
/*!***********************************!*\
  !*** ./src/account/encryption.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.IV_LENGTH = void 0;
exports.decrypt = decrypt;
exports.decryptBytes = decryptBytes;
exports.decryptText = decryptText;
exports.encrypt = encrypt;
exports.encryptBytes = encryptBytes;
exports.encryptText = encryptText;

var _cryptoJs = _interopRequireDefault(__webpack_require__(/*! crypto-js */ "./node_modules/crypto-js/index.js"));

var _utils = __webpack_require__(/*! ./utils */ "./src/account/utils.ts");

var _beeJs = __webpack_require__(/*! @ethersphere/bee-js */ "./node_modules/@ethersphere/bee-js/dist/cjs/index.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const IV_LENGTH = 16;
/**
 * Decrypts text with password
 *
 * @param password string to decrypt text
 * @param text text to be decrypted
 */

exports.IV_LENGTH = IV_LENGTH;

function decryptText(password, text) {
  return decrypt(password, (0, _utils.decodeBase64Url)(text)).toString(_cryptoJs.default.enc.Utf8);
}
/**
 * Decrypts bytes with password
 *
 * @param password string to decrypt bytes
 * @param data bytes to be decrypted
 */


function decryptBytes(password, data) {
  return _beeJs.Utils.hexToBytes(_cryptoJs.default.enc.Hex.stringify(decrypt(password, (0, _utils.bytesToWordArray)(data))));
}
/**
 * Decrypts WordsArray with password
 *
 * @param password string to decrypt bytes
 * @param data WordsArray to be decrypted
 */


function decrypt(password, data) {
  const wordSize = 4;

  const key = _cryptoJs.default.SHA256(password);

  const iv = _cryptoJs.default.lib.WordArray.create(data.words.slice(0, IV_LENGTH), IV_LENGTH);

  const textBytes = _cryptoJs.default.lib.WordArray.create(data.words.slice(IV_LENGTH / wordSize), data.sigBytes - IV_LENGTH);

  const cipherParams = _cryptoJs.default.lib.CipherParams.create({
    ciphertext: textBytes
  });

  return _cryptoJs.default.AES.decrypt(cipherParams, key, {
    iv,
    mode: _cryptoJs.default.mode.CFB,
    padding: _cryptoJs.default.pad.NoPadding
  });
}
/**
 * Encrypts text with password
 *
 * @param password string to encrypt text
 * @param text text to be encrypted
 * @param customIv initial vector for AES. In case of absence, a random vector will be created
 */


function encryptText(password, text, customIv) {
  return (0, _utils.encodeBase64Url)(encrypt(password, text, customIv));
}
/**
 * Encrypt bytes with password
 *
 * @param password string for text encryption
 * @param data bytes to be encrypted
 * @param customIv initial vector for AES. In case of absence, a random vector will be created
 */


function encryptBytes(password, data, customIv) {
  return _beeJs.Utils.hexToBytes(_cryptoJs.default.enc.Hex.stringify(encrypt(password, data, customIv)));
}
/**
 * Encrypt WordArray with password
 *
 * @param password string for text encryption
 * @param data WordArray to be encrypted
 * @param customIv initial vector for AES. In case of absence, a random vector will be created
 */


function encrypt(password, data, customIv) {
  const iv = customIv || _cryptoJs.default.lib.WordArray.random(IV_LENGTH);

  const key = _cryptoJs.default.SHA256(password);

  const cipherParams = _cryptoJs.default.AES.encrypt(data, key, {
    iv,
    mode: _cryptoJs.default.mode.CFB,
    padding: _cryptoJs.default.pad.NoPadding
  });

  return iv.concat(cipherParams.ciphertext);
}

/***/ }),

/***/ "./src/account/mnemonic.ts":
/*!*********************************!*\
  !*** ./src/account/mnemonic.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getEncryptedMnemonic = getEncryptedMnemonic;
exports.uploadEncryptedMnemonic = uploadEncryptedMnemonic;

var _utils = __webpack_require__(/*! ./utils */ "./src/account/utils.ts");

var _api = __webpack_require__(/*! ../feed/api */ "./src/feed/api.ts");

var _bytes = __webpack_require__(/*! ../utils/bytes */ "./src/utils/bytes.ts");

/**
 * Downloads encrypted mnemonic phrase from swarm chunk for version 1 account
 *
 * @deprecated use methods for v2 account instead
 *
 * @param bee Bee client
 * @param username FDP account username
 * @param address FDP account address
 *
 * @returns encrypted mnemonic phrase in Base64url format
 */
async function getEncryptedMnemonic(bee, username, address) {
  (0, _utils.assertUsername)(username);
  return (await (0, _api.getFeedData)(bee, username, address)).data.chunkContent().text();
}
/**
 * Uploads encrypted mnemonic from account version 1 to swarm chunk
 *
 * @deprecated use methods for v2 account instead
 *
 * @param connection connection information for data uploading
 * @param wallet FDP account Ethereum wallet
 * @param username FDP username
 * @param encryptedMnemonic encrypted mnemonic phrase in Base64url format
 */


async function uploadEncryptedMnemonic(connection, wallet, username, encryptedMnemonic) {
  (0, _utils.assertUsername)(username);
  (0, _utils.assertBase64UrlData)(encryptedMnemonic);
  return (0, _api.writeFeedData)(connection, username, (0, _bytes.stringToBytes)(encryptedMnemonic), wallet.privateKey);
}

/***/ }),

/***/ "./src/account/types.ts":
/*!******************************!*\
  !*** ./src/account/types.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isAddressOptions = isAddressOptions;
exports.isMnemonicOptions = isMnemonicOptions;

var _type = __webpack_require__(/*! ../utils/type */ "./src/utils/type.ts");

var _utils = __webpack_require__(/*! ethers/lib/utils */ "./node_modules/ethers/lib/utils.js");

/**
 * Checks that value is an AddressOptions
 */
function isAddressOptions(options) {
  return (0, _type.isObject)(options) && (0, _type.isEthAddress)(options.address);
}
/**
 * Checks that value is an MnemonicOptions
 */


function isMnemonicOptions(options) {
  return (0, _type.isObject)(options) && (0, _utils.isValidMnemonic)(options.mnemonic);
}

/***/ }),

/***/ "./src/account/utils.ts":
/*!******************************!*\
  !*** ./src/account/utils.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MNEMONIC_LENGTH = exports.MAX_CHUNK_LENGTH = exports.CHUNK_SIZE = exports.AUTH_VERSION = void 0;
exports.assertActiveAccount = assertActiveAccount;
exports.assertBase64UrlData = assertBase64UrlData;
exports.assertChunkSizeLength = assertChunkSizeLength;
exports.assertMnemonic = assertMnemonic;
exports.assertNotEmptyString = assertNotEmptyString;
exports.assertPassword = assertPassword;
exports.assertUsername = assertUsername;
exports.bmtHashBytes = bmtHashBytes;
exports.bmtHashString = bmtHashString;
exports.bytesToWordArray = bytesToWordArray;
exports.createCredentialsTopic = createCredentialsTopic;
exports.decodeBase64Url = decodeBase64Url;
exports.encodeBase64Url = encodeBase64Url;
exports.extractChunkContent = extractChunkContent;
exports.removeZeroFromHex = removeZeroFromHex;

var _beeJs = __webpack_require__(/*! @ethersphere/bee-js */ "./node_modules/@ethersphere/bee-js/dist/cjs/index.js");

var _bmt = __webpack_require__(/*! ../chunk/bmt */ "./src/chunk/bmt.ts");

var _bytes = __webpack_require__(/*! ../utils/bytes */ "./src/utils/bytes.ts");

var _utils = __webpack_require__(/*! ethers/lib/utils */ "./node_modules/ethers/lib/utils.js");

var _cryptoJs = _interopRequireDefault(__webpack_require__(/*! crypto-js */ "./node_modules/crypto-js/index.js"));

var _string = __webpack_require__(/*! ../utils/string */ "./src/utils/string.ts");

var _type = __webpack_require__(/*! ../utils/type */ "./src/utils/type.ts");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const MNEMONIC_LENGTH = 12;
exports.MNEMONIC_LENGTH = MNEMONIC_LENGTH;
const MAX_CHUNK_LENGTH = 4096;
exports.MAX_CHUNK_LENGTH = MAX_CHUNK_LENGTH;
const AUTH_VERSION = 'FDP-login-v1.0';
exports.AUTH_VERSION = AUTH_VERSION;
const CHUNK_SIZE = 4096;
/**
 * Encode input data to Base64Url with Go lang compatible paddings
 *
 * @param data input data to encode
 */

exports.CHUNK_SIZE = CHUNK_SIZE;

function encodeBase64Url(data) {
  const base64url = data.toString(_cryptoJs.default.enc.Base64url);
  const paddingNumber = base64url.length % 4;
  let padding = '';

  if (paddingNumber === 2) {
    padding = '==';
  } else if (paddingNumber === 3) {
    padding = '=';
  }

  return base64url + padding;
}
/**
 * Decode input Base64Url data to string
 *
 * @param data Base64Url data
 */


function decodeBase64Url(data) {
  return _cryptoJs.default.enc.Base64url.parse((0, _string.replaceAll)(data, '=', ''));
}
/**
 * Extracts only content from chunk data
 *
 * @param data full chunk data
 */


function extractChunkContent(data) {
  // length of feed (32) + signature length (65) + span length (8)
  const chunkContentPosition = 105;

  if (data.length < chunkContentPosition) {
    throw new Error('Incorrect chunk size');
  }

  return (0, _bytes.wrapBytesWithHelpers)(data.slice(chunkContentPosition));
}
/**
 * Calculate a Binary Merkle Tree hash for a string
 *
 * @returns the keccak256 hash in a byte array
 */


function bmtHashString(stringData) {
  const payload = (0, _bytes.stringToBytes)(stringData);
  return bmtHashBytes(payload);
}
/**
 * Calculate a Binary Merkle Tree hash for a bytes array
 *
 * @returns the keccak256 hash in a byte array
 */


function bmtHashBytes(payload) {
  if (payload.length > MAX_CHUNK_LENGTH) {
    throw new Error(`Chunk is larger than the maximum allowed size - ${MAX_CHUNK_LENGTH} bytes`);
  }

  const span = (0, _bytes.makeSpan)(payload.length);
  const data = new Uint8Array([...span, ...payload]);
  return (0, _bmt.bmtHash)(data);
}
/**
 * Asserts whether non-empty username passed
 *
 * @param value FDP username
 */


function assertUsername(value) {
  (0, _type.assertString)(value);

  if (!value) {
    throw new Error('Incorrect username');
  }
}
/**
 * Asserts whether non-empty password passed
 *
 * @param value password
 */


function assertPassword(value) {
  (0, _type.assertString)(value);

  if (!value) {
    throw new Error('Incorrect password');
  }
}
/**
 * Asserts whether a valid mnemonic phrase has been passed
 *
 * @param value mnemonic phrase
 */


function assertMnemonic(value) {
  (0, _type.assertString)(value);
  const words = value.split(' ');

  if (!(words.length === MNEMONIC_LENGTH && (0, _utils.isValidMnemonic)(value))) {
    throw new Error('Incorrect mnemonic');
  }
}
/**
 * Asserts whether an active account is defined
 *
 * @param value instance of AccountData to check
 */


function assertActiveAccount(value) {
  const data = value;

  if (!data.wallet) {
    throw new Error('Active account not found');
  }
}
/**
 * Asserts whether string is not empty
 */


function assertNotEmptyString(value) {
  (0, _type.assertString)(value);

  if (value.length === 0) {
    throw new Error('String is empty');
  }
}
/**
 * Asserts whether Base64Url encoded string is passed
 */


function assertBase64UrlData(value) {
  (0, _type.assertString)(value);
  assertNotEmptyString(value);

  if (!/^[-A-Za-z0-9_]+[=]{0,2}$/.test(value)) {
    throw new Error('Incorrect symbols in Base64Url data');
  }
}
/**
 * Removes 0x from hex string
 */


function removeZeroFromHex(value) {
  return value.replace('0x', '');
}
/**
 * Creates topic for storing private key using username and password
 */


function createCredentialsTopic(username, password) {
  const topic = AUTH_VERSION + username + password;
  return bmtHashString(topic);
}
/**
 * Asserts whether a valid chunk size is passed
 */


function assertChunkSizeLength(value) {
  const data = value;

  if (data !== CHUNK_SIZE) {
    throw new Error('Chunk size is not incorrect');
  }
}
/**
 * Converts bytes to CryptoJS WordArray
 */


function bytesToWordArray(data) {
  return _cryptoJs.default.enc.Hex.parse(_beeJs.Utils.bytesToHex(data));
}

/***/ }),

/***/ "./src/chunk/bmt.ts":
/*!**************************!*\
  !*** ./src/chunk/bmt.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.bmtHash = bmtHash;

var _jsSha = __webpack_require__(/*! js-sha3 */ "./node_modules/js-sha3/src/sha3.js");

var _error = __webpack_require__(/*! ../utils/error */ "./src/utils/error.ts");

var _beeJs = __webpack_require__(/*! @ethersphere/bee-js */ "./node_modules/@ethersphere/bee-js/dist/cjs/index.js");

const MAX_CHUNK_PAYLOAD_SIZE = 4096;
const SEGMENT_SIZE = 32;
const SEGMENT_PAIR_SIZE = 2 * SEGMENT_SIZE;
const HASH_SIZE = 32;
/**
 * Calculate a Binary Merkle Tree hash for a chunk
 *
 * The BMT chunk address is the hash of the 8 byte span and the root
 * hash of a binary Merkle tree (BMT) built on the 32-byte segments
 * of the underlying data.
 *
 * If the chunk content is less than 4k, the hash is calculated as
 * if the chunk was padded with all zeros up to 4096 bytes.
 *
 * @param chunkContent Chunk data including span and payload as well
 *
 * @returns the keccak256 hash in a byte array
 */

function bmtHash(chunkContent) {
  const span = chunkContent.slice(0, 8);
  const payload = chunkContent.slice(8);
  const rootHash = bmtRootHash(payload);
  const chunkHashInput = new Uint8Array([...span, ...rootHash]);
  return _beeJs.Utils.keccak256Hash(chunkHashInput);
}

function bmtRootHash(payload) {
  if (payload.length > MAX_CHUNK_PAYLOAD_SIZE) {
    throw new _error.BeeArgumentError('invalid data length', payload);
  } // create an input buffer padded with zeros


  let input = new Uint8Array([...payload, ...new Uint8Array(MAX_CHUNK_PAYLOAD_SIZE - payload.length)]);

  while (input.length !== HASH_SIZE) {
    const output = new Uint8Array(input.length / 2); // in each round we hash the segment pairs together

    for (let offset = 0; offset < input.length; offset += SEGMENT_PAIR_SIZE) {
      const hashNumbers = _jsSha.keccak256.array(input.slice(offset, offset + SEGMENT_PAIR_SIZE));

      output.set(hashNumbers, offset / 2);
    }

    input = output;
  }

  return input;
}

/***/ }),

/***/ "./src/chunk/cac.ts":
/*!**************************!*\
  !*** ./src/chunk/cac.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MIN_PAYLOAD_SIZE = exports.MAX_PAYLOAD_SIZE = void 0;
exports.makeContentAddressedChunk = makeContentAddressedChunk;

var _beeJs = __webpack_require__(/*! @ethersphere/bee-js */ "./node_modules/@ethersphere/bee-js/dist/cjs/index.js");

var _bmt = __webpack_require__(/*! ./bmt */ "./src/chunk/bmt.ts");

var _bytes = __webpack_require__(/*! ../utils/bytes */ "./src/utils/bytes.ts");

const MIN_PAYLOAD_SIZE = 1;
exports.MIN_PAYLOAD_SIZE = MIN_PAYLOAD_SIZE;
const MAX_PAYLOAD_SIZE = 4096;
exports.MAX_PAYLOAD_SIZE = MAX_PAYLOAD_SIZE;
const CAC_SPAN_OFFSET = 0;
const CAC_PAYLOAD_OFFSET = CAC_SPAN_OFFSET + _bytes.SPAN_SIZE;

/**
 * Creates a content addressed chunk and verifies the payload size.
 *
 * @param payloadBytes the data to be stored in the chunk
 */
function makeContentAddressedChunk(payloadBytes) {
  const span = (0, _bytes.makeSpan)(payloadBytes.length);
  (0, _bytes.assertFlexBytes)(payloadBytes, MIN_PAYLOAD_SIZE, MAX_PAYLOAD_SIZE);
  const data = (0, _bytes.serializeBytes)(span, payloadBytes);
  return {
    data,
    span: () => span,
    payload: () => _beeJs.Utils.flexBytesAtOffset(data, CAC_PAYLOAD_OFFSET, MIN_PAYLOAD_SIZE, MAX_PAYLOAD_SIZE),
    address: () => (0, _bmt.bmtHash)(data)
  };
}

/***/ }),

/***/ "./src/connection/connection.ts":
/*!**************************************!*\
  !*** ./src/connection/connection.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Connection = void 0;

/**
 * Holder for Bee and BeeDebug instances
 */
class Connection {
  constructor(bee, beeDebug, options) {
    this.bee = bee;
    this.beeDebug = beeDebug;
    this.options = options;
  }

}

exports.Connection = Connection;

/***/ }),

/***/ "./src/content-items/content-item.ts":
/*!*******************************************!*\
  !*** ./src/content-items/content-item.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ContentItem = void 0;

/**
 * DirectoryItem is a representation of a directory or file in the pod
 */
class ContentItem {
  constructor(name, raw, size, reference) {
    this.name = name;
    this.raw = raw;
    this.size = size;
    this.reference = reference;
  }

}

exports.ContentItem = ContentItem;

/***/ }),

/***/ "./src/content-items/directory-item.ts":
/*!*********************************************!*\
  !*** ./src/content-items/directory-item.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.DirectoryItem = void 0;

var _contentItem = __webpack_require__(/*! ./content-item */ "./src/content-items/content-item.ts");

var _utils = __webpack_require__(/*! ./utils */ "./src/content-items/utils.ts");

/**
 * A representation of a directory in the pod
 */
class DirectoryItem extends _contentItem.ContentItem {
  constructor(name, content = [], raw, size, reference) {
    super(name, raw, size, reference);
    this.name = name;
    this.content = content;
    this.raw = raw;
    this.size = size;
    this.reference = reference;
  }
  /**
   * Gets the list of files in the directory
   */


  getFiles() {
    return this.content.filter(_utils.isFileItem);
  }
  /**
   * Gets the list of directories in the directory
   */


  getDirectories() {
    return this.content.filter(_utils.isDirectoryItem);
  }
  /**
   * Converts FairOS directory metadata to a DirectoryItem
   *
   * @param item raw directory metadata from FairOS
   */


  static fromRawDirectoryMetadata(item) {
    return new DirectoryItem(item.Meta.Name, [], item);
  }

}

exports.DirectoryItem = DirectoryItem;

/***/ }),

/***/ "./src/content-items/file-item.ts":
/*!****************************************!*\
  !*** ./src/content-items/file-item.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FileItem = void 0;

var _cryptoJs = _interopRequireDefault(__webpack_require__(/*! crypto-js */ "./node_modules/crypto-js/index.js"));

var _contentItem = __webpack_require__(/*! ./content-item */ "./src/content-items/content-item.ts");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A representation of a file in the pod
 */
class FileItem extends _contentItem.ContentItem {
  constructor(name, raw, size, reference) {
    super(name, raw, size, reference);
    this.name = name;
    this.raw = raw;
    this.size = size;
    this.reference = reference;
  }
  /**
   * Converts FairOS file metadata to a DirectoryItem
   *
   * @param item raw file metadata from FairOS
   */


  static fromRawFileMetadata(item) {
    let reference;

    if (item.file_inode_reference) {
      reference = _cryptoJs.default.enc.Base64.parse(item.file_inode_reference).toString(_cryptoJs.default.enc.Hex);
    }

    return new FileItem(item.file_name, item, Number(item.file_size), reference);
  }

}

exports.FileItem = FileItem;

/***/ }),

/***/ "./src/content-items/handler.ts":
/*!**************************************!*\
  !*** ./src/content-items/handler.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.addEntryToDirectory = addEntryToDirectory;
exports.removeEntryFromDirectory = removeEntryFromDirectory;

var _address = __webpack_require__(/*! ../utils/address */ "./src/utils/address.ts");

var _time = __webpack_require__(/*! ../utils/time */ "./src/utils/time.ts");

var _api = __webpack_require__(/*! ../feed/api */ "./src/feed/api.ts");

var _adapter = __webpack_require__(/*! ../directory/adapter */ "./src/directory/adapter.ts");

var _handler = __webpack_require__(/*! ../file/handler */ "./src/file/handler.ts");

var _utils = __webpack_require__(/*! ../directory/utils */ "./src/directory/utils.ts");

var _utils2 = __webpack_require__(/*! ./utils */ "./src/content-items/utils.ts");

/**
 * Add child file or directory to a defined parent directory
 *
 * @param connection connection information for data management
 * @param wallet wallet of the pod
 * @param parentPath parent path
 * @param entryPath entry path
 * @param isFile define if entry is file or directory
 * @param downloadOptions download options
 */
async function addEntryToDirectory(connection, wallet, parentPath, entryPath, isFile, downloadOptions) {
  var _parentData$FileOrDir;

  if (!parentPath) {
    throw new Error('Incorrect parent path');
  }

  if (!entryPath) {
    throw new Error('Incorrect entry path');
  }

  const itemText = isFile ? 'File' : 'Directory';
  const fullPath = (0, _utils.combine)(parentPath, entryPath);
  let pathData;

  try {
    pathData = await (0, _api.getFeedData)(connection.bee, fullPath, (0, _address.prepareEthAddress)(wallet.address), downloadOptions); // eslint-disable-next-line no-empty
  } catch (e) {}

  if (pathData) {
    throw new Error(`${itemText} "${fullPath}" already uploaded to the network`);
  }

  let parentData;
  let metadataWithEpoch;

  try {
    metadataWithEpoch = await (0, _utils2.getRawMetadata)(connection.bee, parentPath, (0, _address.prepareEthAddress)(wallet.address), downloadOptions);
    (0, _utils.assertRawDirectoryMetadata)(metadataWithEpoch.metadata);
    parentData = metadataWithEpoch.metadata;
  } catch (e) {
    throw new Error('Parent directory does not exist');
  }

  const itemToAdd = (isFile ? _handler.FILE_TOKEN : _handler.DIRECTORY_TOKEN) + entryPath;
  parentData.FileOrDirNames = (_parentData$FileOrDir = parentData.FileOrDirNames) !== null && _parentData$FileOrDir !== void 0 ? _parentData$FileOrDir : [];

  if (parentData.FileOrDirNames.includes(itemToAdd)) {
    throw new Error(`${itemText} already listed in the parent directory list`);
  }

  parentData.FileOrDirNames.push(itemToAdd);
  parentData.Meta.ModificationTime = (0, _time.getUnixTimestamp)();
  return (0, _api.writeFeedData)(connection, parentPath, (0, _adapter.getRawDirectoryMetadataBytes)(parentData), wallet.privateKey, metadataWithEpoch.epoch.getNextEpoch((0, _time.getUnixTimestamp)()));
}
/**
 * Removes file or directory from the parent directory
 *
 * @param connection connection information for data management
 * @param wallet wallet of the pod
 * @param parentPath parent path of the entry
 * @param entryPath full path of the entry
 * @param isFile define if entry is file or directory
 * @param downloadOptions download options
 */


async function removeEntryFromDirectory(connection, wallet, parentPath, entryPath, isFile, downloadOptions) {
  const metadataWithEpoch = await (0, _utils2.getRawMetadata)(connection.bee, parentPath, (0, _address.prepareEthAddress)(wallet.address), downloadOptions);
  const parentData = metadataWithEpoch.metadata;
  (0, _utils.assertRawDirectoryMetadata)(parentData);
  const itemToRemove = (isFile ? _handler.FILE_TOKEN : _handler.DIRECTORY_TOKEN) + entryPath;

  if (parentData.FileOrDirNames) {
    parentData.FileOrDirNames = parentData.FileOrDirNames.filter(name => name !== itemToRemove);
  }

  return (0, _api.writeFeedData)(connection, parentPath, (0, _adapter.getRawDirectoryMetadataBytes)(parentData), wallet.privateKey, metadataWithEpoch.epoch.getNextEpoch((0, _time.getUnixTimestamp)()));
}

/***/ }),

/***/ "./src/content-items/utils.ts":
/*!************************************!*\
  !*** ./src/content-items/utils.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getRawMetadata = getRawMetadata;
exports.isDirectoryItem = isDirectoryItem;
exports.isFileItem = isFileItem;

var _fileItem = __webpack_require__(/*! ./file-item */ "./src/content-items/file-item.ts");

var _directoryItem = __webpack_require__(/*! ./directory-item */ "./src/content-items/directory-item.ts");

var _api = __webpack_require__(/*! ../feed/api */ "./src/feed/api.ts");

var _utils = __webpack_require__(/*! ../directory/utils */ "./src/directory/utils.ts");

/**
 * Directory item guard
 */
function isDirectoryItem(value) {
  return value instanceof _directoryItem.DirectoryItem;
}
/**
 * File item guard
 */


function isFileItem(value) {
  return value instanceof _fileItem.FileItem;
}
/**
 * Get raw metadata by path
 *
 * @param bee Bee client
 * @param path path with information
 * @param address Ethereum address of the pod which owns the path
 * @param downloadOptions options for downloading
 */


async function getRawMetadata(bee, path, address, downloadOptions) {
  const feedData = await (0, _api.getFeedData)(bee, path, address, downloadOptions);
  const data = feedData.data.chunkContent().json();
  let metadata;

  if ((0, _utils.isRawDirectoryMetadata)(data)) {
    metadata = data;
  } else if ((0, _utils.isRawFileMetadata)(data)) {
    metadata = data;
  } else {
    throw new Error('Invalid metadata');
  }

  return {
    epoch: feedData.epoch,
    metadata
  };
}

/***/ }),

/***/ "./src/directory/adapter.ts":
/*!**********************************!*\
  !*** ./src/directory/adapter.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getRawDirectoryMetadataBytes = getRawDirectoryMetadataBytes;

var _bytes = __webpack_require__(/*! ../utils/bytes */ "./src/utils/bytes.ts");

/**
 * Converts FairOS raw directory metadata to bytes representation
 */
function getRawDirectoryMetadataBytes(data) {
  return (0, _bytes.stringToBytes)(JSON.stringify(data));
}

/***/ }),

/***/ "./src/directory/directory.ts":
/*!************************************!*\
  !*** ./src/directory/directory.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Directory = void 0;

var _api = __webpack_require__(/*! ../pod/api */ "./src/pod/api.ts");

var _handler = __webpack_require__(/*! ./handler */ "./src/directory/handler.ts");

var _utils = __webpack_require__(/*! ../account/utils */ "./src/account/utils.ts");

var _handler2 = __webpack_require__(/*! ../content-items/handler */ "./src/content-items/handler.ts");

var _utils2 = __webpack_require__(/*! ../file/utils */ "./src/file/utils.ts");

var _utils3 = __webpack_require__(/*! ../pod/utils */ "./src/pod/utils.ts");

/**
 * Directory related class
 */
class Directory {
  constructor(accountData) {
    this.accountData = accountData;
  }
  /**
   * Get files and directories under the given path
   *
   * @param podName pod for content search
   * @param path path to start searching from
   * @param isRecursive search with recursion or not
   */


  async read(podName, path, isRecursive) {
    var _this$accountData$con, _this$accountData$con2;

    (0, _utils.assertActiveAccount)(this.accountData);
    (0, _utils3.assertPodName)(podName);
    const extendedInfo = await (0, _api.getExtendedPodsList)(this.accountData.connection.bee, podName, this.accountData.wallet, (_this$accountData$con = this.accountData.connection.options) === null || _this$accountData$con === void 0 ? void 0 : _this$accountData$con.downloadOptions);
    return (0, _handler.readDirectory)(this.accountData.connection.bee, path, extendedInfo.podAddress, isRecursive, (_this$accountData$con2 = this.accountData.connection.options) === null || _this$accountData$con2 === void 0 ? void 0 : _this$accountData$con2.downloadOptions);
  }
  /**
   * Creates a directory
   *
   * @param podName pod where to create a directory
   * @param fullPath path for a directory
   */


  async create(podName, fullPath) {
    var _this$accountData$con3;

    (0, _utils.assertActiveAccount)(this.accountData);
    (0, _utils3.assertPodName)(podName);
    const downloadOptions = (_this$accountData$con3 = this.accountData.connection.options) === null || _this$accountData$con3 === void 0 ? void 0 : _this$accountData$con3.downloadOptions;
    const extendedInfo = await (0, _api.getExtendedPodsList)(this.accountData.connection.bee, podName, this.accountData.wallet, downloadOptions);
    return (0, _handler.createDirectory)(this.accountData.connection, fullPath, extendedInfo.podWallet, downloadOptions);
  }
  /**
   * Deletes a directory
   *
   * @param podName pod where to delete a directory
   * @param fullPath path for a directory
   */


  async delete(podName, fullPath) {
    var _connection$options;

    (0, _utils.assertActiveAccount)(this.accountData);
    (0, _utils3.assertPodName)(podName);
    const pathInfo = (0, _utils2.extractPathInfo)(fullPath);
    const connection = this.accountData.connection;
    const downloadOptions = (_connection$options = connection.options) === null || _connection$options === void 0 ? void 0 : _connection$options.downloadOptions;
    const extendedInfo = await (0, _api.getExtendedPodsList)(connection.bee, podName, this.accountData.wallet, downloadOptions);
    await (0, _handler2.removeEntryFromDirectory)(connection, extendedInfo.podWallet, pathInfo.path, pathInfo.filename, false, downloadOptions);
  }

}

exports.Directory = Directory;

/***/ }),

/***/ "./src/directory/handler.ts":
/*!**********************************!*\
  !*** ./src/directory/handler.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.MAX_DIRECTORY_NAME_LENGTH = void 0;
exports.createDirectory = createDirectory;
exports.createRootDirectory = createRootDirectory;
exports.readDirectory = readDirectory;

var _api = __webpack_require__(/*! ../feed/api */ "./src/feed/api.ts");

var _utils = __webpack_require__(/*! ./utils */ "./src/directory/utils.ts");

var _handler = __webpack_require__(/*! ../file/handler */ "./src/file/handler.ts");

var _time = __webpack_require__(/*! ../utils/time */ "./src/utils/time.ts");

var _utils2 = __webpack_require__(/*! ../pod/utils */ "./src/pod/utils.ts");

var _handler2 = __webpack_require__(/*! ../content-items/handler */ "./src/content-items/handler.ts");

var _directoryItem = __webpack_require__(/*! ../content-items/directory-item */ "./src/content-items/directory-item.ts");

var _fileItem = __webpack_require__(/*! ../content-items/file-item */ "./src/content-items/file-item.ts");

var _utils3 = __webpack_require__(/*! ../content-items/utils */ "./src/content-items/utils.ts");

const MAX_DIRECTORY_NAME_LENGTH = 100;
/**
 * Get files and directories under path with recursion or not
 *
 * @param bee Bee instance
 * @param path path to start searching from
 * @param address Ethereum address of the pod which owns the path
 * @param isRecursive search with recursion or not
 * @param downloadOptions options for downloading
 */

exports.MAX_DIRECTORY_NAME_LENGTH = MAX_DIRECTORY_NAME_LENGTH;

async function readDirectory(bee, path, address, isRecursive, downloadOptions) {
  const parentRawDirectoryMetadata = (await (0, _utils3.getRawMetadata)(bee, path, address)).metadata;
  (0, _utils.assertRawDirectoryMetadata)(parentRawDirectoryMetadata);

  const resultDirectoryItem = _directoryItem.DirectoryItem.fromRawDirectoryMetadata(parentRawDirectoryMetadata);

  if (!parentRawDirectoryMetadata.FileOrDirNames) {
    return resultDirectoryItem;
  }

  for (let item of parentRawDirectoryMetadata.FileOrDirNames) {
    const isFile = item.startsWith(_handler.FILE_TOKEN);
    const isDirectory = item.startsWith(_handler.DIRECTORY_TOKEN);

    if (isFile) {
      item = (0, _utils.combine)(path, item.substring(_handler.FILE_TOKEN.length));
      const data = (await (0, _utils3.getRawMetadata)(bee, item, address, downloadOptions)).metadata;
      (0, _utils.assertRawFileMetadata)(data);
      resultDirectoryItem.content.push(_fileItem.FileItem.fromRawFileMetadata(data));
    } else if (isDirectory) {
      item = (0, _utils.combine)(path, item.substring(_handler.DIRECTORY_TOKEN.length));
      const data = (await (0, _utils3.getRawMetadata)(bee, item, address, downloadOptions)).metadata;
      (0, _utils.assertRawDirectoryMetadata)(data);

      const currentMetadata = _directoryItem.DirectoryItem.fromRawDirectoryMetadata(data);

      if (isRecursive) {
        currentMetadata.content = (await readDirectory(bee, item, address, isRecursive)).content;
      }

      resultDirectoryItem.content.push(currentMetadata);
    }
  }

  return resultDirectoryItem;
}
/**
 * Creates directory metadata for a given directory path and upload it to the network
 *
 * @param connection Bee connection
 * @param path parent path
 * @param name name of the directory
 * @param privateKey private key of the pod
 */


async function createDirectoryInfo(connection, path, name, privateKey) {
  const now = (0, _time.getUnixTimestamp)();
  const metadata = (0, _utils2.createRawDirectoryMetadata)(_utils2.META_VERSION, path, name, now, now, now);
  return (0, _api.writeFeedData)(connection, (0, _utils.combine)(path, name), metadata, privateKey);
}
/**
 * Creates root directory for the pod that tied to the private key
 *
 * @param connection Bee connection
 * @param privateKey private key of the pod
 */


async function createRootDirectory(connection, privateKey) {
  return createDirectoryInfo(connection, '', '/', privateKey);
}
/**
 * Creates directory under the pod
 *
 * @param connection Bee connection
 * @param fullPath path to the directory
 * @param podWallet pod wallet
 * @param downloadOptions options for downloading
 */


async function createDirectory(connection, fullPath, podWallet, downloadOptions) {
  const parts = (0, _utils.getPathParts)(fullPath);
  (0, _utils.assertPartsLength)(parts);
  const name = parts[parts.length - 1];
  (0, _utils.assertDirectoryName)(name);
  const parentPath = (0, _utils.getPathFromParts)(parts, 1);
  await (0, _handler2.addEntryToDirectory)(connection, podWallet, parentPath, name, false, downloadOptions);
  await createDirectoryInfo(connection, parentPath, name, podWallet.privateKey);
}

/***/ }),

/***/ "./src/directory/utils.ts":
/*!********************************!*\
  !*** ./src/directory/utils.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.assertDirectoryName = assertDirectoryName;
exports.assertPartsLength = assertPartsLength;
exports.assertRawDirectoryMetadata = assertRawDirectoryMetadata;
exports.assertRawFileMetadata = assertRawFileMetadata;
exports.combine = combine;
exports.getPathFromParts = getPathFromParts;
exports.getPathParts = getPathParts;
exports.isRawDirectoryMetadata = isRawDirectoryMetadata;
exports.isRawFileMetadata = isRawFileMetadata;

var _handler = __webpack_require__(/*! ./handler */ "./src/directory/handler.ts");

var _type = __webpack_require__(/*! ../utils/type */ "./src/utils/type.ts");

var _string = __webpack_require__(/*! ../utils/string */ "./src/utils/string.ts");

/**
 * Combine passed parts of path to full path
 *
 * @param parts path parts to combine
 */
function combine(...parts) {
  // remove empty items
  parts = parts.filter(item => item !== ''); // remove slashes if element contains not only slash

  parts = parts.map(part => part.length > 1 ? (0, _string.replaceAll)(part, '/', '') : part); // add slash to the start of parts if it is not the first element

  if (parts[0] !== '/') {
    parts.unshift('/');
  }

  return getPathFromParts(parts);
}
/**
 * Splits path to parts
 *
 * @param path absolute path
 */


function getPathParts(path) {
  if (path.length === 0) {
    throw new Error('Path is empty');
  }

  if (!path.startsWith('/')) {
    throw new Error('Incorrect path');
  }

  if (path === '/') {
    return ['/'];
  }

  return ['/', ...path.split('/').slice(1)];
}
/**
 * Join parts to path with removing a certain number of parts from the end
 *
 * @param parts parts of path
 * @param minusParts hom many parts should be removed
 */


function getPathFromParts(parts, minusParts = 0) {
  if (parts.length === 0) {
    throw new Error('Parts list is empty');
  }

  if (parts[0] !== '/') {
    throw new Error('Path parts must start with "/"');
  }

  if (parts.length <= minusParts) {
    throw new Error('Incorrect parts count');
  }

  return '/' + parts.slice(1, parts.length - minusParts).join('/');
}
/**
 * Asserts that parts length is correct
 */


function assertPartsLength(value) {
  const parts = value;

  if (parts.length < 2) {
    throw new Error('Can not create directory for root');
  }
}
/**
 * Asserts that directory name is correct
 */


function assertDirectoryName(value) {
  (0, _type.assertString)(value);

  if (value.length === 0) {
    throw new Error('Name is empty');
  }

  if (value.includes('/')) {
    throw new Error('Name contains "/" symbol');
  }

  if (value.length > _handler.MAX_DIRECTORY_NAME_LENGTH) {
    throw new Error('Directory name is too long');
  }
}
/**
 * Asserts that raw directory metadata is correct
 */


function assertRawDirectoryMetadata(value) {
  if (!isRawDirectoryMetadata(value)) {
    throw new Error('Invalid raw directory metadata');
  }
}
/**
 * Asserts that raw file metadata is correct
 */


function assertRawFileMetadata(value) {
  if (!isRawFileMetadata(value)) {
    throw new Error('Invalid raw file metadata');
  }
}
/**
 * Raw directory metadata guard
 */


function isRawDirectoryMetadata(value) {
  const data = value;
  return typeof data.Meta === 'object' && (0, _type.isString)(data.Meta.Name) && (0, _type.isString)(data.Meta.Path) && (0, _type.isNumber)(data.Meta.AccessTime) && (0, _type.isNumber)(data.Meta.ModificationTime) && (0, _type.isNumber)(data.Meta.CreationTime) && (0, _type.isNumber)(data.Meta.Version) && (data.FileOrDirNames === null || Array.isArray(data.FileOrDirNames));
}
/**
 * Raw file metadata guard
 */


function isRawFileMetadata(value) {
  const {
    version,
    user_address,
    pod_name,
    file_path,
    file_name,
    file_size,
    block_size,
    content_type,
    compression,
    creation_time,
    access_time,
    modification_time,
    file_inode_reference
  } = value;
  return (0, _type.isNumber)(version) && Array.isArray(user_address) && (0, _type.isString)(pod_name) && (0, _type.isString)(file_path) && (0, _type.isString)(file_name) && (0, _type.isNumber)(file_size) && (0, _type.isNumber)(block_size) && (0, _type.isString)(content_type) && (0, _type.isString)(compression) && (0, _type.isNumber)(creation_time) && (0, _type.isNumber)(access_time) && (0, _type.isNumber)(modification_time) && (0, _type.isString)(file_inode_reference);
}

/***/ }),

/***/ "./src/fdp-storage.ts":
/*!****************************!*\
  !*** ./src/fdp-storage.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FdpStorage = void 0;

var _beeJs = __webpack_require__(/*! @ethersphere/bee-js */ "./node_modules/@ethersphere/bee-js/dist/cjs/index.js");

var _accountData = __webpack_require__(/*! ./account/account-data */ "./src/account/account-data.ts");

var _personalStorage = __webpack_require__(/*! ./pod/personal-storage */ "./src/pod/personal-storage.ts");

var _connection = __webpack_require__(/*! ./connection/connection */ "./src/connection/connection.ts");

var _directory = __webpack_require__(/*! ./directory/directory */ "./src/directory/directory.ts");

var _file = __webpack_require__(/*! ./file/file */ "./src/file/file.ts");

var _fdpContracts = __webpack_require__(/*! @fairdatasociety/fdp-contracts */ "./node_modules/@fairdatasociety/fdp-contracts/build/index.js");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class FdpStorage {
  constructor(beeUrl, beeDebugUrl, options) {
    _defineProperty(this, "connection", void 0);

    _defineProperty(this, "account", void 0);

    _defineProperty(this, "personalStorage", void 0);

    _defineProperty(this, "directory", void 0);

    _defineProperty(this, "file", void 0);

    _defineProperty(this, "ens", void 0);

    this.connection = new _connection.Connection(new _beeJs.Bee(beeUrl), new _beeJs.BeeDebug(beeDebugUrl), options);
    this.ens = new _fdpContracts.ENS(options === null || options === void 0 ? void 0 : options.ensOptions, null, options === null || options === void 0 ? void 0 : options.ensDomain);
    this.account = new _accountData.AccountData(this.connection, this.ens);
    this.personalStorage = new _personalStorage.PersonalStorage(this.account);
    this.directory = new _directory.Directory(this.account);
    this.file = new _file.File(this.account);
  }

}

exports.FdpStorage = FdpStorage;

/***/ }),

/***/ "./src/feed/api.ts":
/*!*************************!*\
  !*** ./src/feed/api.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getFeedData = getFeedData;
exports.writeFeedData = writeFeedData;

var _beeJs = __webpack_require__(/*! @ethersphere/bee-js */ "./node_modules/@ethersphere/bee-js/dist/cjs/index.js");

var _utils = __webpack_require__(/*! ../account/utils */ "./src/account/utils.ts");

var _handler = __webpack_require__(/*! ./handler */ "./src/feed/handler.ts");

var _linear = __webpack_require__(/*! ./lookup/linear */ "./src/feed/lookup/linear.ts");

var _epoch = __webpack_require__(/*! ./lookup/epoch */ "./src/feed/lookup/epoch.ts");

var _hex = __webpack_require__(/*! ../utils/hex */ "./src/utils/hex.ts");

var _batch = __webpack_require__(/*! ../utils/batch */ "./src/utils/batch.ts");

var _time = __webpack_require__(/*! ../utils/time */ "./src/utils/time.ts");

/**
 * Finds and downloads the latest feed content
 *
 * @param bee Bee client
 * @param topic topic for calculation swarm chunk
 * @param address Ethereum address for calculation swarm chunk
 * @param options download chunk options
 */
async function getFeedData(bee, topic, address, options) {
  const topicHash = (0, _utils.bmtHashString)(topic);
  return (0, _linear.lookup)(0, async (epoch, time) => {
    const tempId = (0, _handler.getId)(topicHash, time, epoch.level);
    const chunkReference = (0, _hex.bytesToHex)(_beeJs.Utils.keccak256Hash(tempId.buffer, address.buffer));
    return bee.downloadChunk(chunkReference, options);
  });
}
/**
 * Writes data to feed using `topic` and `epoch` as a key and signed data with `privateKey` as a value
 *
 * @param connection connection information for data uploading
 * @param topic key for data
 * @param data data to upload
 * @param privateKey private key to sign data
 * @param epoch feed epoch
 */


async function writeFeedData(connection, topic, data, privateKey, epoch) {
  if (!epoch) {
    epoch = new _epoch.Epoch(_epoch.HIGHEST_LEVEL, (0, _time.getUnixTimestamp)());
  }

  const topicHash = (0, _utils.bmtHashString)(topic);
  const id = (0, _handler.getId)(topicHash, epoch.time, epoch.level);
  const socWriter = connection.bee.makeSOCWriter(privateKey);
  return socWriter.upload(await (0, _batch.getBatchId)(connection.beeDebug), id, data);
}

/***/ }),

/***/ "./src/feed/handler.ts":
/*!*****************************!*\
  !*** ./src/feed/handler.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getId = getId;

var _cac = __webpack_require__(/*! ../chunk/cac */ "./src/chunk/cac.ts");

var _epoch = __webpack_require__(/*! ./lookup/epoch */ "./src/feed/lookup/epoch.ts");

const TOPIC_LENGTH = 32;
/**
 * Calculates swarm reference with passed params
 *
 * @param topic identification of content
 * @param time time in epoch for content
 * @param level level in epoch for content
 * @returns swarm reference
 */

function getId(topic, time = 0, level = _epoch.HIGHEST_LEVEL) {
  const bufId = new Uint8Array(40);
  let cursor = 0;

  for (let i = 0; i < TOPIC_LENGTH; i++) {
    bufId[cursor] = topic[cursor];
    cursor++;
  }

  const epoch = new _epoch.Epoch(level, time);
  const eid = epoch.id();

  for (let i = 0; i < eid.length; i++) {
    bufId[cursor + i] = eid[i];
  }

  return (0, _cac.makeContentAddressedChunk)(bufId).address();
}

/***/ }),

/***/ "./src/feed/lookup/epoch.ts":
/*!**********************************!*\
  !*** ./src/feed/lookup/epoch.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.LOWEST_LEVEL = exports.HIGHEST_LEVEL = exports.Epoch = void 0;
exports.getBaseTime = getBaseTime;
exports.getFirstEpoch = getFirstEpoch;

var _bytes = __webpack_require__(/*! ../../utils/bytes */ "./src/utils/bytes.ts");

const EPOCH_LENGTH = 8;
const HIGHEST_LEVEL = 31;
exports.HIGHEST_LEVEL = HIGHEST_LEVEL;
const LOWEST_LEVEL = 0;
exports.LOWEST_LEVEL = LOWEST_LEVEL;

/**
 * Calculates base time in form of number
 *
 * @param time unix timestamp parameter for calculation
 * @param level level parameter for calculation
 */
function getBaseTime(time, level) {
  return time & Number.MAX_SAFE_INTEGER << level;
}
/**
 * Creates instance of `Epoch` where the first update should be located based on what time is passed
 */


function getFirstEpoch(time) {
  return new Epoch(HIGHEST_LEVEL, time);
}
/**
 * An epoch represents a concrete time period starting at a specific point in time, called
 * the epoch base time and has a specific length. Period lengths are expressed as powers
 * of 2 in seconds. The shortest period is 20^0 = 1 second, the longest is 2^31 seconds
 */


class Epoch {
  /**
   * Create en Epoch instance
   *
   * @param level level that identify a specific epoch
   * @param time time that identify a specific epoch
   */
  constructor(level, time) {
    this.level = level;
    this.time = time;
  }
  /**
   * Calculates base time in form of number for `level` and `time`
   *
   * @returns result number
   */


  base() {
    return getBaseTime(this.time, this.level);
  }
  /**
   * Packs time and level into an array of bytes
   *
   * @returns array of bytes with time and level
   */


  id() {
    const base = this.base();
    const id = Uint8Array.from((0, _bytes.longToByteArray)(base));
    id[7] = this.level;
    return id;
  }
  /**
   * Checks if two epochs are equal
   *
   * @param epoch epoch to compare
   */


  equals(epoch) {
    return this.level === epoch.level && this.base() === epoch.base();
  }
  /**
   * Calculates the first nonzero bit of the XOR of base and 'time', counting from the highest significant bit
   * but limited to not return a level that is smaller than the base-1
   *
   * @return the frequency level a next update should be placed at, provided where the last update was and what time it is now
   */


  getNextLevel(time) {
    // if the last update was more than 2^HIGHEST_LEVEL seconds ago, choose the highest level
    if (this.level > HIGHEST_LEVEL) {
      return HIGHEST_LEVEL;
    } // First XOR the last epoch base time with the current clock. This will set all the FairOS most significant bits to zero.


    let mix = this.base() ^ time; // Then, make sure we stop the below loop before one level below the current, by setting that level's bit to 1.
    // If the next level is lower than the current one, it must be exactly level-1 and not lower.

    mix = mix | Math.abs(1 << this.level - 1); // set up a mask to scan for nonzero bits, starting at the highest level

    let mask = Math.abs(Math.pow(2, HIGHEST_LEVEL));

    for (let i = HIGHEST_LEVEL; i > LOWEST_LEVEL; i--) {
      if ((mix & mask) !== 0) {
        // if we find a nonzero bit, this is the level the next update should be at.
        return i;
      } // move our bit one position to the right


      mask >>>= 1;
    }

    return 0;
  }
  /**
   * Calculates the next epoch based on the current level and the new time
   *
   * @param time new time
   */


  getNextEpoch(time) {
    return new Epoch(this.getNextLevel(time), time);
  }

}

exports.Epoch = Epoch;

/***/ }),

/***/ "./src/feed/lookup/linear.ts":
/*!***********************************!*\
  !*** ./src/feed/lookup/linear.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.lookup = lookup;

var _epoch = __webpack_require__(/*! ./epoch */ "./src/feed/lookup/epoch.ts");

var _time = __webpack_require__(/*! ../../utils/time */ "./src/utils/time.ts");

var _utils = __webpack_require__(/*! ../utils */ "./src/feed/utils.ts");

/**
 * Searches feed content with linear way
 *
 * @param time search start time point
 * @param read async function for downloading data using Epoch and time
 */
async function lookup(time, read) {
  if (time === 0) {
    time = (0, _time.getUnixTimestamp)();
  }

  (0, _time.assertUnixTimestamp)(time);
  let previousChunk;
  let level = _epoch.HIGHEST_LEVEL;
  let previousEpoch;
  let epoch = new _epoch.Epoch(level, time);

  while (level > 0) {
    previousEpoch = epoch;
    epoch = new _epoch.Epoch(level, time);

    try {
      previousChunk = await read(epoch, time);
    } catch (e) {
      time = epoch.base() - 1;

      try {
        previousChunk = await read(epoch, time);
      } catch (e) {
        break;
      }
    }

    level--;
  }

  if (!previousChunk) {
    throw new Error('Data not found');
  }

  if (!epoch) {
    throw new Error('Incorrect epoch');
  }

  return {
    data: (0, _utils.wrapChunkHelper)(previousChunk),
    epoch: previousEpoch ? previousEpoch : epoch
  };
}

/***/ }),

/***/ "./src/feed/utils.ts":
/*!***************************!*\
  !*** ./src/feed/utils.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.wrapChunkHelper = wrapChunkHelper;

var _utils = __webpack_require__(/*! ../account/utils */ "./src/account/utils.ts");

/**
 * Wrap chunk data with helper
 *
 * @param data chunk data
 */
function wrapChunkHelper(data) {
  return Object.assign(data, {
    chunkContent: () => (0, _utils.extractChunkContent)(data)
  });
}

/***/ }),

/***/ "./src/file/adapter.ts":
/*!*****************************!*\
  !*** ./src/file/adapter.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.blockToRawBlock = blockToRawBlock;
exports.blocksToManifest = blocksToManifest;
exports.blocksToRawBlocks = blocksToRawBlocks;
exports.fileMetadataToRawFileMetadata = fileMetadataToRawFileMetadata;
exports.getFileMetadataRawBytes = getFileMetadataRawBytes;
exports.rawBlockToBlock = rawBlockToBlock;
exports.rawBlocksToBlocks = rawBlocksToBlocks;
exports.rawFileMetadataToFileMetadata = rawFileMetadataToFileMetadata;

var _address = __webpack_require__(/*! ../utils/address */ "./src/utils/address.ts");

var _utils = __webpack_require__(/*! ./utils */ "./src/file/utils.ts");

var _bytes = __webpack_require__(/*! ../utils/bytes */ "./src/utils/bytes.ts");

/**
 * Converts FairOS block format to FDS block format
 *
 * @param block FairOS block
 */
function rawBlockToBlock(block) {
  return {
    name: block.Name,
    size: block.Size,
    compressedSize: block.CompressedSize,
    reference: (0, _utils.base64toReference)(block.Reference.R)
  };
}
/**
 * Converts FairOS blocks format to FDS blocks format
 *
 * @param blocks FairOS blocks
 */


function rawBlocksToBlocks(blocks) {
  const resultBlocks = blocks.Blocks.map(item => rawBlockToBlock(item));
  return {
    blocks: resultBlocks
  };
}
/**
 * Converts FDS block format to FairOS block format
 *
 * @param block FDS block
 */


function blockToRawBlock(block) {
  return {
    Name: block.name,
    Size: block.size,
    CompressedSize: block.compressedSize,
    Reference: {
      R: (0, _utils.referenceToBase64)(block.reference)
    }
  };
}
/**
 * Converts FDS blocks format to FairOS blocks format
 *
 * @param blocks FDS blocks
 */


function blocksToRawBlocks(blocks) {
  return {
    Blocks: blocks.blocks.map(item => blockToRawBlock(item))
  };
}
/**
 * Converts FDS blocks format to FairOS manifest string
 *
 * @param blocks FDS blocks
 */


function blocksToManifest(blocks) {
  return JSON.stringify(blocksToRawBlocks(blocks));
}
/**
 * Converts FairOS file metadata to FDS file metadata
 *
 * @param data FairOS raw file metadata
 */


function rawFileMetadataToFileMetadata(data) {
  return {
    version: data.version,
    userAddress: (0, _address.prepareEthAddress)(Uint8Array.from(data.user_address)),
    podName: data.pod_name,
    filePath: data.file_path,
    fileName: data.file_name,
    fileSize: data.file_size,
    blockSize: data.block_size,
    contentType: data.content_type,
    compression: data.compression,
    creationTime: data.creation_time,
    accessTime: data.access_time,
    modificationTime: data.modification_time,
    blocksReference: (0, _utils.base64toReference)(data.file_inode_reference)
  };
}
/**
 * Converts FDS file metadata to FairOS file metadata
 */


function fileMetadataToRawFileMetadata(data) {
  return {
    version: data.version,
    user_address: Array.from(data.userAddress),
    pod_name: data.podName,
    file_path: data.filePath,
    file_name: data.fileName,
    file_size: data.fileSize,
    block_size: data.blockSize,
    content_type: data.contentType,
    compression: data.compression,
    creation_time: data.creationTime,
    access_time: data.accessTime,
    modification_time: data.modificationTime,
    file_inode_reference: (0, _utils.referenceToBase64)(data.blocksReference)
  };
}
/**
 * Converts FDS file metadata to FairOS raw file metadata in bytes representation
 *
 * @param data FDS file metadata
 */


function getFileMetadataRawBytes(data) {
  return (0, _bytes.stringToBytes)(JSON.stringify(fileMetadataToRawFileMetadata(data)));
}

/***/ }),

/***/ "./src/file/file.ts":
/*!**************************!*\
  !*** ./src/file/file.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.File = void 0;

var _utils = __webpack_require__(/*! ../account/utils */ "./src/account/utils.ts");

var _utils2 = __webpack_require__(/*! ../pod/utils */ "./src/pod/utils.ts");

var _api = __webpack_require__(/*! ../pod/api */ "./src/pod/api.ts");

var _time = __webpack_require__(/*! ../utils/time */ "./src/utils/time.ts");

var _bytes = __webpack_require__(/*! ../utils/bytes */ "./src/utils/bytes.ts");

var _utils3 = __webpack_require__(/*! ./utils */ "./src/file/utils.ts");

var _api2 = __webpack_require__(/*! ../feed/api */ "./src/feed/api.ts");

var _handler = __webpack_require__(/*! ./handler */ "./src/file/handler.ts");

var _adapter = __webpack_require__(/*! ./adapter */ "./src/file/adapter.ts");

var _handler2 = __webpack_require__(/*! ../content-items/handler */ "./src/content-items/handler.ts");

var _utils4 = __webpack_require__(/*! ../content-items/utils */ "./src/content-items/utils.ts");

var _utils5 = __webpack_require__(/*! ../directory/utils */ "./src/directory/utils.ts");

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/**
 * Files management class
 */
class File {
  constructor(accountData) {
    this.accountData = accountData;

    _defineProperty(this, "defaultUploadOptions", {
      blockSize: 1000000,
      contentType: ''
    });
  }
  /**
   * Downloads file content
   *
   * @param podName pod where file is stored
   * @param fullPath full path of the file
   */


  async downloadData(podName, fullPath) {
    var _this$accountData$con, _this$accountData$con2;

    (0, _utils.assertActiveAccount)(this.accountData);
    (0, _utils2.assertPodName)(podName);
    (0, _utils3.assertFullPathWithName)(fullPath);
    (0, _utils2.assertPodName)(podName);
    const extendedInfo = await (0, _api.getExtendedPodsList)(this.accountData.connection.bee, podName, this.accountData.wallet, (_this$accountData$con = this.accountData.connection.options) === null || _this$accountData$con === void 0 ? void 0 : _this$accountData$con.downloadOptions);
    return (0, _handler.downloadData)(this.accountData.connection.bee, fullPath, extendedInfo.podAddress, (_this$accountData$con2 = this.accountData.connection.options) === null || _this$accountData$con2 === void 0 ? void 0 : _this$accountData$con2.downloadOptions);
  }
  /**
   * Uploads file content
   *
   * @param podName pod where file is stored
   * @param fullPath full path of the file
   * @param data file content
   * @param options upload options
   */


  async uploadData(podName, fullPath, data, options) {
    var _connection$options;

    options = { ...this.defaultUploadOptions,
      ...options
    };
    (0, _utils.assertActiveAccount)(this.accountData);
    (0, _utils2.assertPodName)(podName);
    (0, _utils3.assertFullPathWithName)(fullPath);
    (0, _utils2.assertPodName)(podName);
    data = typeof data === 'string' ? (0, _bytes.stringToBytes)(data) : data;
    const connection = this.accountData.connection;
    const extendedInfo = await (0, _api.getExtendedPodsList)(connection.bee, podName, this.accountData.wallet, (_connection$options = connection.options) === null || _connection$options === void 0 ? void 0 : _connection$options.downloadOptions);
    const pathInfo = (0, _utils3.extractPathInfo)(fullPath);
    const now = (0, _time.getUnixTimestamp)();
    const blocksCount = Math.ceil(data.length / options.blockSize);
    const blocks = {
      blocks: []
    };

    for (let i = 0; i < blocksCount; i++) {
      const currentBlock = data.slice(i * options.blockSize, (i + 1) * options.blockSize);
      const result = await (0, _utils3.uploadBytes)(connection, currentBlock);
      blocks.blocks.push({
        name: (0, _handler.generateBlockName)(i),
        size: currentBlock.length,
        compressedSize: currentBlock.length,
        reference: result.reference
      });
    }

    const manifestBytes = (0, _bytes.stringToBytes)((0, _adapter.blocksToManifest)(blocks));
    const blocksReference = (await (0, _utils3.uploadBytes)(connection, manifestBytes)).reference;
    const meta = {
      version: _utils2.META_VERSION,
      userAddress: extendedInfo.podAddress,
      podName,
      filePath: pathInfo.path,
      fileName: pathInfo.filename,
      fileSize: data.length,
      blockSize: options.blockSize,
      contentType: options.contentType,
      compression: '',
      creationTime: now,
      accessTime: now,
      modificationTime: now,
      blocksReference
    };
    await (0, _handler2.addEntryToDirectory)(connection, extendedInfo.podWallet, pathInfo.path, pathInfo.filename, true);
    await (0, _api2.writeFeedData)(connection, fullPath, (0, _adapter.getFileMetadataRawBytes)(meta), extendedInfo.podWallet.privateKey);
    return meta;
  }
  /**
   * Deletes a file
   *
   * @param podName pod where file is located
   * @param fullPath full path of the file
   */


  async delete(podName, fullPath) {
    var _connection$options2;

    (0, _utils.assertActiveAccount)(this.accountData);
    (0, _utils3.assertFullPathWithName)(fullPath);
    (0, _utils2.assertPodName)(podName);
    const pathInfo = (0, _utils3.extractPathInfo)(fullPath);
    const connection = this.accountData.connection;
    const extendedInfo = await (0, _api.getExtendedPodsList)(connection.bee, podName, this.accountData.wallet, (_connection$options2 = connection.options) === null || _connection$options2 === void 0 ? void 0 : _connection$options2.downloadOptions);
    await (0, _handler2.removeEntryFromDirectory)(connection, extendedInfo.podWallet, pathInfo.path, pathInfo.filename, true);
  }
  /**
   * Shares file information
   *
   * @param podName pod where file is stored
   * @param fullPath full path of the file
   */


  async share(podName, fullPath) {
    var _connection$options3;

    (0, _utils.assertActiveAccount)(this.accountData);
    (0, _utils3.assertFullPathWithName)(fullPath);
    (0, _utils2.assertPodName)(podName);
    const connection = this.accountData.connection;
    const extendedInfo = await (0, _api.getExtendedPodsList)(connection.bee, podName, this.accountData.wallet, (_connection$options3 = connection.options) === null || _connection$options3 === void 0 ? void 0 : _connection$options3.downloadOptions);
    const meta = (await (0, _utils4.getRawMetadata)(connection.bee, fullPath, extendedInfo.podAddress)).metadata;
    (0, _utils5.assertRawFileMetadata)(meta);
    const data = (0, _bytes.stringToBytes)(JSON.stringify((0, _utils3.createFileShareInfo)(meta, extendedInfo.podAddress)));
    return (await (0, _utils3.uploadBytes)(connection, data)).reference;
  }

}

exports.File = File;

/***/ }),

/***/ "./src/file/handler.ts":
/*!*****************************!*\
  !*** ./src/file/handler.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.FILE_TOKEN = exports.DIRECTORY_TOKEN = void 0;
exports.downloadData = downloadData;
exports.generateBlockName = generateBlockName;
exports.getFileMetadata = getFileMetadata;

var _bytes = __webpack_require__(/*! ../utils/bytes */ "./src/utils/bytes.ts");

var _utils = __webpack_require__(/*! ./utils */ "./src/file/utils.ts");

var _adapter = __webpack_require__(/*! ./adapter */ "./src/file/adapter.ts");

var _utils2 = __webpack_require__(/*! ../directory/utils */ "./src/directory/utils.ts");

var _utils3 = __webpack_require__(/*! ../content-items/utils */ "./src/content-items/utils.ts");

/**
 * File prefix
 */
const FILE_TOKEN = '_F_';
/**
 * Directory prefix
 */

exports.FILE_TOKEN = FILE_TOKEN;
const DIRECTORY_TOKEN = '_D_';
/**
 * Get converted metadata by path
 *
 * @param bee Bee client
 * @param path path with information
 * @param address Ethereum address of the pod which owns the path
 * @param downloadOptions options for downloading
 */

exports.DIRECTORY_TOKEN = DIRECTORY_TOKEN;

async function getFileMetadata(bee, path, address, downloadOptions) {
  const data = (await (0, _utils3.getRawMetadata)(bee, path, address, downloadOptions)).metadata;
  (0, _utils2.assertRawFileMetadata)(data);
  return (0, _adapter.rawFileMetadataToFileMetadata)(data);
}
/**
 * Downloads file parts and compile them into Data
 *
 * @param bee Bee client
 * @param fullPath full path to the file
 * @param address address of the pod
 * @param downloadOptions download options
 */


async function downloadData(bee, fullPath, address, downloadOptions) {
  const fileMetadata = await getFileMetadata(bee, fullPath, address, downloadOptions);

  if (fileMetadata.compression) {
    // TODO: implement compression support
    throw new Error('Compressed data is not supported yet');
  }

  const blocks = await (0, _utils.downloadBlocksManifest)(bee, fileMetadata.blocksReference, downloadOptions);
  let totalLength = 0;

  for (const block of blocks.blocks) {
    totalLength += block.size;
  }

  const result = new Uint8Array(totalLength);
  let offset = 0;

  for (const block of blocks.blocks) {
    const data = await bee.downloadData(block.reference, downloadOptions);
    result.set(data, offset);
    offset += data.length;
  }

  return (0, _bytes.wrapBytesWithHelpers)(result);
}
/**
 * Generate block name by block number
 */


function generateBlockName(blockNumber) {
  return 'block-' + blockNumber.toString().padStart(5, '0');
}

/***/ }),

/***/ "./src/file/utils.ts":
/*!***************************!*\
  !*** ./src/file/utils.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.assertFullPathWithName = assertFullPathWithName;
exports.base64toReference = base64toReference;
exports.createFileShareInfo = createFileShareInfo;
exports.downloadBlocksManifest = downloadBlocksManifest;
exports.extractPathInfo = extractPathInfo;
exports.referenceToBase64 = referenceToBase64;
exports.uploadBytes = uploadBytes;

var _batch = __webpack_require__(/*! ../utils/batch */ "./src/utils/batch.ts");

var _adapter = __webpack_require__(/*! ./adapter */ "./src/file/adapter.ts");

var _cryptoJs = _interopRequireDefault(__webpack_require__(/*! crypto-js */ "./node_modules/crypto-js/index.js"));

var _type = __webpack_require__(/*! ../utils/type */ "./src/utils/type.ts");

var _hex = __webpack_require__(/*! ../utils/hex */ "./src/utils/hex.ts");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Asserts that full path string is correct
 *
 * @param value full path string
 */
function assertFullPathWithName(value) {
  (0, _type.assertString)(value);

  if (value.length === 0) {
    throw new Error('Path is empty');
  }

  if (value.trim().length !== value.length) {
    throw new Error('Path to contain characters that can be truncated');
  }

  if (value[0] !== '/') {
    throw new Error('Path must start with "/"');
  }

  const exploded = value.split('/');

  if (exploded.length < 2) {
    throw new Error('Path must contain at least one file or directory name');
  }

  exploded.shift();
  const name = exploded.pop();

  if (!name) {
    throw new Error('File or directory name is empty');
  }
}
/**
 * Uploads data to swarm with specific FairOS configuration
 *
 * @param connection Bee connection
 * @param data data to upload
 */


async function uploadBytes(connection, data) {
  return connection.bee.uploadData(await (0, _batch.getBatchId)(connection.beeDebug), data, {
    pin: true,
    encrypt: true
  });
}
/**
 * Extracts filename and path from full path
 *
 * @param fullPath full absolute path with filename
 */


function extractPathInfo(fullPath) {
  assertFullPathWithName(fullPath);
  const exploded = fullPath.split('/');
  const filename = exploded.pop();

  if (!filename) {
    throw new Error('Path must contain a file');
  }

  const path = exploded.join('/');
  return {
    filename,
    path: path ? path : '/'
  };
}
/**
 * Downloads raw FairOS blocks and convert it to FDS blocks
 *
 * @param bee Bee client
 * @param reference blocks Swarm reference
 * @param downloadOptions download options
 */


async function downloadBlocksManifest(bee, reference, downloadOptions) {
  const rawBlocks = (await bee.downloadData(reference, downloadOptions)).json();
  return (0, _adapter.rawBlocksToBlocks)(rawBlocks);
}
/**
 * Converts Base64 string to Swarm Reference
 *
 * @param base64 Reference encoded to Base64
 */


function base64toReference(base64) {
  return _cryptoJs.default.enc.Base64.parse(base64).toString(_cryptoJs.default.enc.Hex);
}
/**
 * Converts Swarm Reference to Base64
 *
 * @param reference Swarm Reference
 */


function referenceToBase64(reference) {
  return _cryptoJs.default.enc.Hex.parse(reference).toString(_cryptoJs.default.enc.Base64);
}
/**
 * Creates file share information structure
 */


function createFileShareInfo(meta, podAddress) {
  return {
    meta,
    source_address: (0, _hex.bytesToHex)(podAddress)
  };
}

/***/ }),

/***/ "./src/pod/api.ts":
/*!************************!*\
  !*** ./src/pod/api.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getExtendedPodsList = getExtendedPodsList;
exports.getPodsList = getPodsList;

var _api = __webpack_require__(/*! ../feed/api */ "./src/feed/api.ts");

var _personalStorage = __webpack_require__(/*! ./personal-storage */ "./src/pod/personal-storage.ts");

var _utils = __webpack_require__(/*! ./utils */ "./src/pod/utils.ts");

var _address = __webpack_require__(/*! ../utils/address */ "./src/utils/address.ts");

var _wallet = __webpack_require__(/*! ../utils/wallet */ "./src/utils/wallet.ts");

/**
 * Gets pods list with lookup answer
 *
 * @param bee Bee instance
 * @param address Ethereum address
 * @param options request options
 */
async function getPodsList(bee, address, options) {
  let lookupAnswer;
  let pods;

  try {
    lookupAnswer = await (0, _api.getFeedData)(bee, _personalStorage.POD_TOPIC, address, options);
    pods = (0, _utils.extractPods)(lookupAnswer.data.chunkContent());
  } catch (e) {
    pods = [];
  }

  return {
    pods,
    lookupAnswer
  };
}
/**
 * Gets pods list with lookup answer and extended info about pod
 *
 * @param bee Bee instance
 * @param podName pod to find
 * @param wallet Ethereum wallet owns the FDP account
 * @param downloadOptions request options
 */


async function getExtendedPodsList(bee, podName, wallet, downloadOptions) {
  const podsInfo = await getPodsList(bee, (0, _address.prepareEthAddress)(wallet.address), downloadOptions);
  const pod = podsInfo.pods.find(item => item.name === podName);

  if (!pod) {
    throw new Error(`Pod "${podName}" does not exist`);
  }

  const podWallet = (0, _wallet.getWalletByIndex)(wallet.privateKey, pod.index);
  return {
    pod,
    podAddress: (0, _address.prepareEthAddress)(podWallet.address),
    podWallet,
    lookupAnswer: podsInfo.lookupAnswer
  };
}

/***/ }),

/***/ "./src/pod/personal-storage.ts":
/*!*************************************!*\
  !*** ./src/pod/personal-storage.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.PersonalStorage = exports.POD_TOPIC = void 0;

var _utils = __webpack_require__(/*! ../account/utils */ "./src/account/utils.ts");

var _api = __webpack_require__(/*! ../feed/api */ "./src/feed/api.ts");

var _utils2 = __webpack_require__(/*! ./utils */ "./src/pod/utils.ts");

var _epoch = __webpack_require__(/*! ../feed/lookup/epoch */ "./src/feed/lookup/epoch.ts");

var _time = __webpack_require__(/*! ../utils/time */ "./src/utils/time.ts");

var _address = __webpack_require__(/*! ../utils/address */ "./src/utils/address.ts");

var _api2 = __webpack_require__(/*! ./api */ "./src/pod/api.ts");

var _wallet = __webpack_require__(/*! ../utils/wallet */ "./src/utils/wallet.ts");

var _handler = __webpack_require__(/*! ../directory/handler */ "./src/directory/handler.ts");

var _utils3 = __webpack_require__(/*! ../file/utils */ "./src/file/utils.ts");

var _bytes = __webpack_require__(/*! ../utils/bytes */ "./src/utils/bytes.ts");

const POD_TOPIC = 'Pods';
exports.POD_TOPIC = POD_TOPIC;

class PersonalStorage {
  constructor(accountData) {
    this.accountData = accountData;
  }
  /**
   * Gets the list of pods for the active account
   *
   * @returns list of pods
   */


  async list() {
    var _this$accountData$con;

    (0, _utils.assertActiveAccount)(this.accountData);
    return (await (0, _api2.getPodsList)(this.accountData.connection.bee, (0, _address.prepareEthAddress)(this.accountData.wallet.address), (_this$accountData$con = this.accountData.connection.options) === null || _this$accountData$con === void 0 ? void 0 : _this$accountData$con.downloadOptions)).pods;
  }
  /**
   * Creates new pod with passed name
   *
   * @param name pod name
   */


  async create(name) {
    var _this$accountData$con2;

    (0, _utils.assertActiveAccount)(this.accountData);
    name = name.trim();
    (0, _utils2.assertPodName)(name);
    const podsInfo = await (0, _api2.getPodsList)(this.accountData.connection.bee, (0, _address.prepareEthAddress)(this.accountData.wallet.address), (_this$accountData$con2 = this.accountData.connection.options) === null || _this$accountData$con2 === void 0 ? void 0 : _this$accountData$con2.downloadOptions);
    const nextIndex = podsInfo.pods.length + 1;
    (0, _utils2.assertPodsLength)(nextIndex);
    (0, _utils2.assertPodNameAvailable)(podsInfo.pods, name);
    let epoch;
    const currentTime = (0, _time.getUnixTimestamp)();

    if (podsInfo.lookupAnswer) {
      epoch = podsInfo.lookupAnswer.epoch.getNextEpoch(currentTime);
    } else {
      epoch = (0, _epoch.getFirstEpoch)(currentTime);
    }

    const newPod = {
      name,
      index: nextIndex
    };
    podsInfo.pods.push(newPod);
    const allPodsData = (0, _utils2.podListToBytes)(podsInfo.pods);
    const wallet = this.accountData.wallet; // create pod

    await (0, _api.writeFeedData)(this.accountData.connection, POD_TOPIC, allPodsData, wallet.privateKey, epoch);
    const podWallet = (0, _wallet.getWalletByIndex)(wallet.privateKey, nextIndex);
    await (0, _handler.createRootDirectory)(this.accountData.connection, podWallet.privateKey);
    return newPod;
  }
  /**
   * Deletes pod with passed name
   *
   * @param name pod name
   */


  async delete(name) {
    var _this$accountData$con3;

    (0, _utils.assertActiveAccount)(this.accountData);
    name = name.trim();
    const podsInfo = await (0, _api2.getPodsList)(this.accountData.connection.bee, (0, _address.prepareEthAddress)(this.accountData.wallet.address), (_this$accountData$con3 = this.accountData.connection.options) === null || _this$accountData$con3 === void 0 ? void 0 : _this$accountData$con3.downloadOptions);
    (0, _utils2.assertPodsLength)(podsInfo.pods.length);
    const pod = podsInfo.pods.find(item => item.name === name);

    if (!pod) {
      throw new Error(`Pod "${name}" does not exist`);
    }

    const podsFiltered = podsInfo.pods.filter(item => item.name !== name);
    const allPodsData = (0, _utils2.podListToBytes)(podsFiltered);
    const wallet = this.accountData.wallet;
    await (0, _api.writeFeedData)(this.accountData.connection, POD_TOPIC, allPodsData, wallet.privateKey, podsInfo.lookupAnswer.epoch.getNextEpoch((0, _time.getUnixTimestamp)()));
  }
  /**
   * Shares pod information
   *
   * @param name pod name
   *
   * @returns swarm reference of shared metadata about pod
   */


  async share(name) {
    var _this$accountData$con4;

    (0, _utils.assertActiveAccount)(this.accountData);
    (0, _utils2.assertPodName)(name);
    const wallet = this.accountData.wallet;
    const podInfo = await (0, _api2.getExtendedPodsList)(this.accountData.connection.bee, name, wallet, (_this$accountData$con4 = this.accountData.connection.options) === null || _this$accountData$con4 === void 0 ? void 0 : _this$accountData$con4.downloadOptions);
    const data = (0, _bytes.stringToBytes)(JSON.stringify((0, _utils2.createPodShareInfo)(name, podInfo.podAddress, (0, _address.prepareEthAddress)(wallet.address))));
    return (await (0, _utils3.uploadBytes)(this.accountData.connection, data)).reference;
  }

}

exports.PersonalStorage = PersonalStorage;

/***/ }),

/***/ "./src/pod/utils.ts":
/*!**************************!*\
  !*** ./src/pod/utils.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.META_VERSION = exports.MAX_POD_NAME_LENGTH = exports.MAX_PODS_COUNT = void 0;
exports.assertPod = assertPod;
exports.assertPodName = assertPodName;
exports.assertPodNameAvailable = assertPodNameAvailable;
exports.assertPods = assertPods;
exports.assertPodsLength = assertPodsLength;
exports.createPodShareInfo = createPodShareInfo;
exports.createRawDirectoryMetadata = createRawDirectoryMetadata;
exports.extractPods = extractPods;
exports.isPod = isPod;
exports.podListToBytes = podListToBytes;

var _bytes = __webpack_require__(/*! ../utils/bytes */ "./src/utils/bytes.ts");

var _adapter = __webpack_require__(/*! ../directory/adapter */ "./src/directory/adapter.ts");

var _type = __webpack_require__(/*! ../utils/type */ "./src/utils/type.ts");

var _hex = __webpack_require__(/*! ../utils/hex */ "./src/utils/hex.ts");

const META_VERSION = 1;
exports.META_VERSION = META_VERSION;
const MAX_PODS_COUNT = 65536;
exports.MAX_PODS_COUNT = MAX_PODS_COUNT;
const MAX_POD_NAME_LENGTH = 25;
/**
 * Information about pods list
 */

exports.MAX_POD_NAME_LENGTH = MAX_POD_NAME_LENGTH;

/**
 * Extracts pod information from raw data
 *
 * @param data raw data with pod information
 */
function extractPods(data) {
  return data.text().split('\n').filter(item => Boolean(item.trim())).map(item => {
    const parts = item.split(',');

    if (parts.length !== 2) {
      throw new Error('Pod information: incorrect length');
    }

    return {
      name: parts[0],
      index: Number(parts[1])
    };
  });
}
/**
 * Creates metadata in bytes format for pod directory
 */


function createRawDirectoryMetadata(version, path, name, creationTime, modificationTime, accessTime, fileOrDirNames) {
  const data = {
    Meta: {
      Version: version,
      Path: path,
      Name: name,
      CreationTime: creationTime,
      ModificationTime: modificationTime,
      AccessTime: accessTime
    },
    FileOrDirNames: fileOrDirNames !== null && fileOrDirNames !== void 0 ? fileOrDirNames : null
  };
  return (0, _adapter.getRawDirectoryMetadataBytes)(data);
}
/**
 * Verifies if pods list length is correct
 *
 * @param value pods list length
 */


function assertPodsLength(value) {
  (0, _type.assertNumber)(value);

  if (value > MAX_PODS_COUNT) {
    throw new Error('The maximum number of pods for the account has been reached');
  }
}
/**
 * Verifies that name not exists in pods list
 *
 * @param value list of pods
 * @param name name of pod
 */


function assertPodNameAvailable(value, name) {
  assertPods(value);
  value.forEach(pod => {
    if (pod.name === name) {
      throw new Error(`Pod with name "${name}" already exists`);
    }
  });
}
/**
 * Asserts that pod name is correct
 */


function assertPodName(value) {
  (0, _type.assertString)(value);

  if (value.length === 0) {
    throw new Error('Pod name is too short');
  } // because FairOS pod info stored as "podname,index" and does not handle comma shielding


  if (value.includes(',')) {
    throw new Error('Pod name cannot contain commas');
  }

  if (value.length > MAX_POD_NAME_LENGTH) {
    throw new Error('Pod name is too long');
  }
}
/**
 * Converts pods list to bytes array
 *
 * @param list list of pods
 */


function podListToBytes(list) {
  assertPods(list);

  if (list.length === 0) {
    return new Uint8Array([0]);
  }

  return (0, _bytes.stringToBytes)(list.map(pod => `${pod.name},${pod.index}`).join('\n') + '\n');
}
/**
 * Pod guard
 */


function isPod(value) {
  const {
    name,
    index
  } = value;
  return typeof value === 'object' && value !== null && (0, _type.isString)(name) && (0, _type.isNumber)(index);
}
/**
 * Asserts that pod is correct
 */


function assertPod(value) {
  if (!isPod(value)) {
    throw new Error('Invalid pod');
  }
}
/**
 * Asserts that pods are correct
 */


function assertPods(value) {
  for (const pod of value) {
    assertPod(pod);
  }
}
/**
 * Creates information for pod sharing
 */


function createPodShareInfo(podName, podAddress, userAddress) {
  return {
    pod_name: podName,
    pod_address: (0, _hex.bytesToHex)(podAddress),
    user_address: (0, _hex.bytesToHex)(userAddress)
  };
}

/***/ }),

/***/ "./src/polyfills/Blob.js":
/*!*******************************!*\
  !*** ./src/polyfills/Blob.js ***!
  \*******************************/
/***/ ((module, exports, __webpack_require__) => {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

/* Blob.js
 * A Blob, File, FileReader & URL implementation.
 * 2020-02-01
 *
 * By Eli Grey, https://eligrey.com
 * By Jimmy Wrting, https://github.com/jimmywarting
 * License: MIT
 *   See https://github.com/eligrey/Blob.js/blob/master/LICENSE.md
 */
;

(function (global) {
  ;

  (function (factory) {
    if (true) {
      // AMD. Register as an anonymous module.
      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else {}
  })(function (exports) {
    'use strict';

    exports.Blob = Blob;
  });
})(typeof self !== 'undefined' && self || typeof window !== 'undefined' && window || typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g || void 0);

/***/ }),

/***/ "./src/shim/crypto.ts":
/*!****************************!*\
  !*** ./src/shim/crypto.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var _crypto = _interopRequireDefault(__webpack_require__(/*! crypto */ "?254c"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const isNode = typeof process !== 'undefined' && process.versions !== null && process.versions.node !== null;

const getRandomValuesNode = array => {
  if (!(array instanceof Uint8Array || array instanceof Uint32Array)) {
    throw new TypeError('Expected Uint8Array or Uint32Array');
  }

  if (array.length > 65536) {
    const e = new Error();
    e.message = `Failed to execute 'getRandomValues' on 'Crypto': The ArrayBufferView's byte length (${array.length}) exceeds the number of bytes of entropy available via this API (65536).`;
    e.name = 'QuotaExceededError';
    throw e;
  }

  const bytes = _crypto.default.randomBytes(array.length);

  array.set(bytes);
  return array;
};

if (isNode && _crypto.default.randomBytes && globalThis) {
  globalThis.crypto = { ...globalThis.crypto,
    getRandomValues: getRandomValuesNode
  };
}

/***/ }),

/***/ "./src/utils/address.ts":
/*!******************************!*\
  !*** ./src/utils/address.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.prepareEthAddress = prepareEthAddress;

var _beeJs = __webpack_require__(/*! @ethersphere/bee-js */ "./node_modules/@ethersphere/bee-js/dist/cjs/index.js");

/**
 * Converts string to Ethereum address in form of bytes
 *
 * @param address Ethereum address for preparation
 */
function prepareEthAddress(address) {
  return _beeJs.Utils.makeEthAddress(address);
}

/***/ }),

/***/ "./src/utils/batch.ts":
/*!****************************!*\
  !*** ./src/utils/batch.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getBatchId = getBatchId;

/**
 * Gets postage batch ID from already created batches
 *
 * @param beeDebug BeeDebug instance for interaction
 */
async function getBatchId(beeDebug) {
  var _batches$pop;

  const batches = await beeDebug.getAllPostageBatch();

  if (batches.length === 0) {
    throw new Error('Postage batch not exists');
  }

  const batchId = (_batches$pop = batches.pop()) === null || _batches$pop === void 0 ? void 0 : _batches$pop.batchID;

  if (!batchId) {
    throw new Error('Incorrect batch id found');
  }

  return batchId;
}

/***/ }),

/***/ "./src/utils/bytes.ts":
/*!****************************!*\
  !*** ./src/utils/bytes.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SPAN_SIZE = void 0;
exports.assertBytes = assertBytes;
exports.assertFlexBytes = assertFlexBytes;
exports.bytesEqual = bytesEqual;
exports.isBytes = isBytes;
exports.longToByteArray = longToByteArray;
exports.makeBytes = makeBytes;
exports.makeSpan = makeSpan;
exports.serializeBytes = serializeBytes;
exports.stringToBytes = stringToBytes;
exports.wrapBytesWithHelpers = wrapBytesWithHelpers;

var _beeJs = __webpack_require__(/*! @ethersphere/bee-js */ "./node_modules/@ethersphere/bee-js/dist/cjs/index.js");

var _hex = __webpack_require__(/*! ./hex */ "./src/utils/hex.ts");

var _error = __webpack_require__(/*! ./error */ "./src/utils/error.ts");

/**
 * Helper type for dealing with fixed size byte arrays.
 *
 * It changes the type of `length` property of `Uint8Array` to the
 * generic `Length` type parameter which is runtime compatible with
 * the original, because it extends from the `number` type.
 */
const SPAN_SIZE = 8; // we limit the maximum span size in 32 bits to avoid BigInt compatibility issues

exports.SPAN_SIZE = SPAN_SIZE;
const MAX_SPAN_LENGTH = 2 ** 32 - 1;
/**
 * Type guard for `Bytes<T>` type
 *
 * @param b       The byte array
 * @param length  The length of the byte array
 */

function isBytes(b, length) {
  return b instanceof Uint8Array && b.length === length;
}
/**
 * Verifies if a byte array has a certain length
 *
 * @param b       The byte array
 * @param length  The specified length
 */


function assertBytes(b, length) {
  if (!isBytes(b, length)) {
    throw new TypeError(`Parameter is not valid Bytes of length: ${length} !== ${b.length}`);
  }
}
/**
 * Returns true if two byte arrays are equal
 *
 * @param a Byte array to compare
 * @param b Byte array to compare
 */


function bytesEqual(a, b) {
  return a.length === b.length && a.every((value, index) => value === b[index]);
}
/**
 * Returns a new byte array filled with zeroes with the specified length
 *
 * @param length The length of data to be returned
 */


function makeBytes(length) {
  return new Uint8Array(length);
}

function wrapBytesWithHelpers(data) {
  return Object.assign(data, {
    text: () => new TextDecoder('utf-8').decode(data),
    json: () => JSON.parse(new TextDecoder('utf-8').decode(data)),
    hex: () => (0, _hex.bytesToHex)(data)
  });
}
/**
 * Converts long number to bytes array
 *
 * @param long long number
 * @returns representing a long as an array of bytes
 */


function longToByteArray(long) {
  const byteArray = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]);

  for (let index = 0; index < byteArray.length; index++) {
    const byte = long & 0xff;
    byteArray[index] = byte;
    long = (long - byte) / 256;
  }

  return byteArray;
}
/**
 * Helper function for serialize byte arrays
 *
 * @param arrays Any number of byte array arguments
 */


function serializeBytes(...arrays) {
  const length = arrays.reduce((prev, curr) => prev + curr.length, 0);
  const buffer = new Uint8Array(length);
  let offset = 0;
  arrays.forEach(arr => {
    buffer.set(arr, offset);
    offset += arr.length;
  });
  return buffer;
}
/**
 * Create a span for storing the length of the chunk
 *
 * The length is encoded in 64-bit little endian.
 *
 * @param length The length of the span
 */


function makeSpan(length) {
  if (length <= 0) {
    throw new _error.BeeArgumentError('invalid length for span', length);
  }

  if (length > MAX_SPAN_LENGTH) {
    throw new _error.BeeArgumentError('invalid length (> MAX_SPAN_LENGTH)', length);
  }

  const span = new Uint8Array(SPAN_SIZE);
  const dataView = new DataView(span.buffer);
  const littleEndian = true;
  const lengthLower32 = length & 0xffffffff;
  dataView.setUint32(0, lengthLower32, littleEndian);
  return span;
}
/**
 * Converts string to bytes array
 *
 * @param data string data
 */


function stringToBytes(data) {
  return new TextEncoder().encode(data);
}

function assertFlexBytes(b, min, max) {
  return _beeJs.Utils.assertFlexBytes(b, min, max);
}

/***/ }),

/***/ "./src/utils/error.ts":
/*!****************************!*\
  !*** ./src/utils/error.ts ***!
  \****************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BeeResponseError = exports.BeeError = exports.BeeArgumentError = void 0;

class BeeError extends Error {
  constructor(message) {
    super(message);
  }

}

exports.BeeError = BeeError;

class BeeArgumentError extends BeeError {
  constructor(message, value) {
    super(message);
    this.value = value;
  }

}

exports.BeeArgumentError = BeeArgumentError;

class BeeResponseError extends BeeError {
  constructor(status, message) {
    super(message);
    this.status = status;
  }

}

exports.BeeResponseError = BeeResponseError;

/***/ }),

/***/ "./src/utils/hex.ts":
/*!**************************!*\
  !*** ./src/utils/hex.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.bytesToHex = bytesToHex;

var _beeJs = __webpack_require__(/*! @ethersphere/bee-js */ "./node_modules/@ethersphere/bee-js/dist/cjs/index.js");

/**
 * Converts array of number or Uint8Array to HexString without prefix.
 *
 * @param bytes   The input array
 * @param len     The length of the non prefixed HexString
 */
function bytesToHex(bytes, len) {
  return _beeJs.Utils.bytesToHex(bytes, len);
}

/***/ }),

/***/ "./src/utils/string.ts":
/*!*****************************!*\
  !*** ./src/utils/string.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.generateRandomBase64String = generateRandomBase64String;
exports.replaceAll = replaceAll;

var _cryptoJs = _interopRequireDefault(__webpack_require__(/*! crypto-js */ "./node_modules/crypto-js/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Replace all occurrences of a string with another string
 *
 * @param data input string
 * @param search string to search for
 * @param replacement string to replace with
 */
function replaceAll(data, search, replacement) {
  return data.replace(new RegExp(search, 'g'), replacement);
}
/**
 * Generate random base64 string with passed length
 */


function generateRandomBase64String(length = 10) {
  return _cryptoJs.default.lib.WordArray.random(length).toString(_cryptoJs.default.enc.Base64).substring(0, length);
}

/***/ }),

/***/ "./src/utils/time.ts":
/*!***************************!*\
  !*** ./src/utils/time.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.assertUnixTimestamp = assertUnixTimestamp;
exports.getUnixTimestamp = getUnixTimestamp;

var _type = __webpack_require__(/*! ./type */ "./src/utils/type.ts");

/**
 * Get unix timestamp in seconds
 */
function getUnixTimestamp() {
  return Math.round(Date.now() / 1000);
}
/**
 * Asserts unix timestamp
 */


function assertUnixTimestamp(timestamp) {
  (0, _type.assertNumber)(timestamp);

  if (timestamp.toString().length > 10) {
    throw new Error('Number is not a unix timestamp');
  }
}

/***/ }),

/***/ "./src/utils/type.ts":
/*!***************************!*\
  !*** ./src/utils/type.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.assertNumber = assertNumber;
exports.assertString = assertString;
exports.isEthAddress = isEthAddress;
exports.isNumber = isNumber;
exports.isObject = isObject;
exports.isString = isString;

var _beeJs = __webpack_require__(/*! @ethersphere/bee-js */ "./node_modules/@ethersphere/bee-js/dist/cjs/index.js");

/**
 * Asserts that the given value is a number
 */
function assertNumber(value) {
  if (!isNumber(value)) {
    throw new Error('Expected a number');
  }
}
/**
 * Asserts that the given value is a string
 */


function assertString(value) {
  if (!isString(value)) {
    throw new Error('Expected a string');
  }
}
/**
 * Checks that value is a valid Ethereum address
 */


function isEthAddress(value) {
  return _beeJs.Utils.isHexString(value) && value.length === 20;
}
/**
 * Checks that value is a string
 */


function isString(value) {
  return typeof value === 'string';
}
/**
 * Checks that value is a number
 */


function isNumber(value) {
  return typeof value === 'number';
}
/**
 * Checks that value is an object
 */
// eslint-disable-next-line @typescript-eslint/ban-types


function isObject(value) {
  return typeof value === 'object';
}

/***/ }),

/***/ "./src/utils/wallet.ts":
/*!*****************************!*\
  !*** ./src/utils/wallet.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getWalletByIndex = getWalletByIndex;

var _ethers = __webpack_require__(/*! ethers */ "./node_modules/ethers/lib.esm/index.js");

/**
 * Get Hierarchal Deterministic Wallet from private key by index
 *
 * @param privateKey private key of Ethereum wallet
 * @param index wallet index
 */
function getWalletByIndex(privateKey, index) {
  const node = _ethers.utils.HDNode.fromSeed(privateKey);

  return node.derivePath(`m/44'/60'/0'/0/${index}`);
}

/***/ }),

/***/ "?0559":
/*!************************!*\
  !*** stream (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?8131":
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?3fc0":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?9157":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "?254c":
/*!************************!*\
  !*** crypto (ignored) ***!
  \************************/
/***/ (() => {

/* (ignored) */

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/bee-debug.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/bee-debug.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BeeDebug = void 0;

const connectivity = __importStar(__webpack_require__(/*! ./modules/debug/connectivity */ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/connectivity.js"));

const balance = __importStar(__webpack_require__(/*! ./modules/debug/balance */ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/balance.js"));

const chequebook = __importStar(__webpack_require__(/*! ./modules/debug/chequebook */ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/chequebook.js"));

const settlements = __importStar(__webpack_require__(/*! ./modules/debug/settlements */ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/settlements.js"));

const status = __importStar(__webpack_require__(/*! ./modules/debug/status */ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/status.js"));

const transactions = __importStar(__webpack_require__(/*! ./modules/debug/transactions */ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/transactions.js"));

const states = __importStar(__webpack_require__(/*! ./modules/debug/states */ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/states.js"));

const error_1 = __webpack_require__(/*! ./utils/error */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/error.js");

const url_1 = __webpack_require__(/*! ./utils/url */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/url.js");

const type_1 = __webpack_require__(/*! ./utils/type */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/type.js");

const types_1 = __webpack_require__(/*! ./types */ "./node_modules/@ethersphere/bee-js/dist/cjs/types/index.js");

const tag = __importStar(__webpack_require__(/*! ./modules/debug/tag */ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/tag.js"));

const stamps = __importStar(__webpack_require__(/*! ./modules/debug/stamps */ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/stamps.js"));

const http_1 = __webpack_require__(/*! ./utils/http */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/http.js");

class BeeDebug {
  constructor(url, options) {
    var _a;

    (0, url_1.assertBeeUrl)(url); // Remove last slash if present, as our endpoint strings starts with `/...`
    // which could lead to double slash in URL to which Bee responds with
    // unnecessary redirects.

    this.url = (0, url_1.stripLastSlash)(url);
    const kyOptions = {
      prefixUrl: this.url,
      timeout: (_a = options === null || options === void 0 ? void 0 : options.timeout) !== null && _a !== void 0 ? _a : false,
      retry: options === null || options === void 0 ? void 0 : options.retry,
      fetch: options === null || options === void 0 ? void 0 : options.fetch,
      hooks: {
        beforeRequest: [],
        afterResponse: []
      }
    };

    if (options === null || options === void 0 ? void 0 : options.defaultHeaders) {
      kyOptions.headers = options.defaultHeaders;
    }

    if (options === null || options === void 0 ? void 0 : options.onRequest) {
      kyOptions.hooks.beforeRequest.push((0, http_1.wrapRequestClosure)(options.onRequest));
    }

    if (options === null || options === void 0 ? void 0 : options.onResponse) {
      kyOptions.hooks.afterResponse.push((0, http_1.wrapResponseClosure)(options.onResponse));
    }

    this.ky = (0, http_1.makeDefaultKy)(kyOptions);
  }

  getNodeAddresses(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      return connectivity.getNodeAddresses(this.getKy(options));
    });
  }

  getBlocklist(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      return connectivity.getBlocklist(this.getKy(options));
    });
  }
  /**
   * Retrieve tag extended information from Bee node
   *
   * @param tagUid UID or tag object to be retrieved
   * @throws TypeError if tagUid is in not correct format
   *
   * @see [Bee docs - Syncing / Tags](https://docs.ethswarm.org/docs/access-the-swarm/syncing)
   * @see [Bee API reference - `GET /tags/{uid}`](https://docs.ethswarm.org/debug-api/#tag/Tag)
   *
   */


  retrieveExtendedTag(tagUid, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);

      if ((0, type_1.isTag)(tagUid)) {
        tagUid = tagUid.uid;
      } else if (typeof tagUid === 'number') {
        (0, type_1.assertNonNegativeInteger)(tagUid, 'UID');
      } else {
        throw new TypeError('tagUid has to be either Tag or a number (UID)!');
      }

      return tag.retrieveExtendedTag(this.getKy(options), tagUid);
    });
  }
  /**
   * Get list of peers for this node
   */


  getPeers(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      return connectivity.getPeers(this.getKy(options));
    });
  }

  removePeer(peer, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      (0, type_1.assertAddress)(peer);
      return connectivity.removePeer(this.getKy(options), peer);
    });
  }

  getTopology(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      return connectivity.getTopology(this.getKy(options));
    });
  }

  pingPeer(peer, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      (0, type_1.assertAddress)(peer);
      return connectivity.pingPeer(this.getKy(options), peer);
    });
  }
  /*
   * Balance endpoints
   */

  /**
   * Get the balances with all known peers including prepaid services
   */


  getAllBalances(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      return balance.getAllBalances(this.getKy(options));
    });
  }
  /**
   * Get the balances with a specific peer including prepaid services
   *
   * @param address Swarm address of peer
   */


  getPeerBalance(address, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      (0, type_1.assertAddress)(address);
      return balance.getPeerBalance(this.getKy(options), address);
    });
  }
  /**
   * Get the past due consumption balances with all known peers
   */


  getPastDueConsumptionBalances(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      return balance.getPastDueConsumptionBalances(this.getKy(options));
    });
  }
  /**
   * Get the past due consumption balance with a specific peer
   *
   * @param address Swarm address of peer
   */


  getPastDueConsumptionPeerBalance(address, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      (0, type_1.assertAddress)(address);
      return balance.getPastDueConsumptionPeerBalance(this.getKy(options), address);
    });
  }
  /*
   * Chequebook endpoints
   */

  /**
   * Get the address of the chequebook contract used.
   *
   * **Warning:** The address is returned with 0x prefix unlike all other calls.
   * https://github.com/ethersphere/bee/issues/1443
   */


  getChequebookAddress(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      return chequebook.getChequebookAddress(this.getKy(options));
    });
  }
  /**
   * Get the balance of the chequebook
   */


  getChequebookBalance(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      return chequebook.getChequebookBalance(this.getKy(options));
    });
  }
  /**
   * Get last cheques for all peers
   */


  getLastCheques(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      return chequebook.getLastCheques(this.getKy(options));
    });
  }
  /**
   * Get last cheques for the peer
   *
   * @param address  Swarm address of peer
   */


  getLastChequesForPeer(address, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      (0, type_1.assertAddress)(address);
      return chequebook.getLastChequesForPeer(this.getKy(options), address);
    });
  }
  /**
   * Get last cashout action for the peer
   *
   * @param address  Swarm address of peer
   */


  getLastCashoutAction(address, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      (0, type_1.assertAddress)(address);
      return chequebook.getLastCashoutAction(this.getKy(options), address);
    });
  }
  /**
   * Cashout the last cheque for the peer
   *
   * @param address  Swarm address of peer
   * @param options
   * @param options.gasPrice Gas price for the cashout transaction in WEI
   * @param options.gasLimit Gas limit for the cashout transaction in WEI
   */


  cashoutLastCheque(address, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertCashoutOptions)(options);
      (0, type_1.assertAddress)(address);
      return chequebook.cashoutLastCheque(this.getKy(options), address, options);
    });
  }
  /**
   * Deposit tokens from overlay address into chequebook
   *
   * @param amount  Amount of tokens to deposit (must be positive integer)
   * @param gasPrice Gas Price in WEI for the transaction call
   * @return string  Hash of the transaction
   */


  depositTokens(amount, gasPrice, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      (0, type_1.assertNonNegativeInteger)(amount);

      if (gasPrice) {
        (0, type_1.assertNonNegativeInteger)(gasPrice);
      }

      return chequebook.depositTokens(this.getKy(options), amount, gasPrice);
    });
  }
  /**
   * Withdraw tokens from the chequebook to the overlay address
   *
   * @param amount  Amount of tokens to withdraw (must be positive integer)
   * @param gasPrice Gas Price in WEI for the transaction call
   * @return string  Hash of the transaction
   */


  withdrawTokens(amount, gasPrice, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      (0, type_1.assertNonNegativeInteger)(amount);

      if (gasPrice) {
        (0, type_1.assertNonNegativeInteger)(gasPrice);
      }

      return chequebook.withdrawTokens(this.getKy(options), amount, gasPrice);
    });
  }
  /*
   * Settlements endpoint
   */

  /**
   * Get amount of sent and received from settlements with a peer
   *
   * @param address  Swarm address of peer
   */


  getSettlements(address, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      (0, type_1.assertAddress)(address);
      return settlements.getSettlements(this.getKy(options), address);
    });
  }
  /**
   * Get settlements with all known peers and total amount sent or received
   */


  getAllSettlements(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      return settlements.getAllSettlements(this.getKy(options));
    });
  }
  /**
   * Get health of node
   */


  getHealth(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      return status.getHealth(this.getKy(options));
    });
  }
  /**
   * Get mode information of node
   */


  getNodeInfo(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      return status.getNodeInfo(this.getKy(options));
    });
  }
  /**
   * Connnects to a node and checks if it is a supported Bee version by the bee-js
   *
   * @returns true if the Bee node version is supported
   * @deprecated Use `BeeDebug.isSupportedExactVersion()` instead
   */


  isSupportedVersion(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      return status.isSupportedVersion(this.getKy(options));
    });
  }
  /**
   * Connects to a node and checks if its version matches with the one that bee-js supports.
   *
   * Be aware that this is the most strict version check and most probably
   * you will want to use more relaxed API-versions based checks like
   * `BeeDebug.isSupportedApiVersion()`, `BeeDebug.isSupportedMainApiVersion()` or `BeeDebug.isSupportedDebugApiVersion()`
   * based on your use-case.
   *
   * @param options
   */


  isSupportedExactVersion(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      return status.isSupportedExactVersion(this.getKy(options));
    });
  }
  /**
   * Connects to a node and checks if its main's API version matches with the one that bee-js supports.
   *
   * This is useful if you are not using `BeeDebug` class (for anything else then this check)
   * and want to make sure about compatibility.
   *
   * @param options
   */


  isSupportedMainApiVersion(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      return status.isSupportedMainApiVersion(this.getKy(options));
    });
  }
  /**
   * Connects to a node and checks if its Debug API version matches with the one that bee-js supports.
   *
   * This is useful if you are not using `Bee` class in your application and want to make sure
   * about compatibility.
   *
   * @param options
   */


  isSupportedDebugApiVersion(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      return status.isSupportedDebugApiVersion(this.getKy(options));
    });
  }
  /**
   *
   * Connects to a node and checks if its Main and Debug API versions matches with the one that bee-js supports.
   *
   * This should be the main way how to check compatibility for your app and Bee node.
   *
   * @param options
   */


  isSupportedApiVersion(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      return status.isSupportedDebugApiVersion(this.getKy(options));
    });
  }
  /**
   * Returns object with all versions specified by the connected Bee node (properties prefixed with `bee*`)
   * and versions that bee-js supports (properties prefixed with `supported*`).
   *
   * @param options
   */


  getVersions(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      return status.getVersions(this.getKy(options));
    });
  }
  /**
   * Get reserve state
   */


  getReserveState(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      return states.getReserveState(this.getKy(options));
    });
  }
  /**
   * Get chain state
   */


  getChainState(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      return states.getChainState(this.getKy(options));
    });
  }
  /**
   * Creates new postage batch from the funds that the node has available in its Ethereum account.
   *
   * For better understanding what each parameter means and what are the optimal values please see
   * [Bee docs - Keep your data alive / Postage stamps](https://docs.ethswarm.org/docs/access-the-swarm/keep-your-data-alive).
   *
   * **WARNING: THIS CREATES TRANSACTIONS THAT SPENDS MONEY**
   *
   * @param amount Amount that represents the value per chunk, has to be greater or equal zero.
   * @param depth Logarithm of the number of chunks that can be stamped with the batch.
   * @param options Options for creation of postage batch
   * @throws BeeArgumentError when negative amount or depth is specified
   * @throws TypeError if non-integer value is passed to amount or depth
   *
   * @see [Bee docs - Keep your data alive / Postage stamps](https://docs.ethswarm.org/docs/access-the-swarm/keep-your-data-alive)
   * @see [Bee Debug API reference - `POST /stamps`](https://docs.ethswarm.org/debug-api/#tag/Postage-Stamps/paths/~1stamps~1{amount}~1{depth}/post)
   */


  createPostageBatch(amount, depth, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      (0, type_1.assertNonNegativeInteger)(amount);
      (0, type_1.assertNonNegativeInteger)(depth);

      if (depth < types_1.STAMPS_DEPTH_MIN) {
        throw new error_1.BeeArgumentError(`Depth has to be at least ${types_1.STAMPS_DEPTH_MIN}`, depth);
      }

      if (depth > types_1.STAMPS_DEPTH_MAX) {
        throw new error_1.BeeArgumentError(`Depth has to be at most ${types_1.STAMPS_DEPTH_MAX}`, depth);
      }

      if (options === null || options === void 0 ? void 0 : options.gasPrice) {
        (0, type_1.assertNonNegativeInteger)(options.gasPrice);
      }

      if ((options === null || options === void 0 ? void 0 : options.immutableFlag) !== undefined) {
        (0, type_1.assertBoolean)(options.immutableFlag);
      }

      return stamps.createPostageBatch(this.getKy(options), amount, depth, options);
    });
  }
  /**
   * Topup a fresh amount of BZZ to given Postage Batch.
   *
   * For better understanding what each parameter means and what are the optimal values please see
   * [Bee docs - Keep your data alive / Postage stamps](https://docs.ethswarm.org/docs/access-the-swarm/keep-your-data-alive).
   *
   * **WARNING: THIS CREATES TRANSACTIONS THAT SPENDS MONEY**
   *
   * @param postageBatchId Batch ID
   * @param amount Amount to be added to the batch
   * @param options Request options
   *
   * @see [Bee docs - Keep your data alive / Postage stamps](https://docs.ethswarm.org/docs/access-the-swarm/keep-your-data-alive)
   * @see [Bee Debug API reference - `PATCH /stamps/topup/${id}/${amount}`](https://docs.ethswarm.org/debug-api/#tag/Postage-Stamps/paths/~1stamps~1topup~1{id}~1{amount}/patch)
   */


  topUpBatch(postageBatchId, amount, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      (0, type_1.assertNonNegativeInteger)(amount, 'Amount');
      (0, type_1.assertBatchId)(postageBatchId);
      yield stamps.topUpBatch(this.getKy(options), postageBatchId, amount);
    });
  }
  /**
   * Dilute given Postage Batch with new depth (that has to be bigger then the original depth), which allows
   * the Postage Batch to be used for more chunks.
   *
   * For better understanding what each parameter means and what are the optimal values please see
   * [Bee docs - Keep your data alive / Postage stamps](https://docs.ethswarm.org/docs/access-the-swarm/keep-your-data-alive).
   *
   * **WARNING: THIS CREATES TRANSACTIONS THAT SPENDS MONEY**
   *
   * @param postageBatchId Batch ID
   * @param depth Amount to be added to the batch
   * @param options Request options
   *
   * @see [Bee docs - Keep your data alive / Postage stamps](https://docs.ethswarm.org/docs/access-the-swarm/keep-your-data-alive)
   * @see [Bee Debug API reference - `PATCH /stamps/topup/${id}/${amount}`](https://docs.ethswarm.org/debug-api/#tag/Postage-Stamps/paths/~1stamps~1topup~1{id}~1{amount}/patch)
   */


  diluteBatch(postageBatchId, depth, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      (0, type_1.assertNonNegativeInteger)(depth, 'Depth');
      (0, type_1.assertBatchId)(postageBatchId);
      yield stamps.diluteBatch(this.getKy(options), postageBatchId, depth);
    });
  }
  /**
   * Return details for specific postage batch.
   *
   * @param postageBatchId Batch ID
   *
   * @see [Bee docs - Keep your data alive / Postage stamps](https://docs.ethswarm.org/docs/access-the-swarm/keep-your-data-alive)
   * @see [Bee Debug API reference - `GET /stamps/${id}`](https://docs.ethswarm.org/debug-api/#tag/Postage-Stamps/paths/~1stamps~1{id}/get)
   */


  getPostageBatch(postageBatchId, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      (0, type_1.assertBatchId)(postageBatchId);
      return stamps.getPostageBatch(this.getKy(options), postageBatchId);
    });
  }
  /**
   * Return detailed information related to buckets for specific postage batch.
   *
   * @param postageBatchId Batch ID
   *
   * @see [Bee docs - Keep your data alive / Postage stamps](https://docs.ethswarm.org/docs/access-the-swarm/keep-your-data-alive)
   * @see [Bee Debug API reference - `GET /stamps/${id}/buckets`](https://docs.ethswarm.org/debug-api/#tag/Postage-Stamps/paths/~1stamps~1{id}~1buckets/get)
   */


  getPostageBatchBuckets(postageBatchId, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      (0, type_1.assertBatchId)(postageBatchId);
      return stamps.getPostageBatchBuckets(this.getKy(options), postageBatchId);
    });
  }
  /**
   * Return all postage batches that has the node available.
   *
   * @see [Bee docs - Keep your data alive / Postage stamps](https://docs.ethswarm.org/docs/access-the-swarm/keep-your-data-alive)
   * @see [Bee Debug API reference - `GET /stamps`](https://docs.ethswarm.org/debug-api/#tag/Postage-Stamps/paths/~1stamps/get)
   */


  getAllPostageBatch(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      return stamps.getAllPostageBatches(this.getKy(options));
    });
  }
  /**
   * Return lists of all current pending transactions that the Bee made
   */


  getAllPendingTransactions(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      return transactions.getAllTransactions(this.getKy(options));
    });
  }
  /**
   * Return transaction information for specific transaction
   * @param transactionHash
   */


  getPendingTransaction(transactionHash, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      (0, type_1.assertTransactionHash)(transactionHash);
      return transactions.getTransaction(this.getKy(options), transactionHash);
    });
  }
  /**
   * Rebroadcast already created transaction.
   * This is mainly needed when your transaction fall off mempool from other reason is not incorporated into block.
   *
   * @param transactionHash
   */


  rebroadcastPendingTransaction(transactionHash, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      (0, type_1.assertTransactionHash)(transactionHash);
      return transactions.rebroadcastTransaction(this.getKy(options), transactionHash);
    });
  }
  /**
   * Cancel currently pending transaction
   * @param transactionHash
   * @param gasPrice
   */


  cancelPendingTransaction(transactionHash, gasPrice, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_1.assertRequestOptions)(options);
      (0, type_1.assertTransactionHash)(transactionHash);

      if (gasPrice) {
        (0, type_1.assertNonNegativeInteger)(gasPrice);
      }

      return transactions.cancelTransaction(this.getKy(options), transactionHash, gasPrice);
    });
  }

  getKy(options) {
    if (!options) {
      return this.ky;
    }

    return this.ky.extend(options);
  }

}

exports.BeeDebug = BeeDebug;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/bee.js":
/*!**********************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/bee.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Bee = void 0;

const bzz = __importStar(__webpack_require__(/*! ./modules/bzz */ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/bzz.js"));

const stewardship = __importStar(__webpack_require__(/*! ./modules/stewardship */ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/stewardship.js"));

const tag = __importStar(__webpack_require__(/*! ./modules/tag */ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/tag.js"));

const pinning = __importStar(__webpack_require__(/*! ./modules/pinning */ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/pinning.js"));

const bytes = __importStar(__webpack_require__(/*! ./modules/bytes */ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/bytes.js"));

const chunk = __importStar(__webpack_require__(/*! ./modules/chunk */ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/chunk.js"));

const pss = __importStar(__webpack_require__(/*! ./modules/pss */ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/pss.js"));

const status = __importStar(__webpack_require__(/*! ./modules/status */ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/status.js"));

const error_1 = __webpack_require__(/*! ./utils/error */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/error.js");

const data_1 = __webpack_require__(/*! ./utils/data */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/data.browser.js");

const file_1 = __webpack_require__(/*! ./utils/file */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/file.js");

const feed_1 = __webpack_require__(/*! ./feed */ "./node_modules/@ethersphere/bee-js/dist/cjs/feed/index.js");

const signer_1 = __webpack_require__(/*! ./chunk/signer */ "./node_modules/@ethersphere/bee-js/dist/cjs/chunk/signer.js");

const type_1 = __webpack_require__(/*! ./feed/type */ "./node_modules/@ethersphere/bee-js/dist/cjs/feed/type.js");

const soc_1 = __webpack_require__(/*! ./chunk/soc */ "./node_modules/@ethersphere/bee-js/dist/cjs/chunk/soc.js");

const topic_1 = __webpack_require__(/*! ./feed/topic */ "./node_modules/@ethersphere/bee-js/dist/cjs/feed/topic.js");

const feed_2 = __webpack_require__(/*! ./modules/feed */ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/feed.js");

const url_1 = __webpack_require__(/*! ./utils/url */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/url.js");

const eth_1 = __webpack_require__(/*! ./utils/eth */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/eth.js");

const bytes_1 = __webpack_require__(/*! ./utils/bytes */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/bytes.js");

const type_2 = __webpack_require__(/*! ./utils/type */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/type.js");

const json_1 = __webpack_require__(/*! ./feed/json */ "./node_modules/@ethersphere/bee-js/dist/cjs/feed/json.js");

const collection_1 = __webpack_require__(/*! ./utils/collection */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/collection.js");

const collection_node_1 = __webpack_require__(/*! ./utils/collection.node */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/collection.browser.js");

const types_1 = __webpack_require__(/*! ./types */ "./node_modules/@ethersphere/bee-js/dist/cjs/types/index.js");

const http_1 = __webpack_require__(/*! ./utils/http */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/http.js");

const stream_1 = __webpack_require__(/*! ./utils/stream */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/stream.js");
/**
 * The main component that abstracts operations available on the main Bee API.
 *
 * Not all methods are always available as it depends in what mode is Bee node launched in.
 * For example gateway mode and light node mode has only limited set of endpoints enabled.
 */


class Bee {
  /**
   * @param url URL on which is the main API of Bee node exposed
   * @param options
   */
  constructor(url, options) {
    var _a;

    (0, url_1.assertBeeUrl)(url); // Remove last slash if present, as our endpoint strings starts with `/...`
    // which could lead to double slash in URL to which Bee responds with
    // unnecessary redirects.

    this.url = (0, url_1.stripLastSlash)(url);

    if (options === null || options === void 0 ? void 0 : options.signer) {
      this.signer = (0, signer_1.makeSigner)(options.signer);
    }

    const kyOptions = {
      prefixUrl: this.url,
      timeout: (_a = options === null || options === void 0 ? void 0 : options.timeout) !== null && _a !== void 0 ? _a : false,
      retry: options === null || options === void 0 ? void 0 : options.retry,
      fetch: options === null || options === void 0 ? void 0 : options.fetch,
      hooks: {
        beforeRequest: [],
        afterResponse: []
      }
    };

    if (options === null || options === void 0 ? void 0 : options.defaultHeaders) {
      kyOptions.headers = options.defaultHeaders;
    }

    if (options === null || options === void 0 ? void 0 : options.onRequest) {
      kyOptions.hooks.beforeRequest.push((0, http_1.wrapRequestClosure)(options.onRequest));
    }

    if (options === null || options === void 0 ? void 0 : options.onResponse) {
      kyOptions.hooks.afterResponse.push((0, http_1.wrapResponseClosure)(options.onResponse));
    }

    this.ky = (0, http_1.makeDefaultKy)(kyOptions);
  }
  /**
   * Upload data to a Bee node
   *
   * @param postageBatchId Postage BatchId to be used to upload the data with
   * @param data    Data to be uploaded
   * @param options Additional options like tag, encryption, pinning, content-type and request options
   *
   * @returns reference is a content hash of the data
   * @see [Bee docs - Upload and download](https://docs.ethswarm.org/docs/access-the-swarm/upload-and-download)
   * @see [Bee API reference - `POST /bytes`](https://docs.ethswarm.org/api/#tag/Bytes/paths/~1bytes/post)
   */


  uploadData(postageBatchId, data, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertBatchId)(postageBatchId);
      (0, type_2.assertData)(data);
      if (options) (0, type_2.assertUploadOptions)(options);
      return bytes.upload(this.getKy(options), data, postageBatchId, options);
    });
  }
  /**
   * Download data as a byte array
   *
   * @param reference Bee data reference
   * @param options Options that affects the request behavior
   * @see [Bee docs - Upload and download](https://docs.ethswarm.org/docs/access-the-swarm/upload-and-download)
   * @see [Bee API reference - `GET /bytes`](https://docs.ethswarm.org/api/#tag/Bytes/paths/~1bytes~1{reference}/get)
   */


  downloadData(reference, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertRequestOptions)(options);
      (0, type_2.assertReference)(reference);
      return bytes.download(this.getKy(options), reference);
    });
  }
  /**
   * Download data as a Readable stream
   *
   * @param reference Bee data reference
   * @param options Options that affects the request behavior
   * @see [Bee docs - Upload and download](https://docs.ethswarm.org/docs/access-the-swarm/upload-and-download)
   * @see [Bee API reference - `GET /bytes`](https://docs.ethswarm.org/api/#tag/Bytes/paths/~1bytes~1{reference}/get)
   */


  downloadReadableData(reference, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertRequestOptions)(options);
      (0, type_2.assertReference)(reference);
      return bytes.downloadReadable(this.getKy(options), reference);
    });
  }
  /**
   * Upload chunk to a Bee node
   *
   * @param postageBatchId Postage BatchId to be used to upload the chunk with
   * @param data    Raw chunk to be uploaded
   * @param options Additional options like tag, encryption, pinning, content-type and request options
   *
   * @returns reference is a content hash of the data
   * @see [Bee docs - Upload and download](https://docs.ethswarm.org/docs/access-the-swarm/upload-and-download)
   * @see [Bee API reference - `POST /chunks`](https://docs.ethswarm.org/api/#tag/Chunk/paths/~1chunks/post)
   */


  uploadChunk(postageBatchId, data, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertBatchId)(postageBatchId);

      if (!(data instanceof Uint8Array)) {
        throw new TypeError('Data has to be Uint8Array instance!');
      }

      if (data.length < types_1.SPAN_SIZE) {
        throw new error_1.BeeArgumentError(`Chunk has to have size of at least ${types_1.SPAN_SIZE}.`, data);
      }

      if (data.length > types_1.CHUNK_SIZE + types_1.SPAN_SIZE) {
        throw new error_1.BeeArgumentError(`Chunk has to have size of at most ${types_1.CHUNK_SIZE}.`, data);
      }

      if (options) (0, type_2.assertUploadOptions)(options);
      return chunk.upload(this.getKy(options), data, postageBatchId, options);
    });
  }
  /**
   * Download chunk as a byte array
   *
   * @param reference Bee chunk reference
   * @param options Options that affects the request behavior
   * @see [Bee docs - Upload and download](https://docs.ethswarm.org/docs/access-the-swarm/upload-and-download)
   * @see [Bee API reference - `GET /chunks`](https://docs.ethswarm.org/api/#tag/Chunk/paths/~1chunks~1{reference}/get)
   */


  downloadChunk(reference, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertRequestOptions)(options);
      (0, type_2.assertReference)(reference);
      return chunk.download(this.getKy(options), reference);
    });
  }
  /**
   * Upload single file to a Bee node.
   *
   * **To make sure that you won't loose critical data it is highly recommended to also
   * locally pin the data with `options.pin = true`**
   *
   * @param postageBatchId Postage BatchId to be used to upload the data with
   * @param data    Data or file to be uploaded
   * @param name    Optional name of the uploaded file
   * @param options Additional options like tag, encryption, pinning, content-type and request options
   *
   * @see [Bee docs - Keep your data alive / Postage stamps](https://docs.ethswarm.org/docs/access-the-swarm/keep-your-data-alive)
   * @see [Bee docs - Upload and download](https://docs.ethswarm.org/docs/access-the-swarm/upload-and-download)
   * @see [Bee API reference - `POST /bzz`](https://docs.ethswarm.org/api/#tag/File/paths/~1bzz/post)
   * @returns reference is a content hash of the file
   */


  uploadFile(postageBatchId, data, name, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertBatchId)(postageBatchId);
      (0, type_2.assertFileData)(data);
      if (options) (0, type_2.assertFileUploadOptions)(options);

      if (name && typeof name !== 'string') {
        throw new TypeError('name has to be string or undefined!');
      }

      if ((0, file_1.isFile)(data)) {
        const fileData = yield (0, file_1.fileArrayBuffer)(data);
        const fileName = name !== null && name !== void 0 ? name : data.name;
        const contentType = data.type;
        const fileOptions = Object.assign({
          contentType
        }, options);
        return bzz.uploadFile(this.getKy(options), fileData, postageBatchId, fileName, fileOptions);
      } else if ((0, stream_1.isReadable)(data) && (options === null || options === void 0 ? void 0 : options.tag) && !options.size) {
        // TODO: Needed until https://github.com/ethersphere/bee/issues/2317 is resolved
        const result = yield bzz.uploadFile(this.getKy(options), data, postageBatchId, name, options);
        yield this.updateTag(options.tag, result.reference);
        return result;
      } else {
        return bzz.uploadFile(this.getKy(options), data, postageBatchId, name, options);
      }
    });
  }
  /**
   * Download single file.
   *
   * @param reference Bee file reference
   * @param path If reference points to manifest, then this parameter defines path to the file
   * @param options Options that affects the request behavior
   *
   * @see Data
   * @see [Bee docs - Upload and download](https://docs.ethswarm.org/docs/access-the-swarm/upload-and-download)
   * @see [Bee API reference - `GET /bzz`](https://docs.ethswarm.org/api/#tag/Collection/paths/~1bzz~1{reference}~1{path}/get)
   */


  downloadFile(reference, path = '', options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertRequestOptions)(options);
      (0, type_2.assertReference)(reference);
      return bzz.downloadFile(this.getKy(options), reference, path);
    });
  }
  /**
   * Download single file as a readable stream
   *
   * @param reference Hash reference to file
   * @param path If reference points to manifest / collections, then this parameter defines path to the file
   * @param options Options that affects the request behavior
   *
   * @see [Bee docs - Upload and download](https://docs.ethswarm.org/docs/access-the-swarm/upload-and-download)
   * @see [Bee API reference - `GET /bzz`](https://docs.ethswarm.org/api/#tag/Collection/paths/~1bzz~1{reference}~1{path}/get)
   */


  downloadReadableFile(reference, path = '', options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertRequestOptions)(options);
      (0, type_2.assertReference)(reference);
      return bzz.downloadFileReadable(this.getKy(options), reference, path);
    });
  }
  /**
   * Upload collection of files to a Bee node
   *
   * Uses the FileList API from the browser.
   *
   * The returned `UploadResult.tag` might be undefined if called in CORS-enabled environment.
   * This will be fixed upon next Bee release. https://github.com/ethersphere/bee-js/issues/406
   *
   * @param postageBatchId Postage BatchId to be used to upload the data with
   * @param fileList list of files to be uploaded
   * @param options Additional options like tag, encryption, pinning and request options
   *
   * @see [Bee docs - Keep your data alive / Postage stamps](https://docs.ethswarm.org/docs/access-the-swarm/keep-your-data-alive)
   * @see [Bee docs - Upload directory](https://docs.ethswarm.org/docs/access-the-swarm/upload-a-directory/)
   * @see [Bee API reference - `POST /bzz`](https://docs.ethswarm.org/api/#tag/Collection/paths/~1bzz/post)
   */


  uploadFiles(postageBatchId, fileList, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertBatchId)(postageBatchId);
      if (options) (0, type_2.assertCollectionUploadOptions)(options);
      const data = yield (0, collection_1.makeCollectionFromFileList)(fileList);
      return bzz.uploadCollection(this.getKy(options), data, postageBatchId, options);
    });
  }
  /**
   * Upload Collection that you can assembly yourself.
   *
   * The returned `UploadResult.tag` might be undefined if called in CORS-enabled environment.
   * This will be fixed upon next Bee release. https://github.com/ethersphere/bee-js/issues/406
   *
   * @param postageBatchId
   * @param collection
   * @param options Collections and request options
   */


  uploadCollection(postageBatchId, collection, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertBatchId)(postageBatchId);
      (0, collection_1.assertCollection)(collection);
      if (options) (0, type_2.assertCollectionUploadOptions)(options);
      return bzz.uploadCollection(this.ky, collection, postageBatchId, options);
    });
  }
  /**
   * Upload collection of files.
   *
   * Available only in Node.js as it uses the `fs` module.
   *
   * The returned `UploadResult.tag` might be undefined if called in CORS-enabled environment.
   * This will be fixed upon next Bee release. https://github.com/ethersphere/bee-js/issues/406
   *
   * @param postageBatchId Postage BatchId to be used to upload the data with
   * @param dir the path of the files to be uploaded
   * @param options Additional options like tag, encryption, pinning and request options
   *
   * @see [Bee docs - Keep your data alive / Postage stamps](https://docs.ethswarm.org/docs/access-the-swarm/keep-your-data-alive)
   * @see [Bee docs - Upload directory](https://docs.ethswarm.org/docs/access-the-swarm/upload-a-directory/)
   * @see [Bee API reference - `POST /bzz`](https://docs.ethswarm.org/api/#tag/Collection/paths/~1bzz/post)
   */


  uploadFilesFromDirectory(postageBatchId, dir, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertBatchId)(postageBatchId);
      if (options) (0, type_2.assertCollectionUploadOptions)(options);
      const data = yield (0, collection_node_1.makeCollectionFromFS)(dir);
      return bzz.uploadCollection(this.getKy(options), data, postageBatchId, options);
    });
  }
  /**
   * Create a new Tag which is meant for tracking progres of syncing data across network.
   *
   * **Warning! Not allowed when node is in Gateway mode!**
   *
   * @param options Options that affects the request behavior
   * @see [Bee docs - Syncing / Tags](https://docs.ethswarm.org/docs/access-the-swarm/syncing)
   * @see [Bee API reference - `POST /tags`](https://docs.ethswarm.org/api/#tag/Tag/paths/~1tags/post)
   */


  createTag(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertRequestOptions)(options);
      return tag.createTag(this.getKy(options));
    });
  }
  /**
   * Fetches all tags.
   *
   * The listing is limited by options.limit. So you have to iterate using options.offset to get all tags.
   *
   * **Warning! Not allowed when node is in Gateway mode!**
   *
   * @param options Options that affects the request behavior
   * @throws TypeError if limit or offset are not numbers or undefined
   * @throws BeeArgumentError if limit or offset have invalid options
   *
   * @see [Bee docs - Syncing / Tags](https://docs.ethswarm.org/docs/access-the-swarm/syncing)
   * @see [Bee API reference - `GET /tags`](https://docs.ethswarm.org/api/#tag/Tag/paths/~1tags/get)
   */


  getAllTags(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertRequestOptions)(options);
      (0, type_2.assertAllTagsOptions)(options);
      return tag.getAllTags(this.getKy(options), options === null || options === void 0 ? void 0 : options.offset, options === null || options === void 0 ? void 0 : options.limit);
    });
  }
  /**
   * Retrieve tag information from Bee node
   *
   * **Warning! Not allowed when node is in Gateway mode!**
   *
   * @param tagUid UID or tag object to be retrieved
   * @param options Options that affects the request behavior
   * @throws TypeError if tagUid is in not correct format
   *
   * @see [Bee docs - Syncing / Tags](https://docs.ethswarm.org/docs/access-the-swarm/syncing)
   * @see [Bee API reference - `GET /tags/{uid}`](https://docs.ethswarm.org/api/#tag/Tag/paths/~1tags~1{uid}/get)
   *
   */


  retrieveTag(tagUid, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertRequestOptions)(options);
      tagUid = (0, type_2.makeTagUid)(tagUid);
      return tag.retrieveTag(this.getKy(options), tagUid);
    });
  }
  /**
   * Delete Tag
   *
   * **Warning! Not allowed when node is in Gateway mode!**
   *
   * @param tagUid UID or tag object to be retrieved
   * @param options Options that affects the request behavior
   * @throws TypeError if tagUid is in not correct format
   * @throws BeeResponse error if something went wrong on the Bee node side while deleting the tag.
   *
   * @see [Bee docs - Syncing / Tags](https://docs.ethswarm.org/docs/access-the-swarm/syncing)
   * @see [Bee API reference - `DELETE /tags/{uid}`](https://docs.ethswarm.org/api/#tag/Tag/paths/~1tags~1{uid}/delete)
   */


  deleteTag(tagUid, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertRequestOptions)(options);
      tagUid = (0, type_2.makeTagUid)(tagUid);
      return tag.deleteTag(this.getKy(options), tagUid);
    });
  }
  /**
   * Update tag's total chunks count.
   *
   * This is important if you are uploading individual chunks with a tag. Then upon finishing the final root chunk,
   * you can use this method to update the total chunks count for the tag.
   *
   * **Warning! Not allowed when node is in Gateway mode!**
   *
   * @param tagUid UID or tag object to be retrieved
   * @param reference The root reference that contains all the chunks to be counted
   * @param options Options that affects the request behavior
   * @throws TypeError if tagUid is in not correct format
   * @throws BeeResponse error if something went wrong on the Bee node side while deleting the tag.
   *
   * @see [Bee docs - Syncing / Tags](https://docs.ethswarm.org/docs/access-the-swarm/syncing)
   * @see [Bee API reference - `PATCH /tags/{uid}`](https://docs.ethswarm.org/api/#tag/Tag/paths/~1tags~1{uid}/patch)
   */


  updateTag(tagUid, reference, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertReference)(reference);
      (0, type_2.assertRequestOptions)(options);
      tagUid = (0, type_2.makeTagUid)(tagUid);
      return tag.updateTag(this.getKy(options), tagUid, reference);
    });
  }
  /**
   * Pin local data with given reference
   *
   * **Warning! Not allowed when node is in Gateway mode!**
   *
   * @param reference Data reference
   * @param options Options that affects the request behavior
   * @throws TypeError if reference is in not correct format
   *
   * @see [Bee docs - Pinning](https://docs.ethswarm.org/docs/access-the-swarm/pinning)
   */


  pin(reference, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertRequestOptions)(options);
      (0, type_2.assertReference)(reference);
      return pinning.pin(this.getKy(options), reference);
    });
  }
  /**
   * Unpin local data with given reference
   *
   * **Warning! Not allowed when node is in Gateway mode!**
   *
   * @param reference Data reference
   * @param options Options that affects the request behavior
   * @throws TypeError if reference is in not correct format
   *
   * @see [Bee docs - Pinning](https://docs.ethswarm.org/docs/access-the-swarm/pinning)
   */


  unpin(reference, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertRequestOptions)(options);
      (0, type_2.assertReference)(reference);
      return pinning.unpin(this.getKy(options), reference);
    });
  }
  /**
   * Get list of all locally pinned references
   *
   * **Warning! Not allowed when node is in Gateway mode!**
   *
   * @param options Options that affects the request behavior
   * @see [Bee docs - Pinning](https://docs.ethswarm.org/docs/access-the-swarm/pinning)
   */


  getAllPins(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertRequestOptions)(options);
      return pinning.getAllPins(this.getKy(options));
    });
  }
  /**
   * Get pinning status of chunk with given reference
   *
   * **Warning! Not allowed when node is in Gateway mode!**
   *
   * @param reference Bee data reference
   * @param options Options that affects the request behavior
   * @throws TypeError if reference is in not correct format
   *
   * @see [Bee docs - Pinning](https://docs.ethswarm.org/docs/access-the-swarm/pinning)
   */


  getPin(reference, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertRequestOptions)(options);
      (0, type_2.assertReference)(reference);
      return pinning.getPin(this.getKy(options), reference);
    });
  }
  /**
   * Instructs the Bee node to reupload a locally pinned data into the network.
   *
   * @param reference
   * @param options Options that affects the request behavior
   * @throws BeeArgumentError if the reference is not locally pinned
   * @throws TypeError if reference is in not correct format
   *
   * @see [Bee API reference - `PUT /stewardship`](https://docs.ethswarm.org/api/#tag/Stewardship/paths/~1stewardship~1{reference}/put)
   */


  reuploadPinnedData(reference, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertRequestOptions)(options);
      (0, type_2.assertReference)(reference);
      yield stewardship.reupload(this.getKy(options), reference);
    });
  }
  /**
   * Checks if content specified by reference is retrievable from the network.
   *
   * @param reference The checked content
   * @param options Options that affects the request behavior
   *
   * @see [Bee API reference - `GET /stewardship`](https://docs.ethswarm.org/api/#tag/Stewardship/paths/~1stewardship~1{reference}/get)
   */


  isReferenceRetrievable(reference, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertRequestOptions)(options);
      (0, type_2.assertReference)(reference);
      return stewardship.isRetrievable(this.getKy(options), reference);
    });
  }
  /**
   * Send data to recipient or target with Postal Service for Swarm.
   *
   * Because sending a PSS message is slow and CPU intensive,
   * it is not supposed to be used for general messaging but
   * most likely for setting up an encrypted communication
   * channel by sending an one-off message.
   *
   * **Warning! Not allowed when node is in Gateway mode!**
   *
   * **Warning! If the recipient Bee node is a light node, then he will never receive the message!**
   * This is because light nodes does not fully participate in the data exchange in Swarm network and hence the message won't arrive to them.
   *
   * @param postageBatchId Postage BatchId that will be assigned to sent message
   * @param topic Topic name
   * @param target Target message address prefix. Has a limit on length. Recommend to use `Utils.Pss.makeMaxTarget()` to get the most specific target that Bee node will accept.
   * @param data Message to be sent
   * @param recipient Recipient public key
   * @param options Options that affects the request behavior
   * @throws TypeError if `data`, `batchId`, `target` or `recipient` are in invalid format
   *
   * @see [Bee docs - PSS](https://docs.ethswarm.org/docs/dapps-on-swarm/pss)
   * @see [Bee API reference - `POST /pss`](https://docs.ethswarm.org/api/#tag/Postal-Service-for-Swarm/paths/~1pss~1send~1{topic}~1{targets}/post)
   */


  pssSend(postageBatchId, topic, target, data, recipient, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertRequestOptions)(options);
      (0, type_2.assertData)(data);
      (0, type_2.assertBatchId)(postageBatchId);
      (0, type_2.assertAddressPrefix)(target);

      if (typeof topic !== 'string') {
        throw new TypeError('topic has to be an string!');
      }

      if (recipient) {
        (0, type_2.assertPublicKey)(recipient);
        return pss.send(this.getKy(options), topic, target, data, postageBatchId, recipient);
      } else {
        return pss.send(this.getKy(options), topic, target, data, postageBatchId);
      }
    });
  }
  /**
   * Subscribe to messages for given topic with Postal Service for Swarm
   *
   * **Warning! Not allowed when node is in Gateway mode!**
   *
   * **Warning! If connected Bee node is a light node, then he will never receive any message!**
   * This is because light nodes does not fully participate in the data exchange in Swarm network and hence the message won't arrive to them.
   *
   * @param topic Topic name
   * @param handler Message handler interface
   *
   * @returns Subscription to a given topic
   *
   * @see [Bee docs - PSS](https://docs.ethswarm.org/docs/dapps-on-swarm/pss)
   * @see [Bee API reference - `GET /pss`](https://docs.ethswarm.org/api/#tag/Postal-Service-for-Swarm/paths/~1pss~1subscribe~1{topic}/get)
   */


  pssSubscribe(topic, handler) {
    (0, type_2.assertPssMessageHandler)(handler);

    if (typeof topic !== 'string') {
      throw new TypeError('topic has to be an string!');
    }

    const ws = pss.subscribe(this.url, topic);
    let cancelled = false;

    const cancel = () => {
      if (cancelled === false) {
        cancelled = true; // although the WebSocket API offers a `close` function, it seems that
        // with the library that we are using (isomorphic-ws) it doesn't close
        // the websocket properly, whereas `terminate` does

        if (ws.terminate) ws.terminate();else ws.close(); // standard Websocket in browser does not have terminate function
      }
    };

    const subscription = {
      topic,
      cancel
    };

    ws.onmessage = ev => __awaiter(this, void 0, void 0, function* () {
      const data = yield (0, data_1.prepareWebsocketData)(ev.data); // ignore empty messages

      if (data.length > 0) {
        handler.onMessage((0, bytes_1.wrapBytesWithHelpers)(data), subscription);
      }
    });

    ws.onerror = ev => {
      // ignore errors after subscription was cancelled
      if (!cancelled) {
        handler.onError(new error_1.BeeError(ev.message), subscription);
      }
    };

    return subscription;
  }
  /**
   * Receive message with Postal Service for Swarm
   *
   * Because sending a PSS message is slow and CPU intensive,
   * it is not supposed to be used for general messaging but
   * most likely for setting up an encrypted communication
   * channel by sending an one-off message.
   *
   * This is a helper function to wait for exactly one message to
   * arrive and then cancel the subscription. Additionally a
   * timeout can be provided for the message to arrive or else
   * an error will be thrown.
   *
   * **Warning! Not allowed when node is in Gateway mode!**
   *
   * **Warning! If connected Bee node is a light node, then he will never receive any message!**
   * This is because light nodes does not fully participate in the data exchange in Swarm network and hence the message won't arrive to them.
   *
   * @param topic Topic name
   * @param timeoutMsec Timeout in milliseconds
   *
   * @returns Message in byte array
   *
   * @see [Bee docs - PSS](https://docs.ethswarm.org/docs/dapps-on-swarm/pss)
   * @see [Bee API reference - `GET /pss`](https://docs.ethswarm.org/api/#tag/Postal-Service-for-Swarm/paths/~1pss~1subscribe~1{topic}/get)
   */


  pssReceive(topic, timeoutMsec = 0) {
    return __awaiter(this, void 0, void 0, function* () {
      if (typeof topic !== 'string') {
        throw new TypeError('topic has to be an string!');
      }

      if (typeof timeoutMsec !== 'number') {
        throw new TypeError('timeoutMsc parameter has to be a number!');
      }

      return new Promise((resolve, reject) => {
        let timeout;
        const subscription = this.pssSubscribe(topic, {
          onError: error => {
            clearTimeout(timeout);
            subscription.cancel();
            reject(error.message);
          },
          onMessage: message => {
            clearTimeout(timeout);
            subscription.cancel();
            resolve(message);
          }
        });

        if (timeoutMsec > 0) {
          // we need to cast the type because Typescript is getting confused with Node.js'
          // alternative type definitions
          timeout = setTimeout(() => {
            subscription.cancel();
            reject(new error_1.BeeError('pssReceive timeout'));
          }, timeoutMsec);
        }
      });
    });
  }
  /**
   * Create feed manifest chunk and return the reference to it.
   *
   * Feed manifest chunk allows for a feed to be able to be resolved through `/bzz` endpoint.
   *
   * @param postageBatchId  Postage BatchId to be used to create the Feed Manifest
   * @param type            The type of the feed, can be 'epoch' or 'sequence'
   * @param topic           Topic in hex or bytes
   * @param owner           Owner's ethereum address in hex or bytes
   * @param options Options that affects the request behavior
   *
   * @see [Bee docs - Feeds](https://docs.ethswarm.org/docs/dapps-on-swarm/feeds)
   * @see [Bee API reference - `POST /feeds`](https://docs.ethswarm.org/api/#tag/Feed/paths/~1feeds~1{owner}~1{topic}/post)
   */


  createFeedManifest(postageBatchId, type, topic, owner, options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertRequestOptions)(options);
      (0, type_1.assertFeedType)(type);
      (0, type_2.assertBatchId)(postageBatchId);
      const canonicalTopic = (0, topic_1.makeTopic)(topic);
      const canonicalOwner = (0, eth_1.makeHexEthAddress)(owner);
      return (0, feed_2.createFeedManifest)(this.getKy(options), canonicalOwner, canonicalTopic, postageBatchId, {
        type
      });
    });
  }
  /**
   * Make a new feed reader for downloading feed updates.
   *
   * @param type    The type of the feed, can be 'epoch' or 'sequence'
   * @param topic   Topic in hex or bytes
   * @param owner   Owner's ethereum address in hex or bytes
   * @param options Options that affects the request behavior
   *
   * @see [Bee docs - Feeds](https://docs.ethswarm.org/docs/dapps-on-swarm/feeds)
   */


  makeFeedReader(type, topic, owner, options) {
    (0, type_2.assertRequestOptions)(options);
    (0, type_1.assertFeedType)(type);
    const canonicalTopic = (0, topic_1.makeTopic)(topic);
    const canonicalOwner = (0, eth_1.makeHexEthAddress)(owner);
    return (0, feed_1.makeFeedReader)(this.getKy(options), type, canonicalTopic, canonicalOwner);
  }
  /**
   * Make a new feed writer for updating feeds
   *
   * @param type    The type of the feed, can be 'epoch' or 'sequence'
   * @param topic   Topic in hex or bytes
   * @param signer  The signer's private key or a Signer instance that can sign data
   * @param options Options that affects the request behavior
   *
   * @see [Bee docs - Feeds](https://docs.ethswarm.org/docs/dapps-on-swarm/feeds)
   */


  makeFeedWriter(type, topic, signer, options) {
    (0, type_2.assertRequestOptions)(options);
    (0, type_1.assertFeedType)(type);
    const canonicalTopic = (0, topic_1.makeTopic)(topic);
    const canonicalSigner = this.resolveSigner(signer);
    return (0, feed_1.makeFeedWriter)(this.getKy(options), type, canonicalTopic, canonicalSigner);
  }
  /**
   * High-level function that allows you to easily set JSON data to feed.
   * JSON-like data types are supported.
   *
   * The default Signer of Bee instance is used if `options.signer` is not specified.
   * If none of those two is set error is thrown.
   *
   * @param postageBatchId Postage BatchId to be used to upload the data with
   * @param topic Human readable string, that is internally hashed so there are no constrains there.
   * @param data JSON compatible data
   * @param options
   * @param options.signer Custom instance of Signer or string with private key.
   * @param options.type Type of Feed
   *
   * @throws BeeError if `options.signer` is not specified nor the default Signer on Bee's instance is specified.
   *
   * @see [Bee docs - Feeds](https://docs.ethswarm.org/docs/dapps-on-swarm/feeds)
   */


  setJsonFeed(postageBatchId, topic, data, options) {
    var _a;

    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertRequestOptions)(options, 'JsonFeedOptions');
      (0, type_2.assertBatchId)(postageBatchId);
      const hashedTopic = this.makeFeedTopic(topic);
      const feedType = (_a = options === null || options === void 0 ? void 0 : options.type) !== null && _a !== void 0 ? _a : type_1.DEFAULT_FEED_TYPE;
      const writer = this.makeFeedWriter(feedType, hashedTopic, options === null || options === void 0 ? void 0 : options.signer, options);
      return (0, json_1.setJsonData)(this, writer, postageBatchId, data, options);
    });
  }
  /**
   * High-level function that allows you to easily get data from feed.
   * Returned data are parsed using JSON.parse().
   *
   * This method also supports specification of `signer` object passed to constructor. The order of evaluation is:
   *  - `options.address`
   *  - `options.signer`
   *  - `this.signer`
   *
   * At least one of these has to be specified!
   *
   * @param topic Human readable string, that is internally hashed so there are no constrains there.
   * @param options
   * @param options.signer Custom instance of Signer or string with private key. This option is exclusive with `address` option.
   * @param options.address Ethereum address of owner of the feed that signed it. This option is exclusive with `signer` option.
   * @param options.type Type of Feed
   *
   * @see [Bee docs - Feeds](https://docs.ethswarm.org/docs/dapps-on-swarm/feeds)
   */


  getJsonFeed(topic, options) {
    var _a;

    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertRequestOptions)(options, 'JsonFeedOptions');
      const hashedTopic = this.makeFeedTopic(topic);
      const feedType = (_a = options === null || options === void 0 ? void 0 : options.type) !== null && _a !== void 0 ? _a : type_1.DEFAULT_FEED_TYPE;

      if ((options === null || options === void 0 ? void 0 : options.signer) && (options === null || options === void 0 ? void 0 : options.address)) {
        throw new error_1.BeeError('Both options "signer" and "address" can not be specified at one time!');
      }

      let address;

      if (options === null || options === void 0 ? void 0 : options.address) {
        address = (0, eth_1.makeEthAddress)(options === null || options === void 0 ? void 0 : options.address);
      } else {
        try {
          address = this.resolveSigner(options === null || options === void 0 ? void 0 : options.signer).address;
        } catch (e) {
          if (e instanceof error_1.BeeError) {
            throw new error_1.BeeError('Either address, signer or default signer has to be specified!');
          } else {
            throw e;
          }
        }
      }

      const reader = this.makeFeedReader(feedType, hashedTopic, address, options);
      return (0, json_1.getJsonData)(this, reader);
    });
  }
  /**
   * Make a new feed topic from a string
   *
   * Because the topic has to be 32 bytes long this function
   * hashes the input string to create a topic string of arbitrary length.
   *
   * @param topic The input string
   */


  makeFeedTopic(topic) {
    return (0, topic_1.makeTopicFromString)(topic);
  }
  /**
   * Returns an object for reading single owner chunks
   *
   * @param ownerAddress The ethereum address of the owner
   * @param options Options that affects the request behavior
   * @see [Bee docs - Chunk Types](https://docs.ethswarm.org/docs/dapps-on-swarm/chunk-types#single-owner-chunks)
   */


  makeSOCReader(ownerAddress, options) {
    (0, type_2.assertRequestOptions)(options);
    const canonicalOwner = (0, eth_1.makeEthAddress)(ownerAddress);
    return {
      owner: (0, eth_1.makeHexEthAddress)(canonicalOwner),
      download: soc_1.downloadSingleOwnerChunk.bind(null, this.getKy(options), canonicalOwner)
    };
  }
  /**
   * Returns an object for reading and writing single owner chunks
   *
   * @param signer The signer's private key or a Signer instance that can sign data
   * @param options Options that affects the request behavior
   * @see [Bee docs - Chunk Types](https://docs.ethswarm.org/docs/dapps-on-swarm/chunk-types#single-owner-chunks)
   */


  makeSOCWriter(signer, options) {
    (0, type_2.assertRequestOptions)(options);
    const canonicalSigner = this.resolveSigner(signer);
    return Object.assign(Object.assign({}, this.makeSOCReader(canonicalSigner.address, options)), {
      upload: soc_1.uploadSingleOwnerChunkData.bind(null, this.getKy(options), canonicalSigner)
    });
  }
  /**
   * Ping the Bee node to see if there is a live Bee node on the given URL.
   *
   * @param options Options that affects the request behavior
   * @throws If connection was not successful throw error
   */


  checkConnection(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertRequestOptions)(options, 'PostageBatchOptions');
      return status.checkConnection(this.getKy(options));
    });
  }
  /**
   * Ping the Bee node to see if there is a live Bee node on the given URL.
   *
   * @param options Options that affects the request behavior
   * @returns true if successful, false on error
   */


  isConnected(options) {
    return __awaiter(this, void 0, void 0, function* () {
      (0, type_2.assertRequestOptions)(options, 'PostageBatchOptions');

      try {
        yield status.checkConnection(this.getKy(options));
      } catch (e) {
        return false;
      }

      return true;
    });
  }
  /**
   * @param signer
   * @private
   * @throws BeeError if either no Signer was passed or no default Signer was specified for the instance
   */


  resolveSigner(signer) {
    if (signer) {
      return (0, signer_1.makeSigner)(signer);
    }

    if (this.signer) {
      return this.signer;
    }

    throw new error_1.BeeError('You have to pass Signer as property to either the method call or constructor! Non found.');
  }

  getKy(options) {
    if (!options) {
      return this.ky;
    }

    return this.ky.extend(options);
  }

}

exports.Bee = Bee;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/chunk/bmt.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/chunk/bmt.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.bmtHash = void 0; // For ESM compatibility

const js_sha3_1 = __importDefault(__webpack_require__(/*! js-sha3 */ "./node_modules/js-sha3/src/sha3.js"));

const {
  keccak256
} = js_sha3_1.default;

const error_1 = __webpack_require__(/*! ../utils/error */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/error.js");

const hash_1 = __webpack_require__(/*! ../utils/hash */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/hash.js");

const MAX_CHUNK_PAYLOAD_SIZE = 4096;
const SEGMENT_SIZE = 32;
const SEGMENT_PAIR_SIZE = 2 * SEGMENT_SIZE;
const HASH_SIZE = 32;
/**
 * Calculate a Binary Merkle Tree hash for a chunk
 *
 * The BMT chunk address is the hash of the 8 byte span and the root
 * hash of a binary Merkle tree (BMT) built on the 32-byte segments
 * of the underlying data.
 *
 * If the chunk content is less than 4k, the hash is calculated as
 * if the chunk was padded with all zeros up to 4096 bytes.
 *
 * @param chunkContent Chunk data including span and payload as well
 *
 * @returns the keccak256 hash in a byte array
 */

function bmtHash(chunkContent) {
  const span = chunkContent.slice(0, 8);
  const payload = chunkContent.slice(8);
  const rootHash = bmtRootHash(payload);
  const chunkHashInput = new Uint8Array([...span, ...rootHash]);
  const chunkHash = (0, hash_1.keccak256Hash)(chunkHashInput);
  return chunkHash;
}

exports.bmtHash = bmtHash;

function bmtRootHash(payload) {
  if (payload.length > MAX_CHUNK_PAYLOAD_SIZE) {
    throw new error_1.BeeArgumentError('invalid data length', payload);
  } // create an input buffer padded with zeros


  let input = new Uint8Array([...payload, ...new Uint8Array(MAX_CHUNK_PAYLOAD_SIZE - payload.length)]);

  while (input.length !== HASH_SIZE) {
    const output = new Uint8Array(input.length / 2); // in each round we hash the segment pairs together

    for (let offset = 0; offset < input.length; offset += SEGMENT_PAIR_SIZE) {
      const hashNumbers = keccak256.array(input.slice(offset, offset + SEGMENT_PAIR_SIZE));
      output.set(hashNumbers, offset / 2);
    }

    input = output;
  }

  return input;
}

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/chunk/cac.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/chunk/cac.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.assertValidChunkData = exports.isValidChunkData = exports.makeContentAddressedChunk = exports.MAX_PAYLOAD_SIZE = exports.MIN_PAYLOAD_SIZE = void 0;

const error_1 = __webpack_require__(/*! ../utils/error */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/error.js");

const bmt_1 = __webpack_require__(/*! ./bmt */ "./node_modules/@ethersphere/bee-js/dist/cjs/chunk/bmt.js");

const bytes_1 = __webpack_require__(/*! ../utils/bytes */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/bytes.js");

const serialize_1 = __webpack_require__(/*! ./serialize */ "./node_modules/@ethersphere/bee-js/dist/cjs/chunk/serialize.js");

const span_1 = __webpack_require__(/*! ./span */ "./node_modules/@ethersphere/bee-js/dist/cjs/chunk/span.js");

exports.MIN_PAYLOAD_SIZE = 1;
exports.MAX_PAYLOAD_SIZE = 4096;
const CAC_SPAN_OFFSET = 0;
const CAC_PAYLOAD_OFFSET = CAC_SPAN_OFFSET + span_1.SPAN_SIZE;
/**
 * Creates a content addressed chunk and verifies the payload size.
 *
 * @param payloadBytes the data to be stored in the chunk
 */

function makeContentAddressedChunk(payloadBytes) {
  const span = (0, span_1.makeSpan)(payloadBytes.length);
  (0, bytes_1.assertFlexBytes)(payloadBytes, exports.MIN_PAYLOAD_SIZE, exports.MAX_PAYLOAD_SIZE);
  const data = (0, serialize_1.serializeBytes)(span, payloadBytes);
  return {
    data,
    span: () => span,
    payload: () => (0, bytes_1.flexBytesAtOffset)(data, CAC_PAYLOAD_OFFSET, exports.MIN_PAYLOAD_SIZE, exports.MAX_PAYLOAD_SIZE),
    address: () => (0, bmt_1.bmtHash)(data)
  };
}

exports.makeContentAddressedChunk = makeContentAddressedChunk;
/**
 * Type guard for valid content addressed chunk data
 *
 * @param data          The chunk data
 * @param chunkAddress  The address of the chunk
 */

function isValidChunkData(data, chunkAddress) {
  if (!(data instanceof Uint8Array)) return false;
  const address = (0, bmt_1.bmtHash)(data);
  return (0, bytes_1.bytesEqual)(address, chunkAddress);
}

exports.isValidChunkData = isValidChunkData;
/**
 * Asserts if data are representing given address of its chunk.
 *
 * @param data          The chunk data
 * @param chunkAddress  The address of the chunk
 *
 * @returns a valid content addressed chunk or throws error
 */

function assertValidChunkData(data, chunkAddress) {
  if (!isValidChunkData(data, chunkAddress)) {
    throw new error_1.BeeError('Address of content address chunk does not match given data!');
  }
}

exports.assertValidChunkData = assertValidChunkData;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/chunk/serialize.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/chunk/serialize.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.serializeBytes = void 0;
/**
 * Helper function for serialize byte arrays
 *
 * @param arrays Any number of byte array arguments
 */

function serializeBytes(...arrays) {
  const length = arrays.reduce((prev, curr) => prev + curr.length, 0);
  const buffer = new Uint8Array(length);
  let offset = 0;
  arrays.forEach(arr => {
    buffer.set(arr, offset);
    offset += arr.length;
  });
  return buffer;
}

exports.serializeBytes = serializeBytes;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/chunk/signer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/chunk/signer.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.sign = exports.makeSigner = exports.assertSigner = exports.makePrivateKeySigner = exports.recoverAddress = exports.defaultSign = void 0; // For ESM compatibility

const elliptic_1 = __importDefault(__webpack_require__(/*! elliptic */ "./node_modules/elliptic/lib/elliptic.js"));

const {
  ec
} = elliptic_1.default;

const error_1 = __webpack_require__(/*! ../utils/error */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/error.js");

const bytes_1 = __webpack_require__(/*! ../utils/bytes */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/bytes.js");

const hash_1 = __webpack_require__(/*! ../utils/hash */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/hash.js");

const hex_1 = __webpack_require__(/*! ../utils/hex */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/hex.js");

const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@ethersphere/bee-js/dist/cjs/types/index.js");

const type_1 = __webpack_require__(/*! ../utils/type */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/type.js");

const UNCOMPRESSED_RECOVERY_ID = 27;

function hashWithEthereumPrefix(data) {
  const ethereumSignedMessagePrefix = `\x19Ethereum Signed Message:\n${data.length}`;
  const prefixBytes = new TextEncoder().encode(ethereumSignedMessagePrefix);
  return (0, hash_1.keccak256Hash)(prefixBytes, data);
}
/**
 * The default signer function that can be used for integrating with
 * other applications (e.g. wallets).
 *
 * @param data      The data to be signed
 * @param privateKey  The private key used for signing the data
 */


function defaultSign(data, privateKey) {
  const curve = new ec('secp256k1');
  const keyPair = curve.keyFromPrivate(privateKey);
  const hashedDigest = hashWithEthereumPrefix(data);
  const sigRaw = curve.sign(hashedDigest, keyPair, {
    canonical: true,
    pers: undefined
  });

  if (sigRaw.recoveryParam === null) {
    throw new error_1.BeeError('signDigest recovery param was null');
  }

  const signature = new Uint8Array([...sigRaw.r.toArray('be', 32), ...sigRaw.s.toArray('be', 32), sigRaw.recoveryParam + UNCOMPRESSED_RECOVERY_ID]);
  return signature;
}

exports.defaultSign = defaultSign;

function publicKeyToAddress(pubKey) {
  const pubBytes = pubKey.encode('array', false);
  return (0, hash_1.keccak256Hash)(pubBytes.slice(1)).slice(12);
}
/**
 * Recovers the ethereum address from a given signature.
 *
 * Can be used for verifying a piece of data when the public key is
 * known.
 *
 * @param signature The signature
 * @param digest    The digest of the data
 *
 * @returns the recovered address
 */


function recoverAddress(signature, digest) {
  const curve = new ec('secp256k1');
  const sig = {
    r: signature.slice(0, 32),
    s: signature.slice(32, 64)
  };
  const recoveryParam = signature[64] - UNCOMPRESSED_RECOVERY_ID;
  const hash = hashWithEthereumPrefix(digest);
  const recPubKey = curve.recoverPubKey(hash, sig, recoveryParam);
  return publicKeyToAddress(recPubKey);
}

exports.recoverAddress = recoverAddress;
/**
 * Creates a singer object that can be used when the private key is known.
 *
 * @param privateKey The private key
 */

function makePrivateKeySigner(privateKey) {
  const curve = new ec('secp256k1');
  const keyPair = curve.keyFromPrivate(privateKey);
  const address = publicKeyToAddress(keyPair.getPublic());
  return {
    sign: digest => defaultSign(digest, privateKey),
    address
  };
}

exports.makePrivateKeySigner = makePrivateKeySigner;

function assertSigner(signer) {
  if (!(0, type_1.isStrictlyObject)(signer)) {
    throw new TypeError('Signer must be an object!');
  }

  const typedSigner = signer;

  if (!(0, bytes_1.isBytes)(typedSigner.address, 20)) {
    throw new TypeError("Signer's address must be Uint8Array with 20 bytes!");
  }

  if (typeof typedSigner.sign !== 'function') {
    throw new TypeError('Signer sign property needs to be function!');
  }
}

exports.assertSigner = assertSigner;

function makeSigner(signer) {
  if (typeof signer === 'string') {
    const hexKey = (0, hex_1.makeHexString)(signer, 64);
    const keyBytes = (0, hex_1.hexToBytes)(hexKey); // HexString is verified for 64 length => 32 is guaranteed

    return makePrivateKeySigner(keyBytes);
  } else if (signer instanceof Uint8Array) {
    (0, bytes_1.assertBytes)(signer, 32);
    return makePrivateKeySigner(signer);
  }

  assertSigner(signer);
  return signer;
}

exports.makeSigner = makeSigner;

function sign(signer, data) {
  return __awaiter(this, void 0, void 0, function* () {
    const result = yield signer.sign((0, bytes_1.wrapBytesWithHelpers)(data));

    if (typeof result === 'string') {
      const hexString = (0, hex_1.makeHexString)(result, types_1.SIGNATURE_HEX_LENGTH);
      return (0, hex_1.hexToBytes)(hexString);
    }

    if (result instanceof Uint8Array) {
      (0, bytes_1.assertBytes)(result, types_1.SIGNATURE_BYTES_LENGTH);
      return result;
    }

    throw new TypeError('Invalid output of sign function!');
  });
}

exports.sign = sign;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/chunk/soc.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/chunk/soc.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.downloadSingleOwnerChunk = exports.uploadSingleOwnerChunkData = exports.uploadSingleOwnerChunk = exports.makeSingleOwnerChunk = exports.makeSOCAddress = exports.makeSingleOwnerChunkFromData = void 0;

const bytes_1 = __webpack_require__(/*! ../utils/bytes */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/bytes.js");

const bmt_1 = __webpack_require__(/*! ./bmt */ "./node_modules/@ethersphere/bee-js/dist/cjs/chunk/bmt.js");

const signer_1 = __webpack_require__(/*! ./signer */ "./node_modules/@ethersphere/bee-js/dist/cjs/chunk/signer.js");

const hash_1 = __webpack_require__(/*! ../utils/hash */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/hash.js");

const span_1 = __webpack_require__(/*! ./span */ "./node_modules/@ethersphere/bee-js/dist/cjs/chunk/span.js");

const serialize_1 = __webpack_require__(/*! ./serialize */ "./node_modules/@ethersphere/bee-js/dist/cjs/chunk/serialize.js");

const error_1 = __webpack_require__(/*! ../utils/error */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/error.js");

const cac_1 = __webpack_require__(/*! ./cac */ "./node_modules/@ethersphere/bee-js/dist/cjs/chunk/cac.js");

const hex_1 = __webpack_require__(/*! ../utils/hex */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/hex.js");

const socAPI = __importStar(__webpack_require__(/*! ../modules/soc */ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/soc.js"));

const chunkAPI = __importStar(__webpack_require__(/*! ../modules/chunk */ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/chunk.js"));

const type_1 = __webpack_require__(/*! ../utils/type */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/type.js");

const IDENTIFIER_SIZE = 32;
const SIGNATURE_SIZE = 65;
const SOC_IDENTIFIER_OFFSET = 0;
const SOC_SIGNATURE_OFFSET = SOC_IDENTIFIER_OFFSET + IDENTIFIER_SIZE;
const SOC_SPAN_OFFSET = SOC_SIGNATURE_OFFSET + SIGNATURE_SIZE;
const SOC_PAYLOAD_OFFSET = SOC_SPAN_OFFSET + span_1.SPAN_SIZE;

function recoverChunkOwner(data) {
  const cacData = data.slice(SOC_SPAN_OFFSET);
  const chunkAddress = (0, bmt_1.bmtHash)(cacData);
  const signature = (0, bytes_1.bytesAtOffset)(data, SOC_SIGNATURE_OFFSET, SIGNATURE_SIZE);
  const identifier = (0, bytes_1.bytesAtOffset)(data, SOC_IDENTIFIER_OFFSET, IDENTIFIER_SIZE);
  const digest = (0, hash_1.keccak256Hash)(identifier, chunkAddress);
  const ownerAddress = (0, signer_1.recoverAddress)(signature, digest);
  return ownerAddress;
}
/**
 * Verifies if the data is a valid single owner chunk
 *
 * @param data    The chunk data
 * @param address The address of the single owner chunk
 *
 * @returns a single owner chunk or throws error
 */


function makeSingleOwnerChunkFromData(data, address) {
  const ownerAddress = recoverChunkOwner(data);
  const identifier = (0, bytes_1.bytesAtOffset)(data, SOC_IDENTIFIER_OFFSET, IDENTIFIER_SIZE);
  const socAddress = (0, hash_1.keccak256Hash)(identifier, ownerAddress);

  if (!(0, bytes_1.bytesEqual)(address, socAddress)) {
    throw new error_1.BeeError('SOC Data does not match given address!');
  }

  const signature = () => (0, bytes_1.bytesAtOffset)(data, SOC_SIGNATURE_OFFSET, SIGNATURE_SIZE);

  const span = () => (0, bytes_1.bytesAtOffset)(data, SOC_SPAN_OFFSET, span_1.SPAN_SIZE);

  const payload = () => (0, bytes_1.flexBytesAtOffset)(data, SOC_PAYLOAD_OFFSET, cac_1.MIN_PAYLOAD_SIZE, cac_1.MAX_PAYLOAD_SIZE);

  return {
    data,
    identifier: () => identifier,
    signature,
    span,
    payload,
    address: () => socAddress,
    owner: () => ownerAddress
  };
}

exports.makeSingleOwnerChunkFromData = makeSingleOwnerChunkFromData;

function makeSOCAddress(identifier, address) {
  return (0, hash_1.keccak256Hash)(identifier, address);
}

exports.makeSOCAddress = makeSOCAddress;
/**
 * Creates a single owner chunk object
 *
 * @param chunk       A chunk object used for the span and payload
 * @param identifier  The identifier of the chunk
 * @param signer      The singer interface for signing the chunk
 */

function makeSingleOwnerChunk(chunk, identifier, signer) {
  return __awaiter(this, void 0, void 0, function* () {
    const chunkAddress = chunk.address();
    (0, cac_1.assertValidChunkData)(chunk.data, chunkAddress);
    const digest = (0, hash_1.keccak256Hash)(identifier, chunkAddress);
    const signature = yield (0, signer_1.sign)(signer, digest);
    const data = (0, serialize_1.serializeBytes)(identifier, signature, chunk.span(), chunk.payload());
    const address = makeSOCAddress(identifier, signer.address);
    return {
      data,
      identifier: () => identifier,
      signature: () => signature,
      span: () => chunk.span(),
      payload: () => chunk.payload(),
      address: () => address,
      owner: () => signer.address
    };
  });
}

exports.makeSingleOwnerChunk = makeSingleOwnerChunk;
/**
 * Helper function to upload a chunk.
 *
 * It uses the Chunk API and calculates the address before uploading.
 *
 * @param ky              Ky instance
 * @param chunk           A chunk object
 * @param postageBatchId  Postage BatchId that will be assigned to uploaded data
 * @param options         Upload options
 */

function uploadSingleOwnerChunk(ky, chunk, postageBatchId, options) {
  return __awaiter(this, void 0, void 0, function* () {
    const owner = (0, hex_1.bytesToHex)(chunk.owner());
    const identifier = (0, hex_1.bytesToHex)(chunk.identifier());
    const signature = (0, hex_1.bytesToHex)(chunk.signature());
    const data = (0, serialize_1.serializeBytes)(chunk.span(), chunk.payload());
    return socAPI.upload(ky, owner, identifier, signature, data, postageBatchId, options);
  });
}

exports.uploadSingleOwnerChunk = uploadSingleOwnerChunk;
/**
 * Helper function to create and upload SOC.
 *
 * @param ky              Ky instance
 * @param signer          The singer interface for signing the chunk
 * @param postageBatchId
 * @param identifier      The identifier of the chunk
 * @param data            The chunk data
 * @param options
 */

function uploadSingleOwnerChunkData(ky, signer, postageBatchId, identifier, data, options) {
  return __awaiter(this, void 0, void 0, function* () {
    (0, type_1.assertAddress)(postageBatchId);
    const cac = (0, cac_1.makeContentAddressedChunk)(data);
    const soc = yield makeSingleOwnerChunk(cac, identifier, signer);
    return uploadSingleOwnerChunk(ky, soc, postageBatchId, options);
  });
}

exports.uploadSingleOwnerChunkData = uploadSingleOwnerChunkData;
/**
 * Helper function to download SOC.
 *
 * @param url           The url of the Bee service
 * @param ownerAddress  The singer interface for signing the chunk
 * @param identifier    The identifier of the chunk
 */

function downloadSingleOwnerChunk(ky, ownerAddress, identifier) {
  return __awaiter(this, void 0, void 0, function* () {
    const address = makeSOCAddress(identifier, ownerAddress);
    const data = yield chunkAPI.download(ky, (0, hex_1.bytesToHex)(address));
    return makeSingleOwnerChunkFromData(data, address);
  });
}

exports.downloadSingleOwnerChunk = downloadSingleOwnerChunk;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/chunk/span.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/chunk/span.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.makeSpan = exports.SPAN_SIZE = void 0;

const error_1 = __webpack_require__(/*! ../utils/error */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/error.js");

exports.SPAN_SIZE = 8; // we limit the maximum span size in 32 bits to avoid BigInt compatibility issues

const MAX_SPAN_LENGTH = Math.pow(2, 32) - 1;
/**
 * Create a span for storing the length of the chunk
 *
 * The length is encoded in 64-bit little endian.
 *
 * @param length The length of the span
 */

function makeSpan(length) {
  if (length <= 0) {
    throw new error_1.BeeArgumentError('invalid length for span', length);
  }

  if (length > MAX_SPAN_LENGTH) {
    throw new error_1.BeeArgumentError('invalid length (> MAX_SPAN_LENGTH)', length);
  }

  const span = new Uint8Array(exports.SPAN_SIZE);
  const dataView = new DataView(span.buffer);
  const littleEndian = true;
  const lengthLower32 = length & 0xffffffff;
  dataView.setUint32(0, lengthLower32, littleEndian);
  return span;
}

exports.makeSpan = makeSpan;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/feed/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/feed/index.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.makeFeedWriter = exports.makeFeedReader = exports.downloadFeedUpdate = exports.verifyChunkReference = exports.updateFeed = exports.findNextIndex = exports.uploadFeedUpdate = exports.makeFeedIdentifier = exports.makeFeedIndexBytes = exports.makeSequentialFeedIdentifier = exports.isEpoch = void 0;

const hash_1 = __webpack_require__(/*! ../utils/hash */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/hash.js");

const serialize_1 = __webpack_require__(/*! ../chunk/serialize */ "./node_modules/@ethersphere/bee-js/dist/cjs/chunk/serialize.js");

const soc_1 = __webpack_require__(/*! ../chunk/soc */ "./node_modules/@ethersphere/bee-js/dist/cjs/chunk/soc.js");

const feed_1 = __webpack_require__(/*! ../modules/feed */ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/feed.js");

const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@ethersphere/bee-js/dist/cjs/types/index.js");

const bytes_1 = __webpack_require__(/*! ../utils/bytes */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/bytes.js");

const error_1 = __webpack_require__(/*! ../utils/error */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/error.js");

const hex_1 = __webpack_require__(/*! ../utils/hex */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/hex.js");

const uint64_1 = __webpack_require__(/*! ../utils/uint64 */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/uint64.js");

const chunkAPI = __importStar(__webpack_require__(/*! ../modules/chunk */ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/chunk.js"));

const eth_1 = __webpack_require__(/*! ../utils/eth */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/eth.js");

const type_1 = __webpack_require__(/*! ../utils/type */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/type.js");

const TIMESTAMP_PAYLOAD_OFFSET = 0;
const TIMESTAMP_PAYLOAD_SIZE = 8;
const REFERENCE_PAYLOAD_OFFSET = TIMESTAMP_PAYLOAD_SIZE;
const REFERENCE_PAYLOAD_MIN_SIZE = 32;
const REFERENCE_PAYLOAD_MAX_SIZE = 64;
const INDEX_HEX_LENGTH = 16;

function isEpoch(epoch) {
  return typeof epoch === 'object' && epoch !== null && 'time' in epoch && 'level' in epoch;
}

exports.isEpoch = isEpoch;

function hashFeedIdentifier(topic, index) {
  return (0, hash_1.keccak256Hash)((0, hex_1.hexToBytes)(topic), index);
}

function makeSequentialFeedIdentifier(topic, index) {
  const indexBytes = (0, uint64_1.writeUint64BigEndian)(index);
  return hashFeedIdentifier(topic, indexBytes);
}

exports.makeSequentialFeedIdentifier = makeSequentialFeedIdentifier;

function makeFeedIndexBytes(s) {
  const hex = (0, hex_1.makeHexString)(s, INDEX_HEX_LENGTH);
  return (0, hex_1.hexToBytes)(hex);
}

exports.makeFeedIndexBytes = makeFeedIndexBytes;

function makeFeedIdentifier(topic, index) {
  if (typeof index === 'number') {
    return makeSequentialFeedIdentifier(topic, index);
  } else if (typeof index === 'string') {
    const indexBytes = makeFeedIndexBytes(index);
    return hashFeedIdentifier(topic, indexBytes);
  } else if (isEpoch(index)) {
    throw new TypeError('epoch is not yet implemented');
  }

  return hashFeedIdentifier(topic, index);
}

exports.makeFeedIdentifier = makeFeedIdentifier;

function uploadFeedUpdate(ky, signer, topic, index, reference, postageBatchId, options) {
  var _a;

  return __awaiter(this, void 0, void 0, function* () {
    const identifier = makeFeedIdentifier(topic, index);
    const at = (_a = options === null || options === void 0 ? void 0 : options.at) !== null && _a !== void 0 ? _a : Date.now() / 1000.0;
    const timestamp = (0, uint64_1.writeUint64BigEndian)(at);
    const payloadBytes = (0, serialize_1.serializeBytes)(timestamp, reference);
    return (0, soc_1.uploadSingleOwnerChunkData)(ky, signer, postageBatchId, identifier, payloadBytes, options);
  });
}

exports.uploadFeedUpdate = uploadFeedUpdate;

function findNextIndex(ky, owner, topic, options) {
  return __awaiter(this, void 0, void 0, function* () {
    try {
      const feedUpdate = yield (0, feed_1.fetchFeedUpdate)(ky, owner, topic, options);
      return (0, hex_1.makeHexString)(feedUpdate.feedIndexNext, INDEX_HEX_LENGTH);
    } catch (e) {
      if (e instanceof error_1.BeeResponseError && e.status === 404) {
        return (0, hex_1.bytesToHex)((0, bytes_1.makeBytes)(8));
      }

      throw e;
    }
  });
}

exports.findNextIndex = findNextIndex;

function updateFeed(ky, signer, topic, reference, postageBatchId, options) {
  return __awaiter(this, void 0, void 0, function* () {
    const ownerHex = (0, eth_1.makeHexEthAddress)(signer.address);
    const nextIndex = yield findNextIndex(ky, ownerHex, topic, options);
    return uploadFeedUpdate(ky, signer, topic, nextIndex, reference, postageBatchId, options);
  });
}

exports.updateFeed = updateFeed;

function verifyChunkReferenceAtOffset(offset, data) {
  try {
    return (0, bytes_1.bytesAtOffset)(data, offset, REFERENCE_PAYLOAD_MAX_SIZE);
  } catch (e) {
    return (0, bytes_1.bytesAtOffset)(data, offset, REFERENCE_PAYLOAD_MIN_SIZE);
  }
}

function verifyChunkReference(data) {
  return verifyChunkReferenceAtOffset(0, data);
}

exports.verifyChunkReference = verifyChunkReference;

function downloadFeedUpdate(ky, owner, topic, index) {
  return __awaiter(this, void 0, void 0, function* () {
    const identifier = makeFeedIdentifier(topic, index);
    const address = (0, hash_1.keccak256Hash)(identifier, owner);
    const addressHex = (0, hex_1.bytesToHex)(address);
    const data = yield chunkAPI.download(ky, addressHex);
    const soc = (0, soc_1.makeSingleOwnerChunkFromData)(data, address);
    const payload = soc.payload();
    const timestampBytes = (0, bytes_1.bytesAtOffset)(payload, TIMESTAMP_PAYLOAD_OFFSET, TIMESTAMP_PAYLOAD_SIZE);
    const timestamp = (0, uint64_1.readUint64BigEndian)(timestampBytes);
    const reference = verifyChunkReferenceAtOffset(REFERENCE_PAYLOAD_OFFSET, payload);
    return {
      timestamp,
      reference
    };
  });
}

exports.downloadFeedUpdate = downloadFeedUpdate;

function makeFeedReader(ky, type, topic, owner) {
  const download = options => __awaiter(this, void 0, void 0, function* () {
    return (0, feed_1.fetchFeedUpdate)(ky, owner, topic, Object.assign(Object.assign({}, options), {
      type
    }));
  });

  return {
    type,
    owner,
    topic,
    download
  };
}

exports.makeFeedReader = makeFeedReader;

function makeChunkReference(reference) {
  if (typeof reference === 'string') {
    try {
      // Non-encrypted chunk hex string reference
      const hexReference = (0, hex_1.makeHexString)(reference, types_1.REFERENCE_HEX_LENGTH);
      return (0, hex_1.hexToBytes)(hexReference);
    } catch (e) {
      if (!(e instanceof TypeError)) {
        throw e;
      } // Encrypted chunk hex string reference


      const hexReference = (0, hex_1.makeHexString)(reference, types_1.ENCRYPTED_REFERENCE_HEX_LENGTH);
      return (0, hex_1.hexToBytes)(hexReference);
    }
  } else if (reference instanceof Uint8Array) {
    return verifyChunkReference(reference);
  }

  throw new TypeError('invalid chunk reference');
}

function makeFeedWriter(ky, type, topic, signer) {
  const upload = (postageBatchId, reference, options) => __awaiter(this, void 0, void 0, function* () {
    (0, type_1.assertAddress)(postageBatchId);
    const canonicalReference = makeChunkReference(reference);
    return updateFeed(ky, signer, topic, canonicalReference, postageBatchId, Object.assign(Object.assign({}, options), {
      type
    }));
  });

  return Object.assign(Object.assign({}, makeFeedReader(ky, type, topic, (0, eth_1.makeHexEthAddress)(signer.address))), {
    upload
  });
}

exports.makeFeedWriter = makeFeedWriter;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/feed/json.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/feed/json.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.setJsonData = exports.getJsonData = void 0;

const type_1 = __webpack_require__(/*! ../utils/type */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/type.js");

function serializeJson(data) {
  try {
    const jsonString = JSON.stringify(data);
    return new TextEncoder().encode(jsonString);
  } catch (e) {
    if ((0, type_1.isError)(e)) {
      e.message = `JsonFeed: ${e.message}`;
    }

    throw e;
  }
}

function getJsonData(bee, reader) {
  return __awaiter(this, void 0, void 0, function* () {
    const feedUpdate = yield reader.download();
    const retrievedData = yield bee.downloadData(feedUpdate.reference);
    return retrievedData.json();
  });
}

exports.getJsonData = getJsonData;

function setJsonData(bee, writer, postageBatchId, data, options) {
  return __awaiter(this, void 0, void 0, function* () {
    const serializedData = serializeJson(data);
    const {
      reference
    } = yield bee.uploadData(postageBatchId, serializedData, options);
    return writer.upload(postageBatchId, reference);
  });
}

exports.setJsonData = setJsonData;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/feed/topic.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/feed/topic.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.makeTopicFromString = exports.makeTopic = void 0;

const hash_1 = __webpack_require__(/*! ../utils/hash */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/hash.js");

const bytes_1 = __webpack_require__(/*! ../utils/bytes */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/bytes.js");

const hex_1 = __webpack_require__(/*! ../utils/hex */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/hex.js");

const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@ethersphere/bee-js/dist/cjs/types/index.js");

function makeTopic(topic) {
  if (typeof topic === 'string') {
    return (0, hex_1.makeHexString)(topic, types_1.TOPIC_HEX_LENGTH);
  } else if (topic instanceof Uint8Array) {
    (0, bytes_1.assertBytes)(topic, types_1.TOPIC_BYTES_LENGTH);
    return (0, hex_1.bytesToHex)(topic, types_1.TOPIC_HEX_LENGTH);
  }

  throw new TypeError('invalid topic');
}

exports.makeTopic = makeTopic;

function makeTopicFromString(s) {
  if (typeof s !== 'string') {
    throw new TypeError('topic has to be string!');
  }

  return (0, hex_1.bytesToHex)((0, hash_1.keccak256Hash)(s), types_1.TOPIC_HEX_LENGTH);
}

exports.makeTopicFromString = makeTopicFromString;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/feed/type.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/feed/type.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.assertFeedType = exports.isFeedType = exports.DEFAULT_FEED_TYPE = void 0;
const feedTypes = ['sequence', 'epoch'];
exports.DEFAULT_FEED_TYPE = 'sequence';

function isFeedType(type) {
  return typeof type === 'string' && feedTypes.includes(type);
}

exports.isFeedType = isFeedType;

function assertFeedType(type) {
  if (!isFeedType(type)) {
    throw new TypeError('invalid feed type');
  }
}

exports.assertFeedType = assertFeedType;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/index.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BeeDebug = exports.Bee = exports.SUPPORTED_BEE_VERSION_EXACT = exports.SUPPORTED_BEE_VERSION = exports.Utils = void 0;

const bee_1 = __webpack_require__(/*! ./bee */ "./node_modules/@ethersphere/bee-js/dist/cjs/bee.js");

Object.defineProperty(exports, "Bee", ({
  enumerable: true,
  get: function () {
    return bee_1.Bee;
  }
}));

const bee_debug_1 = __webpack_require__(/*! ./bee-debug */ "./node_modules/@ethersphere/bee-js/dist/cjs/bee-debug.js");

Object.defineProperty(exports, "BeeDebug", ({
  enumerable: true,
  get: function () {
    return bee_debug_1.BeeDebug;
  }
}));
exports.Utils = __importStar(__webpack_require__(/*! ./utils/expose */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/expose.js"));

__exportStar(__webpack_require__(/*! ./types */ "./node_modules/@ethersphere/bee-js/dist/cjs/types/index.js"), exports);

__exportStar(__webpack_require__(/*! ./utils/error */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/error.js"), exports);

var status_1 = __webpack_require__(/*! ./modules/debug/status */ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/status.js");

Object.defineProperty(exports, "SUPPORTED_BEE_VERSION", ({
  enumerable: true,
  get: function () {
    return status_1.SUPPORTED_BEE_VERSION;
  }
}));
Object.defineProperty(exports, "SUPPORTED_BEE_VERSION_EXACT", ({
  enumerable: true,
  get: function () {
    return status_1.SUPPORTED_BEE_VERSION_EXACT;
  }
}));

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/bytes.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/modules/bytes.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.downloadReadable = exports.download = exports.upload = void 0;

const data_1 = __webpack_require__(/*! ../utils/data */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/data.browser.js");

const headers_1 = __webpack_require__(/*! ../utils/headers */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/headers.js");

const http_1 = __webpack_require__(/*! ../utils/http */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/http.js");

const bytes_1 = __webpack_require__(/*! ../utils/bytes */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/bytes.js");

const type_1 = __webpack_require__(/*! ../utils/type */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/type.js");

const endpoint = 'bytes';
/**
 * Upload data to a Bee node
 *
 * @param ky              Ky instance
 * @param data            Data to be uploaded
 * @param postageBatchId  Postage BatchId that will be assigned to uploaded data
 * @param options         Additional options like tag, encryption, pinning
 */

function upload(ky, data, postageBatchId, options) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      path: endpoint,
      method: 'post',
      responseType: 'json',
      body: yield (0, data_1.prepareData)(data),
      headers: Object.assign({
        'content-type': 'application/octet-stream'
      }, (0, headers_1.extractUploadHeaders)(postageBatchId, options))
    });
    return {
      reference: response.data.reference,
      tagUid: (0, type_1.makeTagUid)(response.headers.get('swarm-tag'))
    };
  });
}

exports.upload = upload;
/**
 * Download data as a byte array
 *
 * @param ky
 * @param hash Bee content reference
 */

function download(ky, hash) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      responseType: 'arraybuffer',
      path: `${endpoint}/${hash}`
    });
    return (0, bytes_1.wrapBytesWithHelpers)(new Uint8Array(response.data));
  });
}

exports.download = download;
/**
 * Download data as a readable stream
 *
 * @param ky
 * @param hash Bee content reference
 */

function downloadReadable(ky, hash) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      responseType: 'stream',
      path: `${endpoint}/${hash}`
    });
    return response.data;
  });
}

exports.downloadReadable = downloadReadable;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/bzz.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/modules/bzz.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.uploadCollection = exports.downloadFileReadable = exports.downloadFile = exports.uploadFile = void 0;

const headers_1 = __webpack_require__(/*! ../utils/headers */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/headers.js");

const http_1 = __webpack_require__(/*! ../utils/http */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/http.js");

const data_1 = __webpack_require__(/*! ../utils/data */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/data.browser.js");

const tar_1 = __webpack_require__(/*! ../utils/tar */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/tar.js");

const collection_1 = __webpack_require__(/*! ../utils/collection */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/collection.js");

const bytes_1 = __webpack_require__(/*! ../utils/bytes */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/bytes.js");

const stream_1 = __webpack_require__(/*! ../utils/stream */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/stream.js");

const type_1 = __webpack_require__(/*! ../utils/type */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/type.js");

const bzzEndpoint = 'bzz';

function extractFileUploadHeaders(postageBatchId, options) {
  const headers = (0, headers_1.extractUploadHeaders)(postageBatchId, options);
  if (options === null || options === void 0 ? void 0 : options.size) headers['content-length'] = String(options.size);
  if (options === null || options === void 0 ? void 0 : options.contentType) headers['content-type'] = options.contentType;
  return headers;
}
/**
 * Upload single file
 *
 * @param ky
 * @param data Files data
 * @param postageBatchId  Postage BatchId that will be assigned to uploaded data
 * @param name Name that will be attached to the uploaded file. Wraps the data into manifest with set index document.
 * @param options
 */


function uploadFile(ky, data, postageBatchId, name, options) {
  return __awaiter(this, void 0, void 0, function* () {
    if ((0, stream_1.isReadable)(data) && !(options === null || options === void 0 ? void 0 : options.contentType)) {
      if (!options) options = {};
      options.contentType = 'application/octet-stream';
    }

    const response = yield (0, http_1.http)(ky, {
      method: 'post',
      path: bzzEndpoint,
      body: yield (0, data_1.prepareData)(data),
      headers: Object.assign({}, extractFileUploadHeaders(postageBatchId, options)),
      searchParams: {
        name
      },
      responseType: 'json'
    });
    return {
      reference: response.data.reference,
      tagUid: (0, type_1.makeTagUid)(response.headers.get('swarm-tag'))
    };
  });
}

exports.uploadFile = uploadFile;
/**
 * Download single file as a buffer
 *
 * @param ky Ky instance for given Bee class instance
 * @param hash Bee file or collection hash
 * @param path If hash is collection then this defines path to a single file in the collection
 */

function downloadFile(ky, hash, path = '') {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      method: 'GET',
      responseType: 'arraybuffer',
      path: `${bzzEndpoint}/${hash}/${path}`
    });
    const file = Object.assign(Object.assign({}, (0, headers_1.readFileHeaders)(response.headers)), {
      data: (0, bytes_1.wrapBytesWithHelpers)(new Uint8Array(response.data))
    });
    return file;
  });
}

exports.downloadFile = downloadFile;
/**
 * Download single file as a readable stream
 *
 * @param ky Ky instance for given Bee class instance
 * @param hash Bee file or collection hash
 * @param path If hash is collection then this defines path to a single file in the collection
 */

function downloadFileReadable(ky, hash, path = '') {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      method: 'GET',
      responseType: 'stream',
      path: `${bzzEndpoint}/${hash}/${path}`
    });
    const file = Object.assign(Object.assign({}, (0, headers_1.readFileHeaders)(response.headers)), {
      data: response.data
    });
    return file;
  });
}

exports.downloadFileReadable = downloadFileReadable;

function extractCollectionUploadHeaders(postageBatchId, options) {
  const headers = (0, headers_1.extractUploadHeaders)(postageBatchId, options);
  if (options === null || options === void 0 ? void 0 : options.indexDocument) headers['swarm-index-document'] = options.indexDocument;
  if (options === null || options === void 0 ? void 0 : options.errorDocument) headers['swarm-error-document'] = options.errorDocument;
  return headers;
}
/**
 * Upload collection
 * @param ky Ky instance for given Bee class instance
 * @param collection Collection of Uint8Array buffers to upload
 * @param postageBatchId  Postage BatchId that will be assigned to uploaded data
 * @param options
 */


function uploadCollection(ky, collection, postageBatchId, options) {
  return __awaiter(this, void 0, void 0, function* () {
    (0, collection_1.assertCollection)(collection);
    const tarData = (0, tar_1.makeTar)(collection);
    const response = yield (0, http_1.http)(ky, {
      method: 'post',
      path: bzzEndpoint,
      body: tarData,
      responseType: 'json',
      headers: Object.assign({
        'content-type': 'application/x-tar',
        'swarm-collection': 'true'
      }, extractCollectionUploadHeaders(postageBatchId, options))
    });
    return {
      reference: response.data.reference,
      tagUid: (0, type_1.makeTagUid)(response.headers.get('swarm-tag'))
    };
  });
}

exports.uploadCollection = uploadCollection;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/chunk.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/modules/chunk.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.download = exports.upload = void 0;

const headers_1 = __webpack_require__(/*! ../utils/headers */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/headers.js");

const http_1 = __webpack_require__(/*! ../utils/http */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/http.js");

const bytes_1 = __webpack_require__(/*! ../utils/bytes */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/bytes.js");

const endpoint = 'chunks';
/**
 * Upload chunk to a Bee node
 *
 * The chunk data consists of 8 byte span and up to 4096 bytes of payload data.
 * The span stores the length of the payload in uint64 little endian encoding.
 * Upload expects the chuck data to be set accordingly.
 *
 * @param ky Ky instance
 * @param data    Chunk data to be uploaded
 * @param postageBatchId  Postage BatchId that will be assigned to uploaded data
 * @param options Additional options like tag, encryption, pinning
 */

function upload(ky, data, postageBatchId, options) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      method: 'post',
      path: `${endpoint}`,
      body: data,
      headers: Object.assign({
        'content-type': 'application/octet-stream'
      }, (0, headers_1.extractUploadHeaders)(postageBatchId, options)),
      responseType: 'json'
    });
    return response.data.reference;
  });
}

exports.upload = upload;
/**
 * Download chunk data as a byte array
 *
 * @param ky Ky instance for given Bee class instance
 * @param hash Bee content reference
 *
 */

function download(ky, hash) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      responseType: 'arraybuffer',
      path: `${endpoint}/${hash}`
    });
    return (0, bytes_1.wrapBytesWithHelpers)(new Uint8Array(response.data));
  });
}

exports.download = download;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/balance.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/balance.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getPastDueConsumptionPeerBalance = exports.getPastDueConsumptionBalances = exports.getPeerBalance = exports.getAllBalances = void 0;

const http_1 = __webpack_require__(/*! ../../utils/http */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/http.js");

const balancesEndpoint = 'balances';
const consumedEndpoint = 'consumed';
/**
 * Get the balances with all known peers including prepaid services
 *
 * @param ky Ky debug instance
 */

function getAllBalances(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      path: balancesEndpoint,
      responseType: 'json'
    });
    return response.data;
  });
}

exports.getAllBalances = getAllBalances;
/**
 * Get the balances with a specific peer including prepaid services
 *
 * @param ky Ky debug instance
 * @param address Swarm address of peer
 */

function getPeerBalance(ky, address) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      path: `${balancesEndpoint}/${address}`,
      responseType: 'json'
    });
    return response.data;
  });
}

exports.getPeerBalance = getPeerBalance;
/**
 * Get the past due consumption balances with all known peers
 *
 * @param ky Ky debug instance
 */

function getPastDueConsumptionBalances(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      path: consumedEndpoint,
      responseType: 'json'
    });
    return response.data;
  });
}

exports.getPastDueConsumptionBalances = getPastDueConsumptionBalances;
/**
 * Get the past due consumption balance with a specific peer
 *
 * @param ky Ky debug instance
 * @param address Swarm address of peer
 */

function getPastDueConsumptionPeerBalance(ky, address) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      path: `${consumedEndpoint}/${address}`,
      responseType: 'json'
    });
    return response.data;
  });
}

exports.getPastDueConsumptionPeerBalance = getPastDueConsumptionPeerBalance;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/chequebook.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/chequebook.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.withdrawTokens = exports.depositTokens = exports.getLastCheques = exports.getLastChequesForPeer = exports.cashoutLastCheque = exports.getLastCashoutAction = exports.getChequebookBalance = exports.getChequebookAddress = void 0;

const http_1 = __webpack_require__(/*! ../../utils/http */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/http.js");

const chequebookEndpoint = 'chequebook';
/**
 * Get the address of the chequebook contract used
 *
 * @param ky Ky debug instance
 */

function getChequebookAddress(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      path: chequebookEndpoint + '/address',
      responseType: 'json'
    });
    return response.data;
  });
}

exports.getChequebookAddress = getChequebookAddress;
/**
 * Get the balance of the chequebook
 *
 * @param ky Ky debug instance
 */

function getChequebookBalance(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      path: chequebookEndpoint + '/balance',
      responseType: 'json'
    });
    return response.data;
  });
}

exports.getChequebookBalance = getChequebookBalance;
/**
 * Get last cashout action for the peer
 *
 * @param ky Ky debug instance
 * @param peer  Swarm address of peer
 */

function getLastCashoutAction(ky, peer) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      path: chequebookEndpoint + `/cashout/${peer}`,
      responseType: 'json'
    });
    return response.data;
  });
}

exports.getLastCashoutAction = getLastCashoutAction;
/**
 * Cashout the last cheque for the peer
 *
 * @param ky Ky debug instance
 * @param peer  Swarm address of peer
 * @param options
 */

function cashoutLastCheque(ky, peer, options) {
  return __awaiter(this, void 0, void 0, function* () {
    const headers = {};

    if (options === null || options === void 0 ? void 0 : options.gasPrice) {
      headers['gas-price'] = options.gasPrice.toString();
    }

    if (options === null || options === void 0 ? void 0 : options.gasLimit) {
      headers['gas-limit'] = options.gasLimit.toString();
    }

    const response = yield (0, http_1.http)(ky, {
      method: 'post',
      path: chequebookEndpoint + `/cashout/${peer}`,
      responseType: 'json',
      headers
    });
    return response.data.transactionHash;
  });
}

exports.cashoutLastCheque = cashoutLastCheque;
/**
 * Get last cheques for the peer
 *
 * @param ky Ky debug instance
 * @param peer  Swarm address of peer
 */

function getLastChequesForPeer(ky, peer) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      path: chequebookEndpoint + `/cheque/${peer}`,
      responseType: 'json'
    });
    return response.data;
  });
}

exports.getLastChequesForPeer = getLastChequesForPeer;
/**
 * Get last cheques for all peers
 *
 * @param ky Ky debug instance
 */

function getLastCheques(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      path: chequebookEndpoint + '/cheque',
      responseType: 'json'
    });
    return response.data;
  });
}

exports.getLastCheques = getLastCheques;
/**
 * Deposit tokens from overlay address into chequebook
 *
 * @param ky Ky debug instance
 * @param amount   Amount of tokens to deposit
 * @param gasPrice Gas Price in WEI for the transaction call
 * @return string  Hash of the transaction
 */

function depositTokens(ky, amount, gasPrice) {
  return __awaiter(this, void 0, void 0, function* () {
    const headers = {};

    if (gasPrice) {
      headers['gas-price'] = gasPrice.toString();
    }

    const response = yield (0, http_1.http)(ky, {
      method: 'post',
      path: chequebookEndpoint + '/deposit',
      responseType: 'json',
      searchParams: {
        amount: amount.toString(10)
      },
      headers
    });
    return response.data.transactionHash;
  });
}

exports.depositTokens = depositTokens;
/**
 * Withdraw tokens from the chequebook to the overlay address
 *
 * @param ky Ky debug instance
 * @param amount   Amount of tokens to withdraw
 * @param gasPrice Gas Price in WEI for the transaction call
 * @return string  Hash of the transaction
 */

function withdrawTokens(ky, amount, gasPrice) {
  return __awaiter(this, void 0, void 0, function* () {
    const headers = {};

    if (gasPrice) {
      headers['gas-price'] = gasPrice.toString();
    }

    const response = yield (0, http_1.http)(ky, {
      method: 'post',
      path: chequebookEndpoint + '/withdraw',
      responseType: 'json',
      searchParams: {
        amount: amount.toString(10)
      },
      headers
    });
    return response.data.transactionHash;
  });
}

exports.withdrawTokens = withdrawTokens;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/connectivity.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/connectivity.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.pingPeer = exports.getTopology = exports.removePeer = exports.getBlocklist = exports.getPeers = exports.getNodeAddresses = void 0;

const http_1 = __webpack_require__(/*! ../../utils/http */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/http.js");

function getNodeAddresses(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      path: 'addresses',
      responseType: 'json'
    });
    return response.data;
  });
}

exports.getNodeAddresses = getNodeAddresses;

function getPeers(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      path: 'peers',
      responseType: 'json'
    });
    return response.data.peers || [];
  });
}

exports.getPeers = getPeers;

function getBlocklist(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      path: 'blocklist',
      responseType: 'json'
    });
    return response.data.peers || [];
  });
}

exports.getBlocklist = getBlocklist;

function removePeer(ky, peer) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      path: `peers/${peer}`,
      responseType: 'json',
      method: 'DELETE'
    });
    return response.data;
  });
}

exports.removePeer = removePeer;

function getTopology(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      path: `topology`,
      responseType: 'json'
    });
    return response.data;
  });
}

exports.getTopology = getTopology;

function pingPeer(ky, peer) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      path: `pingpong/${peer}`,
      responseType: 'json',
      method: 'POST'
    });
    return response.data;
  });
}

exports.pingPeer = pingPeer;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/settlements.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/settlements.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getAllSettlements = exports.getSettlements = void 0;

const http_1 = __webpack_require__(/*! ../../utils/http */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/http.js");

const settlementsEndpoint = 'settlements';
/**
 * Get amount of sent and received from settlements with a peer
 *
 * @param ky Ky debug instance
 * @param peer  Swarm address of peer
 */

function getSettlements(ky, peer) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      path: `${settlementsEndpoint}/${peer}`,
      responseType: 'json'
    });
    return response.data;
  });
}

exports.getSettlements = getSettlements;
/**
 * Get settlements with all known peers and total amount sent or received
 *
 * @param ky Ky debug instance
 */

function getAllSettlements(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      path: settlementsEndpoint,
      responseType: 'json'
    });
    return response.data;
  });
}

exports.getAllSettlements = getAllSettlements;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/stamps.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/stamps.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.diluteBatch = exports.topUpBatch = exports.createPostageBatch = exports.getPostageBatchBuckets = exports.getPostageBatch = exports.getAllPostageBatches = void 0;

const http_1 = __webpack_require__(/*! ../../utils/http */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/http.js");

const STAMPS_ENDPOINT = 'stamps';

function getAllPostageBatches(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      method: 'get',
      path: `${STAMPS_ENDPOINT}`,
      responseType: 'json'
    });
    return response.data.stamps || [];
  });
}

exports.getAllPostageBatches = getAllPostageBatches;

function getPostageBatch(ky, postageBatchId) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      method: 'get',
      path: `${STAMPS_ENDPOINT}/${postageBatchId}`,
      responseType: 'json'
    });
    return response.data;
  });
}

exports.getPostageBatch = getPostageBatch;

function getPostageBatchBuckets(ky, postageBatchId) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      method: 'get',
      path: `${STAMPS_ENDPOINT}/${postageBatchId}/buckets`,
      responseType: 'json'
    });
    return response.data;
  });
}

exports.getPostageBatchBuckets = getPostageBatchBuckets;

function createPostageBatch(ky, amount, depth, options) {
  return __awaiter(this, void 0, void 0, function* () {
    const headers = {};

    if (options === null || options === void 0 ? void 0 : options.gasPrice) {
      headers['gas-price'] = options.gasPrice.toString();
    }

    if ((options === null || options === void 0 ? void 0 : options.immutableFlag) !== undefined) {
      headers.immutable = String(options.immutableFlag);
    }

    const response = yield (0, http_1.http)(ky, {
      method: 'post',
      path: `${STAMPS_ENDPOINT}/${amount}/${depth}`,
      responseType: 'json',
      searchParams: {
        label: options === null || options === void 0 ? void 0 : options.label
      },
      headers
    });
    return response.data.batchID;
  });
}

exports.createPostageBatch = createPostageBatch;

function topUpBatch(ky, id, amount) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      method: 'patch',
      path: `${STAMPS_ENDPOINT}/topup/${id}/${amount}`,
      responseType: 'json'
    });
    return response.data.batchID;
  });
}

exports.topUpBatch = topUpBatch;

function diluteBatch(ky, id, depth) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      method: 'patch',
      path: `${STAMPS_ENDPOINT}/dilute/${id}/${depth}`,
      responseType: 'json'
    });
    return response.data.batchID;
  });
}

exports.diluteBatch = diluteBatch;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/states.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/states.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getChainState = exports.getReserveState = void 0;

const http_1 = __webpack_require__(/*! ../../utils/http */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/http.js");

const RESERVE_STATE_ENDPOINT = 'reservestate';
const CHAIN_STATE_ENDPOINT = 'chainstate';
/**
 * Get state of reserve
 *
 * @param ky Ky debug instance
 */

function getReserveState(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      method: 'get',
      path: `${RESERVE_STATE_ENDPOINT}`,
      responseType: 'json'
    });
    return response.data;
  });
}

exports.getReserveState = getReserveState;
/**
 * Get state of reserve
 *
 * @param ky Ky debug instance
 */

function getChainState(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      method: 'get',
      path: `${CHAIN_STATE_ENDPOINT}`,
      responseType: 'json'
    });
    return response.data;
  });
}

exports.getChainState = getChainState;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/status.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/status.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getVersions = exports.isSupportedApiVersion = exports.isSupportedDebugApiVersion = exports.isSupportedMainApiVersion = exports.isSupportedExactVersion = exports.isSupportedVersion = exports.getNodeInfo = exports.getHealth = exports.SUPPORTED_BEE_VERSION = exports.SUPPORTED_DEBUG_API_VERSION = exports.SUPPORTED_API_VERSION = exports.SUPPORTED_BEE_VERSION_EXACT = void 0;

const http_1 = __webpack_require__(/*! ../../utils/http */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/http.js");

const major_js_1 = __importDefault(__webpack_require__(/*! semver/functions/major.js */ "./node_modules/@ethersphere/bee-js/node_modules/semver/functions/major.js")); // Following lines bellow are automatically updated with GitHub Action when Bee version is updated
// so if you are changing anything about them change the `update_bee` action accordingly!


exports.SUPPORTED_BEE_VERSION_EXACT = '1.4.3-1213e063';
exports.SUPPORTED_API_VERSION = '2.0.0';
exports.SUPPORTED_DEBUG_API_VERSION = '1.2.1';
exports.SUPPORTED_BEE_VERSION = exports.SUPPORTED_BEE_VERSION_EXACT.substring(0, exports.SUPPORTED_BEE_VERSION_EXACT.indexOf('-'));
const NODE_INFO_URL = 'node';
const HEALTH_URL = 'health';
/**
 * Get health of node
 *
 * @param ky Ky debug instance
 */

function getHealth(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      method: 'get',
      path: HEALTH_URL,
      responseType: 'json'
    });
    return response.data;
  });
}

exports.getHealth = getHealth;
/**
 * Get information about Bee node
 *
 * @param ky Ky debug instance
 */

function getNodeInfo(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      method: 'get',
      path: NODE_INFO_URL,
      responseType: 'json'
    });
    return response.data;
  });
}

exports.getNodeInfo = getNodeInfo;
/**
 * Connects to a node and checks if it is a supported Bee version by the bee-js
 *
 * @param ky Ky debug instance
 *
 * @returns true if the Bee node version is supported
 * @deprecated Use `isSupportedExactVersion` instead
 */

function isSupportedVersion(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    return isSupportedExactVersion(ky);
  });
}

exports.isSupportedVersion = isSupportedVersion;
/**
 * Connects to a node and checks if its version matches with the one that bee-js supports.
 *
 * Be aware that this is the most strict version check and most probably
 * you will want to use more relaxed API-versions based checks like
 * `isSupportedApiVersion`, `isSupportedMainApiVersion` or `isSupportedDebugApiVersion`
 * based on your use-case.
 *
 * @param ky
 */

function isSupportedExactVersion(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    const {
      version
    } = yield getHealth(ky);
    return version === exports.SUPPORTED_BEE_VERSION_EXACT;
  });
}

exports.isSupportedExactVersion = isSupportedExactVersion;
/**
 * Connects to a node and checks if its main's API version matches with the one that bee-js supports.
 *
 * This is useful if you are not using `BeeDebug` class (for anything else then this check)
 * and want to make sure about compatibility.
 *
 * @param ky
 */

function isSupportedMainApiVersion(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    const {
      apiVersion
    } = yield getHealth(ky);
    return (0, major_js_1.default)(apiVersion) === (0, major_js_1.default)(exports.SUPPORTED_API_VERSION);
  });
}

exports.isSupportedMainApiVersion = isSupportedMainApiVersion;
/**
 * Connects to a node and checks if its Debug API version matches with the one that bee-js supports.
 *
 * This is useful if you are not using `Bee` class in your application and want to make sure
 * about compatibility.
 *
 * @param ky
 */

function isSupportedDebugApiVersion(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    const {
      debugApiVersion
    } = yield getHealth(ky);
    return (0, major_js_1.default)(debugApiVersion) === (0, major_js_1.default)(exports.SUPPORTED_DEBUG_API_VERSION);
  });
}

exports.isSupportedDebugApiVersion = isSupportedDebugApiVersion;
/**
 * Connects to a node and checks if its Main and Debug API versions matches with the one that bee-js supports.
 *
 * This should be the main way how to check compatibility for your app and Bee node.
 *
 * @param ky
 */

function isSupportedApiVersion(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    const {
      apiVersion,
      debugApiVersion
    } = yield getHealth(ky);
    return (0, major_js_1.default)(apiVersion) === (0, major_js_1.default)(exports.SUPPORTED_API_VERSION) && (0, major_js_1.default)(debugApiVersion) === (0, major_js_1.default)(exports.SUPPORTED_DEBUG_API_VERSION);
  });
}

exports.isSupportedApiVersion = isSupportedApiVersion;
/**
 * Returns object with all versions specified by the connected Bee node (properties prefixed with `bee*`)
 * and versions that bee-js supports (properties prefixed with `supported*`).
 *
 * @param ky
 */

function getVersions(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    const {
      version,
      apiVersion,
      debugApiVersion
    } = yield getHealth(ky);
    return {
      supportedBeeVersion: exports.SUPPORTED_BEE_VERSION_EXACT,
      supportedBeeApiVersion: exports.SUPPORTED_API_VERSION,
      supportedBeeDebugApiVersion: exports.SUPPORTED_DEBUG_API_VERSION,
      beeVersion: version,
      beeApiVersion: apiVersion,
      beeDebugApiVersion: debugApiVersion
    };
  });
}

exports.getVersions = getVersions;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/tag.js":
/*!************************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/tag.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.retrieveExtendedTag = void 0;

const http_1 = __webpack_require__(/*! ../../utils/http */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/http.js");

const endpoint = 'tags';
/**
 * Retrieve tag with extended information from Bee node
 *
 * @param ky Ky debug instance
 * @param uid UID of tag to be retrieved
 */

function retrieveExtendedTag(ky, uid) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      path: `${endpoint}/${uid}`,
      responseType: 'json'
    });
    return response.data;
  });
}

exports.retrieveExtendedTag = retrieveExtendedTag;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/transactions.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/modules/debug/transactions.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.cancelTransaction = exports.rebroadcastTransaction = exports.getTransaction = exports.getAllTransactions = void 0;

const http_1 = __webpack_require__(/*! ../../utils/http */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/http.js");

const transactionsEndpoint = 'transactions';
/**
 * Get list of all pending transactions
 *
 * @param ky   Debug Ky instance
 */

function getAllTransactions(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      path: transactionsEndpoint,
      responseType: 'json'
    });
    return response.data.pendingTransactions;
  });
}

exports.getAllTransactions = getAllTransactions;
/**
 * Get information for specific pending transactions
 *
 * @param ky   Debug Ky instance
 * @param transactionHash Hash of the transaction
 */

function getTransaction(ky, transactionHash) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      path: `${transactionsEndpoint}/${transactionHash}`,
      responseType: 'json'
    });
    return response.data;
  });
}

exports.getTransaction = getTransaction;
/**
 * Rebroadcast existing transaction
 *
 * @param ky   Debug Ky instance
 * @param transactionHash Hash of the transaction
 */

function rebroadcastTransaction(ky, transactionHash) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      method: 'post',
      path: `${transactionsEndpoint}/${transactionHash}`,
      responseType: 'json'
    });
    return response.data.transactionHash;
  });
}

exports.rebroadcastTransaction = rebroadcastTransaction;
/**
 * Cancel existing transaction
 *
 * @param ky   Debug Ky instance
 * @param transactionHash Hash of the transaction
 * @param gasPrice Optional gas price
 */

function cancelTransaction(ky, transactionHash, gasPrice) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      method: 'delete',
      headers: {
        'gas-price': gasPrice
      },
      path: `${transactionsEndpoint}/${transactionHash}`,
      responseType: 'json'
    });
    return response.data.transactionHash;
  });
}

exports.cancelTransaction = cancelTransaction;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/feed.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/modules/feed.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.fetchFeedUpdate = exports.createFeedManifest = void 0;

const http_1 = __webpack_require__(/*! ../utils/http */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/http.js");

const headers_1 = __webpack_require__(/*! ../utils/headers */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/headers.js");

const error_1 = __webpack_require__(/*! ../utils/error */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/error.js");

const feedEndpoint = 'feeds';
/**
 * Create an initial feed root manifest
 *
 * @param ky Ky instance
 * @param owner           Owner's ethereum address in hex
 * @param topic           Topic in hex
 * @param postageBatchId  Postage BatchId to be used to create the Feed Manifest
 * @param options         Additional options, like type (default: 'sequence')
 */

function createFeedManifest(ky, owner, topic, postageBatchId, options) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      method: 'post',
      responseType: 'json',
      path: `${feedEndpoint}/${owner}/${topic}`,
      searchParams: (0, http_1.filterHeaders)(options),
      headers: (0, headers_1.extractUploadHeaders)(postageBatchId)
    });
    return response.data.reference;
  });
}

exports.createFeedManifest = createFeedManifest;

function readFeedUpdateHeaders(headers) {
  const feedIndex = headers.get('swarm-feed-index');
  const feedIndexNext = headers.get('swarm-feed-index-next');

  if (!feedIndex) {
    throw new error_1.BeeError('Response did not contain expected swarm-feed-index!');
  }

  if (!feedIndexNext) {
    throw new error_1.BeeError('Response did not contain expected swarm-feed-index-next!');
  }

  return {
    feedIndex,
    feedIndexNext
  };
}
/**
 * Find and retrieve feed update
 *
 * The feed consists of updates. This endpoint looks up an
 * update that matches the provided parameters and returns
 * the reference it contains along with its index and the
 * index of the subsequent update.
 *
 * @param ky Ky instance
 * @param owner       Owner's ethereum address in hex
 * @param topic       Topic in hex
 * @param options     Additional options, like index, at, type
 */


function fetchFeedUpdate(ky, owner, topic, options) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      responseType: 'json',
      path: `${feedEndpoint}/${owner}/${topic}`,
      searchParams: (0, http_1.filterHeaders)(options)
    });
    return Object.assign(Object.assign({}, response.data), readFeedUpdateHeaders(response.headers));
  });
}

exports.fetchFeedUpdate = fetchFeedUpdate;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/pinning.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/modules/pinning.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getAllPins = exports.getPin = exports.unpin = exports.pin = void 0;

const http_1 = __webpack_require__(/*! ../utils/http */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/http.js");

const PINNING_ENDPOINT = 'pins';
/**
 * Pin data with given reference
 *
 * @param ky Ky instance for given Bee class instance
 * @param reference Bee data reference
 */

function pin(ky, reference) {
  return __awaiter(this, void 0, void 0, function* () {
    yield (0, http_1.http)(ky, {
      method: 'post',
      responseType: 'json',
      path: `${PINNING_ENDPOINT}/${reference}`
    });
  });
}

exports.pin = pin;
/**
 * Unpin data with given reference
 *
 * @param ky Ky instance for given Bee class instance
 * @param reference Bee data reference
 */

function unpin(ky, reference) {
  return __awaiter(this, void 0, void 0, function* () {
    yield (0, http_1.http)(ky, {
      method: 'delete',
      responseType: 'json',
      path: `${PINNING_ENDPOINT}/${reference}`
    });
  });
}

exports.unpin = unpin;
/**
 * Get pin status for specific address.
 *
 * @param ky Ky instance
 * @param reference
 * @throws Error if given address is not pinned
 */

function getPin(ky, reference) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      method: 'get',
      responseType: 'json',
      path: `${PINNING_ENDPOINT}/${reference}`
    });
    return response.data;
  });
}

exports.getPin = getPin;
/**
 * Get list of all pins
 *
 * @param ky Ky instance
 */

function getAllPins(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      method: 'get',
      responseType: 'json',
      path: `${PINNING_ENDPOINT}`
    });
    const result = response.data.references;

    if (result === null) {
      return [];
    }

    return result;
  });
}

exports.getAllPins = getAllPins;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/pss.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/modules/pss.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.subscribe = exports.send = void 0;

const isomorphic_ws_1 = __importDefault(__webpack_require__(/*! isomorphic-ws */ "./node_modules/isomorphic-ws/browser.js"));

const data_1 = __webpack_require__(/*! ../utils/data */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/data.browser.js");

const http_1 = __webpack_require__(/*! ../utils/http */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/http.js");

const headers_1 = __webpack_require__(/*! ../utils/headers */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/headers.js");

const endpoint = 'pss';
/**
 * Send to recipient or target with Postal Service for Swarm
 *
 * @param ky Ky instance for given Bee class instance
 * @param topic Topic name
 * @param target Target message address prefix
 * @param data
 * @param postageBatchId Postage BatchId that will be assigned to sent message
 * @param recipient Recipient public key
 *
 */

function send(ky, topic, target, data, postageBatchId, recipient) {
  return __awaiter(this, void 0, void 0, function* () {
    yield (0, http_1.http)(ky, {
      method: 'post',
      path: `${endpoint}/send/${topic}/${target}`,
      body: yield (0, data_1.prepareData)(data),
      responseType: 'json',
      searchParams: {
        recipient
      },
      headers: (0, headers_1.extractUploadHeaders)(postageBatchId)
    });
  });
}

exports.send = send;
/**
 * Subscribe for messages on the given topic
 *
 * @param url Bee node URL
 * @param topic Topic name
 */

function subscribe(url, topic) {
  const wsUrl = url.replace(/^http/i, 'ws');
  return new isomorphic_ws_1.default(`${wsUrl}/${endpoint}/subscribe/${topic}`);
}

exports.subscribe = subscribe;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/soc.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/modules/soc.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.upload = void 0;

const headers_1 = __webpack_require__(/*! ../utils/headers */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/headers.js");

const http_1 = __webpack_require__(/*! ../utils/http */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/http.js");

const socEndpoint = 'soc';
/**
 * Upload single owner chunk (SOC) to a Bee node
 *
 * @param ky Ky instance
 * @param owner           Owner's ethereum address in hex
 * @param identifier      Arbitrary identifier in hex
 * @param signature       Signature in hex
 * @param data            Content addressed chunk data to be uploaded
 * @param postageBatchId  Postage BatchId that will be assigned to uploaded data
 * @param options         Additional options like tag, encryption, pinning
 */

function upload(ky, owner, identifier, signature, data, postageBatchId, options) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      method: 'post',
      path: `${socEndpoint}/${owner}/${identifier}`,
      body: data,
      headers: Object.assign({
        'content-type': 'application/octet-stream'
      }, (0, headers_1.extractUploadHeaders)(postageBatchId, options)),
      responseType: 'json',
      searchParams: {
        sig: signature
      }
    });
    return response.data.reference;
  });
}

exports.upload = upload;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/status.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/modules/status.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.checkConnection = void 0;

const http_1 = __webpack_require__(/*! ../utils/http */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/http.js");
/**
 * Ping the base bee URL. If connection was not successful throw error
 *
 * @param ky Ky instance for given Bee class instance
 */


function checkConnection(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    yield (0, http_1.http)(ky, {
      path: ''
    });
  });
}

exports.checkConnection = checkConnection;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/stewardship.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/modules/stewardship.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.isRetrievable = exports.reupload = void 0;

const http_1 = __webpack_require__(/*! ../utils/http */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/http.js");

const stewardshipEndpoint = 'stewardship';
/**
 * Reupload locally pinned data
 * @param ky Ky instance
 * @param reference
 * @param options
 * @throws BeeResponseError if not locally pinned or invalid data
 */

function reupload(ky, reference) {
  return __awaiter(this, void 0, void 0, function* () {
    yield (0, http_1.http)(ky, {
      method: 'put',
      path: `${stewardshipEndpoint}/${reference}`
    });
  });
}

exports.reupload = reupload;

function isRetrievable(ky, reference) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      method: 'get',
      responseType: 'json',
      path: `${stewardshipEndpoint}/${reference}`
    });
    return response.data.isRetrievable;
  });
}

exports.isRetrievable = isRetrievable;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/modules/tag.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/modules/tag.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.updateTag = exports.deleteTag = exports.getAllTags = exports.retrieveTag = exports.createTag = void 0;

const http_1 = __webpack_require__(/*! ../utils/http */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/http.js");

const endpoint = 'tags';
/**
 * Create new tag on the Bee node
 *
 * @param url Bee tag URL
 */

function createTag(ky) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      method: 'post',
      path: endpoint,
      responseType: 'json'
    });
    return response.data;
  });
}

exports.createTag = createTag;
/**
 * Retrieve tag information from Bee node
 *
 * @param url Bee tag URL
 * @param uid UID of tag to be retrieved
 */

function retrieveTag(ky, uid) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      path: `${endpoint}/${uid}`,
      responseType: 'json'
    });
    return response.data;
  });
}

exports.retrieveTag = retrieveTag;
/**
 * Get limited listing of all tags.
 *
 * @param url
 * @param offset
 * @param limit
 */

function getAllTags(ky, offset, limit) {
  return __awaiter(this, void 0, void 0, function* () {
    const response = yield (0, http_1.http)(ky, {
      path: `${endpoint}`,
      searchParams: {
        offset,
        limit
      },
      responseType: 'json'
    });
    return response.data.tags;
  });
}

exports.getAllTags = getAllTags;
/**
 * Removes tag from the Bee node.
 * @param url
 * @param uid
 */

function deleteTag(ky, uid) {
  return __awaiter(this, void 0, void 0, function* () {
    yield (0, http_1.http)(ky, {
      method: 'delete',
      path: `${endpoint}/${uid}`
    });
  });
}

exports.deleteTag = deleteTag;
/**
 * Updates tag
 * @param url
 * @param uid
 * @param reference
 */

function updateTag(ky, uid, reference) {
  return __awaiter(this, void 0, void 0, function* () {
    yield (0, http_1.http)(ky, {
      method: 'patch',
      path: `${endpoint}/${uid}`,
      json: {
        reference
      }
    });
  });
}

exports.updateTag = updateTag;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/types/debug.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/types/debug.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BeeModes = void 0;
var BeeModes;

(function (BeeModes) {
  BeeModes["FULL"] = "full";
  BeeModes["LIGHT"] = "light";
  BeeModes["DEV"] = "dev";
})(BeeModes = exports.BeeModes || (exports.BeeModes = {}));

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/types/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/types/index.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __exportStar = this && this.__exportStar || function (m, exports) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.SIGNATURE_BYTES_LENGTH = exports.SIGNATURE_HEX_LENGTH = exports.TOPIC_HEX_LENGTH = exports.TOPIC_BYTES_LENGTH = exports.TAGS_LIMIT_MAX = exports.TAGS_LIMIT_MIN = exports.STAMPS_DEPTH_MAX = exports.STAMPS_DEPTH_MIN = exports.ENCRYPTED_REFERENCE_BYTES_LENGTH = exports.REFERENCE_BYTES_LENGTH = exports.ENCRYPTED_REFERENCE_HEX_LENGTH = exports.REFERENCE_HEX_LENGTH = exports.BATCH_ID_HEX_LENGTH = exports.PUBKEY_HEX_LENGTH = exports.PSS_TARGET_HEX_LENGTH_MAX = exports.ADDRESS_HEX_LENGTH = exports.CHUNK_SIZE = exports.BRANCHES = exports.SECTION_SIZE = exports.SPAN_SIZE = void 0;

__exportStar(__webpack_require__(/*! ./debug */ "./node_modules/@ethersphere/bee-js/dist/cjs/types/debug.js"), exports);

exports.SPAN_SIZE = 8;
exports.SECTION_SIZE = 32;
exports.BRANCHES = 128;
exports.CHUNK_SIZE = exports.SECTION_SIZE * exports.BRANCHES;
exports.ADDRESS_HEX_LENGTH = 64;
exports.PSS_TARGET_HEX_LENGTH_MAX = 6;
exports.PUBKEY_HEX_LENGTH = 66;
exports.BATCH_ID_HEX_LENGTH = 64;
exports.REFERENCE_HEX_LENGTH = 64;
exports.ENCRYPTED_REFERENCE_HEX_LENGTH = 128;
exports.REFERENCE_BYTES_LENGTH = 32;
exports.ENCRYPTED_REFERENCE_BYTES_LENGTH = 64;
/**
 * Minimal depth that can be used for creation of postage batch
 */

exports.STAMPS_DEPTH_MIN = 17;
/**
 * Maximal depth that can be used for creation of postage batch
 */

exports.STAMPS_DEPTH_MAX = 255;
exports.TAGS_LIMIT_MIN = 1;
exports.TAGS_LIMIT_MAX = 1000;
/*********************************************************
 * Writers and Readers interfaces
 */

exports.TOPIC_BYTES_LENGTH = 32;
exports.TOPIC_HEX_LENGTH = 64;
/*********************************************************
 * Ethereum compatible signing interfaces and definitions
 */

exports.SIGNATURE_HEX_LENGTH = 130;
exports.SIGNATURE_BYTES_LENGTH = 65;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/bytes.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/utils/bytes.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.wrapBytesWithHelpers = exports.makeBytes = exports.bytesEqual = exports.flexBytesAtOffset = exports.bytesAtOffset = exports.assertFlexBytes = exports.isFlexBytes = exports.assertBytes = exports.isBytes = void 0;

const hex_1 = __webpack_require__(/*! ./hex */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/hex.js");
/**
 * Type guard for `Bytes<T>` type
 *
 * @param b       The byte array
 * @param length  The length of the byte array
 */


function isBytes(b, length) {
  return b instanceof Uint8Array && b.length === length;
}

exports.isBytes = isBytes;
/**
 * Verifies if a byte array has a certain length
 *
 * @param b       The byte array
 * @param length  The specified length
 */

function assertBytes(b, length) {
  if (!isBytes(b, length)) {
    throw new TypeError(`Parameter is not valid Bytes of length: ${length} !== ${b.length}`);
  }
}

exports.assertBytes = assertBytes;
/**
 * Type guard for FlexBytes<Min,Max> type
 *
 * @param b       The byte array
 * @param min     Minimum size of the array
 * @param max     Maximum size of the array
 */

function isFlexBytes(b, min, max) {
  return b instanceof Uint8Array && b.length >= min && b.length <= max;
}

exports.isFlexBytes = isFlexBytes;
/**
 * Verifies if a byte array has a certain length between min and max
 *
 * @param b       The byte array
 * @param min     Minimum size of the array
 * @param max     Maximum size of the array
 */

function assertFlexBytes(b, min, max) {
  if (!isFlexBytes(b, min, max)) {
    throw new TypeError(`Parameter is not valid FlexBytes of  min: ${min}, max: ${max}, length: ${b.length}`);
  }
}

exports.assertFlexBytes = assertFlexBytes;
/**
 * Return `length` bytes starting from `offset`
 *
 * @param data   The original data
 * @param offset The offset to start from
 * @param length The length of data to be returned
 */

function bytesAtOffset(data, offset, length) {
  const offsetBytes = data.slice(offset, offset + length); // We are returning strongly typed Bytes so we have to verify that length is really what we claim

  assertBytes(offsetBytes, length);
  return offsetBytes;
}

exports.bytesAtOffset = bytesAtOffset;
/**
 * Return flex bytes starting from `offset`
 *
 * @param data   The original data
 * @param offset The offset to start from
 * @param _min   The minimum size of the data
 * @param _max   The maximum size of the data
 */

function flexBytesAtOffset(data, offset, // eslint-disable-next-line @typescript-eslint/no-unused-vars
_min, // eslint-disable-next-line @typescript-eslint/no-unused-vars
_max) {
  return data.slice(offset);
}

exports.flexBytesAtOffset = flexBytesAtOffset;
/**
 * Returns true if two byte arrays are equal
 *
 * @param a Byte array to compare
 * @param b Byte array to compare
 */

function bytesEqual(a, b) {
  return a.length === b.length && a.every((value, index) => value === b[index]);
}

exports.bytesEqual = bytesEqual;
/**
 * Returns a new byte array filled with zeroes with the specified length
 *
 * @param length The length of data to be returned
 */

function makeBytes(length) {
  return new Uint8Array(length);
}

exports.makeBytes = makeBytes;

function wrapBytesWithHelpers(data) {
  return Object.assign(data, {
    text: () => new TextDecoder('utf-8').decode(data),
    json: () => JSON.parse(new TextDecoder('utf-8').decode(data)),
    hex: () => (0, hex_1.bytesToHex)(data)
  });
}

exports.wrapBytesWithHelpers = wrapBytesWithHelpers;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/collection.browser.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/utils/collection.browser.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getFolderSize = exports.makeCollectionFromFS = void 0;
/**
 * Creates array in the format of Collection with data loaded from directory on filesystem.
 * The function loads all the data into memory!
 *
 * @param dir path to the directory
 */

function makeCollectionFromFS(dir) {
  return __awaiter(this, void 0, void 0, function* () {
    throw new Error('Creating Collection from File System is not supported in browsers!');
  });
}

exports.makeCollectionFromFS = makeCollectionFromFS;
/**
 * Calculate folder size recursively
 *
 * @param dir the path to the folder to check
 * @returns size in bytes
 */

function getFolderSize(dir) {
  return __awaiter(this, void 0, void 0, function* () {
    throw new Error('Creating Collection from File System is not supported in browsers!');
  });
}

exports.getFolderSize = getFolderSize;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/collection.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/utils/collection.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getCollectionSize = exports.makeCollectionFromFileList = exports.assertCollection = exports.isCollection = void 0;

const error_1 = __webpack_require__(/*! ./error */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/error.js");

const file_1 = __webpack_require__(/*! ./file */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/file.js");

const type_1 = __webpack_require__(/*! ./type */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/type.js");

function isCollection(data) {
  if (!Array.isArray(data)) {
    return false;
  }

  return data.every(entry => typeof entry === 'object' && entry.data && entry.path && (0, type_1.isUint8Array)(entry.data));
}

exports.isCollection = isCollection;

function assertCollection(data) {
  if (!isCollection(data)) {
    throw new error_1.BeeArgumentError('invalid collection', data);
  }
}

exports.assertCollection = assertCollection;

function makeFilePath(file) {
  if (file.webkitRelativePath && file.webkitRelativePath !== '') {
    return file.webkitRelativePath.replace(/.*?\//i, '');
  }

  if (file.name) {
    return file.name;
  }

  throw new TypeError('file is not valid File object');
}

function makeCollectionFromFileList(fileList) {
  return __awaiter(this, void 0, void 0, function* () {
    const collection = [];

    for (let i = 0; i < fileList.length; i++) {
      const file = fileList[i];

      if (file) {
        collection.push({
          path: makeFilePath(file),
          data: new Uint8Array(yield (0, file_1.fileArrayBuffer)(file))
        });
      }
    }

    return collection;
  });
}

exports.makeCollectionFromFileList = makeCollectionFromFileList;
/**
 * Calculate cumulative size of files
 *
 * @param fileList list of files to check
 * @returns size in bytes
 */

function getCollectionSize(fileList) {
  let sum = 0;

  for (let i = 0; i < fileList.length; i++) {
    const file = fileList[i];

    if (file) {
      sum += file.size;
    }
  }

  return sum;
}

exports.getCollectionSize = getCollectionSize;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/data.browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/utils/data.browser.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.prepareWebsocketData = exports.prepareData = void 0;

const stream_1 = __webpack_require__(/*! ./stream */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/stream.js");

const cross_blob_1 = __importDefault(__webpack_require__(/*! cross-blob */ "./node_modules/cross-blob/browser.js"));
/**
 * Validates input and converts to Uint8Array
 *
 * @param data any string, ArrayBuffer or Uint8Array
 */


function prepareData(data) {
  return __awaiter(this, void 0, void 0, function* () {
    if (typeof data === 'string') return new cross_blob_1.default([data], {
      type: 'text/plain'
    });

    if (data instanceof Uint8Array || data instanceof ArrayBuffer) {
      return new cross_blob_1.default([data], {
        type: 'application/octet-stream'
      });
    }

    if (data instanceof cross_blob_1.default) {
      return data;
    } // Currently it is not possible to stream requests from browsers
    // there are already first experiments on this field (Chromium)
    // but till it is fully implemented across browsers-land we have to
    // buffer the data before sending the requests.


    if ((0, stream_1.isNodeReadable)(data)) {
      return new Promise(resolve => {
        const buffers = [];
        data.on('data', d => {
          buffers.push(d);
        });
        data.on('end', () => {
          resolve(new cross_blob_1.default(buffers, {
            type: 'application/octet-stream'
          }));
        });
      });
    }

    if ((0, stream_1.isReadableStream)(data)) {
      return new Promise(resolve => __awaiter(this, void 0, void 0, function* () {
        const reader = data.getReader();
        const buffers = [];
        let done, value;

        do {
          ;
          ({
            done,
            value
          } = yield reader.read());

          if (!done) {
            buffers.push(value);
          }
        } while (!done);

        resolve(new cross_blob_1.default(buffers, {
          type: 'application/octet-stream'
        }));
      }));
    }

    throw new TypeError('unknown data type');
  });
}

exports.prepareData = prepareData;

function prepareWebsocketData(data) {
  return __awaiter(this, void 0, void 0, function* () {
    if (typeof data === 'string') return new TextEncoder().encode(data);
    if (data instanceof ArrayBuffer) return new Uint8Array(data);
    if (data instanceof cross_blob_1.default) return new Uint8Array(yield new Response(data).arrayBuffer());
    throw new TypeError('unknown websocket data type');
  });
}

exports.prepareWebsocketData = prepareWebsocketData;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/error.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/utils/error.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.BeeNotAJsonError = exports.BeeResponseError = exports.BeeRequestError = exports.BeeArgumentError = exports.BeeError = void 0;

class BeeError extends Error {
  constructor(message) {
    super(message);
  }

}

exports.BeeError = BeeError;

class BeeArgumentError extends BeeError {
  constructor(message, value) {
    super(message);
    this.value = value;
  }

}

exports.BeeArgumentError = BeeArgumentError;

class BeeRequestError extends BeeError {
  /**
   * @param message
   * @param requestOptions KyOptions that were used to assemble the request. THIS MIGHT NOT BE COMPLETE! If custom Ky instance was used that has set defaults then these defaults are not visible in this object!
   */
  constructor(message, requestOptions) {
    super(message);
    this.requestOptions = requestOptions;
  }

}

exports.BeeRequestError = BeeRequestError;

class BeeResponseError extends BeeError {
  /**
   * @param status HTTP status code number
   * @param response Response returned from the server
   * @param responseBody Response body as string which is returned from response.text() call
   * @param requestOptions KyOptions that were used to assemble the request. THIS MIGHT NOT BE COMPLETE! If custom Ky instance was used that has set defaults then these defaults are not visible in this object!
   * @param message
   */
  constructor(status, response, responseBody, requestOptions, message) {
    super(message);
    this.status = status;
    this.response = response;
    this.responseBody = responseBody;
    this.requestOptions = requestOptions;
  }

}

exports.BeeResponseError = BeeResponseError;

class BeeNotAJsonError extends BeeError {
  constructor() {
    super(`Received response is not valid JSON.`);
  }

}

exports.BeeNotAJsonError = BeeNotAJsonError;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/eth.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/utils/eth.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.makeEthereumWalletSigner = exports.ethToSwarmAddress = exports.fromLittleEndian = exports.toLittleEndian = exports.isHexEthAddress = exports.makeHexEthAddress = exports.makeEthAddress = void 0; // For ESM compatibility

const js_sha3_1 = __importDefault(__webpack_require__(/*! js-sha3 */ "./node_modules/js-sha3/src/sha3.js"));

const {
  keccak256,
  sha3_256
} = js_sha3_1.default;

const hex_1 = __webpack_require__(/*! ./hex */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/hex.js");

const bytes_1 = __webpack_require__(/*! ./bytes */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/bytes.js");

const ETH_ADDR_BYTES_LENGTH = 20;
const ETH_ADDR_HEX_LENGTH = 40;

function makeEthAddress(address) {
  if (typeof address === 'string') {
    const hexAddr = (0, hex_1.makeHexString)(address, ETH_ADDR_HEX_LENGTH);
    const ownerBytes = (0, hex_1.hexToBytes)(hexAddr);
    (0, bytes_1.assertBytes)(ownerBytes, ETH_ADDR_BYTES_LENGTH);
    return ownerBytes;
  } else if (address instanceof Uint8Array) {
    (0, bytes_1.assertBytes)(address, ETH_ADDR_BYTES_LENGTH);
    return address;
  }

  throw new TypeError('Invalid EthAddress');
}

exports.makeEthAddress = makeEthAddress;

function makeHexEthAddress(address) {
  try {
    return (0, hex_1.makeHexString)(address, ETH_ADDR_HEX_LENGTH);
  } catch (e) {
    if (e instanceof TypeError) {
      e.message = `Invalid HexEthAddress: ${e.message}`;
    }

    throw e;
  }
}

exports.makeHexEthAddress = makeHexEthAddress;
/**
 * Check if this is all caps or small caps eth address (=address without checksum)
 *
 * @param address Ethereum address as hex string
 */

function isEthAddrCaseIns(address) {
  // Check it's string, all small caps or all all caps hex and 40 chars long without the `0x` prefix
  return typeof address === 'string' && (/^(0x|0X)?[0-9a-f]{40}$/.test(address) || /^(0x|0X)?[0-9A-F]{40}$/.test(address));
}
/**
 * Check if this is checksummed ethereum address
 *
 * @param address Ethereum address as hex string
 */


function isValidChecksummedEthAddress(address) {
  try {
    // Check for valid case insensitive hex type string, 40 chars
    const addr = (0, hex_1.makeHexString)(address, ETH_ADDR_HEX_LENGTH); // Check the checksum

    const addressHash = keccak256(addr.toLowerCase());

    for (let i = 0; i < 40; i += 1) {
      // the nth letter should be uppercase if the nth digit of casemap is 1
      if (parseInt(addressHash[i], 16) > 7 && addr[i].toUpperCase() !== addr[i] || parseInt(addressHash[i], 16) <= 7 && addr[i].toLowerCase() !== addr[i]) {
        return false;
      }
    }

    return true;
  } catch (e) {
    if (e instanceof TypeError) {
      return false;
    }

    throw e;
  }
}
/**
 * Check if is valid ethereum address
 *
 * Pretty much typed version from web3js
 * https://github.com/ChainSafe/web3.js/blob/1.x/packages/web3-utils/src/utils.js
 *
 * @param address  Ethereum address as hex string
 *
 * @return True if is valid eth address
 */


function isHexEthAddress(address) {
  return isEthAddrCaseIns(address) || isValidChecksummedEthAddress(address);
}

exports.isHexEthAddress = isHexEthAddress;
/**
 * Convert big-endian hex or number to little-endian.
 * Note: Before conversion it is automatically padded to even length hexstring
 *
 * @param bigEndian Big-endian hex string or number to convert
 * @param pad       Length to which the string should be padded before conversion (defaul: 2)
 *
 * @return little-endian encoded hexstring
 */

function toLittleEndian(bigEndian, pad = 2) {
  var _a;

  if (!(Number.isInteger(pad) && pad >= 2 && pad % 2 === 0)) {
    throw new TypeError('minimal padding for conversion needs to be positive even integer');
  }

  let hexRep;
  if (typeof bigEndian === 'string') hexRep = (0, hex_1.makeHexString)(bigEndian);else if (typeof bigEndian === 'number') hexRep = (0, hex_1.intToHex)(bigEndian);else throw new TypeError('incorrect input type');
  hexRep = hexRep.padStart(pad, '0'); // Extend to an even length hexstring

  if (hexRep.length % 2 !== 0) hexRep = hexRep.padStart(hexRep.length + 1, '0'); // Match all two pairs in the hexstring, reverse the pairs and join it again

  const littleEndian = (_a = hexRep.match(/../g)) === null || _a === void 0 ? void 0 : _a.reverse().join('');
  if (littleEndian) return littleEndian;
  throw new Error('failed to convert');
}

exports.toLittleEndian = toLittleEndian;
/**
 * Convert little-endian hex or number to big-endian
 * Note: Before conversion it is automatically padded to even length hexstring
 *
 * @param littleEndian Little-endian hex string or number to convert
 * @param pad          Length to which the string should be padded before conversion (defaul: 2)
 *
 * @return big-endian encoded hexstring
 */

function fromLittleEndian(littleEndian, pad = 2) {
  // It's a reversible function
  return toLittleEndian(littleEndian, pad);
}

exports.fromLittleEndian = fromLittleEndian;

function assertEthAddress(ethAddress) {
  if (!isHexEthAddress(ethAddress)) throw new TypeError('invalid ETH address');
}

function assertSwarmNetworkId(networkId) {
  if (Number.isInteger(networkId && networkId > 0 && networkId < Number.MAX_SAFE_INTEGER)) {
    throw new TypeError('swarm network id must be positive integer');
  }
}
/**
 * Get swarm overlay address from public ethereum address and swarm network id
 *
 * @param ethAddress  Public ethereum address
 * @param networkId   Swarm network id
 *
 * @return Swarm overlay address
 */


function ethToSwarmAddress(ethAddress, networkId = 1) {
  assertEthAddress(ethAddress);
  assertSwarmNetworkId(networkId);
  const hex = `${(0, hex_1.makeHexString)(ethAddress)}${toLittleEndian(networkId, 16)}`;
  (0, hex_1.assertHexString)(hex);
  const overlayAddress = sha3_256((0, hex_1.hexToBytes)(hex));
  return overlayAddress;
}

exports.ethToSwarmAddress = ethToSwarmAddress;
/**
 * Function that takes Ethereum EIP-1193 compatible provider and create an Signer instance that
 * uses `personal_sign` method to sign requested data.
 *
 * @param provider Injected web3 provider like window.ethereum or other compatible with EIP-1193
 * @param ethAddress Optional address of the account which the data should be signed with. If not specified `eth_requestAccounts` request is used to get the account address.
 */

function makeEthereumWalletSigner(provider, ethAddress) {
  return __awaiter(this, void 0, void 0, function* () {
    let executorFnc;

    if (typeof provider !== 'object' || provider === null) {
      throw new TypeError('We need JsonRPC provider object!');
    }

    if (provider.request) {
      executorFnc = provider.request;
    } else if (provider.sendAsync) {
      executorFnc = provider.sendAsync;
    } else {
      throw new Error('Incompatible interface of given provider!');
    }

    if (!ethAddress) {
      ethAddress = (yield executorFnc({
        method: 'eth_requestAccounts'
      }))[0];
    }

    const bytesEthAddress = makeEthAddress(ethAddress);
    const hexEthAddress = makeHexEthAddress(ethAddress);
    return {
      address: bytesEthAddress,
      sign: data => __awaiter(this, void 0, void 0, function* () {
        const result = yield executorFnc({
          jsonrpc: '2.0',
          method: 'personal_sign',
          params: ['0x' + data.hex(), '0x' + hexEthAddress]
        });
        return result;
      })
    };
  });
}

exports.makeEthereumWalletSigner = makeEthereumWalletSigner;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/expose.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/utils/expose.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getStampUsage = exports.makeMaxTarget = exports.keccak256Hash = exports.isReadable = exports.normalizeToReadableStream = exports.isNodeReadable = exports.isReadableStream = exports.readableNodeToWeb = exports.readableWebToNode = exports.makeEthereumWalletSigner = exports.fromLittleEndian = exports.toLittleEndian = exports.ethToSwarmAddress = exports.isHexEthAddress = exports.makeHexEthAddress = exports.makeEthAddress = exports.assertPrefixedHexString = exports.assertHexString = exports.isHexString = exports.intToHex = exports.bytesToHex = exports.hexToBytes = exports.makeHexString = exports.bytesEqual = exports.flexBytesAtOffset = exports.bytesAtOffset = exports.assertFlexBytes = exports.isFlexBytes = exports.assertBytes = exports.isBytes = exports.getFolderSize = exports.getCollectionSize = void 0;

var collection_1 = __webpack_require__(/*! ./collection */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/collection.js");

Object.defineProperty(exports, "getCollectionSize", ({
  enumerable: true,
  get: function () {
    return collection_1.getCollectionSize;
  }
}));

var collection_node_1 = __webpack_require__(/*! ./collection.node */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/collection.browser.js");

Object.defineProperty(exports, "getFolderSize", ({
  enumerable: true,
  get: function () {
    return collection_node_1.getFolderSize;
  }
}));

var bytes_1 = __webpack_require__(/*! ./bytes */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/bytes.js");

Object.defineProperty(exports, "isBytes", ({
  enumerable: true,
  get: function () {
    return bytes_1.isBytes;
  }
}));
Object.defineProperty(exports, "assertBytes", ({
  enumerable: true,
  get: function () {
    return bytes_1.assertBytes;
  }
}));
Object.defineProperty(exports, "isFlexBytes", ({
  enumerable: true,
  get: function () {
    return bytes_1.isFlexBytes;
  }
}));
Object.defineProperty(exports, "assertFlexBytes", ({
  enumerable: true,
  get: function () {
    return bytes_1.assertFlexBytes;
  }
}));
Object.defineProperty(exports, "bytesAtOffset", ({
  enumerable: true,
  get: function () {
    return bytes_1.bytesAtOffset;
  }
}));
Object.defineProperty(exports, "flexBytesAtOffset", ({
  enumerable: true,
  get: function () {
    return bytes_1.flexBytesAtOffset;
  }
}));
Object.defineProperty(exports, "bytesEqual", ({
  enumerable: true,
  get: function () {
    return bytes_1.bytesEqual;
  }
}));

var hex_1 = __webpack_require__(/*! ./hex */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/hex.js");

Object.defineProperty(exports, "makeHexString", ({
  enumerable: true,
  get: function () {
    return hex_1.makeHexString;
  }
}));
Object.defineProperty(exports, "hexToBytes", ({
  enumerable: true,
  get: function () {
    return hex_1.hexToBytes;
  }
}));
Object.defineProperty(exports, "bytesToHex", ({
  enumerable: true,
  get: function () {
    return hex_1.bytesToHex;
  }
}));
Object.defineProperty(exports, "intToHex", ({
  enumerable: true,
  get: function () {
    return hex_1.intToHex;
  }
}));
Object.defineProperty(exports, "isHexString", ({
  enumerable: true,
  get: function () {
    return hex_1.isHexString;
  }
}));
Object.defineProperty(exports, "assertHexString", ({
  enumerable: true,
  get: function () {
    return hex_1.assertHexString;
  }
}));
Object.defineProperty(exports, "assertPrefixedHexString", ({
  enumerable: true,
  get: function () {
    return hex_1.assertPrefixedHexString;
  }
}));

var eth_1 = __webpack_require__(/*! ./eth */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/eth.js");

Object.defineProperty(exports, "makeEthAddress", ({
  enumerable: true,
  get: function () {
    return eth_1.makeEthAddress;
  }
}));
Object.defineProperty(exports, "makeHexEthAddress", ({
  enumerable: true,
  get: function () {
    return eth_1.makeHexEthAddress;
  }
}));
Object.defineProperty(exports, "isHexEthAddress", ({
  enumerable: true,
  get: function () {
    return eth_1.isHexEthAddress;
  }
}));
Object.defineProperty(exports, "ethToSwarmAddress", ({
  enumerable: true,
  get: function () {
    return eth_1.ethToSwarmAddress;
  }
}));
Object.defineProperty(exports, "toLittleEndian", ({
  enumerable: true,
  get: function () {
    return eth_1.toLittleEndian;
  }
}));
Object.defineProperty(exports, "fromLittleEndian", ({
  enumerable: true,
  get: function () {
    return eth_1.fromLittleEndian;
  }
}));
Object.defineProperty(exports, "makeEthereumWalletSigner", ({
  enumerable: true,
  get: function () {
    return eth_1.makeEthereumWalletSigner;
  }
}));

var stream_1 = __webpack_require__(/*! ./stream */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/stream.js");

Object.defineProperty(exports, "readableWebToNode", ({
  enumerable: true,
  get: function () {
    return stream_1.readableWebToNode;
  }
}));
Object.defineProperty(exports, "readableNodeToWeb", ({
  enumerable: true,
  get: function () {
    return stream_1.readableNodeToWeb;
  }
}));
Object.defineProperty(exports, "isReadableStream", ({
  enumerable: true,
  get: function () {
    return stream_1.isReadableStream;
  }
}));
Object.defineProperty(exports, "isNodeReadable", ({
  enumerable: true,
  get: function () {
    return stream_1.isNodeReadable;
  }
}));
Object.defineProperty(exports, "normalizeToReadableStream", ({
  enumerable: true,
  get: function () {
    return stream_1.normalizeToReadableStream;
  }
}));
Object.defineProperty(exports, "isReadable", ({
  enumerable: true,
  get: function () {
    return stream_1.isReadable;
  }
}));

var hash_1 = __webpack_require__(/*! ./hash */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/hash.js");

Object.defineProperty(exports, "keccak256Hash", ({
  enumerable: true,
  get: function () {
    return hash_1.keccak256Hash;
  }
}));

var pss_1 = __webpack_require__(/*! ./pss */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/pss.js");

Object.defineProperty(exports, "makeMaxTarget", ({
  enumerable: true,
  get: function () {
    return pss_1.makeMaxTarget;
  }
}));

var stamps_1 = __webpack_require__(/*! ./stamps */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/stamps.js");

Object.defineProperty(exports, "getStampUsage", ({
  enumerable: true,
  get: function () {
    return stamps_1.getStampUsage;
  }
}));

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/file.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/utils/file.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";

/**
 * Compatibility functions for working with File API objects
 *
 * https://developer.mozilla.org/en-US/docs/Web/API/File
 */

var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.fileArrayBuffer = exports.isFile = void 0;

function isFile(file) {
  // browser
  if (typeof File === 'function') {
    return file instanceof File;
  } // node.js


  const f = file;
  return typeof f === 'object' && typeof f.name === 'string' && (typeof f.stream === 'function' || typeof f.arrayBuffer === 'function');
}

exports.isFile = isFile;
/**
 * Compatibility helper for browsers where the `arrayBuffer function is
 * missing from `File` objects.
 *
 * @param file A File object
 */

function fileArrayBuffer(file) {
  return __awaiter(this, void 0, void 0, function* () {
    if (file.arrayBuffer) {
      return file.arrayBuffer();
    } // workaround for Safari where arrayBuffer is not supported on Files


    return new Promise(resolve => {
      const fr = new FileReader();

      fr.onload = () => resolve(fr.result);

      fr.readAsArrayBuffer(file);
    });
  });
}

exports.fileArrayBuffer = fileArrayBuffer;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/hash.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/utils/hash.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.keccak256Hash = void 0; // For ESM compatibility

const js_sha3_1 = __importDefault(__webpack_require__(/*! js-sha3 */ "./node_modules/js-sha3/src/sha3.js"));

const {
  keccak256
} = js_sha3_1.default;
/**
 * Helper function for calculating the keccak256 hash with
 * correct types.
 *
 * @param messages Any number of messages (strings, byte arrays etc.)
 */

function keccak256Hash(...messages) {
  const hasher = keccak256.create();
  messages.forEach(bytes => hasher.update(bytes));
  return Uint8Array.from(hasher.digest());
}

exports.keccak256Hash = keccak256Hash;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/headers.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/utils/headers.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.extractUploadHeaders = exports.readFileHeaders = void 0;

const error_1 = __webpack_require__(/*! ./error */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/error.js");
/**
 * Read the filename from the content-disposition header
 * See https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Disposition
 *
 * @param header the content-disposition header value
 *
 * @returns the filename
 */


function readContentDispositionFilename(header) {
  if (!header) {
    throw new error_1.BeeError('missing content-disposition header');
  } // Regex was found here
  // https://stackoverflow.com/questions/23054475/javascript-regex-for-extracting-filename-from-content-disposition-header


  const dispositionMatch = header.match(/filename\*?=['"]?(?:UTF-\d['"]*)?([^;\r\n"']*)['"]?;?/i);

  if (dispositionMatch && dispositionMatch.length > 0) {
    return dispositionMatch[1];
  }

  throw new error_1.BeeError('invalid content-disposition header');
}

function readTagUid(header) {
  if (!header) {
    return undefined;
  }

  return parseInt(header, 10);
}

function readFileHeaders(headers) {
  const name = readContentDispositionFilename(headers.get('content-disposition'));
  const tagUid = readTagUid(headers.get('swarm-tag-uid'));
  const contentType = headers.get('content-type') || undefined;
  return {
    name,
    tagUid,
    contentType
  };
}

exports.readFileHeaders = readFileHeaders;

function extractUploadHeaders(postageBatchId, options) {
  if (!postageBatchId) {
    throw new error_1.BeeError('Postage BatchID has to be specified!');
  }

  const headers = {
    'swarm-postage-batch-id': postageBatchId
  };
  if (options === null || options === void 0 ? void 0 : options.pin) headers['swarm-pin'] = String(options.pin);
  if (options === null || options === void 0 ? void 0 : options.encrypt) headers['swarm-encrypt'] = String(options.encrypt);
  if (options === null || options === void 0 ? void 0 : options.tag) headers['swarm-tag'] = String(options.tag);
  if (typeof (options === null || options === void 0 ? void 0 : options.deferred) === 'boolean') headers['swarm-deferred-upload'] = options.deferred.toString();
  return headers;
}

exports.extractUploadHeaders = extractUploadHeaders;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/hex.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/utils/hex.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.assertPrefixedHexString = exports.assertHexString = exports.isPrefixedHexString = exports.isHexString = exports.intToHex = exports.bytesToHex = exports.hexToBytes = exports.makeHexString = void 0;

const bytes_1 = __webpack_require__(/*! ./bytes */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/bytes.js");
/**
 * Creates unprefixed hex string from wide range of data.
 *
 * TODO: Make Length mandatory: https://github.com/ethersphere/bee-js/issues/208
 *
 * @param input
 * @param len of the resulting HexString WITHOUT prefix!
 */


function makeHexString(input, len) {
  if (typeof input === 'number') {
    return intToHex(input, len);
  }

  if (input instanceof Uint8Array) {
    return bytesToHex(input, len);
  }

  if (typeof input === 'string') {
    if (isPrefixedHexString(input)) {
      const hex = input.slice(2);

      if (len && hex.length !== len) {
        throw new TypeError(`Length mismatch for valid hex string. Expecting length ${len}: ${hex}`);
      }

      return hex;
    } else {
      // We use assertHexString() as there might be more reasons why a string is not valid hex string
      // and usage of isHexString() would not give enough information to the user on what is going
      // wrong.
      assertHexString(input, len);
      return input;
    }
  }

  throw new TypeError('Not HexString compatible type!');
}

exports.makeHexString = makeHexString;
/**
 * Converts a hex string to Uint8Array
 *
 * @param hex string input without 0x prefix!
 */

function hexToBytes(hex) {
  assertHexString(hex);
  const bytes = (0, bytes_1.makeBytes)(hex.length / 2);

  for (let i = 0; i < bytes.length; i++) {
    const hexByte = hex.substr(i * 2, 2);
    bytes[i] = parseInt(hexByte, 16);
  }

  return bytes;
}

exports.hexToBytes = hexToBytes;
/**
 * Converts array of number or Uint8Array to HexString without prefix.
 *
 * @param bytes   The input array
 * @param len     The length of the non prefixed HexString
 */

function bytesToHex(bytes, len) {
  const hexByte = n => n.toString(16).padStart(2, '0');

  const hex = Array.from(bytes, hexByte).join(''); // TODO: Make Length mandatory: https://github.com/ethersphere/bee-js/issues/208

  if (len && hex.length !== len) {
    throw new TypeError(`Resulting HexString does not have expected length ${len}: ${hex}`);
  }

  return hex;
}

exports.bytesToHex = bytesToHex;
/**
 * Converts integer number to hex string.
 *
 * Optionally provides '0x' prefix or padding
 *
 * @param int         The positive integer to be converted
 * @param len     The length of the non prefixed HexString
 */

function intToHex(int, len) {
  if (!Number.isInteger(int)) throw new TypeError('the value provided is not integer');
  if (int > Number.MAX_SAFE_INTEGER) throw new TypeError('the value provided exceeds safe integer');
  if (int < 0) throw new TypeError('the value provided is a negative integer');
  const hex = int.toString(16); // TODO: Make Length mandatory: https://github.com/ethersphere/bee-js/issues/208

  if (len && hex.length !== len) {
    throw new TypeError(`Resulting HexString does not have expected length ${len}: ${hex}`);
  }

  return hex;
}

exports.intToHex = intToHex;
/**
 * Type guard for HexStrings.
 * Requires no 0x prefix!
 *
 * TODO: Make Length mandatory: https://github.com/ethersphere/bee-js/issues/208
 *
 * @param s string input
 * @param len expected length of the HexString
 */

function isHexString(s, len) {
  return typeof s === 'string' && /^[0-9a-f]+$/i.test(s) && (!len || s.length === len);
}

exports.isHexString = isHexString;
/**
 * Type guard for PrefixedHexStrings.
 * Does enforce presence of 0x prefix!
 *
 * @param s string input
 */

function isPrefixedHexString(s) {
  return typeof s === 'string' && /^0x[0-9a-f]+$/i.test(s);
}

exports.isPrefixedHexString = isPrefixedHexString;
/**
 * Verifies if the provided input is a HexString.
 *
 * TODO: Make Length mandatory: https://github.com/ethersphere/bee-js/issues/208
 *
 * @param s string input
 * @param len expected length of the HexString
 * @param name optional name for the asserted value
 * @returns HexString or throws error
 */

function assertHexString(s, len, name = 'value') {
  if (!isHexString(s, len)) {
    if (isPrefixedHexString(s)) {
      throw new TypeError(`${name} not valid non prefixed hex string (has 0x prefix): ${s}`);
    } // Don't display length error if no length specified in order not to confuse user


    const lengthMsg = len ? ` of length ${len}` : '';
    throw new TypeError(`${name} not valid hex string${lengthMsg}: ${s}`);
  }
}

exports.assertHexString = assertHexString;
/**
 * Verifies if the provided input is a PrefixedHexString.
 *
 * @param s string input
 * @param len expected length of the HexString
 * @param name optional name for the asserted value
 * @returns HexString or throws error
 */

function assertPrefixedHexString(s, name = 'value') {
  if (!isPrefixedHexString(s)) {
    throw new TypeError(`${name} not valid prefixed hex string: ${s}`);
  }
}

exports.assertPrefixedHexString = assertPrefixedHexString;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/http.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/utils/http.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __rest = this && this.__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.makeDefaultKy = exports.http = exports.filterHeaders = exports.wrapResponseClosure = exports.wrapRequestClosure = void 0;

const error_1 = __webpack_require__(/*! ./error */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/error.js");

const ky_universal_1 = __importDefault(__webpack_require__(/*! ky-universal */ "./node_modules/ky-universal/browser.js"));

const stream_1 = __webpack_require__(/*! ./stream */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/stream.js");

const merge_1 = __webpack_require__(/*! ./merge */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/merge.js");

const type_1 = __webpack_require__(/*! ./type */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/type.js");

const DEFAULT_KY_CONFIG = {
  headers: {
    accept: 'application/json, text/plain, */*',
    'user-agent': `bee-js`
  }
};

function isHttpError(e) {
  return (0, type_1.isObject)(e) && typeof e.response !== 'undefined';
}

function isHttpRequestError(e) {
  return (0, type_1.isObject)(e) && typeof e.request !== 'undefined';
}

function headersToObject(header) {
  return [...header.entries()].reduce((obj, [key, val]) => {
    obj[key] = val;
    return obj;
  }, {});
}

function wrapRequest(request) {
  return {
    url: request.url,
    method: request.method.toUpperCase(),
    headers: headersToObject(request.headers)
  };
}

function wrapRequestClosure(cb) {
  return request => __awaiter(this, void 0, void 0, function* () {
    yield cb(wrapRequest(request));
  });
}

exports.wrapRequestClosure = wrapRequestClosure;

function wrapResponseClosure(cb) {
  return (request, options, response) => __awaiter(this, void 0, void 0, function* () {
    yield cb({
      headers: headersToObject(response.headers),
      status: response.status,
      statusText: response.statusText,
      request: wrapRequest(request)
    });
  });
}

exports.wrapResponseClosure = wrapResponseClosure;
/**
 * Filters out entries that has undefined value from headers object.
 * Modifies the original object!
 *
 * @param obj
 */
// eslint-disable-next-line @typescript-eslint/ban-types

function filterHeaders(obj) {
  if (obj === undefined) {
    return undefined;
  }

  (0, type_1.isStrictlyObject)(obj);
  const typedObj = obj;

  for (const key in typedObj) {
    if (typedObj[key] === undefined) {
      delete typedObj[key];
    }
  }

  if (Object.keys(typedObj).length === 0) {
    return undefined;
  }

  return typedObj;
}

exports.filterHeaders = filterHeaders;
/**
 * Main utility function to make HTTP requests.
 * @param ky
 * @param config
 */

function http(ky, config) {
  return __awaiter(this, void 0, void 0, function* () {
    try {
      const {
        path,
        responseType
      } = config,
            kyConfig = __rest(config, ["path", "responseType"]);

      const response = yield ky(path, Object.assign(Object.assign({}, kyConfig), {
        searchParams: filterHeaders(kyConfig.searchParams)
      }));

      switch (responseType) {
        case 'stream':
          if (!response.body) {
            throw new error_1.BeeError('Response was expected to get data but did not get any!');
          }

          response.data = (0, stream_1.normalizeToReadableStream)(response.body);
          break;

        case 'arraybuffer':
          response.data = yield response.arrayBuffer();
          break;

        case 'json':
          try {
            response.data = yield response.json();
          } catch (e) {
            throw new error_1.BeeNotAJsonError();
          }

          break;

        default:
          break;
        // If responseType is not set, then no data are expected
      }

      return response;
    } catch (e) {
      // Passthrough thrown errors
      if (e instanceof error_1.BeeNotAJsonError) {
        throw e;
      }

      if (isHttpError(e)) {
        let message; // We store the response body here as it can be read only once in Response's lifecycle so to make it exposed
        // to the user in the BeeResponseError, for further analysis.

        const body = yield e.response.text();

        try {
          // The response can be Bee's JSON with structure `{code, message}` lets try to parse it
          message = JSON.parse(body).message;
        } catch (e) {}

        if (message) {
          throw new error_1.BeeResponseError(e.response.status, e.response, body, config, `${e.response.statusText}: ${message}`);
        } else {
          throw new error_1.BeeResponseError(e.response.status, e.response, body, config, e.response.statusText);
        }
      } else if (isHttpRequestError(e)) {
        throw new error_1.BeeRequestError(e.message, config);
      } else {
        throw new error_1.BeeError(e.message);
      }
    }
  });
}

exports.http = http;

function makeDefaultKy(kyConfig) {
  return ky_universal_1.default.create((0, merge_1.deepMerge)(DEFAULT_KY_CONFIG, kyConfig));
}

exports.makeDefaultKy = makeDefaultKy;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/merge.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/utils/merge.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.deepMerge = void 0;

const type_1 = __webpack_require__(/*! ./type */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/type.js");
/**
 * Function that deep merges objects
 *
 * @copyright https://github.com/sindresorhus/ky/blob/b3c9e88fa49d50150dbb6e6b771b4af56cb40c98/source/utils/merge.ts
 * @licence MIT
 * @param sources
 */


function deepMerge(...sources) {
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  let returnValue = {};

  for (const source of sources) {
    if (Array.isArray(source)) {
      if (!Array.isArray(returnValue)) {
        returnValue = [];
      }

      returnValue = [...returnValue, ...source];
    } else if ((0, type_1.isObject)(source)) {
      // eslint-disable-next-line prefer-const
      for (let [key, value] of Object.entries(source)) {
        if ((0, type_1.isObject)(value) && key in returnValue) {
          value = deepMerge(returnValue[key], value);
        }

        returnValue = Object.assign(Object.assign({}, returnValue), {
          [key]: value
        });
      }
    }
  }

  return returnValue;
}

exports.deepMerge = deepMerge;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/pss.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/utils/pss.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.makeMaxTarget = void 0;

const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@ethersphere/bee-js/dist/cjs/types/index.js");
/**
 * Utility function that for given strings/reference takes the most specific
 * target that Bee node will except.
 *
 * @param target is a non-prefixed hex string Bee address
 * @see [Bee docs - PSS](https://docs.ethswarm.org/docs/dapps-on-swarm/pss)
 */


function makeMaxTarget(target) {
  if (typeof target !== 'string') {
    throw new TypeError('target has to be an string!');
  }

  return target.slice(0, types_1.PSS_TARGET_HEX_LENGTH_MAX);
}

exports.makeMaxTarget = makeMaxTarget;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/stamps.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/utils/stamps.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.getStampUsage = void 0;
/**
 * Utility function that calculates usage of postage batch based on its utilization, depth and bucket depth.
 *
 * Be aware for small depths (17, 18) this does not provide that much information as the provided set of distinct values
 * is small.
 *
 * @param utilization
 * @param depth
 * @param bucketDepth
 */

function getStampUsage({
  utilization,
  depth,
  bucketDepth
}) {
  return utilization / Math.pow(2, depth - bucketDepth);
}

exports.getStampUsage = getStampUsage;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/stream.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/utils/stream.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.normalizeToReadableStream = exports.readableWebToNode = exports.readableNodeToWeb = exports.isNodeReadable = exports.isReadableStream = exports.isReadable = void 0;

const stream_1 = __webpack_require__(/*! stream */ "?0559");

const type_1 = __webpack_require__(/*! ./type */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/type.js");

const ponyfill_js_1 = __webpack_require__(/*! web-streams-polyfill/dist/ponyfill.js */ "./node_modules/web-streams-polyfill/dist/ponyfill.js");

const NodeReadable = stream_1.Readable || class {};
/**
 * Validates if passed object is either browser's ReadableStream
 * or Node's Readable.
 *
 * @param entry
 */

function isReadable(entry) {
  return isReadableStream(entry) || isNodeReadable(entry);
}

exports.isReadable = isReadable;

function isReadableStream(entry) {
  if (!(0, type_1.isStrictlyObject)(entry)) {
    return false;
  }

  const browserReadable = entry;

  if (typeof browserReadable.getReader === 'function' && browserReadable.locked !== undefined && typeof browserReadable.cancel === 'function' && typeof browserReadable.pipeTo === 'function' && typeof browserReadable.pipeThrough === 'function') {
    return true;
  }

  return false;
}

exports.isReadableStream = isReadableStream;

function isNodeReadable(entry) {
  if (!(0, type_1.isStrictlyObject)(entry)) {
    return false;
  }

  const nodeReadable = entry;

  if (typeof nodeReadable.pipe === 'function' && nodeReadable.readable && typeof nodeReadable._read === 'function') {
    return true;
  }

  return false;
}

exports.isNodeReadable = isNodeReadable;
/**
 * Function that converts Node's Readable into WHATWG ReadableStream
 *
 * Taken over from https://github.com/gwicke/node-web-streams/blob/master/lib/conversions.js
 * Because it uses forked web-streams-polyfill that are outdated.
 *
 * @author https://github.com/gwicke
 * @licence Apache License 2.0 https://github.com/gwicke/node-web-streams/blob/master/LICENSE
 * @param nodeStream
 */

function readableNodeToWeb(nodeStream) {
  return new ponyfill_js_1.ReadableStream({
    start(controller) {
      nodeStream.pause();
      nodeStream.on('data', chunk => {
        if (Buffer.isBuffer(chunk)) {
          controller.enqueue(new Uint8Array(chunk.buffer));
        } else {
          controller.enqueue(chunk);
        }

        nodeStream.pause();
      });
      nodeStream.on('end', () => controller.close());
      nodeStream.on('error', e => controller.error(e));
    },

    pull() {
      nodeStream.resume();
    },

    cancel() {
      nodeStream.pause();
    }

  });
}

exports.readableNodeToWeb = readableNodeToWeb;
/**
 * Taken over from https://github.com/gwicke/node-web-streams/blob/master/lib/conversions.js
 * Because it uses forked web-streams-polyfill that are outdated.
 *
 * @author https://github.com/gwicke
 * @licence Apache License 2.0 https://github.com/gwicke/node-web-streams/blob/master/LICENSE
 */

class NodeReadableWrapper extends NodeReadable {
  constructor(webStream, options) {
    super(options);
    this._webStream = webStream;
    this._reader = webStream.getReader();
    this._reading = false;
  }

  _read() {
    if (this._reading) {
      return;
    }

    this._reading = true;

    const doRead = () => {
      this._reader.read().then(res => {
        if (res.done) {
          this.push(null);
          return;
        }

        if (this.push(res.value)) {
          return doRead();
        } else {
          this._reading = false;
        }
      });
    };

    doRead();
  }

}
/**
 * Function that converts WHATWG ReadableStream into Node's Readable
 *
 * Taken over from https://github.com/gwicke/node-web-streams/blob/master/lib/conversions.js
 * Because it uses forked web-streams-polyfill that is outdated.
 *
 * **Warning!**
 * If you want to use this function in browser you have to polyfill `stream` package with your bundler.
 *
 * @author https://github.com/gwicke
 * @licence Apache License 2.0 https://github.com/gwicke/node-web-streams/blob/master/LICENSE
 * @param webStream
 * @param options
 */


function readableWebToNode(webStream, options) {
  if (!stream_1.Readable) {
    throw new Error("The Node's Readable is not available! If you are running this in browser you have to polyfill 'stream' package!");
  }

  return new NodeReadableWrapper(webStream, options);
}

exports.readableWebToNode = readableWebToNode;

function normalizeToReadableStream(stream) {
  if (isNodeReadable(stream)) {
    return readableNodeToWeb(stream);
  } else if (isReadableStream(stream)) {
    return stream;
  }

  throw new TypeError('Passed stream is not Node Readable nor ReadableStream!');
}

exports.normalizeToReadableStream = normalizeToReadableStream;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/tar.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/utils/tar.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";


var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.makeTar = void 0;

const tar_js_1 = __importDefault(__webpack_require__(/*! tar-js */ "./node_modules/tar-js/lib/tar.js")); // converts a string to utf8 Uint8Array and returns it as a string-like
// object that `tar.append` accepts as path


function fixUnicodePath(path) {
  const codes = new TextEncoder().encode(path);
  return {
    length: codes.length,
    charCodeAt: index => codes[index]
  };
}

function makeTar(data) {
  const tar = new tar_js_1.default();

  for (const entry of data) {
    const path = fixUnicodePath(entry.path);
    tar.append(path, entry.data);
  }

  return tar.out;
}

exports.makeTar = makeTar;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/type.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/utils/type.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.assertTransactionHash = exports.makeTagUid = exports.assertAllTagsOptions = exports.assertFileData = exports.assertData = exports.assertCashoutOptions = exports.assertPostageBatchOptions = exports.assertPublicKey = exports.assertPssMessageHandler = exports.assertAddressPrefix = exports.assertTag = exports.isTag = exports.assertCollectionUploadOptions = exports.assertFileUploadOptions = exports.assertUploadOptions = exports.assertRequestOptions = exports.assertBatchId = exports.assertAddress = exports.assertReference = exports.assertNonNegativeInteger = exports.assertInteger = exports.assertBoolean = exports.assertStrictlyObject = exports.isError = exports.isStrictlyObject = exports.isObject = exports.isInteger = exports.isUint8Array = void 0;

const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@ethersphere/bee-js/dist/cjs/types/index.js");

const error_1 = __webpack_require__(/*! ./error */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/error.js");

const file_1 = __webpack_require__(/*! ./file */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/file.js");

const hex_1 = __webpack_require__(/*! ./hex */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/hex.js");

const stream_1 = __webpack_require__(/*! ./stream */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/stream.js");

function isUint8Array(obj) {
  return obj instanceof Uint8Array;
}

exports.isUint8Array = isUint8Array;

function isInteger(value) {
  return typeof value === 'string' && /^-?(0|[1-9][0-9]*)$/g.test(value) || typeof value === 'number' && value > Number.MIN_SAFE_INTEGER && value < Number.MAX_SAFE_INTEGER && Number.isInteger(value);
}

exports.isInteger = isInteger;

function isObject(value) {
  return value !== null && typeof value === 'object';
}

exports.isObject = isObject;
/**
 * Generally it is discouraged to use `object` type, but in this case I think
 * it is best to do so as it is possible to easily convert from `object`to other
 * types, which will be usually the case after asserting that the object is
 * strictly object. With for example Record<string, unknown> you have to first
 * cast it to `unknown` which I think bit defeat the purpose.
 *
 * @param value
 */
// eslint-disable-next-line @typescript-eslint/ban-types

function isStrictlyObject(value) {
  return isObject(value) && !Array.isArray(value);
}

exports.isStrictlyObject = isStrictlyObject;
/**
 * Asserts if object is Error
 *
 * @param e
 */

function isError(e) {
  return e instanceof Error;
}

exports.isError = isError; // eslint-disable-next-line @typescript-eslint/ban-types

function assertStrictlyObject(value, name = 'value') {
  if (!isStrictlyObject(value)) {
    throw new TypeError(`${name} has to be an object that is not null nor array!`);
  }
}

exports.assertStrictlyObject = assertStrictlyObject;

function assertBoolean(value, name = 'value') {
  if (value !== true && value !== false) throw new TypeError(`${name} is not boolean`);
}

exports.assertBoolean = assertBoolean;

function assertInteger(value, name = 'value') {
  if (!isInteger(value)) throw new TypeError(`${name} is not integer`);
}

exports.assertInteger = assertInteger;

function assertNonNegativeInteger(value, name = 'Value') {
  assertInteger(value, name);
  if (Number(value) < 0) throw new error_1.BeeArgumentError(`${name} has to be bigger or equal to zero`, value);
}

exports.assertNonNegativeInteger = assertNonNegativeInteger;

function assertReference(value) {
  try {
    (0, hex_1.assertHexString)(value, types_1.REFERENCE_HEX_LENGTH);
  } catch (e) {
    (0, hex_1.assertHexString)(value, types_1.ENCRYPTED_REFERENCE_HEX_LENGTH);
  }
}

exports.assertReference = assertReference;

function assertAddress(value) {
  (0, hex_1.assertHexString)(value, types_1.ADDRESS_HEX_LENGTH, 'Address');
}

exports.assertAddress = assertAddress;

function assertBatchId(value) {
  (0, hex_1.assertHexString)(value, types_1.BATCH_ID_HEX_LENGTH, 'BatchId');
}

exports.assertBatchId = assertBatchId;

function assertRequestOptions(value, name = 'RequestOptions') {
  if (value === undefined) {
    return;
  }

  if (!isStrictlyObject(value)) {
    throw new TypeError(`${name} has to be an object!`);
  }

  const options = value;

  if (options.retry) {
    assertNonNegativeInteger(options.retry, `${name}.retry`);
  }

  if (options.timeout) {
    assertNonNegativeInteger(options.timeout, `${name}.timeout`);
  }

  if (options.fetch && typeof options.fetch !== 'function') {
    throw new TypeError(`${name}.fetch has to be a function or undefined!`);
  }
}

exports.assertRequestOptions = assertRequestOptions;

function assertUploadOptions(value, name = 'UploadOptions') {
  if (!isStrictlyObject(value)) {
    throw new TypeError(`${name} has to be an object!`);
  }

  assertRequestOptions(value, name);
  const options = value;

  if (options.pin && typeof options.pin !== 'boolean') {
    throw new TypeError(`options.pin property in ${name} has to be boolean or undefined!`);
  }

  if (options.encrypt && typeof options.encrypt !== 'boolean') {
    throw new TypeError(`options.encrypt property in ${name} has to be boolean or undefined!`);
  }

  if (options.tag) {
    if (typeof options.tag !== 'number') {
      throw new TypeError(`options.tag property in ${name} has to be number or undefined!`);
    }

    assertNonNegativeInteger(options.tag, 'options.tag');
  }
}

exports.assertUploadOptions = assertUploadOptions;

function assertFileUploadOptions(value) {
  assertUploadOptions(value, 'FileUploadOptions');
  const options = value;

  if (options.size) {
    if (typeof options.size !== 'number') {
      throw new TypeError('tag property in FileUploadOptions has to be number or undefined!');
    }

    assertNonNegativeInteger(options.size, 'options.size');
  }

  if (options.contentType && typeof options.contentType !== 'string') {
    throw new TypeError('contentType property in FileUploadOptions has to be string or undefined!');
  }
}

exports.assertFileUploadOptions = assertFileUploadOptions;

function assertCollectionUploadOptions(value) {
  assertUploadOptions(value, 'CollectionUploadOptions');
  const options = value;

  if (options.indexDocument && typeof options.indexDocument !== 'string') {
    throw new TypeError('indexDocument property in CollectionUploadOptions has to be string or undefined!');
  }

  if (options.errorDocument && typeof options.errorDocument !== 'string') {
    throw new TypeError('errorDocument property in CollectionUploadOptions has to be string or undefined!');
  }
}

exports.assertCollectionUploadOptions = assertCollectionUploadOptions;

function isTag(value) {
  if (!isStrictlyObject(value)) {
    return false;
  }

  const tag = value;
  const numberProperties = ['total', 'processed', 'synced', 'uid'];
  const correctNumberProperties = numberProperties.every(numberProperty => typeof tag[numberProperty] === 'number');

  if (!correctNumberProperties || !tag.startedAt || typeof tag.startedAt !== 'string') {
    return false;
  }

  return true;
}

exports.isTag = isTag;

function assertTag(value) {
  if (!isStrictlyObject(value)) {
    throw new TypeError('Tag is not an object!');
  }

  const tag = value;
  const numberProperties = ['total', 'processed', 'synced', 'uid'];

  for (const numberProperty of numberProperties) {
    if (!tag[numberProperty]) {
      throw new TypeError(`Tag's property '${numberProperty}' has to be specified!`);
    }

    if (typeof tag[numberProperty] !== 'number') {
      throw new TypeError(`Tag's property '${numberProperty}' has to be number!`);
    }
  }

  if (!tag.startedAt) {
    throw new TypeError("Tag's property 'startedAt' has to be specified!");
  }

  if (typeof tag.startedAt !== 'string') {
    throw new TypeError("Tag's property 'startedAt' has to be string!");
  }
}

exports.assertTag = assertTag;

function assertAddressPrefix(value) {
  (0, hex_1.assertHexString)(value, undefined, 'AddressPrefix');

  if (value.length > types_1.PSS_TARGET_HEX_LENGTH_MAX) {
    throw new error_1.BeeArgumentError(`AddressPrefix must have length of ${types_1.PSS_TARGET_HEX_LENGTH_MAX} at most! Got string with ${value.length}`, value);
  }
}

exports.assertAddressPrefix = assertAddressPrefix;

function assertPssMessageHandler(value) {
  if (!isStrictlyObject(value)) {
    throw new TypeError('PssMessageHandler has to be object!');
  }

  const handler = value;

  if (typeof handler.onMessage !== 'function') {
    throw new TypeError('onMessage property of PssMessageHandler has to be function!');
  }

  if (typeof handler.onError !== 'function') {
    throw new TypeError('onError property of PssMessageHandler has to be function!');
  }
}

exports.assertPssMessageHandler = assertPssMessageHandler;

function assertPublicKey(value) {
  (0, hex_1.assertHexString)(value, types_1.PUBKEY_HEX_LENGTH, 'PublicKey');
}

exports.assertPublicKey = assertPublicKey;

function assertPostageBatchOptions(value) {
  if (value === undefined) {
    return;
  }

  assertStrictlyObject(value);
  const options = value;
  assertRequestOptions(options, 'PostageBatchOptions');

  if (options === null || options === void 0 ? void 0 : options.gasPrice) {
    assertNonNegativeInteger(options.gasPrice);
  }

  if ((options === null || options === void 0 ? void 0 : options.immutableFlag) !== undefined) {
    assertBoolean(options.immutableFlag);
  }
}

exports.assertPostageBatchOptions = assertPostageBatchOptions;

function assertCashoutOptions(value) {
  if (value === undefined) {
    return;
  }

  assertStrictlyObject(value);
  const options = value;
  assertRequestOptions(options, 'PostageBatchOptions');

  if (options === null || options === void 0 ? void 0 : options.gasLimit) {
    assertNonNegativeInteger(options.gasLimit);
  }

  if (options === null || options === void 0 ? void 0 : options.gasPrice) {
    assertNonNegativeInteger(options.gasPrice);
  }
}

exports.assertCashoutOptions = assertCashoutOptions;
/**
 * Check whether the given parameter is valid data to upload
 * @param value
 * @throws TypeError if not valid
 */

function assertData(value) {
  if (typeof value !== 'string' && !(value instanceof Uint8Array)) {
    throw new TypeError('Data must be either string or Uint8Array!');
  }
}

exports.assertData = assertData;
/**
 * Check whether the given parameter is a correct file representation to file upload.
 * @param value
 * @throws TypeError if not valid
 */

function assertFileData(value) {
  if (typeof value !== 'string' && !(value instanceof Uint8Array) && !(0, file_1.isFile)(value) && !(0, stream_1.isReadable)(value)) {
    throw new TypeError('Data must be either string, Readable, Uint8Array or File!');
  }
}

exports.assertFileData = assertFileData;
/**
 * Checks whether optional options for AllTags query are valid
 * @param options
 */

function assertAllTagsOptions(entry) {
  if (entry !== undefined && !isStrictlyObject(entry)) {
    throw new TypeError('options has to be an object or undefined!');
  }

  assertRequestOptions(entry, 'AllTagsOptions');
  const options = entry;

  if ((options === null || options === void 0 ? void 0 : options.limit) !== undefined) {
    if (typeof options.limit !== 'number') {
      throw new TypeError('AllTagsOptions.limit has to be a number or undefined!');
    }

    if (options.limit < types_1.TAGS_LIMIT_MIN) {
      throw new error_1.BeeArgumentError(`AllTagsOptions.limit has to be at least ${types_1.TAGS_LIMIT_MIN}`, options.limit);
    }

    if (options.limit > types_1.TAGS_LIMIT_MAX) {
      throw new error_1.BeeArgumentError(`AllTagsOptions.limit has to be at most ${types_1.TAGS_LIMIT_MAX}`, options.limit);
    }
  }

  if ((options === null || options === void 0 ? void 0 : options.offset) !== undefined) {
    assertNonNegativeInteger(options.offset, 'AllTagsOptions.offset');
  }
}

exports.assertAllTagsOptions = assertAllTagsOptions;
/**
 * Utility functions that return Tag UID
 * @param tagUid
 */

function makeTagUid(tagUid) {
  if (tagUid === undefined || tagUid === null) {
    throw new TypeError('TagUid was expected but got undefined or null instead!');
  }

  if (isTag(tagUid)) {
    return tagUid.uid;
  } else if (typeof tagUid === 'number') {
    assertNonNegativeInteger(tagUid, 'UID');
    return tagUid;
  } else if (typeof tagUid === 'string') {
    const int = parseInt(tagUid);

    if (isNaN(int)) {
      throw new TypeError('Passed tagUid string is not valid integer!');
    }

    if (int < 0) {
      throw new TypeError(`TagUid was expected to be positive non-negative integer! Got ${int}`);
    }

    return int;
  }

  throw new TypeError('tagUid has to be either Tag or a number (UID)!');
}

exports.makeTagUid = makeTagUid;

function assertTransactionHash(transactionHash) {
  if (typeof transactionHash !== 'string') {
    throw new TypeError('TransactionHash has to be a string!');
  }

  (0, hex_1.assertPrefixedHexString)(transactionHash, 'TransactionHash'); // Hash is 64 long + '0x' prefix = 66

  if (transactionHash.length !== 66) {
    throw new TypeError('TransactionHash has to be prefixed hex string with total length 66 (prefix including)');
  }
}

exports.assertTransactionHash = assertTransactionHash;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/uint64.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/utils/uint64.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.readUint64BigEndian = exports.writeUint64BigEndian = exports.writeUint64LittleEndian = void 0;

const bytes_1 = __webpack_require__(/*! ./bytes */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/bytes.js"); // TODO handle bigger values than 32 bit
// For now it's good enough because we only use these functions
// sequential feed indexes.


function writeUint64LittleEndian(value, bytes = (0, bytes_1.makeBytes)(8)) {
  const dataView = new DataView(bytes.buffer);
  const valueLower32 = value & 0xffffffff;
  const littleEndian = true;
  dataView.setUint32(0, valueLower32, littleEndian);
  dataView.setUint32(4, 0, littleEndian);
  return bytes;
}

exports.writeUint64LittleEndian = writeUint64LittleEndian;

function writeUint64BigEndian(value, bytes = (0, bytes_1.makeBytes)(8)) {
  const dataView = new DataView(bytes.buffer);
  const valueLower32 = value & 0xffffffff;
  dataView.setUint32(0, 0);
  dataView.setUint32(4, valueLower32);
  return bytes;
}

exports.writeUint64BigEndian = writeUint64BigEndian;

function readUint64BigEndian(bytes) {
  const dataView = new DataView(bytes.buffer);
  return dataView.getUint32(4);
}

exports.readUint64BigEndian = readUint64BigEndian;

/***/ }),

/***/ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/url.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersphere/bee-js/dist/cjs/utils/url.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.stripLastSlash = exports.assertBeeUrl = exports.isValidBeeUrl = void 0;

const error_1 = __webpack_require__(/*! ./error */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/error.js");

const type_1 = __webpack_require__(/*! ./type */ "./node_modules/@ethersphere/bee-js/dist/cjs/utils/type.js");

function isNodeJsError(e) {
  return (0, type_1.isObject)(e) && typeof e.code === 'string';
}
/**
 * Validates that passed string is valid URL of Bee.
 * We support only HTTP and HTTPS protocols.
 *
 * @param url
 */


function isValidBeeUrl(url) {
  try {
    if (typeof url !== 'string') {
      return false;
    }

    const urlObject = new URL(url); // There can be wide range of protocols passed.

    return urlObject.protocol === 'http:' || urlObject.protocol === 'https:';
  } catch (e) {
    // URL constructor throws TypeError if not valid URL
    // TODO: Drop the `.code` hack for NodeJS environment: https://github.com/ethersphere/bee-js/issues/204
    if (e instanceof TypeError || isNodeJsError(e) && e.code === 'ERR_INVALID_URL') {
      return false;
    }

    throw e;
  }
}

exports.isValidBeeUrl = isValidBeeUrl;
/**
 * Validates that passed string is valid URL of Bee, if not it throws BeeArgumentError.
 * We support only HTTP and HTTPS protocols.
 * @param url
 * @throws BeeArgumentError if non valid URL
 */

function assertBeeUrl(url) {
  if (!isValidBeeUrl(url)) {
    throw new error_1.BeeArgumentError('URL is not valid!', url);
  }
}

exports.assertBeeUrl = assertBeeUrl;
/**
 * Removes trailing slash out of the given string.
 * @param url
 */

function stripLastSlash(url) {
  if (url.endsWith('/')) {
    return url.slice(0, -1);
  }

  return url;
}

exports.stripLastSlash = stripLastSlash;

/***/ }),

/***/ "./node_modules/elliptic/package.json":
/*!********************************************!*\
  !*** ./node_modules/elliptic/package.json ***!
  \********************************************/
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"elliptic","version":"6.5.4","description":"EC cryptography","main":"lib/elliptic.js","files":["lib"],"scripts":{"lint":"eslint lib test","lint:fix":"npm run lint -- --fix","unit":"istanbul test _mocha --reporter=spec test/index.js","test":"npm run lint && npm run unit","version":"grunt dist && git add dist/"},"repository":{"type":"git","url":"git@github.com:indutny/elliptic"},"keywords":["EC","Elliptic","curve","Cryptography"],"author":"Fedor Indutny <fedor@indutny.com>","license":"MIT","bugs":{"url":"https://github.com/indutny/elliptic/issues"},"homepage":"https://github.com/indutny/elliptic","devDependencies":{"brfs":"^2.0.2","coveralls":"^3.1.0","eslint":"^7.6.0","grunt":"^1.2.1","grunt-browserify":"^5.3.0","grunt-cli":"^1.3.2","grunt-contrib-connect":"^3.0.0","grunt-contrib-copy":"^1.0.0","grunt-contrib-uglify":"^5.0.0","grunt-mocha-istanbul":"^5.0.2","grunt-saucelabs":"^9.0.1","istanbul":"^0.4.5","mocha":"^8.0.1"},"dependencies":{"bn.js":"^4.11.9","brorand":"^1.1.0","hash.js":"^1.0.0","hmac-drbg":"^1.0.1","inherits":"^2.0.4","minimalistic-assert":"^1.0.1","minimalistic-crypto-utils":"^1.0.1"}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/


Object.defineProperty(exports, "__esModule", ({
  value: true
}));
Object.defineProperty(exports, "AccountData", ({
  enumerable: true,
  get: function () {
    return _accountData.AccountData;
  }
}));
Object.defineProperty(exports, "Directory", ({
  enumerable: true,
  get: function () {
    return _directory.Directory;
  }
}));
Object.defineProperty(exports, "FdpContracts", ({
  enumerable: true,
  get: function () {
    return _fdpContracts.default;
  }
}));
Object.defineProperty(exports, "FdpStorage", ({
  enumerable: true,
  get: function () {
    return _fdpStorage.FdpStorage;
  }
}));
Object.defineProperty(exports, "PersonalStorage", ({
  enumerable: true,
  get: function () {
    return _personalStorage.PersonalStorage;
  }
}));

__webpack_require__(/*! ./shim/crypto */ "./src/shim/crypto.ts");

var _fdpStorage = __webpack_require__(/*! ./fdp-storage */ "./src/fdp-storage.ts");

var _accountData = __webpack_require__(/*! ./account/account-data */ "./src/account/account-data.ts");

var _personalStorage = __webpack_require__(/*! ./pod/personal-storage */ "./src/pod/personal-storage.ts");

var _directory = __webpack_require__(/*! ./directory/directory */ "./src/directory/directory.ts");

var _fdpContracts = _interopRequireDefault(__webpack_require__(/*! @fairdatasociety/fdp-contracts */ "./node_modules/@fairdatasociety/fdp-contracts/build/index.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
})();

/******/ 	return __webpack_exports__;
/******/ })()
;
});
//# sourceMappingURL=index.browser.js.map